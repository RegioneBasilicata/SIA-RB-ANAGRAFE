--------------------------------------------------------
--  File creato - lunedì-luglio-31-2023   
--------------------------------------------------------
--------------------------------------------------------
--  DDL for Procedure PRC_MANDATI_CAA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "SMRGAA"."PRC_MANDATI_CAA" 
is
    utenteAggiornamento         PAPUA.PAPUA_T_ENTE.UTENTE_AGGIORNAMENTO%TYPE := 9999999999;
    idIntermediario             SMRGAA.DB_INTERMEDIARIO.ID_INTERMEDIARIO%TYPE;
    idUffZonaInterm             SMRGAA.DB_UFFICIO_ZONA_INTERMEDIARIO.ID_UFFICIO_ZONA_INTERMEDIARIO%TYPE;
    idEnte                      papua.papua_t_ente.id_ente%TYPE;
    idDelega                    smrgaa.db_delega.id_delega%type;

    cursor curCaaDaInserire is
    select * 
    from tmp_caa3_2020 sian
    where 1=1
    and   sian.id_ufficio_zona_intermediario is null
    --and   sian.n_mandati > 10
    --and   sian.n_mandati < 800
    and   sian.codice_caa is not null
    and   substr(sian.codice_caa, 1, 1) = '1'
    and   sian.new_id_intermediario is null
    and   sian.id_import_caa = 150 -- cia BA 006
    order by sian.n_mandati desc
    ;

    cursor curCaaPresenti is
    select * 
    from tmp_caa3_2020 sian
    where 0=1 
    and   sian.id_ufficio_zona_intermediario is not null
    and   sian.n_mandati > 10
    --and   sian.n_mandati < 800    
    and   sian.codice_caa is not null
    and   substr(sian.codice_caa, 1, 1) = '1'
    --and   sian.id_import_caa = 105 -- unicaa potenza 010 21 fascicoli
    order by sian.n_mandati desc
    ;

begin
    FOR recCaa IN curCaaDaInserire LOOP

        select seq_intermediario.nextval 
        into idIntermediario
        from dual;

        insert into smrgaa.db_intermediario
            (ID_INTERMEDIARIO, 
             DENOMINAZIONE, 
             CODICE_FISCALE, 
             INDIRIZZO, 
	         CAP,
             COMUNE,
             TIPO_INTERMEDIARIO,
             ID_INTERMEDIARIO_PADRE,
             LIVELLO,
             PARTITA_IVA,
             DATA_FINE_VALIDITA,
             RESPONSABILE,
             TELEFONO,
             FAX,
             EMAIL,
             PEC,
             EXT_ID_AZIENDA,
             EXT_CUAA)           
        values
            (idIntermediario,
             recCaa.DENOMINAZIONE_CAA,
             recCaa.CODICE_CAA,
             recCaa.IND_CAA,
             recCaa.CAP_CAA,
             recCaa.COMISTAT_CAA,
             'C',
             nvl(recCaa.CAA_PADRE_PROV, recCaa.CAA_PADRE_REG),
             'Z',
             recCaa.CODICE_CAA,
             null,
             recCaa.NOMINITIVO_RESPONSABILE_CAA,
             recCaa.TELEFONO_CAA,
             null,
             recCaa.EMAIL_CAA,
             recCaa.PEC_CAA,
             null,
             null
            );

        select seq_ufficio_zona_intermediario.nextval 
        into idUffZonaInterm
        from dual;

        insert into smrgaa.db_ufficio_zona_intermediario
            (ID_UFFICIO_ZONA_INTERMEDIARIO,
             ID_INTERMEDIARIO,
             DENOMINAZIONE,
             CODICE_AGEA,
             INDIRIZZO,
             CAP,
             COMUNE,
             RECAPITO,
             MAIL
            )
        values
            (idUffZonaInterm,
             idIntermediario,
             recCaa.DENOMINAZIONE_CAA,
             recCaa.CODICE_CAA,
             recCaa.IND_CAA,
             recCaa.CAP_CAA,
             recCaa.COMISTAT_CAA,
             null,
             recCaa.EMAIL_CAA
            );

        insert into papua.papua_d_intermediario
            (ID_INTERMEDIARIO, 
             DENOMINAZIONE, 
             CODICE_FISCALE, 
             INDIRIZZO, 
	         CAP,
             EXT_ISTAT_COMUNE,
             TIPO_INTERMEDIARIO,
             ID_INTERMEDIARIO_PADRE,
             LIVELLO,
             PARTITA_IVA,
             DATA_FINE_VALIDITA,
             RESPONSABILE,
             TELEFONO,
             FAX,
             EMAIL,
             PEC)           
        values 
            (idIntermediario,
             recCaa.DENOMINAZIONE_CAA,
             recCaa.CODICE_CAA,
             recCaa.IND_CAA,
             recCaa.CAP_CAA,
             recCaa.COMISTAT_CAA,
             'C',
             (select max(avp.papua_id) from smrgaa.tmp_caa_2020_anag_papua avp where avp.anag_id = nvl(recCaa.CAA_PADRE_PROV, recCaa.CAA_PADRE_REG)),
             'Z',
             recCaa.CODICE_CAA,
             null,
             recCaa.NOMINITIVO_RESPONSABILE_CAA,
             recCaa.TELEFONO_CAA,
             null,
             recCaa.EMAIL_CAA,
             recCaa.PEC_CAA);

        select papua.seq_papua_t_ente.nextval 
        into idEnte
        from dual;

        insert into papua.papua_t_ente 
            (ID_ENTE,
             ID_TIPO_ENTE,
             EXT_ID_AZIENDA,
             EXT_ID_AMM_COMPETENZA,
             EXT_ID_INTERMEDIARIO,
             FLAG_ENTE_PAPUA,
             CUAA,
             P_IVA,
             DENOMINAZIONE,
             FORMA_GIURIDICA,
             INDIRIZZO,
             COMUNE,
             CAP,
             PROV,
             TELEFONO,
             FAX,
             EMAIL,
             EXT_ID_AMM_COMPETENZA_PADRE,
             FLAG_STATO_ATTIVITA_ENTE,
             DATA_AGGIORNAMENTO_ENTE,
             PROTOCOLLO,
             DATA_INIZIO_CONCESSIONE,
             DATA_FINE_CONCESSIONE,
             DT_ULTIMO_AGGIORNAMENTO,
             UTENTE_AGGIORNAMENTO,
             DATA_INIZIO_ATTIVITA,
             DATA_FINE_ATTIVITA,
             DATA_INIZIO_VALIDITA,
             CODICE_ENTE,
             DATA_FINE_VALIDITA,
             TIPO_ENTE_IRIDE1,
             EXT_ID_ENTE_IRIDE1,
             GRUPPO_WEBI,
             ENTE_RUPAR,
             ALLEGATO_RICHIESTA_ACCREDITAME,
             NOME_ALLEG_RICHIESTA_ACCR,
             ISTAT_COMUNE,
             USER_WEBI_GRUPPO,
             EMAIL_PEC)
        values 
            (idEnte,
             1,
             null,
             null,
             idIntermediario,
             'S',
             recCaa.CODICE_CAA,
             recCaa.CODICE_CAA,
             recCaa.DENOMINAZIONE_CAA,
             null,
             recCaa.IND_CAA,
             recCaa.COMISTAT_CAA,
             recCaa.CAP_CAA,
             recCaa.PROVINCIA_CAA,
             recCaa.TELEFONO_CAA,
             null,
             recCaa.EMAIL_CAA,
             null,
             'A',
             sysdate,
             null,
             sysdate,
             null,
             sysdate,
             utenteAggiornamento,
             sysdate,
             null,
             sysdate,
             recCaa.CODICE_CAA,
             null,
             null,
             null,
             null,
             'Z',
             null,
             null,
             null,
             null,
             null
            );

        -- inserisce associazione ente-procedimento altrimenti gli utenti non accedono
        -- PSR
        insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
            (ID_PROCEDIMENTO_ENTE,
             ID_ENTE,
             ID_PROCEDIMENTO,
             DATA_INIZIO_VALIDITA,
             DATA_FINE_VALIDITA)
        values 
            (papua.seq_papua_r_procedimento_ente.nextval,
             idEnte,
             46,
             trunc(sysdate),
             null);

        -- Anagrafe
        insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
            (ID_PROCEDIMENTO_ENTE,
             ID_ENTE,
             ID_PROCEDIMENTO,
             DATA_INIZIO_VALIDITA,
             DATA_FINE_VALIDITA)
        values 
            (papua.seq_papua_r_procedimento_ente.nextval,
             idEnte,
             7,
             trunc(sysdate),
             null);

        -- UMA
        insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
            (ID_PROCEDIMENTO_ENTE,
             ID_ENTE,
             ID_PROCEDIMENTO,
             DATA_INIZIO_VALIDITA,
             DATA_FINE_VALIDITA)
        values 
            (papua.seq_papua_r_procedimento_ente.nextval,
             idEnte,
             1,
             trunc(sysdate),
             null);

        --gestire caa senza ufficio provinciale padre perché poi non si riescono ad associare dai cruscotti papua ;

        update smrgaa.tmp_caa3_2020 sian
        set sian.NEW_ID_INTERMEDIARIO = idIntermediario,
            sian.NEW_ID_UFF_ZONA = idUffZonaInterm,
            sian.NEW_ID_ENTE = idEnte
        where sian.ID_IMPORT_CAA = recCaa.ID_IMPORT_CAA;

        for recMandato in (select man.*
                           from smrgaa.tmp_fascicoli2_2020 man
                           where man.codice_caa = recCaa.CODICE_CAA
                           and   man.data_decesso is null
                           and   man.cessazione_cciaa is null
                           and   man.id_azienda is not null
                           and   man.new_id_delega is null)
        loop

            select smrgaa.seq_delega.nextval 
            into idDelega
            from dual;

            insert into smrgaa.db_delega
                (ID_DELEGA,
                ID_INTERMEDIARIO,
                ID_PROCEDIMENTO,
                ID_AZIENDA,
                DATA_INIZIO,
                DATA_FINE,
                ID_UTENTE_INSERIMENTO_DELEGA,
                ID_UFFICIO_ZONA_INTERMEDIARIO,
                UFFICIO_FASCICOLO,
                ID_UTENTE_FINE_DELEGA,
                INDIRIZZO,
                COMUNE,
                CAP,
                CODICE_AMMINISTRAZIONE,
                RECAPITO,
                DATA_INIZIO_MANDATO,
                DATA_FINE_MANDATO,
                DATA_AGGIORNAMENTO_SIAN,
                DATA_RICEVUTA_RITORNO_REVOCA,
                ID_UTENTE_REVOCA)
            values
                (idDelega,
                idIntermediario,
                7,
                recMandato.id_azienda,
                sysdate,
                null,
                utenteAggiornamento,
                idUffZonaInterm,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                sysdate,
                null,
                null,
                null,
                null);

            update smrgaa.tmp_fascicoli2_2020 man
            set man.new_id_delega = idDelega
            where man.id_import_mandato = recMandato.id_import_mandato;

        end loop;        

    end loop;

    /******************************************************************************************************************/

    FOR recCaa IN curCaaPresenti LOOP

        for recMandato in (select man.*
                           from smrgaa.tmp_fascicoli2_2020 man
                           where man.codice_caa = recCaa.CODICE_CAA
                           and   man.data_decesso is null
                           and   man.cessazione_cciaa is null
                           and   man.id_azienda is not null
                           and   man.new_id_delega is null)
        loop

            select smrgaa.seq_delega.nextval 
            into idDelega
            from dual;

            insert into smrgaa.db_delega
                (ID_DELEGA,
                ID_INTERMEDIARIO,
                ID_PROCEDIMENTO,
                ID_AZIENDA,
                DATA_INIZIO,
                DATA_FINE,
                ID_UTENTE_INSERIMENTO_DELEGA,
                ID_UFFICIO_ZONA_INTERMEDIARIO,
                UFFICIO_FASCICOLO,
                ID_UTENTE_FINE_DELEGA,
                INDIRIZZO,
                COMUNE,
                CAP,
                CODICE_AMMINISTRAZIONE,
                RECAPITO,
                DATA_INIZIO_MANDATO,
                DATA_FINE_MANDATO,
                DATA_AGGIORNAMENTO_SIAN,
                DATA_RICEVUTA_RITORNO_REVOCA,
                ID_UTENTE_REVOCA)
            values
                (idDelega,
                recCaa.id_intermediario,
                7,
                recMandato.id_azienda,
                sysdate,
                null,
                utenteAggiornamento,
                recCaa.id_Ufficio_Zona_Intermediario,
                null,
                null,
                null,
                null,
                null,
                null,
                null,
                sysdate,
                null,
                null,
                null,
                null);

            update smrgaa.tmp_fascicoli2_2020 man
            set man.new_id_delega = idDelega
            where man.id_import_mandato = recMandato.id_import_mandato;

        end loop;        

    end loop;

end;

/
--------------------------------------------------------
--  DDL for Procedure PRC_NUOVA_AZIENDA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "SMRGAA"."PRC_NUOVA_AZIENDA" (
    p_cuaa varchar2,
    p_denom varchar2
)
is
    utenteAggiornamento         PAPUA.PAPUA_T_ENTE.UTENTE_AGGIORNAMENTO%TYPE := 9999999999;
    checkAzienda                integer     :=0;
    idAzienda                   SMRGAA.DB_AZIENDA.ID_AZIENDA%TYPE;
    idAnagraficaAzienda         SMRGAA.DB_ANAGRAFICA_AZIENDA.ID_ANAGRAFICA_AZIENDA%TYPE;

begin

    -- verifica che l'azienda non sia già presente
    select count(1)
    into checkAzienda
    from SMRGAA.DB_anagrafica_azienda ana
    where ana.cuaa = p_cuaa;

    if checkAzienda > 0 then
        dbms_output.put_line('Azienda già presente');
        return;
    end if;

    -- inserisce su smrgaa db_azienda    
    select seq_azienda.nextval 
    into idAzienda
    from dual;

    insert into smrgaa.db_azienda
        (ID_AZIENDA,
         DATA_INIZIO_VALIDITA,
         FLAG_OBBLIGO_FASCICOLO,
         FLAG_ESENTE_DELEGA,
         FASCICOLO_DEMATERIALIZZATO)
    values
        (idAzienda,
         trunc(sysdate),
         'S',
         'N',
         'N');

    select seq_anagrafica_azienda.nextval 
    into idAnagraficaAzienda
    from dual;

    insert into smrgaa.db_ANAGRAFICA_AZIENDA
        (ID_ANAGRAFICA_AZIENDA,
         ID_AZIENDA,
         DATA_INIZIO_VALIDITA,
         CUAA,
         DENOMINAZIONE,
         PROVINCIA_COMPETENZA,
         DATA_AGGIORNAMENTO,
         ID_UTENTE_AGGIORNAMENTO,
         FLAG_IAP)
    values
        (idAnagraficaAzienda,
         idAzienda,
         trunc(sysdate),
         p_cuaa,
         p_denom,
         '076',
         trunc(sysdate),
         utenteAggiornamento,
         'N');
    commit;
end;

/
--------------------------------------------------------
--  DDL for Procedure PRC_NUOVO_CAA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "SMRGAA"."PRC_NUOVO_CAA" 
is
    utenteAggiornamento         PAPUA.PAPUA_T_ENTE.UTENTE_AGGIORNAMENTO%TYPE := 9999999999;
    idIntermediario             SMRGAA.DB_INTERMEDIARIO.ID_INTERMEDIARIO%TYPE;
    idIntermediarioPadre        SMRGAA.DB_INTERMEDIARIO.ID_INTERMEDIARIO%TYPE;
    idIntermPadrePapua          PAPUA.papua_d_intermediario.ID_INTERMEDIARIO%TYPE;
    idUffZonaInterm             SMRGAA.DB_UFFICIO_ZONA_INTERMEDIARIO.ID_UFFICIO_ZONA_INTERMEDIARIO%TYPE;
    idEnte                      papua.papua_t_ente.id_ente%TYPE;
    checkCAA    integer     :=0;
    codiceCAA   SMRGAA.DB_INTERMEDIARIO.codice_fiscale%TYPE     := '';  -- tripletta
    denomCAA    SMRGAA.DB_INTERMEDIARIO.denominazione%TYPE      := '';
    indirizzoCAA    SMRGAA.DB_INTERMEDIARIO.indirizzo%TYPE      := '';
    comuneCAA       SMRGAA.DB_INTERMEDIARIO.comune%TYPE         := '';  -- cod istat
    capCAA          SMRGAA.DB_INTERMEDIARIO.cap%TYPE            := '';
    provCAA         varchar2(2 byte)                            := '';  -- sigla
    respCAA         SMRGAA.DB_INTERMEDIARIO.RESPONSABILE%TYPE   := '';
    telCAA          SMRGAA.DB_INTERMEDIARIO.TELEFONO%TYPE       := '';
    faxCAA          SMRGAA.DB_INTERMEDIARIO.FAX%TYPE            := '';
    emailCAA        SMRGAA.DB_INTERMEDIARIO.EMAIL%TYPE          := '';
    pecCAA          SMRGAA.DB_INTERMEDIARIO.PEC%TYPE            := '';

begin

    -- verifica che il CAA non sia già presente
    select count(1)
    into checkCAA
    from SMRGAA.DB_INTERMEDIARIO caa
    where caa.codice_fiscale = codiceCAA
    and   caa.tipo_intermediario = 'C';

    if checkCAA > 0 then
        dbms_output.put_line('CAA già presente');
        return;
    end if;

    -- verifica che il CAA non sia già presente in PAPUA
    select count(1)
    into checkCAA
    from PAPUA.papua_d_intermediario caa
    where caa.codice_fiscale = codiceCAA
    and   caa.tipo_intermediario = 'C';

    if checkCAA > 0 then
        dbms_output.put_line('CAA già presente in PAPUA');
        return;
    end if;

    -- verifica che esista ufficio provinciale (caa padre)
    begin
        select caa.id_intermediario
        into idIntermediarioPadre
        from SMRGAA.DB_INTERMEDIARIO caa
        where substr(caa.codice_fiscale, 1, 6) = substr(codiceCAA, 1, 6)
        and   caa.livello = 'P'
        and   caa.tipo_intermediario = 'C';
    exception when NO_DATA_FOUND then
        dbms_output.put_line('Ufficio provinciale mancante');
        return;
    end;

    -- verifica che esista ufficio provinciale su papua (caa padre)
    begin
        select caa.id_intermediario
        into idIntermPadrePapua
        from PAPUA.papua_d_intermediario caa
        where substr(caa.codice_fiscale, 1, 6) = substr(codiceCAA, 1, 6)
        and   caa.livello = 'P'
        and   caa.tipo_intermediario = 'C';
    exception when NO_DATA_FOUND then
        dbms_output.put_line('Ufficio provinciale mancante SU PAPUA');
        return;
    end;

    -- inserisce su smrgaa db_intermediario    
    select seq_intermediario.nextval 
    into idIntermediario
    from dual;

    insert into smrgaa.db_intermediario
        (ID_INTERMEDIARIO, 
         DENOMINAZIONE, 
         CODICE_FISCALE, 
         INDIRIZZO, 
         CAP,
         COMUNE,
         TIPO_INTERMEDIARIO,
         ID_INTERMEDIARIO_PADRE,
         LIVELLO,
         PARTITA_IVA,
         DATA_FINE_VALIDITA,
         RESPONSABILE,
         TELEFONO,
         FAX,
         EMAIL,
         PEC,
         EXT_ID_AZIENDA,
         EXT_CUAA)           
    values
        (idIntermediario,
         denomCAA,
         codiceCAA,
         indirizzoCAA,
         capCAA,
         comuneCAA,
         'C',
         idIntermediarioPadre,
         'Z',
         codiceCAA,
         null,
         respCAA,
         telCAA,
         faxCAA,
         emailCAA,
         pecCAA,
         null,
         null
        );

    select seq_ufficio_zona_intermediario.nextval 
    into idUffZonaInterm
    from dual;

    insert into smrgaa.db_ufficio_zona_intermediario
        (ID_UFFICIO_ZONA_INTERMEDIARIO,
         ID_INTERMEDIARIO,
         DENOMINAZIONE,
         CODICE_AGEA,
         INDIRIZZO,
         CAP,
         COMUNE,
         RECAPITO,
         MAIL
        )
    values
        (idUffZonaInterm,
         idIntermediario,
         denomCAA,
         codiceCAA,
         indirizzoCAA,
         capCAA,
         comuneCAA,
         null,
         emailCAA
        );

    insert into papua.papua_d_intermediario
        (ID_INTERMEDIARIO, 
         DENOMINAZIONE, 
         CODICE_FISCALE, 
         INDIRIZZO, 
         CAP,
         EXT_ISTAT_COMUNE,
         TIPO_INTERMEDIARIO,
         ID_INTERMEDIARIO_PADRE,
         LIVELLO,
         PARTITA_IVA,
         DATA_FINE_VALIDITA,
         RESPONSABILE,
         TELEFONO,
         FAX,
         EMAIL,
         PEC)           
    values 
        (idIntermediario,
         denomCAA,
         codiceCAA,
         indirizzoCAA,
         capCAA,
         comuneCAA,
         'C',
         idIntermPadrePapua,
         'Z',
         codiceCAA,
         null,
         respCAA,
         telCAA,
         faxCAA,
         emailCAA,
         pecCAA);

    select papua.seq_papua_t_ente.nextval 
    into idEnte
    from dual;

    insert into papua.papua_t_ente 
        (ID_ENTE,
         ID_TIPO_ENTE,
         EXT_ID_AZIENDA,
         EXT_ID_AMM_COMPETENZA,
         EXT_ID_INTERMEDIARIO,
         FLAG_ENTE_PAPUA,
         CUAA,
         P_IVA,
         DENOMINAZIONE,
         FORMA_GIURIDICA,
         INDIRIZZO,
         COMUNE,
         CAP,
         PROV,
         TELEFONO,
         FAX,
         EMAIL,
         EXT_ID_AMM_COMPETENZA_PADRE,
         FLAG_STATO_ATTIVITA_ENTE,
         DATA_AGGIORNAMENTO_ENTE,
         PROTOCOLLO,
         DATA_INIZIO_CONCESSIONE,
         DATA_FINE_CONCESSIONE,
         DT_ULTIMO_AGGIORNAMENTO,
         UTENTE_AGGIORNAMENTO,
         DATA_INIZIO_ATTIVITA,
         DATA_FINE_ATTIVITA,
         DATA_INIZIO_VALIDITA,
         CODICE_ENTE,
         DATA_FINE_VALIDITA,
         TIPO_ENTE_IRIDE1,
         EXT_ID_ENTE_IRIDE1,
         GRUPPO_WEBI,
         ENTE_RUPAR,
         ALLEGATO_RICHIESTA_ACCREDITAME,
         NOME_ALLEG_RICHIESTA_ACCR,
         ISTAT_COMUNE,
         USER_WEBI_GRUPPO,
         EMAIL_PEC)
    values 
        (idEnte,
         1,
         null,
         null,
         idIntermediario,
         'S',
         codiceCAA,
         codiceCAA,
         denomCAA,
         null,
         indirizzoCAA,
         comuneCAA,
         capCAA,
         provCAA,
         telCAA,
         null,
         emailCAA,
         null,
         'A',
         sysdate,
         null,
         sysdate,
         null,
         sysdate,
         utenteAggiornamento,
         sysdate,
         null,
         sysdate,
         codiceCAA,
         null,
         null,
         null,
         null,
         'Z',
         null,
         null,
         null,
         null,
         null
        );

    -- inserisce associazione ente-procedimento altrimenti gli utenti non accedono
    -- PSR
    insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
        (ID_PROCEDIMENTO_ENTE,
         ID_ENTE,
         ID_PROCEDIMENTO,
         DATA_INIZIO_VALIDITA,
         DATA_FINE_VALIDITA)
    values 
        (papua.seq_papua_r_procedimento_ente.nextval,
         idEnte,
         46,
         trunc(sysdate),
         null);

    -- Anagrafe
    insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
        (ID_PROCEDIMENTO_ENTE,
         ID_ENTE,
         ID_PROCEDIMENTO,
         DATA_INIZIO_VALIDITA,
         DATA_FINE_VALIDITA)
    values 
        (papua.seq_papua_r_procedimento_ente.nextval,
         idEnte,
         7,
         trunc(sysdate),
         null);

    -- UMA
    insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
        (ID_PROCEDIMENTO_ENTE,
         ID_ENTE,
         ID_PROCEDIMENTO,
         DATA_INIZIO_VALIDITA,
         DATA_FINE_VALIDITA)
    values 
        (papua.seq_papua_r_procedimento_ente.nextval,
         idEnte,
         1,
         trunc(sysdate),
         null);

end;

/
--------------------------------------------------------
--  DDL for Procedure PRC_NUOVO_CAA_DYNAMIC
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "SMRGAA"."PRC_NUOVO_CAA_DYNAMIC" 
is
    utenteAggiornamento         PAPUA.PAPUA_T_ENTE.UTENTE_AGGIORNAMENTO%TYPE := 9999999999;
    idIntermediario             SMRGAA.DB_INTERMEDIARIO.ID_INTERMEDIARIO%TYPE;
    idIntermediarioPadre        SMRGAA.DB_INTERMEDIARIO.ID_INTERMEDIARIO%TYPE;
    idIntermPadrePapua          PAPUA.papua_d_intermediario.ID_INTERMEDIARIO%TYPE;
    idUffZonaInterm             SMRGAA.DB_UFFICIO_ZONA_INTERMEDIARIO.ID_UFFICIO_ZONA_INTERMEDIARIO%TYPE;
    idEnte                      papua.papua_t_ente.id_ente%TYPE;
    checkCAA       integer     :=0;
    checkCAAPAP    integer     :=0;

    /*codiceCAA   SMRGAA.DB_INTERMEDIARIO.codice_fiscale%TYPE     := '';  -- tripletta
    denomCAA    SMRGAA.DB_INTERMEDIARIO.denominazione%TYPE      := '';
    indirizzoCAA    SMRGAA.DB_INTERMEDIARIO.indirizzo%TYPE      := '';
    comuneCAA       SMRGAA.DB_INTERMEDIARIO.comune%TYPE         := '';  -- cod istat
    capCAA          SMRGAA.DB_INTERMEDIARIO.cap%TYPE            := '';
    provCAA         varchar2(2 byte)                            := '';  -- sigla
    respCAA         SMRGAA.DB_INTERMEDIARIO.RESPONSABILE%TYPE   := '';
    telCAA          SMRGAA.DB_INTERMEDIARIO.TELEFONO%TYPE       := '';
    faxCAA          SMRGAA.DB_INTERMEDIARIO.FAX%TYPE            := '';
    emailCAA        SMRGAA.DB_INTERMEDIARIO.EMAIL%TYPE          := '';
    pecCAA          SMRGAA.DB_INTERMEDIARIO.PEC%TYPE            := '';*/
    recIntermed     SMRGAA.TMP_DB_UFFICIO_ZONA_INTERMED%ROWTYPE;
    aa NUMBER;

begin


FOR recIntermed IN (SELECT ID_UFFICIO_ZONA_INTERMEDIARIO, ID_INTERMEDIARIO, DENOMINAZIONE, CODICE_AGEA, INDIRIZZO, CAP, COMUNE, RECAPITO, MAIL
FROM TMP_DB_UFFICIO_ZONA_INTERMED) LOOP

    -- verifica che il CAA non sia già presente
    select count(1)
    into checkCAA
    from SMRGAA.DB_INTERMEDIARIO caa
    where caa.codice_fiscale = recIntermed.CODICE_AGEA
    and   caa.tipo_intermediario = 'C';

    if checkCAA > 0 then
        dbms_output.put_line('CAA già presente '||recIntermed.CODICE_AGEA);
        return;
    end if;

    -- verifica che il CAA non sia già presente in PAPUA
    select count(1)
    into checkCAAPAP
    from PAPUA.papua_d_intermediario caa
    where caa.codice_fiscale = recIntermed.CODICE_AGEA--codiceCAA
    and   caa.tipo_intermediario = 'C';

    if checkCAAPAP > 0 then
        dbms_output.put_line('CAA già presente in PAPUA '||recIntermed.CODICE_AGEA);
        return;
    end if;

    -- verifica che esista ufficio provinciale (caa padre)
    begin
        select caa.id_intermediario
        into idIntermediarioPadre
        from SMRGAA.DB_INTERMEDIARIO caa
        where substr(caa.codice_fiscale, 1, 6) = substr(recIntermed.CODICE_AGEA, 1, 6)
        and   caa.livello = 'P'
        and   caa.tipo_intermediario = 'C';
    exception when NO_DATA_FOUND then
        dbms_output.put_line('Ufficio provinciale mancante '||recIntermed.CODICE_AGEA);
        return;
    end;

    -- verifica che esista ufficio provinciale su papua (caa padre)
    begin
        select caa.id_intermediario
        into idIntermPadrePapua
        from PAPUA.papua_d_intermediario caa
        where substr(caa.codice_fiscale, 1, 6) = substr(recIntermed.CODICE_AGEA, 1, 6)
        and   caa.livello = 'P'
        and   caa.tipo_intermediario = 'C';
    exception when NO_DATA_FOUND then
        dbms_output.put_line('Ufficio provinciale mancante SU PAPUA '||recIntermed.CODICE_AGEA);
        return;
    end;

--IF (checkCAA > 0) OR (checkCAAPAP > 0) OR (idIntermediarioPadre IS NULL) OR (idIntermPadrePapua IS NULL) THEN

--ELSE
 dbms_output.put_line('Procedo con inserimento '||recIntermed.CODICE_AGEA);
    -- inserisce su smrgaa db_intermediario    
    select seq_intermediario.nextval 
    into idIntermediario
    from dual;

    insert into smrgaa.db_intermediario
        (ID_INTERMEDIARIO, 
         DENOMINAZIONE, 
         CODICE_FISCALE, 
         INDIRIZZO, 
         CAP,
         COMUNE,
         TIPO_INTERMEDIARIO,
         ID_INTERMEDIARIO_PADRE,
         LIVELLO,
         PARTITA_IVA,
         DATA_FINE_VALIDITA,
         RESPONSABILE,
         TELEFONO,
         FAX,
         EMAIL,
         PEC,
         EXT_ID_AZIENDA,
         EXT_CUAA)           
    values
        (idIntermediario,
         recIntermed.DENOMINAZIONE,
         recIntermed.CODICE_AGEA,
         recIntermed.INDIRIZZO,
         recIntermed.CAP,
         recIntermed.COMUNE,
         'C',
         idIntermediarioPadre,
         'Z',
         recIntermed.CODICE_AGEA,
         null,
         NULL,--respCAA,
         recIntermed.RECAPITO,
         null,
         recIntermed.MAIL,
         null,
         null,
         null
        );

    select seq_ufficio_zona_intermediario.nextval 
    into idUffZonaInterm
    from dual;

    insert into smrgaa.db_ufficio_zona_intermediario
        (ID_UFFICIO_ZONA_INTERMEDIARIO,
         ID_INTERMEDIARIO,
         DENOMINAZIONE,
         CODICE_AGEA,
         INDIRIZZO,
         CAP,
         COMUNE,
         RECAPITO,
         MAIL
        )
    values
        (idUffZonaInterm,
         idIntermediario,
         recIntermed.DENOMINAZIONE,
         recIntermed.CODICE_AGEA,
         recIntermed.INDIRIZZO,
         recIntermed.CAP,
         recIntermed.COMUNE,
         null,
         recIntermed.MAIL
        );

    insert into papua.papua_d_intermediario
        (ID_INTERMEDIARIO, 
         DENOMINAZIONE, 
         CODICE_FISCALE, 
         INDIRIZZO, 
         CAP,
         EXT_ISTAT_COMUNE,
         TIPO_INTERMEDIARIO,
         ID_INTERMEDIARIO_PADRE,
         LIVELLO,
         PARTITA_IVA,
         DATA_FINE_VALIDITA,
         RESPONSABILE,
         TELEFONO,
         FAX,
         EMAIL,
         PEC)           
    values 
        (idIntermediario,
         recIntermed.DENOMINAZIONE,
         recIntermed.CODICE_AGEA,
         recIntermed.INDIRIZZO,
         recIntermed.CAP,
         recIntermed.COMUNE,
         'C',
         idIntermPadrePapua,
         'Z',
         recIntermed.CODICE_AGEA,
         null,
         NULL, --respCAA,
         recIntermed.RECAPITO,
         null,
         recIntermed.MAIL,
         null);

    select papua.seq_papua_t_ente.nextval 
    into idEnte
    from dual;

    insert into papua.papua_t_ente 
        (ID_ENTE,
         ID_TIPO_ENTE,
         EXT_ID_AZIENDA,
         EXT_ID_AMM_COMPETENZA,
         EXT_ID_INTERMEDIARIO,
         FLAG_ENTE_PAPUA,
         CUAA,
         P_IVA,
         DENOMINAZIONE,
         FORMA_GIURIDICA,
         INDIRIZZO,
         COMUNE,
         CAP,
         PROV,
         TELEFONO,
         FAX,
         EMAIL,
         EXT_ID_AMM_COMPETENZA_PADRE,
         FLAG_STATO_ATTIVITA_ENTE,
         DATA_AGGIORNAMENTO_ENTE,
         PROTOCOLLO,
         DATA_INIZIO_CONCESSIONE,
         DATA_FINE_CONCESSIONE,
         DT_ULTIMO_AGGIORNAMENTO,
         UTENTE_AGGIORNAMENTO,
         DATA_INIZIO_ATTIVITA,
         DATA_FINE_ATTIVITA,
         DATA_INIZIO_VALIDITA,
         CODICE_ENTE,
         DATA_FINE_VALIDITA,
         TIPO_ENTE_IRIDE1,
         EXT_ID_ENTE_IRIDE1,
         GRUPPO_WEBI,
         ENTE_RUPAR,
         ALLEGATO_RICHIESTA_ACCREDITAME,
         NOME_ALLEG_RICHIESTA_ACCR,
         ISTAT_COMUNE,
         USER_WEBI_GRUPPO,
         EMAIL_PEC)
    values 
        (idEnte,
         1,
         null,
         null,
         idIntermediario,
         'S',
         recIntermed.CODICE_AGEA,
         recIntermed.CODICE_AGEA,
         recIntermed.DENOMINAZIONE,
         null,
         recIntermed.INDIRIZZO,
         recIntermed.COMUNE,
         recIntermed.CAP,
         NULL,--provCAA,
         recIntermed.RECAPITO,
         null,
         recIntermed.MAIL,
         null,
         'A',
         sysdate,
         null,
         sysdate,
         null,
         sysdate,
         utenteAggiornamento,
         sysdate,
         null,
         sysdate,
         recIntermed.CODICE_AGEA,
         null,
         null,
         null,
         null,
         'Z',
         null,
         null,
         null,
         null,
         null
        );

    -- inserisce associazione ente-procedimento altrimenti gli utenti non accedono
    -- PSR
    insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
        (ID_PROCEDIMENTO_ENTE,
         ID_ENTE,
         ID_PROCEDIMENTO,
         DATA_INIZIO_VALIDITA,
         DATA_FINE_VALIDITA)
    values 
        (papua.seq_papua_r_procedimento_ente.nextval,
         idEnte,
         46,
         trunc(sysdate),
         null);

    -- Anagrafe
    insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
        (ID_PROCEDIMENTO_ENTE,
         ID_ENTE,
         ID_PROCEDIMENTO,
         DATA_INIZIO_VALIDITA,
         DATA_FINE_VALIDITA)
    values 
        (papua.seq_papua_r_procedimento_ente.nextval,
         idEnte,
         7,
         trunc(sysdate),
         null);

    -- UMA
    insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
        (ID_PROCEDIMENTO_ENTE,
         ID_ENTE,
         ID_PROCEDIMENTO,
         DATA_INIZIO_VALIDITA,
         DATA_FINE_VALIDITA)
    values 
        (papua.seq_papua_r_procedimento_ente.nextval,
         idEnte,
         1,
         trunc(sysdate),
         null);
--END IF;
END LOOP;

end;

/
--------------------------------------------------------
--  DDL for Procedure PRC_NUOVO_CAA_PROVINCIA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "SMRGAA"."PRC_NUOVO_CAA_PROVINCIA" 
is
    utenteAggiornamento         PAPUA.PAPUA_T_ENTE.UTENTE_AGGIORNAMENTO%TYPE := 9999999999;
    idIntermediario             SMRGAA.DB_INTERMEDIARIO.ID_INTERMEDIARIO%TYPE;
    idIntermediarioPadre        SMRGAA.DB_INTERMEDIARIO.ID_INTERMEDIARIO%TYPE;
    idIntermPadrePapua          PAPUA.papua_d_intermediario.ID_INTERMEDIARIO%TYPE;
    idUffZonaInterm             SMRGAA.DB_UFFICIO_ZONA_INTERMEDIARIO.ID_UFFICIO_ZONA_INTERMEDIARIO%TYPE;
    idEnte                      papua.papua_t_ente.id_ente%TYPE;
    checkCAA    integer     :=0;
    codiceCAA   SMRGAA.DB_INTERMEDIARIO.codice_fiscale%TYPE     := '';  -- tripletta
    denomCAA    SMRGAA.DB_INTERMEDIARIO.denominazione%TYPE      := 'CONFAGRICOLTURA - POTENZA';
    indirizzoCAA    SMRGAA.DB_INTERMEDIARIO.indirizzo%TYPE      := '';
    comuneCAA       SMRGAA.DB_INTERMEDIARIO.comune%TYPE         := '';  -- cod istat
    capCAA          SMRGAA.DB_INTERMEDIARIO.cap%TYPE            := '';
    provCAA         varchar2(2 byte)                            := '';  -- sigla
    respCAA         SMRGAA.DB_INTERMEDIARIO.RESPONSABILE%TYPE   := '';
    telCAA          SMRGAA.DB_INTERMEDIARIO.TELEFONO%TYPE       := '';
    faxCAA          SMRGAA.DB_INTERMEDIARIO.FAX%TYPE            := '';
    emailCAA        SMRGAA.DB_INTERMEDIARIO.EMAIL%TYPE          := '';
    pecCAA          SMRGAA.DB_INTERMEDIARIO.PEC%TYPE            := '';
		
begin

    -- verifica che il CAA non sia già presente
    select count(1)
    into checkCAA
    from SMRGAA.DB_INTERMEDIARIO caa
    where caa.codice_fiscale = codiceCAA
    and   caa.tipo_intermediario = 'C';

    if checkCAA > 0 then
        dbms_output.put_line('CAA già presente');
        return;
    end if;

    -- verifica che il CAA non sia già presente in PAPUA
    select count(1)
    into checkCAA
    from PAPUA.papua_d_intermediario caa
    where caa.codice_fiscale = codiceCAA
    and   caa.tipo_intermediario = 'C';

    if checkCAA > 0 then
        dbms_output.put_line('CAA già presente in PAPUA');
        return;
    end if;

    -- verifica che esista ufficio regionale (caa padre)
    begin
        select caa.id_intermediario
        into idIntermediarioPadre
        from SMRGAA.DB_INTERMEDIARIO caa
        where substr(caa.codice_fiscale, 1, 3) = substr(codiceCAA, 1, 3)
        and   caa.livello = 'R'
        and   caa.tipo_intermediario = 'C';
    exception when NO_DATA_FOUND then
        dbms_output.put_line('Ufficio regionale mancante');
        return;
    end;

    -- verifica che esista ufficio regionale su papua (caa padre)
    begin
        select caa.id_intermediario
        into idIntermPadrePapua
        from PAPUA.papua_d_intermediario caa
        where substr(caa.codice_fiscale, 1, 3) = substr(codiceCAA, 1, 3)
        and   caa.livello = 'R'
        and   caa.tipo_intermediario = 'C';
    exception when NO_DATA_FOUND then
        dbms_output.put_line('Ufficio regionale mancante SU PAPUA');
        return;
    end;

    -- inserisce su smrgaa db_intermediario    
    select seq_intermediario.nextval 
    into idIntermediario
    from dual;

    insert into smrgaa.db_intermediario
        (ID_INTERMEDIARIO, 
         DENOMINAZIONE, 
         CODICE_FISCALE, 
         INDIRIZZO, 
         CAP,
         COMUNE,
         TIPO_INTERMEDIARIO,
         ID_INTERMEDIARIO_PADRE,
         LIVELLO,
         PARTITA_IVA,
         DATA_FINE_VALIDITA,
         RESPONSABILE,
         TELEFONO,
         FAX,
         EMAIL,
         PEC,
         EXT_ID_AZIENDA,
         EXT_CUAA)           
    values
        (idIntermediario,
         denomCAA,
         codiceCAA,
         indirizzoCAA,
         capCAA,
         comuneCAA,
         'C',
         idIntermediarioPadre,
         'P',
         codiceCAA,
         null,
         respCAA,
         telCAA,
         faxCAA,
         emailCAA,
         pecCAA,
         null,
         null
        ); 

    -- aggiorna id_padre per uffici di zona
    update smrgaa.db_intermediario caa
    set caa.id_intermediario_padre = idIntermediario
    where substr(caa.codice_fiscale, 1, 6) = substr(codiceCAA, 1, 6)
    and   caa.livello = 'Z'
    and   caa.tipo_intermediario = 'C';

    insert into papua.papua_d_intermediario
        (ID_INTERMEDIARIO, 
         DENOMINAZIONE, 
         CODICE_FISCALE, 
         INDIRIZZO, 
         CAP,
         EXT_ISTAT_COMUNE,
         TIPO_INTERMEDIARIO,
         ID_INTERMEDIARIO_PADRE,
         LIVELLO,
         PARTITA_IVA,
         DATA_FINE_VALIDITA,
         RESPONSABILE,
         TELEFONO,
         FAX,
         EMAIL,
         PEC)           
    values 
        (idIntermediario,
         denomCAA,
         codiceCAA,
         indirizzoCAA,
         capCAA,
         comuneCAA,
         'C',
         idIntermPadrePapua,
         'P',
         codiceCAA,
         null,
         respCAA,
         telCAA,
         faxCAA,
         emailCAA,
         pecCAA);

    -- aggiorna id_padre per uffici di zona
    update papua.db_intermediario caa
    set caa.id_intermediario_padre = idIntermediario
    where substr(caa.codice_fiscale, 1, 6) = substr(codiceCAA, 1, 6)
    and   caa.livello = 'Z'
    and   caa.tipo_intermediario = 'C';

    select papua.seq_papua_t_ente.nextval 
    into idEnte
    from dual;

    insert into papua.papua_t_ente 
        (ID_ENTE,
         ID_TIPO_ENTE,
         EXT_ID_AZIENDA,
         EXT_ID_AMM_COMPETENZA,
         EXT_ID_INTERMEDIARIO,
         FLAG_ENTE_PAPUA,
         CUAA,
         P_IVA,
         DENOMINAZIONE,
         FORMA_GIURIDICA,
         INDIRIZZO,
         COMUNE,
         CAP,
         PROV,
         TELEFONO,
         FAX,
         EMAIL,
         EXT_ID_AMM_COMPETENZA_PADRE,
         FLAG_STATO_ATTIVITA_ENTE,
         DATA_AGGIORNAMENTO_ENTE,
         PROTOCOLLO,
         DATA_INIZIO_CONCESSIONE,
         DATA_FINE_CONCESSIONE,
         DT_ULTIMO_AGGIORNAMENTO,
         UTENTE_AGGIORNAMENTO,
         DATA_INIZIO_ATTIVITA,
         DATA_FINE_ATTIVITA,
         DATA_INIZIO_VALIDITA,
         CODICE_ENTE,
         DATA_FINE_VALIDITA,
         TIPO_ENTE_IRIDE1,
         EXT_ID_ENTE_IRIDE1,
         GRUPPO_WEBI,
         ENTE_RUPAR,
         ALLEGATO_RICHIESTA_ACCREDITAME,
         NOME_ALLEG_RICHIESTA_ACCR,
         ISTAT_COMUNE,
         USER_WEBI_GRUPPO,
         EMAIL_PEC)
    values 
        (idEnte,
         1,
         null,
         null,
         idIntermediario,
         'S',
         codiceCAA,
         codiceCAA,
         denomCAA,
         null,
         indirizzoCAA,
         comuneCAA,
         capCAA,
         provCAA,
         telCAA,
         null,
         emailCAA,
         null,
         'A',
         sysdate,
         null,
         sysdate,
         null,
         sysdate,
         utenteAggiornamento,
         sysdate,
         null,
         sysdate,
         codiceCAA,
         null,
         null,
         null,
         null,
         'Z',
         null,
         null,
         null,
         null,
         null
        );

    -- inserisce associazione ente-procedimento altrimenti gli utenti non accedono
    -- PSR
    insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
        (ID_PROCEDIMENTO_ENTE,
         ID_ENTE,
         ID_PROCEDIMENTO,
         DATA_INIZIO_VALIDITA,
         DATA_FINE_VALIDITA)
    values 
        (papua.seq_papua_r_procedimento_ente.nextval,
         idEnte,
         46,
         trunc(sysdate),
         null);

    -- Anagrafe
    insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
        (ID_PROCEDIMENTO_ENTE,
         ID_ENTE,
         ID_PROCEDIMENTO,
         DATA_INIZIO_VALIDITA,
         DATA_FINE_VALIDITA)
    values 
        (papua.seq_papua_r_procedimento_ente.nextval,
         idEnte,
         7,
         trunc(sysdate),
         null);

    -- UMA
    insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
        (ID_PROCEDIMENTO_ENTE,
         ID_ENTE,
         ID_PROCEDIMENTO,
         DATA_INIZIO_VALIDITA,
         DATA_FINE_VALIDITA)
    values 
        (papua.seq_papua_r_procedimento_ente.nextval,
         idEnte,
         1,
         trunc(sysdate),
         null);

end;

/
--------------------------------------------------------
--  DDL for Procedure PRC_NUOVO_CAA_PROVINCIA_PAPUA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "SMRGAA"."PRC_NUOVO_CAA_PROVINCIA_PAPUA" 
is
    utenteAggiornamento         PAPUA.PAPUA_T_ENTE.UTENTE_AGGIORNAMENTO%TYPE := 9999999999;
    idIntermediario             SMRGAA.DB_INTERMEDIARIO.ID_INTERMEDIARIO%TYPE;
    idIntermediarioPadre        SMRGAA.DB_INTERMEDIARIO.ID_INTERMEDIARIO%TYPE;
    idIntermPadrePapua          PAPUA.papua_d_intermediario.ID_INTERMEDIARIO%TYPE;
    idUffZonaInterm             SMRGAA.DB_UFFICIO_ZONA_INTERMEDIARIO.ID_UFFICIO_ZONA_INTERMEDIARIO%TYPE;
    idEnte                      papua.papua_t_ente.id_ente%TYPE;
    checkCAA    integer     :=0;
    codiceCAA   SMRGAA.DB_INTERMEDIARIO.codice_fiscale%TYPE     := '';  -- tripletta
    denomCAA    SMRGAA.DB_INTERMEDIARIO.denominazione%TYPE      := '';
    indirizzoCAA    SMRGAA.DB_INTERMEDIARIO.indirizzo%TYPE      := '';
    comuneCAA       SMRGAA.DB_INTERMEDIARIO.comune%TYPE         := '';  -- cod istat
    capCAA          SMRGAA.DB_INTERMEDIARIO.cap%TYPE            := '';
    provCAA         varchar2(2 byte)                            := '';  -- sigla
    respCAA         SMRGAA.DB_INTERMEDIARIO.RESPONSABILE%TYPE   := '';
    telCAA          SMRGAA.DB_INTERMEDIARIO.TELEFONO%TYPE       := '';
    faxCAA          SMRGAA.DB_INTERMEDIARIO.FAX%TYPE            := '';
    emailCAA        SMRGAA.DB_INTERMEDIARIO.EMAIL%TYPE          := '';
    pecCAA          SMRGAA.DB_INTERMEDIARIO.PEC%TYPE            := '';

begin

    -- verifica che il CAA sia già presente in anagrafe
    select count(1)
    into checkCAA
    from SMRGAA.DB_INTERMEDIARIO caa
    where caa.codice_fiscale = codiceCAA
    and   caa.tipo_intermediario = 'C';

    if checkCAA = 0 then
        dbms_output.put_line('CAA provinciale non presente in anagrafe');
        return;
    end if;

    -- verifica che il CAA non sia già presente in PAPUA
    select count(1)
    into checkCAA
    from PAPUA.papua_d_intermediario caa
    where caa.codice_fiscale = codiceCAA
    and   caa.tipo_intermediario = 'C';

    if checkCAA > 0 then
        dbms_output.put_line('CAA già presente in PAPUA');
        return;
    end if;

    -- verifica che esista ufficio regionale (caa padre)
    begin
        select caa.id_intermediario
        into idIntermediarioPadre
        from SMRGAA.DB_INTERMEDIARIO caa
        where substr(caa.codice_fiscale, 1, 3) = substr(codiceCAA, 1, 3)
        and   caa.livello = 'R'
        and   caa.tipo_intermediario = 'C';
    exception when NO_DATA_FOUND then
        dbms_output.put_line('Ufficio regionale mancante');
        return;
    end;

    -- verifica che esista ufficio regionale su papua (caa padre)
    begin
        select caa.id_intermediario
        into idIntermPadrePapua
        from PAPUA.papua_d_intermediario caa
        where substr(caa.codice_fiscale, 1, 3) = substr(codiceCAA, 1, 3)
        and   caa.livello = 'R'
        and   caa.tipo_intermediario = 'C';
    exception when NO_DATA_FOUND then
        dbms_output.put_line('Ufficio regionale mancante SU PAPUA');
        return;
    end;

    -- inserisce su intermediario    
    select 242 --seq_intermediario.nextval 
    into idIntermediario
    from dual;

    insert into papua.papua_d_intermediario
        (ID_INTERMEDIARIO, 
         DENOMINAZIONE, 
         CODICE_FISCALE, 
         INDIRIZZO, 
         CAP,
         EXT_ISTAT_COMUNE,
         TIPO_INTERMEDIARIO,
         ID_INTERMEDIARIO_PADRE,
         LIVELLO,
         PARTITA_IVA,
         DATA_FINE_VALIDITA,
         RESPONSABILE,
         TELEFONO,
         FAX,
         EMAIL,
         PEC)           
    values 
        (idIntermediario,
         denomCAA,
         codiceCAA,
         indirizzoCAA,
         capCAA,
         comuneCAA,
         'C',
         idIntermPadrePapua,
         'P',
         codiceCAA,
         null,
         respCAA,
         telCAA,
         faxCAA,
         emailCAA,
         pecCAA);

    -- aggiorna id_padre per uffici di zona
    update papua.db_intermediario caa
    set caa.id_intermediario_padre = idIntermediario
    where substr(caa.codice_fiscale, 1, 6) = substr(codiceCAA, 1, 6)
    and   caa.livello = 'Z'
    and   caa.tipo_intermediario = 'C';

    select papua.seq_papua_t_ente.nextval 
    into idEnte
    from dual;

    insert into papua.papua_t_ente 
        (ID_ENTE,
         ID_TIPO_ENTE,
         EXT_ID_AZIENDA,
         EXT_ID_AMM_COMPETENZA,
         EXT_ID_INTERMEDIARIO,
         FLAG_ENTE_PAPUA,
         CUAA,
         P_IVA,
         DENOMINAZIONE,
         FORMA_GIURIDICA,
         INDIRIZZO,
         COMUNE,
         CAP,
         PROV,
         TELEFONO,
         FAX,
         EMAIL,
         EXT_ID_AMM_COMPETENZA_PADRE,
         FLAG_STATO_ATTIVITA_ENTE,
         DATA_AGGIORNAMENTO_ENTE,
         PROTOCOLLO,
         DATA_INIZIO_CONCESSIONE,
         DATA_FINE_CONCESSIONE,
         DT_ULTIMO_AGGIORNAMENTO,
         UTENTE_AGGIORNAMENTO,
         DATA_INIZIO_ATTIVITA,
         DATA_FINE_ATTIVITA,
         DATA_INIZIO_VALIDITA,
         CODICE_ENTE,
         DATA_FINE_VALIDITA,
         TIPO_ENTE_IRIDE1,
         EXT_ID_ENTE_IRIDE1,
         GRUPPO_WEBI,
         ENTE_RUPAR,
         ALLEGATO_RICHIESTA_ACCREDITAME,
         NOME_ALLEG_RICHIESTA_ACCR,
         ISTAT_COMUNE,
         USER_WEBI_GRUPPO,
         EMAIL_PEC)
    values 
        (idEnte,
         1,
         null,
         null,
         idIntermediario,
         'S',
         codiceCAA,
         codiceCAA,
         denomCAA,
         null,
         indirizzoCAA,
         comuneCAA,
         capCAA,
         provCAA,
         telCAA,
         null,
         emailCAA,
         null,
         'A',
         sysdate,
         null,
         sysdate,
         null,
         sysdate,
         utenteAggiornamento,
         sysdate,
         null,
         sysdate,
         codiceCAA,
         null,
         null,
         null,
         null,
         'Z',
         null,
         null,
         null,
         null,
         null
        );

    -- inserisce associazione ente-procedimento altrimenti gli utenti non accedono
    -- PSR
    insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
        (ID_PROCEDIMENTO_ENTE,
         ID_ENTE,
         ID_PROCEDIMENTO,
         DATA_INIZIO_VALIDITA,
         DATA_FINE_VALIDITA)
    values 
        (papua.seq_papua_r_procedimento_ente.nextval,
         idEnte,
         46,
         trunc(sysdate),
         null);

    -- Anagrafe
    insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
        (ID_PROCEDIMENTO_ENTE,
         ID_ENTE,
         ID_PROCEDIMENTO,
         DATA_INIZIO_VALIDITA,
         DATA_FINE_VALIDITA)
    values 
        (papua.seq_papua_r_procedimento_ente.nextval,
         idEnte,
         7,
         trunc(sysdate),
         null);

    -- UMA
    insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
        (ID_PROCEDIMENTO_ENTE,
         ID_ENTE,
         ID_PROCEDIMENTO,
         DATA_INIZIO_VALIDITA,
         DATA_FINE_VALIDITA)
    values 
        (papua.seq_papua_r_procedimento_ente.nextval,
         idEnte,
         1,
         trunc(sysdate),
         null);

end;

/
--------------------------------------------------------
--  DDL for Procedure PRC_NUOVO_CAA_REGIONE
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "SMRGAA"."PRC_NUOVO_CAA_REGIONE" 
is
    utenteAggiornamento         PAPUA.PAPUA_T_ENTE.UTENTE_AGGIORNAMENTO%TYPE := 9999999999;
    idIntermediario             SMRGAA.DB_INTERMEDIARIO.ID_INTERMEDIARIO%TYPE;
    idIntermediarioPadre        SMRGAA.DB_INTERMEDIARIO.ID_INTERMEDIARIO%TYPE;
    idIntermPadrePapua          PAPUA.papua_d_intermediario.ID_INTERMEDIARIO%TYPE;
    idUffZonaInterm             SMRGAA.DB_UFFICIO_ZONA_INTERMEDIARIO.ID_UFFICIO_ZONA_INTERMEDIARIO%TYPE;
    idEnte                      papua.papua_t_ente.id_ente%TYPE;
    checkCAA    integer     :=0;
    codiceCAA   SMRGAA.DB_INTERMEDIARIO.codice_fiscale%TYPE     := '';  -- tripletta
    denomCAA    SMRGAA.DB_INTERMEDIARIO.denominazione%TYPE      := '';
    indirizzoCAA    SMRGAA.DB_INTERMEDIARIO.indirizzo%TYPE      := '';
    comuneCAA       SMRGAA.DB_INTERMEDIARIO.comune%TYPE         := '';  -- cod istat
    capCAA          SMRGAA.DB_INTERMEDIARIO.cap%TYPE            := '';
    provCAA         varchar2(2 byte)                            := '';  -- sigla
    respCAA         SMRGAA.DB_INTERMEDIARIO.RESPONSABILE%TYPE   := '';
    telCAA          SMRGAA.DB_INTERMEDIARIO.TELEFONO%TYPE       := '';
    faxCAA          SMRGAA.DB_INTERMEDIARIO.FAX%TYPE            := '';
    emailCAA        SMRGAA.DB_INTERMEDIARIO.EMAIL%TYPE          := '';
    pecCAA          SMRGAA.DB_INTERMEDIARIO.PEC%TYPE            := '';

begin

    -- verifica che il CAA non sia già presente
    select count(1)
    into checkCAA
    from SMRGAA.DB_INTERMEDIARIO caa
    where caa.codice_fiscale = codiceCAA
    and   caa.tipo_intermediario = 'C';

    if checkCAA > 0 then
        dbms_output.put_line('CAA già presente');
        return;
    end if;

    -- verifica che il CAA non sia già presente in PAPUA
    select count(1)
    into checkCAA
    from PAPUA.papua_d_intermediario caa
    where caa.codice_fiscale = codiceCAA
    and   caa.tipo_intermediario = 'C';

    if checkCAA > 0 then
        dbms_output.put_line('CAA già presente in PAPUA');
        return;
    end if;

    -- inserisce su smrgaa db_intermediario    
    select seq_intermediario.nextval 
    into idIntermediario
    from dual;

    insert into smrgaa.db_intermediario
        (ID_INTERMEDIARIO, 
         DENOMINAZIONE, 
         CODICE_FISCALE, 
         INDIRIZZO, 
         CAP,
         COMUNE,
         TIPO_INTERMEDIARIO,
         ID_INTERMEDIARIO_PADRE,
         LIVELLO,
         PARTITA_IVA,
         DATA_FINE_VALIDITA,
         RESPONSABILE,
         TELEFONO,
         FAX,
         EMAIL,
         PEC,
         EXT_ID_AZIENDA,
         EXT_CUAA)           
    values
        (idIntermediario,
         denomCAA,
         codiceCAA,
         indirizzoCAA,
         capCAA,
         comuneCAA,
         'C',
         null,
         'R',
         codiceCAA,
         null,
         respCAA,
         telCAA,
         faxCAA,
         emailCAA,
         pecCAA,
         null,
         null
        );

    insert into papua.papua_d_intermediario
        (ID_INTERMEDIARIO, 
         DENOMINAZIONE, 
         CODICE_FISCALE, 
         INDIRIZZO, 
         CAP,
         EXT_ISTAT_COMUNE,
         TIPO_INTERMEDIARIO,
         ID_INTERMEDIARIO_PADRE,
         LIVELLO,
         PARTITA_IVA,
         DATA_FINE_VALIDITA,
         RESPONSABILE,
         TELEFONO,
         FAX,
         EMAIL,
         PEC)           
    values 
        (idIntermediario,
         denomCAA,
         codiceCAA,
         indirizzoCAA,
         capCAA,
         comuneCAA,
         'C',
         null,
         'R',
         codiceCAA,
         null,
         respCAA,
         telCAA,
         faxCAA,
         emailCAA,
         pecCAA);

    select papua.seq_papua_t_ente.nextval 
    into idEnte
    from dual;

    insert into papua.papua_t_ente 
        (ID_ENTE,
         ID_TIPO_ENTE,
         EXT_ID_AZIENDA,
         EXT_ID_AMM_COMPETENZA,
         EXT_ID_INTERMEDIARIO,
         FLAG_ENTE_PAPUA,
         CUAA,
         P_IVA,
         DENOMINAZIONE,
         FORMA_GIURIDICA,
         INDIRIZZO,
         COMUNE,
         CAP,
         PROV,
         TELEFONO,
         FAX,
         EMAIL,
         EXT_ID_AMM_COMPETENZA_PADRE,
         FLAG_STATO_ATTIVITA_ENTE,
         DATA_AGGIORNAMENTO_ENTE,
         PROTOCOLLO,
         DATA_INIZIO_CONCESSIONE,
         DATA_FINE_CONCESSIONE,
         DT_ULTIMO_AGGIORNAMENTO,
         UTENTE_AGGIORNAMENTO,
         DATA_INIZIO_ATTIVITA,
         DATA_FINE_ATTIVITA,
         DATA_INIZIO_VALIDITA,
         CODICE_ENTE,
         DATA_FINE_VALIDITA,
         TIPO_ENTE_IRIDE1,
         EXT_ID_ENTE_IRIDE1,
         GRUPPO_WEBI,
         ENTE_RUPAR,
         ALLEGATO_RICHIESTA_ACCREDITAME,
         NOME_ALLEG_RICHIESTA_ACCR,
         ISTAT_COMUNE,
         USER_WEBI_GRUPPO,
         EMAIL_PEC)
    values 
        (idEnte,
         1,
         null,
         null,
         idIntermediario,
         'S',
         codiceCAA,
         codiceCAA,
         denomCAA,
         null,
         indirizzoCAA,
         comuneCAA,
         capCAA,
         provCAA,
         telCAA,
         null,
         emailCAA,
         null,
         'A',
         sysdate,
         null,
         sysdate,
         null,
         sysdate,
         utenteAggiornamento,
         sysdate,
         null,
         sysdate,
         codiceCAA,
         null,
         null,
         null,
         null,
         'Z',
         null,
         null,
         null,
         null,
         null
        );

    -- inserisce associazione ente-procedimento altrimenti gli utenti non accedono
    -- PSR
    insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
        (ID_PROCEDIMENTO_ENTE,
         ID_ENTE,
         ID_PROCEDIMENTO,
         DATA_INIZIO_VALIDITA,
         DATA_FINE_VALIDITA)
    values 
        (papua.seq_papua_r_procedimento_ente.nextval,
         idEnte,
         46,
         trunc(sysdate),
         null);

    -- Anagrafe
    insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
        (ID_PROCEDIMENTO_ENTE,
         ID_ENTE,
         ID_PROCEDIMENTO,
         DATA_INIZIO_VALIDITA,
         DATA_FINE_VALIDITA)
    values 
        (papua.seq_papua_r_procedimento_ente.nextval,
         idEnte,
         7,
         trunc(sysdate),
         null);

    -- UMA
    insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
        (ID_PROCEDIMENTO_ENTE,
         ID_ENTE,
         ID_PROCEDIMENTO,
         DATA_INIZIO_VALIDITA,
         DATA_FINE_VALIDITA)
    values 
        (papua.seq_papua_r_procedimento_ente.nextval,
         idEnte,
         1,
         trunc(sysdate),
         null);

end;

/
--------------------------------------------------------
--  DDL for Procedure PRC_NUOVO_CAA_REGIONE_PAPUA
--------------------------------------------------------
set define off;

  CREATE OR REPLACE PROCEDURE "SMRGAA"."PRC_NUOVO_CAA_REGIONE_PAPUA" 
is
    utenteAggiornamento         PAPUA.PAPUA_T_ENTE.UTENTE_AGGIORNAMENTO%TYPE := 9999999999;
    idIntermediario             SMRGAA.DB_INTERMEDIARIO.ID_INTERMEDIARIO%TYPE;
    idIntermediarioPadre        SMRGAA.DB_INTERMEDIARIO.ID_INTERMEDIARIO%TYPE;
    idIntermPadrePapua          PAPUA.papua_d_intermediario.ID_INTERMEDIARIO%TYPE;
    idUffZonaInterm             SMRGAA.DB_UFFICIO_ZONA_INTERMEDIARIO.ID_UFFICIO_ZONA_INTERMEDIARIO%TYPE;
    idEnte                      papua.papua_t_ente.id_ente%TYPE;
    checkCAA    integer     :=0;
    codiceCAA   SMRGAA.DB_INTERMEDIARIO.codice_fiscale%TYPE     := '';  -- tripletta
    denomCAA    SMRGAA.DB_INTERMEDIARIO.denominazione%TYPE      := '';
    indirizzoCAA    SMRGAA.DB_INTERMEDIARIO.indirizzo%TYPE      := '';
    comuneCAA       SMRGAA.DB_INTERMEDIARIO.comune%TYPE         := '';  -- cod istat
    capCAA          SMRGAA.DB_INTERMEDIARIO.cap%TYPE            := '';
    provCAA         varchar2(2 byte)                            := '';  -- sigla
    respCAA         SMRGAA.DB_INTERMEDIARIO.RESPONSABILE%TYPE   := '';
    telCAA          SMRGAA.DB_INTERMEDIARIO.TELEFONO%TYPE       := '';
    faxCAA          SMRGAA.DB_INTERMEDIARIO.FAX%TYPE            := '';
    emailCAA        SMRGAA.DB_INTERMEDIARIO.EMAIL%TYPE          := '';
    pecCAA          SMRGAA.DB_INTERMEDIARIO.PEC%TYPE            := '';

begin


    -- verifica che il CAA sia già presente su smrgaa
    begin 
        select id_intermediario
        into idIntermediario
        from SMRGAA.DB_INTERMEDIARIO caa
        where caa.codice_fiscale = codiceCAA
        and   caa.tipo_intermediario = 'C'
        and   caa.livello = 'R';
    exception when no_data_found then    
        dbms_output.put_line('CAA regionale non presente su anagrafe');
        return;
    end;

    -- verifica che il CAA non sia già presente in PAPUA
    select count(1)
    into checkCAA
    from PAPUA.papua_d_intermediario caa
    where caa.codice_fiscale = codiceCAA
    and   caa.tipo_intermediario = 'C';

    if checkCAA > 0 then
        dbms_output.put_line('CAA già presente in PAPUA');
        return;
    end if;

/*    
    -- inserisce su smrgaa db_intermediario    
    select seq_intermediario.nextval 
    into idIntermediario
    from dual;

    insert into smrgaa.db_intermediario
        (ID_INTERMEDIARIO, 
         DENOMINAZIONE, 
         CODICE_FISCALE, 
         INDIRIZZO, 
         CAP,
         COMUNE,
         TIPO_INTERMEDIARIO,
         ID_INTERMEDIARIO_PADRE,
         LIVELLO,
         PARTITA_IVA,
         DATA_FINE_VALIDITA,
         RESPONSABILE,
         TELEFONO,
         FAX,
         EMAIL,
         PEC,
         EXT_ID_AZIENDA,
         EXT_CUAA)           
    values
        (idIntermediario,
         denomCAA,
         codiceCAA,
         indirizzoCAA,
         capCAA,
         comuneCAA,
         'C',
         null,
         'R',
         codiceCAA,
         null,
         respCAA,
         telCAA,
         faxCAA,
         emailCAA,
         pecCAA,
         null,
         null
        );
*/

    insert into papua.papua_d_intermediario
        (ID_INTERMEDIARIO, 
         DENOMINAZIONE, 
         CODICE_FISCALE, 
         INDIRIZZO, 
         CAP,
         EXT_ISTAT_COMUNE,
         TIPO_INTERMEDIARIO,
         ID_INTERMEDIARIO_PADRE,
         LIVELLO,
         PARTITA_IVA,
         DATA_FINE_VALIDITA,
         RESPONSABILE,
         TELEFONO,
         FAX,
         EMAIL,
         PEC)           
    values 
        (idIntermediario,
         denomCAA,
         codiceCAA,
         indirizzoCAA,
         capCAA,
         comuneCAA,
         'C',
         null,
         'R',
         codiceCAA,
         null,
         respCAA,
         telCAA,
         faxCAA,
         emailCAA,
         pecCAA);

    select papua.seq_papua_t_ente.nextval 
    into idEnte
    from dual;

    insert into papua.papua_t_ente 
        (ID_ENTE,
         ID_TIPO_ENTE,
         EXT_ID_AZIENDA,
         EXT_ID_AMM_COMPETENZA,
         EXT_ID_INTERMEDIARIO,
         FLAG_ENTE_PAPUA,
         CUAA,
         P_IVA,
         DENOMINAZIONE,
         FORMA_GIURIDICA,
         INDIRIZZO,
         COMUNE,
         CAP,
         PROV,
         TELEFONO,
         FAX,
         EMAIL,
         EXT_ID_AMM_COMPETENZA_PADRE,
         FLAG_STATO_ATTIVITA_ENTE,
         DATA_AGGIORNAMENTO_ENTE,
         PROTOCOLLO,
         DATA_INIZIO_CONCESSIONE,
         DATA_FINE_CONCESSIONE,
         DT_ULTIMO_AGGIORNAMENTO,
         UTENTE_AGGIORNAMENTO,
         DATA_INIZIO_ATTIVITA,
         DATA_FINE_ATTIVITA,
         DATA_INIZIO_VALIDITA,
         CODICE_ENTE,
         DATA_FINE_VALIDITA,
         TIPO_ENTE_IRIDE1,
         EXT_ID_ENTE_IRIDE1,
         GRUPPO_WEBI,
         ENTE_RUPAR,
         ALLEGATO_RICHIESTA_ACCREDITAME,
         NOME_ALLEG_RICHIESTA_ACCR,
         ISTAT_COMUNE,
         USER_WEBI_GRUPPO,
         EMAIL_PEC)
    values 
        (idEnte,
         1,
         null,
         null,
         idIntermediario,
         'S',
         codiceCAA,
         codiceCAA,
         denomCAA,
         null,
         indirizzoCAA,
         comuneCAA,
         capCAA,
         provCAA,
         telCAA,
         null,
         emailCAA,
         null,
         'A',
         sysdate,
         null,
         sysdate,
         null,
         sysdate,
         utenteAggiornamento,
         sysdate,
         null,
         sysdate,
         codiceCAA,
         null,
         null,
         null,
         null,
         'Z',
         null,
         null,
         null,
         null,
         null
        );

    -- inserisce associazione ente-procedimento altrimenti gli utenti non accedono
    -- PSR
    insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
        (ID_PROCEDIMENTO_ENTE,
         ID_ENTE,
         ID_PROCEDIMENTO,
         DATA_INIZIO_VALIDITA,
         DATA_FINE_VALIDITA)
    values 
        (papua.seq_papua_r_procedimento_ente.nextval,
         idEnte,
         46,
         trunc(sysdate),
         null);

    -- Anagrafe
    insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
        (ID_PROCEDIMENTO_ENTE,
         ID_ENTE,
         ID_PROCEDIMENTO,
         DATA_INIZIO_VALIDITA,
         DATA_FINE_VALIDITA)
    values 
        (papua.seq_papua_r_procedimento_ente.nextval,
         idEnte,
         7,
         trunc(sysdate),
         null);

    -- UMA
    insert into PAPUA.PAPUA_R_PROCEDIMENTO_ENTE 
        (ID_PROCEDIMENTO_ENTE,
         ID_ENTE,
         ID_PROCEDIMENTO,
         DATA_INIZIO_VALIDITA,
         DATA_FINE_VALIDITA)
    values 
        (papua.seq_papua_r_procedimento_ente.nextval,
         idEnte,
         1,
         trunc(sysdate),
         null);

end;

/
--------------------------------------------------------
--  DDL for Package CABAAD778_PS_WP
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."CABAAD778_PS_WP" AS

  TolleranzaDefault               CONSTANT PLS_INTEGER := 1;
  NumCombinazioniMassimoDefault   CONSTANT PLS_INTEGER := 1000;
  ModoSaturazioneUtilizziDefault  CONSTANT NUMBER := 1;

  TYPE tabApcgType IS TABLE OF CABAAPCG_TAB%ROWTYPE;

  TYPE recAppezz IS RECORD(idAppezzamento  NUMBER,
                           idDeus          NUMBER);

  TYPE tblAppezz IS TABLE OF recAppezz INDEX BY BINARY_INTEGER;

  -- funzione che richiama la classe java datiSuoloPerPianoGrafico
  FUNCTION datiSuoloPerPianoGrafico(pIstatComune  VARCHAR2,
                                    pSezione      VARCHAR2,
                                    pFoglio       NUMBER,
                                    pParticella   NUMBER) RETURN tblSitiSuolo is LANGUAGE JAVA
  NAME 'it.csi.smranag.storedproc.SitiDbBridge.datiSuoloPerPianoGrafico(java.lang.String,java.lang.String,java.lang.Long,java.lang.Long) return it.csi.smranag.storedproc.SitiSuoloVO';

  -- funzione che richiama la classe java unisciShape
  FUNCTION unisciShape(pArrayShape  SDO_GEOMETRY_ARRAY) RETURN SDO_GEOMETRY is LANGUAGE JAVA
  NAME 'it.csi.smranag.storedproc.SitiDbBridge.unisciShape(oracle.sql.ARRAY) return oracle.sql.STRUCT';

  -- funzione per estrarre i dati di un soggetto a partire dal CUAA
  FUNCTION getDatiSogg(pCodiUtilita  VARCHAR2,
                       pCodiCuaa     VARCHAR2) RETURN tabDatiSoggType_wp2 PIPELINED;

  -- funzione per estrarre il catalogo prodotti a 5 codici
  FUNCTION getCatalogoVari(pCodiUtilita   VARCHAR2,
                           pCodiOccu      VARCHAR2 DEFAULT NULL,
                           pCodiDestUso   VARCHAR2 DEFAULT NULL,
                           pCodiUso       VARCHAR2 DEFAULT NULL,
                           pCodiQual      VARCHAR2 DEFAULT NULL,
                           pCodiOccuVari  VARCHAR2 DEFAULT NULL) RETURN tabCataVariType PIPELINED;

  -- funzione per estrarre i criteri di mantenimento per prodotto
  FUNCTION getPratManFromCata(pCodiUtilita   VARCHAR2,
                              pCodiOccu      VARCHAR2,
                              pCodiDestUsoo  VARCHAR2 DEFAULT NULL,
                              pCodiUsoo      VARCHAR2 DEFAULT NULL,
                              pCodiQual      VARCHAR2 DEFAULT NULL) RETURN tabPratManType PIPELINED;

  FUNCTION preCaricamento(pIdDichiarazioneConsistenza  DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE) RETURN NUMBER;

  --- funzione per estrarre i dati di utilizzo del suolo di un CUAA
  FUNCTION getUtilizziCuaa(pCodiUtilita  VARCHAR2,
                           pCodiCuaa     VARCHAR2,
                           pCodiBelf     VARCHAR2 DEFAULT NULL,
                           pSeziCens     VARCHAR2 DEFAULT NULL,
                           pNumeFogl     NUMBER   DEFAULT NULL) RETURN tabDeusPoliType_AG PIPELINED;

  -- La procedura e' utilizzata per riportare i dati del piano colturale grafico sul piano colturale alfanumerico
  PROCEDURE scriviPColtGrafico(pCodiUtilita   VARCHAR2,
                               pCodiCuaa      VARCHAR2,
                               pUtenApplGraf  VARCHAR2,
                               pListUtil      tabUtilType);

  -- funzione per estrarre i dati del suolo GIS richiamera' una classe java deployata sul db
  FUNCTION getSuoliGisCuaa(pCodiUtilita  VARCHAR2,
                           pCodiCuaa     VARCHAR2,
                           pCodiBelf     VARCHAR2 DEFAULT NULL,
                           pSeziCens     VARCHAR2 DEFAULT NULL,
                           pNumeFogl     NUMBER   DEFAULT NULL) RETURN TabSuoliGisType PIPELINED;

  -- funzione per estrarre il catalogo prodotti a 5 codici
  FUNCTION getMatB1FromGISCata(pCodiUtilita   VARCHAR2,
                               pCodiRile      VARCHAR2 DEFAULT NULL,
                               pCodiProdRile  VARCHAR2 DEFAULT NULL) RETURN tabMatB1CataType PIPELINED;

  -- funzione per estrarre i dati di conduzione di un CUAA
  FUNCTION getConduzioneCuaa(pCodiUtilita  VARCHAR2,
                             pCodiCuaa     VARCHAR2,
                             pCodiBelf     VARCHAR2 DEFAULT NULL,
                             pSeziCens     VARCHAR2 DEFAULT NULL,
                             pNumeFogl     NUMBER   DEFAULT NULL) RETURN tabCopaPoliType_AG PIPELINED;

  PROCEDURE calcolaAppezzamento(pUserInse             VARCHAR2,
                                pDeusPoliTabe  IN OUT tabDeusPoliType_wp2,
                                pApcgTabe         OUT tabApcgType,
                                pAppezz           OUT tblAppezz);

  FUNCTION getParticelleGisCuaa(pCodiUtilita  VARCHAR2,
                                pCodiCuaa     VARCHAR2,
                                pCodiBelf     VARCHAR2 DEFAULT NULL,
                                pSeziCens     VARCHAR2 DEFAULT NULL,
                                pNumeFogl     VARCHAR2 DEFAULT NULL) RETURN tabParticelleGisType_AG PIPELINED;

  PROCEDURE calcolaIsola(pUserInse             VARCHAR2,
                         pDeusPoliTabe  IN OUT tabDeusPoliType_wp2,
                         pApcgTabe         OUT tabApcgType,
                         pAppezz           OUT tblAppezz);

END CABAAD778_PS_WP;

/
--------------------------------------------------------
--  DDL for Package PACK_AGGIORNA_ATTESTAZIONI
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PACK_AGGIORNA_ATTESTAZIONI" IS

    -- costante che identificativo la voce di menù delle DICHIARAZIONI
    kvVoceMenuDichiarazioni CONSTANT DB_TIPO_ATTESTAZIONE.VOCE_MENU%TYPE:='DICHIARAZIONI';
    -- costante che identificativo la voce di menù delle ALLEGATI
    kvVoceMenuAllegati CONSTANT DB_TIPO_ATTESTAZIONE.VOCE_MENU%TYPE:='ALLEGATI';
    -- costante identificativo titolo possesso in asservimento
    knIdTitPossessoAsservimento CONSTANT DB_TIPO_TITOLO_POSSESSO.ID_TITOLO_POSSESSO%TYPE:=5;
    -- costante identificativo del procedimento RPU
    knIdProcedimentoRPU CONSTANT DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE:=12;
    -- costante identificativo del procedimento PSR
    knIdProcedimentoPSR CONSTANT DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE:=2;
    -- costante identificativo AREE MONTANE
    knAreaMontana CONSTANT DB_TIPO_ZONA_ALTIMETRICA.ID_ZONA_ALTIMETRICA%TYPE:=1;


  /*********************************************************************
  Gestisce in automatico le attestazioni in relazione alla consistenza aziendale
  Funziona sia per le Dichiarazioni al piano in lavorazione che per gli Allegati
  sia al piano in lavorazione che alla dichiarazione.
  Date:15/06/2010
  Tipo:Procedura
  Input:P_ID_AZIENDA Identificativo azienda
        P_ID_UTENTE_AGGIORNAMENTO:Identificativo Utente Iride
        P_COD_ATTESTAZIONE:codice dell'attestazione
  Output:Inserisce le attestazioni sul piano in lavorazione oppure
         alla dichiarazione di consistenza, DB_ATTESTAZIONE_AZIENDA,
         DB_ATTESTAZIONE_DICHIARATA
  Modifiche:16/06/2010
            Aggiunto il parametro P_ID_DICHIARAZIONE_CONSISTENZA
            per gestire correttamente gli allegati al piano della dichiarazione.
  *********************************************************************/
    PROCEDURE  CARICA_ATTESTAZIONI(P_ID_AZIENDA                   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                   P_ID_UTENTE_AGGIORNAMENTO      IN DB_ATTESTAZIONE_AZIENDA.ID_UTENTE_AGGIORNAMENTO%TYPE,
                                   P_COD_ATTESTAZIONE             IN DB_TIPO_ATTESTAZIONE.CODICE_ATTESTAZIONE%TYPE,
                                   P_ID_DICHIARAZIONE_CONSISTENZA IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                   P_CODERR                       IN OUT VARCHAR2,
                                   P_MSGERR                       IN OUT VARCHAR2);


    /*********************************************************************
    Dato un ID_DICHIARAZIONE_CONSISTENZA controlla se sono presenti
    su DB_ATTESTAZIONE_DICHIARATA degli ID_ATTESTAZIONE con occorrenze
    multiple aggiornatate nella data di sistema ed elimina tutte le occorrenze
    multiple tranne la più recente
    Tipo: procedure
    input: P_ID_DICHIARAZIONE_CONSISTENZA
    output: P_COD_ERR , P_MSG_ERR
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE RAGGRUPPA_ATTESTAZIONI (P_ID_DICHIARAZIONE_CONSISTENZA IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                      P_COD_ERR                  IN OUT VARCHAR2,
                                      P_MSG_ERR                  IN OUT VARCHAR2);



END;

/
--------------------------------------------------------
--  DDL for Package PACK_AGGIORNA_UV
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PACK_AGGIORNA_UV" IS

--TYPE ELENCO_PART IS TABLE OF DB_STORICO_PARTICELLA.ID_PARTICELLA%TYPE INDEX BY BINARY_INTEGER;
--TYPE ELENCO_PART IS TABLE OF DB_STORICO_PARTICELLA.ID_PARTICELLA%TYPE;

--TYPE ELENCO_UNAR IS TABLE OF DB_UNITA_ARBOREA_DICHIARATA.ID_UNITA_ARBOREA_DICHIARATA%TYPE INDEX BY BINARY_INTEGER;

-- IL TYPE NUM_VARRAY è DEFINITO COME TYPE DI ORACLE.

    PROCEDURE  AGGIORNA_STATO_UV(P_ELENCO_PARTICELLE IN NUM_VARRAY,
                              P_CODERR        IN OUT VARCHAR2,
                              P_MSGERR       IN OUT VARCHAR2);

    PROCEDURE  AGGIORNA_STATO_UV_DICH(P_ELENCO_UV IN     NUM_VARRAY,
                              P_CODERR        IN OUT VARCHAR2,
                              P_MSGERR       IN OUT VARCHAR2);

END;

/
--------------------------------------------------------
--  DDL for Package PACK_COMUNICAZIONE_10R
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PACK_COMUNICAZIONE_10R" IS


kvCodIstatPiemonte CONSTANT REGIONE.ID_REGIONE%TYPE:='01';
-- codice per reperimento parametro coefficiente utilizzato nel calcolo della recettività massima azoto in ZVN per superficie agronomica
kvCdAlDtCoefRctMaxAzotoZvnSA    CONSTANT DB_ALTRI_DATI.CODICE%TYPE:= '10RA';
-- codice per reperimento parametro coefficiente utilizzato nel calcolo della recettività massima azoto non in ZVN per superficie agronomica
kvCdAlDtCoefRctMaxAzotoNoZvnSA  CONSTANT DB_ALTRI_DATI.CODICE%TYPE:= '10RB';
-- codice per reperimento parametro cefficiente utilizzato nel calcolo della recettività massima azoto in ZVN per superficie condotta in asservimento
kvCdAlDtCoefRctMaxAzotoZvnSC    CONSTANT DB_ALTRI_DATI.CODICE%TYPE:= '10RC';
-- codice per reperimento parametro coefficiente utilizzato nel calcolo della recettività massima azoto non in ZVN per superficie condotta in asservimento
kvCdAlDtCoefRctMaxAzotoNoZvnSC  CONSTANT DB_ALTRI_DATI.CODICE%TYPE:= '10RD';
-- codice per reperimento parametro coefficiente utilizzato nel calcolo della recettività massima azoto in ZVN per superficie agronomica in caso di deroga
kvCdAlDtCoefRctMaxAzotoZvnSAD   CONSTANT DB_ALTRI_DATI.CODICE%TYPE:= '10RE';
-- codice per reperimento parametro cefficiente utilizzato nel calcolo della recettività massima azoto in ZVN per superficie condotta in asservimento in caso di deroga
kvCdAlDtCoefRctMaxAzotoZvnSCD   CONSTANT DB_ALTRI_DATI.CODICE%TYPE:= '10RF';
-- codice per reperimento parametro limite minimo kg di azoto dal quale effettuare il calcolo dei giorni di stocaggio
kvCdAlDtMinAzotoForCalcGGStoc   CONSTANT DB_ALTRI_DATI.CODICE%TYPE:= 'MINAZOTO';
-- identificativo tipo zona altimetrica montagna
knIdTipoZonaAltMontagna         CONSTANT DB_TIPO_ZONA_ALTIMETRICA.ID_ZONA_ALTIMETRICA%TYPE:=1;
-- identificativo tipo motivo dichiarazione "comunicazione 10R"
knIdTipoMotDichComu10R          CONSTANT DB_TIPO_MOTIVO_DICHIARAZIONE.ID_MOTIVO_DICHIARAZIONE%TYPE:=10;


FUNCTION FNC_COEFFICENTE_PIOGGIA         (    pIdFabbricato IN NUMBER    ) RETURN NUMBER;

PRAGMA RESTRICT_REFERENCES (FNC_COEFFICENTE_PIOGGIA, RNPS);

PROCEDURE CALCOLA_VOLUME_PIOGGIE_M3     (     pIdUte                    IN         NUMBER,
                                                          pSuperficeScoperta    OUT         NUMBER,
                                                          pCodErr                    OUT         VARCHAR2,
                                                          pDesErr                    OUT         VARCHAR2
                                                    );

PROCEDURE CALCOLA_EFFLUENTI_M3             (    pIdUte                        IN     NUMBER,
                                                        pFlagPalabile                IN     VARCHAR2 DEFAULT NULL,
                                                        pFlagTrattamento            IN     VARCHAR2,
                                                        pIdEffluente                IN        NUMBER     DEFAULT NULL,
                                                        pVolumeProdotto            OUT     NUMBER,
                                                        pVolumeProdottoAz            OUT     NUMBER,
                                                        pAzotoProdotto                OUT     NUMBER,
                                                        pAzotoProdottoAz            OUT     NUMBER,
                                                        pCodErr                        OUT     VARCHAR2,
                                                        pDesErr                        OUT     VARCHAR2
                                                    );

PROCEDURE CALCOLA_SUPERFICI_AGRONOMICA (     pIdUte                        IN     NUMBER,
                                                          pSuperficeAgromica_Z        OUT     NUMBER,
                                                        pSuperficeAgromica_NoZ    OUT     NUMBER,
                                                          pCodErr                        OUT     VARCHAR2,
                                                          pDesErr                        OUT     VARCHAR2
                                                    );


PROCEDURE CALCOLA_SUPERFICI_CONDOTTA     (     pIdUte                        IN     NUMBER,
                                                        pSuperficieCondotta_Z    OUT     NUMBER,
                                                        pSuperficieCondotta_NoZ    OUT     NUMBER,
                                                          pCodErr                        OUT     VARCHAR2,
                                                          pDesErr                        OUT     VARCHAR2
                                                    );


PROCEDURE CALCOLA_UTILE_FAB_STOCCAGGIO (     pIdUte                        IN     NUMBER,
                                                        pFlagPalabile                IN     VARCHAR2,
                                                          pUtileFabStock                OUT     NUMBER,
                                                          pCodErr                        OUT     VARCHAR2,
                                                          pDesErr                        OUT     VARCHAR2
                                                    );


PROCEDURE CALCOLA_LETTIERA_PERM_ALLEVAM ( pIdUte                        IN     NUMBER,
                                                          pTotLettiera                OUT     NUMBER,
                                                        pCodErr                        OUT     VARCHAR2,
                                                        pDesErr                        OUT     VARCHAR2
                                                    );

PROCEDURE CALCOLA_STOCCAGGIO_EXTRA_AZ     (     pIdComunicazione            IN     NUMBER,
                                                        pFlagPalabile                IN     VARCHAR2,
                                                          pStockExtraAz                OUT     NUMBER,
                                                          pCodErr                        OUT     VARCHAR2,
                                                          pDesErr                        OUT     VARCHAR2
                                                    );


PROCEDURE CALCOLA_CES_ACQUISIZIONE         (    pIdComunicazione            IN     NUMBER,
                                                        pFlagPalabile                IN     VARCHAR2 DEFAULT NULL,
                                                        pCausaleEffluente            IN     NUMBER,
                                                        pIdEffluente                IN        NUMBER     DEFAULT NULL,
                                                          pStockAcqAz                    OUT     NUMBER,
                                                          pStockAcqAzSto                OUT     NUMBER,
                                                          pCodErr                        OUT     VARCHAR2,
                                                          pDesErr                        OUT     VARCHAR2
                                                    );

PROCEDURE CALCOLA_ACQUE_MUNGITURA         (    pIdUte                        IN     NUMBER,
                                                        pTotMungitura                OUT     NUMBER,
                                                          pCodErr                        OUT     VARCHAR2,
                                                          pDesErr                        OUT     VARCHAR2
                                                    );

PROCEDURE CALCOLA_SUPERF_SAU_SPANDIBILE (    pIdUte                        IN     NUMBER,
                                                        pTotSup                        OUT     NUMBER,
                                                          pCodErr                        OUT     VARCHAR2,
                                                          pDesErr                        OUT     VARCHAR2
                                                    );

PROCEDURE CALCOLA_SUPERF_SAU_BIS         (    pIdUte                        IN     NUMBER,
                                                        pTotSup                        OUT     NUMBER,
                                                          pCodErr                        OUT     VARCHAR2,
                                                          pDesErr                        OUT     VARCHAR2
                                                    );


PROCEDURE CALCOLA_SUPERF_ZVN_SAU_SPAND (    pIdUte                        IN     NUMBER,
                                                        pTotSupZvn                    OUT    NUMBER,
                                                          pCodErr                        OUT     VARCHAR2,
                                                        pDesErr                        OUT     VARCHAR2
                                                    );

PROCEDURE CALCOLA_SUPERF_ZVN_SAU_BIS     (    pIdUte                        IN     NUMBER,
                                                        pTotSupZvn                    OUT    NUMBER,
                                                          pCodErr                        OUT     VARCHAR2,
                                                        pDesErr                        OUT     VARCHAR2
                                                    );


PROCEDURE CALCOLA_GIORNI_STOC_NECESSARI (   pIdUte              IN NUMBER,
                                            pIdEffluente        IN NUMBER,
                                            pMaxAzoto           IN NUMBER,
                                            pTotGg             OUT NUMBER,
                                            pCodErr            OUT VARCHAR2,
                                            pDesErr            OUT VARCHAR2);

PROCEDURE TROVA_CES_ACQ_10R                 (     pIdUte                      IN  DB_COMUNICAZIONE_10R.ID_UTE%TYPE,
                                                pIdComunicazione            IN     NUMBER,
                                                pCausaleEffluente            IN     NUMBER,
                                                pIdEffluente                IN     NUMBER,
                                                pQuantitaIn                    IN     NUMBER,
                                                pQuantitaOut                OUT     NUMBER,
                                                pCodErr                        OUT     VARCHAR2,
                                                pDesErr                        OUT     VARCHAR2
                                                    );

PROCEDURE TROVA_AZOTO_CES_ACQ_10R         (     pIdComunicazione            IN     NUMBER,
                                                        pFlagPalabile                IN     VARCHAR2 DEFAULT NULL,
                                                        pCausaleEffluente            IN     NUMBER,
                                                        pIdEffluente                IN     NUMBER     DEFAULT NULL,
--                                                          pQuantitaAzoto                OUT     NUMBER,    -- BM001
                                                          pQuantitaAzotoDic            OUT     NUMBER,    -- BM001
                                                          pCodErr                        OUT     VARCHAR2,
                                                          pDesErr                        OUT     VARCHAR2
                                                    );


PROCEDURE RICALCOLA                             (    pIdUte                        IN NUMBER,
                                                    pIdUtente                    IN NUMBER,
                                                    pOutIdComunicazione            OUT NUMBER,
                                                    pCodErr                        OUT VARCHAR2,
                                                    pDesErr                        OUT VARCHAR2
                                                    );

PROCEDURE RICALCOLA_AZIENDA                 (    pIdAzienda                     IN NUMBER,
                                                pIdUtente                    IN NUMBER,
                                                pCodErr                        OUT VARCHAR2,
                                                  pDesErr                        OUT VARCHAR2
                                                );

/*********************************************************************
Calcola la quantità di effluente ceduta od acquisita dall'azienda corrente
rispetto all'azienda cedente od acquirente per la tipologia di effluente
ed il tipo causale dati in input
Tipo: procedure
input: pIdAziendaCorrente, pIdAziendaCesAcq, pIdEffluente, pIdCausaleEffluente
output: pTotEffluenteCedAcq, pCodErr, pMessErr
ritorno: nessuno
*********************************************************************/
PROCEDURE M3_EFFLUENTE_CEDUTO_ACQUISITO (pIdAziendaCorrente     IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                         pIdAziendaCesAcq       IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                         pIdEffluente           IN DB_TIPO_EFFLUENTE.ID_EFFLUENTE%TYPE,
                                         pIdCausaleEffluente    IN DB_TIPO_CAUSALE_EFFLUENTE.ID_CAUSALE_EFFLUENTE%TYPE,
                                         pTotEffluenteCedAcq   OUT DB_EFFLUENTE_CES_ACQ_10R.QUANTITA%TYPE,
                                         pCodErr               OUT VARCHAR2,
                                         pMessErr              OUT VARCHAR2
                                         );

END Pack_Comunicazione_10r;

/
--------------------------------------------------------
--  DDL for Package PACK_CONTROLLI
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PACK_CONTROLLI" IS
    -- identificativo titolo possesso asservimento
    knIdTitoloPossessoAsservimento  CONSTANT DB_TIPO_TITOLO_POSSESSO.ID_TITOLO_POSSESSO%TYPE:=5;
    -- identificativo titolo possesso conferimento
    knIdTitoloPossessoConferimento  CONSTANT DB_TIPO_TITOLO_POSSESSO.ID_TITOLO_POSSESSO%TYPE:=6;
    -- identificativo tipo documento conto corrente
    knIdTipoDocumentoCC             CONSTANT DB_TIPO_DOCUMENTO.ID_TIPOLOGIA_DOCUMENTO%TYPE:=5;
    -- identificativo tipo fonte SIAP
    knIdTipoFonteSiap               CONSTANT DB_TIPO_FONTE.ID_FONTE%TYPE:=3;
    -- costante stato pratica in corso
    kvStatoPraticaInCorso           CONSTANT DB_PROCEDIMENTO_AZIENDA.STATO%TYPE:='I';
    -- costante stato pratica in conclusa
    kvStatoPraticaConclusa          CONSTANT DB_PROCEDIMENTO_AZIENDA.STATO%TYPE:='C';
    -- identificativo ruolo rappresentante legale / titolare
    knIdRuoloTitRPLeg               CONSTANT DB_TIPO_RUOLO.ID_RUOLO%TYPE:=1;
    -- identificativo fase controlli polizza
    knIdFaseControlliPolizza        CONSTANT DB_TIPO_FASE.ID_FASE%TYPE:=5;
    -- codice parametro per controllo VAL03
    kvCodParControlloVal03          CONSTANT DB_TIPO_CONTROLLO_PARAMETRO.CODICE%TYPE:= 'DATAXCONTROLLO';
    --identificativo del controllo VAL03
    knIdControlloVal03              CONSTANT DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE:=802;
    -- codice parametro per controllo ANA21
    kvCodParControlloANA21          CONSTANT DB_TIPO_CONTROLLO_PARAMETRO.CODICE%TYPE:= 'DATAXCONTROLLO';
    --identificativo del controllo ANA21
    knIdControlloANA21              CONSTANT DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE:=188;
    -- identificativo tipo allegato validazione
    knIdTipoAllegatoValidazione     CONSTANT DB_TIPO_ALLEGATO.ID_TIPO_ALLEGATO%TYPE:=10;

    gnMaxLenghtMessaggio            INTEGER;


    FUNCTION fncControllaComune( parComune VARCHAR2 ) RETURN BOOLEAN;

    FUNCTION fncCodiceFiscale(    tmp_codice_fiscale DB_PERSONA_FISICA.codice_fiscale%TYPE,
                                        tmp_cognome        IN OUT DB_PERSONA_FISICA.cognome%TYPE,
                                        tmp_nome           DB_PERSONA_FISICA.nome%TYPE,
                                        tmp_nascita_comune DB_PERSONA_FISICA.nascita_comune%TYPE,
                                        tmp_nascita_data   DB_PERSONA_FISICA.nascita_data%TYPE,
                                        tmp_sesso          DB_PERSONA_FISICA.sesso%TYPE
                                        ) RETURN BOOLEAN;

    FUNCTION fncMessaggioErrore(p_id_err INTEGER) RETURN VARCHAR2;

    FUNCTION fncCheckDigit( parCUAA DB_ANAGRAFICA_AZIENDA.cuaa%TYPE DEFAULT NULL ) RETURN BOOLEAN;

    FUNCTION confrontaStringhe(var1 VARCHAR2, var2 VARCHAR2, tipo NUMBER) RETURN NUMBER;

    PROCEDURE ANA01(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE ANA02(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE ANA03(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE ANA04(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE ANA05(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE ANA07(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE ANA08(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE ANA10(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE ANA11(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE ANA12(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE ANA13(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE ANA14(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE ANA15(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);
    PROCEDURE ANA16(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE ANA18(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    -- verifica che almeno un recapito
    -- dell'azienda sia valorizzato
    PROCEDURE ANA19(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    -- verifica che la PEC sia valorizzata
    PROCEDURE ANA20(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    -- verifica che l'azienda abbia consolidato le UV
    PROCEDURE ANA21(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    -- controlla che almeno uno tra il telefono
    -- dell'azienda ed i telefono del titolare / rappresentante
    -- legale siano valorizzati
    PROCEDURE ANA22(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER
                    );

    -- nuovo controllo
    -- verifica che non siano indicati i dati relativi
    -- all¿iscrizione in camera di commercio sul fascicolo se l¿azienda in oggetto
    -- non risulta iscritta in CCIAA (fonte Infocamere)
    PROCEDURE ANA23(p_id_azienda    IN DB_AZIENDA.ID_AZIENDA%TYPE,
                    p_cuaa          IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER
                    );

  PROCEDURE ANA24(pIdAzienda      DB_AZIENDA.ID_AZIENDA%TYPE,
                  pResult     OUT VARCHAR2,
                  pMsg        OUT VARCHAR2,
                  pIdErr      OUT NUMBER);

    PROCEDURE ADE01(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE ADE02(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE ADE03(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE ADE04(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE ADE05(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE ADE06(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    -- Controlla che per ogni polizza dell'azienda
    -- per l'anno della campagna passato in input e l'intervento
    -- la data di stipula non sia maggiore della data di inizio copertura
    PROCEDURE ASS01(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                    pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                    pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                    pResult            OUT VARCHAR2,
                    pMsg               OUT VARCHAR2);

    -- Controlla che per ogni polizza dell'azienda
    -- per l'anno della campagna passato in input e l'intervento
    -- la data di inizio copertura non sia precedente alla data di inizio campagna
    PROCEDURE ASS02(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                    pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                    pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                    pResult            OUT VARCHAR2,
                    pMsg               OUT VARCHAR2);

    -- Controlla che per ogni polizza dell'azienda
    -- per l'anno della campagna passato in input e l'intervento
    -- la data di fine copertura non sia successiva alla data di fine campagna
    PROCEDURE ASS03(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                    pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                    pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                    pResult            OUT VARCHAR2,
                    pMsg               OUT VARCHAR2);

    -- Controlla che per ogni polizza dell'azienda
    -- per l'anno della campagna passato in input e l'intervento
    -- la data di quietanza sia stata valorizzata
    PROCEDURE ASS04(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                    pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                    pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                    pResult            OUT VARCHAR2,
                    pMsg               OUT VARCHAR2);

    -- Controlla per ogni polizza dell'azienda
    -- per l'anno della campagna passato in input , l'intervento
    -- e la dichiarazione di consistenza passate in input
    -- che la superficie assicurata per comune e gruppo macrouso non
    -- superi la superficie effettivamente dichiarata in fascicolo
    PROCEDURE ASS05(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                    pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                    pIdProcedimento     IN DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE,
                    pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                    pResult            OUT VARCHAR2,
                    pMsg               OUT VARCHAR2);

    -- Controlla per ogni polizza dell'azienda
    -- per l'anno della campagna passato in input , l'intervento
    -- e la dichiarazione di consistenza passate in input
    -- che la superficie assicurata per comune e macrouso non
    -- superi la superficie effettivamente dichiarata in fascicolo
    PROCEDURE ASS06(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                    pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                    pIdProcedimento     IN DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE,
                    pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                    pResult            OUT VARCHAR2,
                    pMsg               OUT VARCHAR2);

    -- Controlla che per l'azienda , l'anno campagna ed gli interventi
    -- forniti in input siano stipulate polizze con solamente un consorzio
    -- per regione (salto ASS07 e ASS08 perchè qualcuno si è inventato dei controlli fittizi)
    PROCEDURE ASS09(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                    pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                    pVetTipoIntervento  IN VARCHAR2,
                    pResult            OUT VARCHAR2,
                    pMsg               OUT VARCHAR2);


    /*********************************************************************
    Controllo se per le polizze dell'azienda data in input per l'intervento
    e la campagna dati in input risultano prodotti con rese superiori a
    quanto previsto dalle tabelle regionali
    Tipo: procedure
    input: pIdAzienda, pAnnoCampagna, pIdTipoIntervento
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ASS11(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                    pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                    pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                    pResult            OUT VARCHAR2,
                    pMsg               OUT VARCHAR2);

    /*********************************************************************
    Ccontrolla se la polizza e' stata presentata piu' di un tot di giorni dal termine previsto
    Tipo: procedure
    input: pIdAzienda, pAnnoCampagna, pIdTipoIntervento
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ASS12(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                    pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                    pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                    pResult            OUT VARCHAR2,
                    pMsg               OUT VARCHAR2);

    /*********************************************************************
    Verifica l'esistenza di una anomalia SIAN P01 sulla polizza
    Tipo: procedure
    input: pIdAzienda, pAnnoCampagna, pIdTipoIntervento
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ASS13(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                    pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                    pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                    pResult            OUT VARCHAR2,
                    pMsg               OUT VARCHAR2);

    /*********************************************************************
    Verifica l'esistenza di una anomalia SIAN P01 sulla polizza
    Tipo: procedure
    input: pIdAzienda, pAnnoCampagna, pIdTipoIntervento
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ASS15(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                    pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                    pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                    pResult            OUT VARCHAR2,
                    pMsg               OUT VARCHAR2);


    -- implementato nuovo controllo ATT da esporre ai procedimenti fruitori
    -- speculare al controllo "Dichiarazioni_Obbligatorie" presente nel PACK_DICHIARAZIONE_CONSISTENZA
    PROCEDURE ATT01 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                     p_result                   OUT VARCHAR2,
                     p_msg                      OUT VARCHAR2,
                     p_id_err                   OUT NUMBER);

    -- implementato nuovo controllo ATT da esporre ai procedimenti fruitori
    -- speculare al controllo "Condizionalita_Norme" presente nel PACK_DICHIARAZIONE_CONSISTENZA
    PROCEDURE ATT03 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                     p_result                   OUT VARCHAR2,
                     p_msg                      OUT VARCHAR2,
                     p_id_err                   OUT NUMBER);

    /*********************************************************************
    Controllo ATT05 : verifica norme e varietà di utilizzo
    Tipo:   Procedure
    input:  pIdDichiarazioneConsistenza
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ATT05 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                     p_result                   OUT VARCHAR2,
                     p_msg                      OUT VARCHAR2,
                     p_id_err                   OUT NUMBER);

    /*********************************************************************
    ATT06 : Atto A1 - verifica congruenza terreni appartenenti a ZPS
    Tipo:   Procedure
    input:  pIdDichiarazioneConsistenza
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ATT06 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                     p_result                   OUT VARCHAR2,
                     p_msg                      OUT VARCHAR2,
                     p_id_err                   OUT NUMBER);


    /*********************************************************************
    ATT07 : Atto A2 - Verifica congruenza dichiarazioni
    Tipo:   Procedure
    input:  pIdDichiarazioneConsistenza
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ATT07 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                     p_result                   OUT VARCHAR2,
                     p_msg                      OUT VARCHAR2,
                     p_id_err                   OUT NUMBER);

    /*********************************************************************
    ATT08 : Atto A3 - Verifica congruenza dichiarazioni
    Tipo:   Procedure
    input:  pIdDichiarazioneConsistenza
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ATT08 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                     p_result                   OUT VARCHAR2,
                     p_msg                      OUT VARCHAR2,
                     p_id_err                   OUT NUMBER);

    /*********************************************************************
    ATT09 : Atto A4 - verifica congruenza dichiarazione
    Tipo:   Procedure
    input:  pIdDichiarazioneConsistenza
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ATT09 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                     p_result                   OUT VARCHAR2,
                     p_msg                      OUT VARCHAR2,
                     p_id_err                   OUT NUMBER);

    /*********************************************************************
    ATT10 : Atto A5 - verifica congruenza dichiarazione
    Tipo:   Procedure
    input:  pIdDichiarazioneConsistenza
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ATT10 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                     p_result                   OUT VARCHAR2,
                     p_msg                      OUT VARCHAR2,
                     p_id_err                   OUT NUMBER);


    /*********************************************************************
    ATT11 : Matrice CGO - Verifica congruenza dichiarazioni
    Tipo:   Procedure
    input:  pIdDichiarazioneConsistenza
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ATT11 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                     p_result                   OUT VARCHAR2,
                     p_msg                      OUT VARCHAR2,
                     p_id_err                   OUT NUMBER);

    /*********************************************************************
    ATT12 : Atto A4 addendum - verifica congruenza dichiarazioni terreni in ZO (Zootecnia ?)
    Tipo:   Procedure
    input:  pIdDichiarazioneConsistenza
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ATT12 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                     p_result                   OUT VARCHAR2,
                     p_msg                      OUT VARCHAR2,
                     p_id_err                   OUT NUMBER);

    /*********************************************************************
    ATT13 : Verifica congruenza prodotti/varietà - attestazioni sottoscritte per B9-B11 addendum
    Tipo:   Procedure
    input:  pIdDichiarazioneConsistenza
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ATT13 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                     p_result                   OUT VARCHAR2,
                     p_msg                      OUT VARCHAR2,
                     p_id_err                   OUT NUMBER);

    /*********************************************************************
    ATT14 : Verifica congruenza sottoscrizione atti B9/B11
    Tipo:   Procedure
    input:  pIdDichiarazioneConsistenza
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ATT14 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                     p_result                   OUT VARCHAR2,
                     p_msg                      OUT VARCHAR2,
                     p_id_err                   OUT NUMBER);


    /*********************************************************************
    Verifica che il conto corrente identificato dal parametro di ingresso
    pIdCC non sia Estinto, Cessato, Invalidato.
    Tipo:   Procedure
    input:  pIdCC
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE CNC05(pIdCC           IN DB_CONTO_CORRENTE.ID_CONTO_CORRENTE%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    /*********************************************************************
    Verifica che il conto corrente identificato dal parametro di ingresso
    pIdCC non sia Estinto, Cessato, Invalidato ed in caso di aziende
    con forma giuridica con il FLAG_CONTO_GF ad 'S' che il conto corrente
    sia effettivamente un girofondo.
    Tipo:   Procedure
    input:  pIdCC
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE CNC06(pIdCC           IN DB_CONTO_CORRENTE.ID_CONTO_CORRENTE%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    /*********************************************************************
    Verifica che il conto corrente identificato coi parametri di ingresso
    pIdAzienda e pIban non sia Estinto, Cessato, Invalidato ed in caso di aziende
    con forma giuridica con il FLAG_CONTO_GF ad 'S' che il conto corrente
    sia effettivamente un girofondo.
    Tipo:   Procedure
    input:  pIdAzienda, pIban
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE CNC06(pIdAzienda        IN DB_CONTO_CORRENTE.ID_AZIENDA%TYPE,
                    pIban             IN DB_CONTO_CORRENTE.IBAN%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    /*********************************************************************
    Dato l'id_azienda ed e l'id_Procedimento verifica che esiste
    almeno una dichiarazione di consistenza effettuata per motivi
    non da escludersi per il procedimento
    Tipo:   Procedure
    input:  pIdAzienda, pIdProcedimento
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE DCC01(pIdAzienda      IN DB_AZIENDA.ID_AZIENDA%TYPE,
                    pIdProcedimento IN DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    /*********************************************************************
    Dato l'id_azienda ed e l'id_Procedimento verifica che esiste
    almeno una dichiarazione di consistenza effettuata per motivi
    non da escludersi per il procedimento e che essa sia protocollata
    Tipo:   Procedure
    input:  pIdAzienda, pIdProcedimento
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE DCC02(pIdAzienda      IN DB_AZIENDA.ID_AZIENDA%TYPE,
                    pIdProcedimento IN DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    /*********************************************************************
    Dato l'id_azienda ed e l'id_Procedimento verifica che esiste
    almeno una dichiarazione di consistenza effettuata per motivi
    non da escludersi per il procedimento, che essa sia protocollata
    e che sia stata effettuata dopo una certa data fornita in input
    Tipo:   Procedure
    input:  pIdAzienda, pIdProcedimento, pDataDa
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE DCC03(pIdAzienda      IN DB_AZIENDA.ID_AZIENDA%TYPE,
                    pIdProcedimento IN DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE,
                    pDataDa         IN DATE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);


    /*********************************************************************
    Dato l'id_azienda ed e l'id_Procedimento verifica che esiste
    almeno una dichiarazione di consistenza effettuata per motivi
    non da escludersi per il procedimento, che essa sia protocollata
    e che sia stata effettuata entro gli N mesi dati in input precedenti
    alla data di sistema
    Tipo:   Procedure
    input:  pIdAzienda, pIdProcedimento, pNumMesi
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE DCC04(pIdAzienda      IN DB_AZIENDA.ID_AZIENDA%TYPE,
                    pIdProcedimento IN DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE,
                    pNumMesi        IN INTEGER,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    /*********************************************************************
    Dato un ID_DICHIARAZIONE_CONSISTENZA verifica che essa
    sia protocollata e firmata (grafometrica o normale)
    Tipo: Procedure
    input: pIdDichCons
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE DCC05(pIdDichCons      IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    /*********************************************************************
    Dato un identificativo conto corrente il sistema ricerca se esiste un
    documento attivo e valido di tipo conto corrente
    Tipo:   Procedure
    input:  pIdContoCorrente
    output: p_Result, p_Msg, p_Id_Err
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE DOC25(pIdContoCorrente IN DB_CONTO_CORRENTE.ID_CONTO_CORRENTE%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE TIT01(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE TIT02(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE TIT03(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE TIT04(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE TIT05(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE TIT06(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_id_titolo     IN  DB_TIPO_TITOLO_STUDIO.id_titolo_studio%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER,
                    p_valore        OUT VARCHAR2);

    PROCEDURE TIT07(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg             OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE TIT08(p_id_azienda        IN  DB_AZIENDA.id_azienda%TYPE,
                    p_eta_riferimento   IN  NUMBER,
                    p_result            OUT VARCHAR2,
                    p_msg               OUT VARCHAR2,
                    p_id_err            OUT NUMBER,
                    p_valore            OUT VARCHAR2);

    PROCEDURE TIT09(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_mesi_ruolo    IN  NUMBER,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER,
                    p_valore        OUT VARCHAR2);

    PROCEDURE TIT10(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE TIT11(p_id_soggetto   IN DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE,
                    p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE TIT12(p_id_azienda        IN  DB_AZIENDA.id_azienda%TYPE,
                    p_eta_riferimento   IN  NUMBER,
                    p_result            OUT VARCHAR2,
                    p_msg                 OUT VARCHAR2,
                    p_id_err            OUT NUMBER,
                    p_valore            OUT VARCHAR2);

    FUNCTION PER01(p_cognome        IN  DB_PERSONA_FISICA.cognome%TYPE,
                   p_nome           IN  DB_PERSONA_FISICA.nome%TYPE,
                   p_nascita_data   IN  DB_PERSONA_FISICA.nascita_data%TYPE,
                   p_nascita_comune IN  DB_PERSONA_FISICA.nascita_comune%TYPE,
                   p_codice_fiscale IN  DB_PERSONA_FISICA.codice_fiscale%TYPE,
                   p_result         IN OUT VARCHAR2,
                   p_msg            IN OUT VARCHAR2,
                   p_id_err         OUT NUMBER)RETURN BOOLEAN;

    PROCEDURE RIC01(p_id_persona    IN DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE RIC02(p_id_persona    IN DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE RIC03(p_id_persona    IN DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE RIC04(p_id_persona IN DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);

    PROCEDURE RIC05(p_id_persona    IN DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE RIC06(p_id_persona        IN DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE,
                    p_id_titolo_minimo  IN DB_TIPO_TITOLO_STUDIO.ID_TITOLO_STUDIO%TYPE,
                    p_result            OUT VARCHAR2,
                    p_msg               OUT VARCHAR2,
                    p_id_err            OUT NUMBER);

    PROCEDURE RIC07(p_id_persona        IN DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE,
                    p_indirizzo_agrario IN DB_TIPO_INDIRIZZO_STUDIO.indirizzo_agrario%TYPE,
                    p_result            OUT VARCHAR2,
                    p_msg               OUT VARCHAR2,
                    p_id_err            OUT NUMBER);

    PROCEDURE RIC08(p_id_persona    IN DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE RIC09(p_id_persona    IN DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE RIC10(p_id_persona    IN DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE,
                  p_eta_min         IN INTEGER,
                  p_eta_max         IN INTEGER,
                  p_result          OUT VARCHAR2,
                  p_msg             OUT VARCHAR2,
                  p_id_err          OUT NUMBER);

    PROCEDURE RIC11(p_id_persona    IN DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE,
                    p_eta_min       IN INTEGER,
                    p_eta_max       IN INTEGER,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE RIC12(p_id_soggetto   IN DB_PERSONA_FISICA.ID_SOGGETTO%TYPE,
                    p_id_azienda    IN DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE UTE01(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE UTE02(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_comune        IN  COMUNE.istat_comune%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE UTE03(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE UTE04(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE UVC01(pIdUnitaArbDich IN DB_UNITA_ARBOREA_DICHIARATA.ID_UNITA_ARBOREA_DICHIARATA%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);
    PROCEDURE UVR25(pIdAzienda  IN DB_COMPENSAZIONE_AZIENDA.ID_AZIENDA%TYPE,
                    pTipoCtrl   IN VARCHAR2,
                    p_result   OUT VARCHAR2,
                    p_msg      OUT VARCHAR2,
                    p_id_err   OUT NUMBER);

    PROCEDURE GIO01(p_id_azienda IN  DB_AZIENDA.id_azienda%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);

    --presenza in AAEP
    PROCEDURE AEP01(p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);
    --presente attiva in AAEP
    PROCEDURE AEP02(p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);
    --denominazione azienda congruente con AAEP
    PROCEDURE AEP03(p_id_azienda IN DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                    p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);
    --forma giuridica azienda congruente con AAEP
    PROCEDURE AEP04(p_id_azienda IN DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                    p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);
    --partita iva azienda congruente con AAEP
    PROCEDURE AEP05(p_id_azienda IN DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                    p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);
    --ubicazione sede lagale azienda congruente con AAEP
    PROCEDURE AEP06(p_id_azienda IN DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                    p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);

    --codice fiscale rappresentante legale azienda congruente con AAEP
    PROCEDURE AEP07(p_id_azienda IN DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                    p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);
    --dati iscrizione CCIAA  azienda congruente con AAEP
    PROCEDURE AEP08(p_id_azienda IN DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                    p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);

    -- nuova versione del contrllo AEP02
    -- che esclude le forme giuridiche esenti
    -- e lavora alla data passata in input
    PROCEDURE AEP09(pIdAzienda  IN  DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                    pDataOffSet IN  DATE,
                    p_result    OUT VARCHAR2,
                    p_msg       OUT VARCHAR2,
                    p_id_err    OUT NUMBER);

    -- Verifica che li codice ateco dichiarato
    -- in anagrafe coincide con quello di AAEP (fonte infocamere)
    -- se presente
    PROCEDURE AEP10(pIdAzienda   IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                    pCuaa        IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result    OUT VARCHAR2,
                    p_msg       OUT VARCHAR2,
                    p_id_err    OUT NUMBER);

    -- Verifica se l'azienda è attiva su Fonte Infocamare AAEP e che i codici ateco secondari
    -- in anagrafe coincidono con quello di AAEP (fonte infocamere)
    PROCEDURE AEP11(pIdAzienda   IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                    pCuaa        IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result    OUT VARCHAR2,
                    p_msg       OUT VARCHAR2,
                    p_id_err    OUT NUMBER);

    --luisa: presenza cuaa in anagrafe tributaria
    PROCEDURE TRB01(p_id_azienda IN DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                    p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);


    -- luisa: controllo denominazione con anagrafe tributaria
    PROCEDURE TRB02(p_id_azienda IN DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                    p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);

    -- luisa: confronto cuaa con anagrafe tributaria
    PROCEDURE TRB03(p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);

    -- Controllo sigla provincia sede legale con anagrafe tributaria
    PROCEDURE TRB04(p_id_azienda IN DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                    p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);

    PROCEDURE TRB05(p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);

    PROCEDURE TRB06(p_id_azienda IN DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                    p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);

    PROCEDURE TRB07(p_id_azienda IN DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                    p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);

    PROCEDURE TRB08(p_id_azienda IN DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                    p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);

    -- restyling di TRB09 ora cerca su anagrafe (SIAP) il titolare / rappresentante legale
    -- attivo e vede su anagrafe tributaria se e' deceduto
    PROCEDURE TRB09(p_id_azienda IN DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);

    PROCEDURE CNC01(p_id_azienda   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                    p_id_sportello IN DB_TIPO_SPORTELLO.ID_SPORTELLO%TYPE,
                    p_result       OUT VARCHAR2,
                    p_msg          OUT VARCHAR2,
                    p_id_err       OUT NUMBER);

    PROCEDURE CNC02(p_id_azienda    IN DB_AZIENDA.ID_AZIENDA%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    PROCEDURE CNC03(p_id_azienda   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                    p_result       OUT VARCHAR2,
                    p_msg          OUT VARCHAR2,
                    p_id_err       OUT NUMBER);

    PROCEDURE ALL05(p_id_azienda IN DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                    p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);

    PROCEDURE ALL06(p_id_azienda IN DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                    p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    p_result     OUT VARCHAR2,
                    p_msg        OUT VARCHAR2,
                    p_id_err     OUT NUMBER);

    -- verifica che l'azienda abbia fatto validazione
    -- dopo aver consolidato il gis delle UV
    PROCEDURE VAL03(p_id_azienda    IN  DB_AZIENDA.ID_AZIENDA%TYPE,
                    p_id_proc       IN  DB_MOTIVO_ESCLUSO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE,
                    p_result        OUT VARCHAR2,
                    p_msg           OUT VARCHAR2,
                    p_id_err        OUT NUMBER);

    FUNCTION IBAN_OK(pIban    IN  VARCHAR2, -- IBAN,
                     pErrCode OUT VARCHAR2) RETURN BOOLEAN;


    -- Valori restituiti nel parametro p_result delle procedure di controllo
    RET_OK          CONSTANT CHAR(1) := '0';      -- Elaborazione terminata correttamente
    RET_ERR         CONSTANT CHAR(1) := '1';      -- Errore Oracle
    RET_ERR_PROC    CONSTANT CHAR(1) := '2';      -- Errore applicativo (Errore dati)
    RET_ERR_CNTL    CONSTANT CHAR(1) := '3';      -- Il controllo ha esito negativo


    -- Percentuale minima per confronto stringhe
    LIMITE_PERC     CONSTANT NUMBER(5,2):=60;

END Pack_Controlli;

/
--------------------------------------------------------
--  DDL for Package PACK_CONTROLLI_PARTICELLARE
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PACK_CONTROLLI_PARTICELLARE" IS

    -- aggiunto parametro P_ID_UTENTE_IRIDE
    PROCEDURE ESEGUI_CONTROLLI(P_ID_AZIENDA         IN DB_AZIENDA.ID_AZIENDA%TYPE,
                               P_ANNO_RIF            IN DB_UTILIZZO_PARTICELLA.ANNO%TYPE,
                               P_ID_UTENTE_LOGIN    IN PAPUA_V_UTENTE_LOGIN.ID_UTENTE_LOGIN%TYPE, 
                                  P_MSGERR            IN OUT VARCHAR2,
                                P_CODERR         IN OUT VARCHAR2);



END Pack_Controlli_Particellare;

/
--------------------------------------------------------
--  DDL for Package PACK_DICHIARAZIONE_CONSISTENZA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PACK_DICHIARAZIONE_CONSISTENZA" IS

   kvCodParNumMinGGDocRiesame    CONSTANT DB_PARAMETRO.ID_PARAMETRO%TYPE:='DIGG';
   knIdentificativoDocRiesame    CONSTANT DB_TIPO_CATEGORIA_DOCUMENTO.IDENTIFICATIVO%TYPE:=518;
    -- identificativo parametro percentuale tolleranza
   kvIdParamPercP26              CONSTANT DB_PARAMETRO.ID_PARAMETRO%TYPE:='P26P';
   -- identificativo del parametro che evidenzia il tempo che deve trascorrere tra l'anno di impianto
   -- e quello di prima produzione di una UV
   kvIdParamPeriodoAnnoImpAnnoPP CONSTANT DB_PARAMETRO.ID_PARAMETRO%TYPE:='APUV';
   -- identificativo del parametro della percentuale di tolleranza per il controllo UV21 (621)
   kvIdParamPercTollUV21         CONSTANT DB_PARAMETRO.ID_PARAMETRO%TYPE:='PV21';
   -- identificativo del parametro della percentuale di tolleranza per il controllo UV22 (622)
   kvIdParamPercTollUV22         CONSTANT DB_PARAMETRO.ID_PARAMETRO%TYPE:='PV22';
   -- identificativo del parametro anno per il controllo UV23
   kvIdParamAnnoUV23             CONSTANT DB_PARAMETRO.ID_PARAMETRO%TYPE:='UV23';
   -- identificativo del parametro anno per il controllo UV11
   kvIdParamAnnoUV11             CONSTANT DB_PARAMETRO.ID_PARAMETRO%TYPE:='UV11';
   -- identificativo del parametro anno per il controllo UV26
   kvIdParamAnnoUV26             CONSTANT DB_PARAMETRO.ID_PARAMETRO%TYPE:='UV26';
   -- identificativo del parametro contenente la data di fermo orologi
   kvIdParamDtFermoOrologi       CONSTANT DB_PARAMETRO.ID_PARAMETRO%TYPE:='SRPU';
   -- identificativo controllo P25
   knIdControlloP25              CONSTANT DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE:=213;
   -- identificativo controllo P30
   knIdControlloP30              CONSTANT DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE:=211;
   -- identiticativo parametro data da controllo Ter 37
   kvIdParamDataDaTer37          CONSTANT DB_PARAMETRO.ID_PARAMETRO%TYPE:='T37D';
   -- identiticativo parametro data a controllo Ter 37
   kvIdParamDataATer37           CONSTANT DB_PARAMETRO.ID_PARAMETRO%TYPE:='T37A';
   -- identificativo fonte certificazione particella "Catasto"
   knIdFonteCatasto              CONSTANT DB_TIPO_FONTE.ID_FONTE%TYPE:=1;
   -- identificativo tipo eleggibilità fittizia VITE
   knIdTipoEleggibilitaFitVite   CONSTANT DB_TIPO_ELEGGIBILITA_FIT.ID_ELEGGIBILITA_FIT%TYPE:=26;
   -- codice parametro percentuale di tollerenza per controllo TER41
   kvCodParControlloTer41        CONSTANT DB_TIPO_CONTROLLO_PARAMETRO.CODICE%TYPE:='PTTER41';
   -- codice parametro percentuale di tollerenza per controllo TER42
   kvCodParControlloTer42        CONSTANT DB_TIPO_CONTROLLO_PARAMETRO.CODICE%TYPE:='PTTER42';
   -- identificativo fase istanza di riesame in lavorazione
   knIdFaseIstRiesameInLav       CONSTANT DB_FASE_ISTANZA_RIESAME.ID_FASE_ISTANZA_RIESAME%TYPE:=1;
   -- identificativo mese di luglio
   knMeseLuglio                  CONSTANT NUMBER(1):=7;
   -- id causale modifica unita vitata per impianto in accertamento comunicazione viticola
   knIdCausaleModImpAccComVit    CONSTANT DB_TIPO_CAUSALE_MODIFICA.ID_CAUSALE_MODIFICA%TYPE:=9;
   -- id causale modifica unita vitata per impianto in trasmissione comunicazione viticola
   knIdCausaleModImpTraComVit    CONSTANT DB_TIPO_CAUSALE_MODIFICA.ID_CAUSALE_MODIFICA%TYPE:=14;
   -- id causale modifica unita vitata per variazione idoneinta' in trasmissione comunicazione viticola
   knIdCausaleModVarIdoTraComVit CONSTANT DB_TIPO_CAUSALE_MODIFICA.ID_CAUSALE_MODIFICA%TYPE:=16;
   -- id causale modifica unita vitata per variazione idoneinta' in accertamento comunicazione viticola
   knIdCausaleModVarIdoAccComVit CONSTANT DB_TIPO_CAUSALE_MODIFICA.ID_CAUSALE_MODIFICA%TYPE:=17;
   -- identificativo fase generazione isole parcelle
   knIdFaseGenIsoleParcelle      CONSTANT DB_TIPO_FASE.ID_FASE%TYPE:=7;
   -- codice altro dato documento/i deroga nitrati
   kvCodAltroDatoDocNitrati      CONSTANT DB_ALTRI_DATI.CODICE%TYPE:='ADESIONE_DIR_NIT';
   -- codice parametro controllo per identificatizione categoria documento che prevedono l'indicazione del proprietario
   kvCodParametroIdCatDocConProp CONSTANT DB_TIPO_CONTROLLO_PARAMETRO.CODICE%TYPE:='IDCATDOCPROP';
   -- codice parametro controllo per identificazione dalla dalla quale il controllo di congruenza dei proprietario
   -- documento col proprietario particella del catasto diventa bloccante (la data e da intendersi rispetto alla data inizio validita del docuemnto)
   kvCodParamDataDaDocConPropB   CONSTANT DB_TIPO_CONTROLLO_PARAMETRO.CODICE%TYPE:='DATAXCONTROLLO';
   -- identificativo procedimento anagrafe
   knIdTipoProcedimentoSMRGAA    CONSTANT DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE:=7;
   -- identificativo fonte certificazione particella "Catasto"
   knIdFontePratoPermanente      CONSTANT DB_TIPO_FONTE.ID_FONTE%TYPE:=9;
   -- identificativo tipo documento deroga mentenimento prati
   knIdTipoDocDerogaMantenimPrati CONSTANT DB_TIPO_DOCUMENTO.ID_DOCUMENTO%TYPE:=410;
   -- identificativo zona altrimetrica montana
   knIdZonaAltimetricaMontana    CONSTANT DB_TIPO_ZONA_ALTIMETRICA.ID_ZONA_ALTIMETRICA%TYPE:=1;

   -- aggiunto parametro P_ID_UTENTE_IRIDE
   PROCEDURE  CONTROLLI_DICHIARAZIONE(    P_ID_AZIENDA                     IN         DB_AZIENDA.ID_AZIENDA%TYPE,
                                        P_ANNO_RIF                        IN         DB_UTILIZZO_PARTICELLA.ANNO%TYPE,
                                        P_ID_MOTIVO_DICHIARAZIONE         IN         DB_TIPO_MOTIVO_DICHIARAZIONE.ID_MOTIVO_DICHIARAZIONE%TYPE,
                                        P_ID_UTENTE_LOGIN               IN      PAPUA_V_UTENTE_LOGIN.ID_UTENTE_LOGIN%TYPE, 
                                        P_ESITO_CONTR                   OUT     VARCHAR2,
                                        P_MSGERR                        IN OUT     VARCHAR2,
                                        P_CODERR                         IN OUT     VARCHAR2);

   -- nuova procedure per eseguire i controlli per un certo ID_FASE
   -- attualmente utilizzata in fase di consolidamento delle unità vitate
   -- aggiunto parametro P_ID_UTENTE_IRIDE
   PROCEDURE CONTROLLI_FASE(P_ID_AZIENDA          IN DB_AZIENDA.ID_AZIENDA%TYPE,
                            P_ID_FASE             IN DB_TIPO_FASE.ID_FASE%TYPE,
                            P_ID_UTENTE_LOGIN     IN PAPUA_V_UTENTE_LOGIN.ID_UTENTE_LOGIN%TYPE, 
                            P_PRESENZA_ANOM       OUT VARCHAR2,
                            P_MSGERR              IN OUT VARCHAR2,
                            P_CODERR              IN OUT VARCHAR2);
   -- aggiunto parametro P_ID_UTENTE_IRIDE
   PROCEDURE  CONTROLLI_VERIFICA        (    P_ID_AZIENDA                      IN         DB_AZIENDA.ID_AZIENDA%TYPE,
                                            P_ANNO_RIF                        IN         DB_UTILIZZO_PARTICELLA.ANNO%TYPE,
                                            P_ID_GRUPPO_CONTROLLO             IN         DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE,
                                            P_ID_UTENTE_LOGIN               IN      PAPUA_V_UTENTE_LOGIN.ID_UTENTE_LOGIN%TYPE, 
                                            P_PRESENZA_ANOM                  OUT     VARCHAR2,
                                            P_MSGERR                        IN OUT     VARCHAR2,
                                            P_CODERR                         IN OUT     VARCHAR2
                                        );
   -- aggiunto parametro P_ID_UTENTE_IRIDE
    PROCEDURE CONTROLLI_INSEDIAMENTO(    P_ID_AZIENDA          IN     DB_AZIENDA.ID_AZIENDA%TYPE,
                                        P_ID_UTENTE_LOGIN   IN  PAPUA_V_UTENTE_LOGIN.ID_UTENTE_LOGIN%TYPE, 
                                        P_ESITO_CONTR         OUT     VARCHAR2,
                                        P_MSGERR        IN OUT     VARCHAR2,
                                        P_CODERR         IN OUT     VARCHAR2
                                        );

    PROCEDURE  INSERIMENTO_TERRENI    (    P_ID_AZIENDA                         IN         DB_AZIENDA.ID_AZIENDA%TYPE,
                                          P_ANNO_RIF                            IN         DB_UTILIZZO_PARTICELLA.ANNO%TYPE,
                                           P_CODICE_FOTO                         IN         DB_DICHIARAZIONE_CONSISTENZA.CODICE_FOTOGRAFIA_TERRENI%TYPE,
                                        P_ID_UTENTE_AGGIORNAMENTO             IN         DB_CONDUZIONE_DICHIARATA.ID_UTENTE_AGGIORNAMENTO%TYPE,
                                           P_MSGERR                            OUT     VARCHAR2,
                                           P_CODERR                             OUT     VARCHAR2
                                    );

    PROCEDURE  OPERAZIONE_AMMESSA        (    P_ID_AZIENDA                         IN         DB_AZIENDA.ID_AZIENDA%TYPE,
                                                    P_ID                                     IN         NUMBER,
                                                    P_OPERAZIONE                          IN         VARCHAR2,
                                                    P_ESITO                                IN OUT     VARCHAR2,
                                                    P_MSGERR                                IN OUT     VARCHAR2,
                                                    P_CODERR                             IN OUT     VARCHAR2
                                                );

    PROCEDURE  INDICATORI_AZIENDALI    (    P_ID_AZIENDA                     IN         DB_AZIENDA.ID_AZIENDA%TYPE,
                                          P_ID_UTENTE_AGGIORNAMENTO         IN         DB_CONDUZIONE_DICHIARATA.ID_UTENTE_AGGIORNAMENTO%TYPE,
                                           P_MSGERR                        OUT     VARCHAR2,
                                           P_CODERR                         OUT     VARCHAR2
                                                );

  PROCEDURE CREA_ACCESSO_GRAFICO(P_ID_AZIENDA                      DB_AZIENDA.ID_AZIENDA%TYPE,
                                 P_ANNO_RIF                        DB_UTILIZZO_PARTICELLA.ANNO%TYPE,
                                 P_CODICE_FOTO                     DB_DICHIARAZIONE_CONSISTENZA.CODICE_FOTOGRAFIA_TERRENI%TYPE,
                                 P_ID_UTENTE_AGGIORNAMENTO         DB_CONDUZIONE_DICHIARATA.ID_UTENTE_AGGIORNAMENTO%TYPE,
                                 P_MSGERR                   IN OUT VARCHAR2,
                                 P_CODERR                   IN OUT VARCHAR2);

    PROCEDURE  SALVA_DICHIARAZIONE    (    P_ID_AZIENDA                         IN         DB_AZIENDA.ID_AZIENDA%TYPE,
                                          P_ANNO_RIF                            IN         DB_UTILIZZO_PARTICELLA.ANNO%TYPE,
                                          P_CODICE_FOTO                         IN         DB_DICHIARAZIONE_CONSISTENZA.CODICE_FOTOGRAFIA_TERRENI%TYPE,
                                          P_ID_UTENTE_AGGIORNAMENTO         IN         DB_CONDUZIONE_DICHIARATA.ID_UTENTE_AGGIORNAMENTO%TYPE,
--                                                   P_ID_ANAGRAFICA_AZIENDA             OUT         DB_ANAGRAFICA_AZIENDA.ID_UTENTE_AGGIORNAMENTO%TYPE,
                                           P_MSGERR                                IN OUT     VARCHAR2,
                                           P_CODERR                             IN OUT     VARCHAR2
                                                );

  FUNCTION SCRIVI_SEGNALAZIONE (P_ID_AZIENDA   IN     DB_AZIENDA.ID_AZIENDA%TYPE,
                               P_ID_CONTROLLO IN     DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                              P_DESCRIZIONE     IN     DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE,
                              P_BLOCCANTE     IN     DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                              P_ID_STORICO_PARTICELLA IN DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE,
                              P_ID_STORICO_UNITA_ARBOREA IN DB_STORICO_UNITA_ARBOREA.ID_STORICO_UNITA_ARBOREA%TYPE,
                                  P_MSGERR       IN OUT VARCHAR2,
                              P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN ;

  FUNCTION SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA   IN     DB_AZIENDA.ID_AZIENDA%TYPE,
                               P_ID_CONTROLLO IN     DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                              P_DESCRIZIONE     IN     DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE,
                              P_BLOCCANTE     IN     DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                              P_ID_CONDUZIONE_PARTICELLA IN DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE,
                                  P_MSGERR       IN OUT VARCHAR2,
                              P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN;

  FUNCTION SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA   IN     DB_AZIENDA.ID_AZIENDA%TYPE,
                               P_ID_CONTROLLO IN     DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                              P_DESCRIZIONE     IN     DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE,
                              P_BLOCCANTE     IN     DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                              P_ID_STORICO_UNITA_ARBOREA IN DB_STORICO_UNITA_ARBOREA.ID_STORICO_UNITA_ARBOREA%TYPE,
                                  P_MSGERR       IN OUT VARCHAR2,
                              P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN;

  -- rc 15/04/2016 nuova procedura che effettua i controlli a partite dalla dichiarazione di consistenza
  PROCEDURE CONTROLLI_VALIDAZIONE(P_ID_AZIENDA               DB_AZIENDA.ID_AZIENDA%TYPE,
                                  P_ID_FASE                  DB_TIPO_FASE.ID_FASE%TYPE,
                                  P_ID_UTENTE_LOGIN          PAPUA_V_UTENTE_LOGIN.ID_UTENTE_LOGIN%TYPE, 
                                  P_ID_DICHIARAZIONE         DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                  P_PRESENZA_ANOM        OUT VARCHAR2,
                                  P_MSGERR            IN OUT VARCHAR2,
                                  P_CODERR            IN OUT VARCHAR2);

  FUNCTION my_to_number (pvalore IN VARCHAR2, pformato IN VARCHAR2) RETURN NUMBER;

  FUNCTION SelectValoreParametro (pCodParametro IN VARCHAR2) RETURN VARCHAR2;

END PACK_DICHIARAZIONE_CONSISTENZA;

/
--------------------------------------------------------
--  DDL for Package PACK_INEA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PACK_INEA" IS

c_codice_attivita_suinetti CONSTANT DB_TIPO_ATTIVITA_INEA.CODICE_ATTIVITA%TYPE := 'J11';
c_codice_attivita_suini    CONSTANT DB_TIPO_ATTIVITA_INEA.CODICE_ATTIVITA%TYPE := 'J12';
c_coefficiente_calcolo_ude CONSTANT NUMBER := 1/1200;

c_parametro_membro_sx       CONSTANT DB_INEA_TIPO_PARAMETRO.ID_INEA_TIPO_PARAMETRO%TYPE := 1;
c_parametro_membro_dx       CONSTANT DB_INEA_TIPO_PARAMETRO.ID_INEA_TIPO_PARAMETRO%TYPE := 2;
c_parametro_operatore       CONSTANT DB_INEA_TIPO_PARAMETRO.ID_INEA_TIPO_PARAMETRO%TYPE := 3;

c_minore                   CONSTANT DB_INEA_OPERATORE.DESCRIZIONE%TYPE := '<';
c_minore_uguale               CONSTANT DB_INEA_OPERATORE.DESCRIZIONE%TYPE := '<=';
c_uguale                   CONSTANT DB_INEA_OPERATORE.DESCRIZIONE%TYPE := '=';
c_maggiore_uguale           CONSTANT DB_INEA_OPERATORE.DESCRIZIONE%TYPE := '>=';
c_maggiore                   CONSTANT DB_INEA_OPERATORE.DESCRIZIONE%TYPE := '>';
c_diverso                   CONSTANT DB_INEA_OPERATORE.DESCRIZIONE%TYPE := '<>';


-- questa procedura deve essere lanciata dall'online perché gestisce rollback e commit in quanto la calcolo_inea va a scrivere su --
-- tabelle temporanee che, se non svuotate, potrebbero esplodere --
PROCEDURE esegui_calcolo_inea(p_id_azienda                        DB_AZIENDA.ID_AZIENDA%TYPE,
                              p_id_ute                            DB_UTE.ID_UTE%TYPE,
                              p_id_dichiarazione_consistenza      DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                              rls                             OUT NUMBER,
                              ude                             OUT DB_TIPO_UDE.ID_UDE%TYPE,
                              ote                             OUT DB_TIPO_ATTIVITA_OTE.CODICE%TYPE,
                              ps                              OUT NUMBER,
                              v_return_val                    OUT NUMBER,
                              v_DescErr                       OUT VARCHAR2);

-- effettua il calcolo vero e proprio, ma non gestisce commit e rollback perché potrebbe essere richiamato dal pack_controlli --
-- e quindi non sarebbe corretto fare commit o rollback --
PROCEDURE CALCOLO_INEA(p_id_azienda                        DB_AZIENDA.ID_AZIENDA%TYPE,
                       p_id_ute                            DB_UTE.ID_UTE%TYPE,
                       p_id_dichiarazione_consistenza      DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                       rls                             OUT NUMBER,
                       ude                             OUT DB_TIPO_UDE.ID_UDE%TYPE,
                       ote                             OUT DB_TIPO_ATTIVITA_OTE.CODICE%TYPE,
                       ps                              OUT NUMBER,
                       v_return_val                    OUT NUMBER,
                       v_DescErr                       OUT VARCHAR2);

END Pack_Inea;

/
--------------------------------------------------------
--  DDL for Package PACK_MANAGE_SEQUENCE
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PACK_MANAGE_SEQUENCE" AS

  /******************************************************************************
   NAME:       PACK_MANAGE_SEQUENCE
   PURPOSE:    SEMPLICE: dagli 3 parametri (sole,cuore,amore...  :-)   ->
               
               - nome sequence
               - nome colonna PK sulla quale agisce la sequence
               - nome tabella
               
               Lui ripristina la sequence al valore massimo della PK esistente in
               tabella così che il NEXTVAL sia una PK non utilizzata.

               N.B. se la procedura deve agire sugli oggetti di un altro USER,
                    bisogna ricordarsi di valorizzare USER.seqName e USER.tableName
                    come parametri passati.

   ******************************************************************************/
   
PROCEDURE resetThisSequence(PseqName IN VARCHAR2,
                           PPKcolumn IN VARCHAR2,
                           PtableName IN VARCHAR2);                          
END;

/
--------------------------------------------------------
--  DDL for Package PACK_PRATICA_AZIENDA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PACK_PRATICA_AZIENDA" IS


    -- identificativo procedimento SMRGAA
    knIdProcSmrgaa                  CONSTANT DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE:=7;
    -- identificativo dichiarazione di tipo correttivo
    kvTipoDichCorrettiva            CONSTANT DB_TIPO_MOTIVO_DICHIARAZIONE.TIPO_DICHIARAZIONE%TYPE:='C';
    -- identificativo procedimento comunicazioni 10R
    knIdProcComu10R                 CONSTANT DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE:=37;
    -- procedimento fittizio istanza riesame
    knIdProcIstanzaRiesame          CONSTANT DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE:=40;
    -- identificativo fase istanza di riesame fotointerpretazione
    knIdFaseIstanzaRieFoto          CONSTANT DB_FASE_ISTANZA_RIESAME.ID_FASE_ISTANZA_RIESAME%TYPE:=1;
    -- identificativo fase istanza di riesame controllo in contraddittorio
    knIdFaseIstanzaRieControllo     CONSTANT DB_FASE_ISTANZA_RIESAME.ID_FASE_ISTANZA_RIESAME%TYPE:=2;
    -- identificativo fase istanza di riesame sopraluogo in campo
    knIdFaseIstanzaRieSopralluogo   CONSTANT DB_FASE_ISTANZA_RIESAME.ID_FASE_ISTANZA_RIESAME%TYPE:=3;
    -- identificativo motivo dichiarazione cosman
    knIdTipoMotDichCosman           CONSTANT DB_TIPO_MOTIVO_DICHIARAZIONE.ID_MOTIVO_DICHIARAZIONE%TYPE:=20;





PROCEDURE  AGGIORNA_PRATICA_AZIENDA(P_ID_AZIENDA     IN         DB_AZIENDA.ID_AZIENDA%TYPE,
                                                P_MSGERR            IN OUT     VARCHAR2,
                                                P_CODERR         IN OUT     VARCHAR2);


PROCEDURE CESSAZIONE_AMMESSA(         P_ID_AZIENDA     IN        DB_AZIENDA.ID_AZIENDA%TYPE,
                                                P_ESITO            OUT    VARCHAR2,
                                                P_MSG          OUT     VARCHAR2,
                                                P_CODERR           OUT    VARCHAR2);

    /*********************************************************************
    Effettua il popolamento della tabella SMRGAA_W_AZIENDA_SCARICO_XML
    ed il richiamo della procedure AGGIORNA_PRATICA_AZIENDA per ogni
    azienda presente sulla tabella
    Tipo:   procedure
    input: pIdParScFile, pTreChrCf, pAggPrat, pDataDa, pDataA
    output: pCodErr, pMsgErr
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE PopolaAziendePerScaricoXml (pIdParScFile  IN DB_PARAMETRO_SCARICO_FILE.ID_PARAMETRO_SCARICO_FILE%TYPE,
                                          pTreChrCf     IN VARCHAR2,
                                          pAggPrat      IN VARCHAR2,
                                          pDataDa       IN VARCHAR2,
                                          pDataA        IN VARCHAR2,
                                          pCodErr      OUT VARCHAR2,
                                          pMsgErr      OUT VARCHAR2
                                          );

END;

/
--------------------------------------------------------
--  DDL for Package PACK_RIBALTAMENTO_CONSISTENZA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PACK_RIBALTAMENTO_CONSISTENZA" IS

    -- data max futura
    D_DATA_CUTOFF      CONSTANT DATE:=TO_DATE('31/12/9999 23:59:59','DD/MM/YYYY HH24:MI:SS');


    PROCEDURE  RIBALTAMENTO_CONSISTENZA(P_ID_AZIENDA_NEW  IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                           P_ID_AZIENDA_PROV IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                           P_MSGERR          IN OUT VARCHAR2,
                                           P_CODERR           IN OUT VARCHAR2);

END;

/
--------------------------------------------------------
--  DDL for Package PACK_RIBALTA_UV_SU_PCOLTURALE
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PACK_RIBALTA_UV_SU_PCOLTURALE" IS

    -- costante codice utilizzo uso agricolo da definire
    kvCodAltroDatoUsoAgrDaDefinire     CONSTANT DB_ALTRI_DATI.CODICE%TYPE:='USOAGRDADEF';


    -- costante codice varieta' generica
    kvCodVarietaGenerica            CONSTANT DB_TIPO_VARIETA.CODICE_VARIETA%TYPE:='000';
    -- costante codice varieta' generica
    kvCodDettaglioUsoGenerico       CONSTANT DB_TIPO_DETTAGLIO_USO.CODICE_DETTAGLIO_USO%TYPE:='000';

    -- identificativo regione PIEMONTE
    kvIdRegionePiemonte             CONSTANT REGIONE.ID_REGIONE%TYPE:='01';


    PROCEDURE RIBALTA_UV(P_ID_AZIENDA                   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                         P_ELENCO_UV                    IN NUM_VARRAY,
                         P_ID_UTENTE_AGGIORNAMENTO      IN DB_DICHIARAZIONE_CONSISTENZA.ID_UTENTE%TYPE,
                         P_MSGERR                       IN OUT VARCHAR2,
                         P_CODERR                       IN OUT VARCHAR2);

END;

/
--------------------------------------------------------
--  DDL for Package PACK_RIPRISTINA_DICHIARAZIONE
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PACK_RIPRISTINA_DICHIARAZIONE" IS



    PROCEDURE  RIPRISTINA_DICHIARAZIONE(P_ID_DICHIARAZIONE        IN      DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                           P_ID_UTENTE_AGGIORNAMENTO IN      DB_DICHIARAZIONE_CONSISTENZA.ID_UTENTE%TYPE,
                                           P_MSGERR          IN OUT VARCHAR2,
                                           P_CODERR           IN OUT VARCHAR2);

END;

/
--------------------------------------------------------
--  DDL for Package PCK_AGGIORNA_DATI_BIOLOGICO
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_AGGIORNA_DATI_BIOLOGICO" AS
/*****************************************************************************
Package che espone tutte le function / stored procedure propedeutiche all'aggiornamento
dei dati relaviti all'agricoltura biologica provenienti dalla fonte ABIO sull'anagrafe
aziende agricole
******************************************************************************/

    -- identificativo applicazione batch di aggiornamento soci
    knIdApplBatchAggBiologico CONSTANT SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE:=4;
    -- identificativo tipologia info aggiuntiva
    knIdTipoInfoAggiuntivaBio CONSTANT DB_TIPO_INFO_AGGIUNTIVA.ID_INFO_AGGIUNTIVA%TYPE:=1;
    -- identificativo utente aggiornamento batch
    knIdUtenteAggBatch        CONSTANT DB_AZIENDA_COLLEGATA.ID_UTENTE_AGGIORNAMENTO%TYPE:=9999999999;



    /*********************************************************************
    Effettua l'aggiornamento dei dati relativi all'agricoltura biologica passati
    da ABIO su SMRGAA
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION AggiornaDatiBiologico RETURN NUMBER;


END Pck_Aggiorna_Dati_Biologico;

/
--------------------------------------------------------
--  DDL for Package PCK_AGGIORNA_DATI_ELEGGIBILITA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_AGGIORNA_DATI_ELEGGIBILITA" IS

    -- identificativo applicazione batch RPAIEA000-1
    knIdApplBatchEleggibilita       CONSTANT SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE:=1;
    -- codice parametro data dalla quale ricalcolare l'eleggibilità
    kvCodParametroDataDa            CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='ABEL';
    -- codice parametro opzionale data dalla quale inviare le particelle con U.V. da VITI
    kvCodParametroDataMinInvioUv    CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='DTINVIOUV';
    -- codice parametro invio particelle istanza riesame
    kvCodParametroInvioParticelle   CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='INVP';
    -- codice parametro per modalità massiva (SE S) di eliminazione particelle in istanza di riesame non più presenti in appositi documenti attivi
    kvCodParametroTipoEliminazione  CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='ELISTMASS';
    -- codice parametro tipo esecuzione batch RPAIEA000-1
    kvCodParametroTipoEsecuzione    CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='TPESEC';
    -- codice parametro identificativo categoria notifica per chiusura istanza di riesame
    kvCodParametroCategNotIstRies   CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='CATNOTIFY';
    -- costante identificativo titolo possesso in asservimento
    knIdTitPossessoAsservimento     CONSTANT DB_TIPO_TITOLO_POSSESSO.ID_TITOLO_POSSESSO%TYPE:=5;
    -- codice tipo motivo dichiarazione correttiva
    kvCodTipoMotivoDichCorrettiva   CONSTANT DB_TIPO_MOTIVO_DICHIARAZIONE.TIPO_DICHIARAZIONE%TYPE:='C';
    -- identificativo tipo motivo dichiarazione siccità 2006
    knIdTipoMotivoDichSiccita2006   CONSTANT DB_TIPO_MOTIVO_DICHIARAZIONE.ID_MOTIVO_DICHIARAZIONE%TYPE:=7;
    -- identificativo tipologia unar vino
    knIdTipologiaUnarVino           CONSTANT DB_TIPO_TIPOLOGIA_UNAR.ID_TIPOLOGIA_UNAR%TYPE:=2;
    -- identificativo stato documento storicizzato
    knIdStatoDocStoricizzato        CONSTANT DB_TIPO_STATO_DOCUMENTO.ID_STATO_DOCUMENTO%TYPE:=2;
    -- identificativo stato documento annullato
    knIdStatoDocAnnullato           CONSTANT DB_TIPO_STATO_DOCUMENTO.ID_STATO_DOCUMENTO%TYPE:=1;
    -- identificativo fase istanza di riesame in lavorazione
    knIdFaseIstRiesameInLav         CONSTANT DB_FASE_ISTANZA_RIESAME.ID_FASE_ISTANZA_RIESAME%TYPE:=1;
    -- identificativo procedimento anagrafe
    knIdProcedimentoSMRGAA          CONSTANT DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE:=7;
    -- identificativo regione PIEMONTE
    kvIdRegionePiemonte             CONSTANT REGIONE.ID_REGIONE%TYPE:='01';
    -- codice parametro per reperire l'identificativo del tipo documento per istanza riesame fotointerpretazione
    kvCodParametroIdDocIstRieXFoto  CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='DOCRIE';
    -- codice altro dato data per lista gis
    kvCodAltroDatoDtListaGIS        CONSTANT DB_ALTRI_DATI.CODICE%TYPE:='DT_LISTE_GIS';
    -- codice parametro per reperire i giorni massimi di sospensione di una lavorazione per istanza di riesame
    kvCodParametroGGMaxSospLavIst   CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='GGMAXSOSIS';

    FUNCTION FIND_ELEGGIBILITA_DA_CLS_FIT(pIdEleFit IN NUMBER) RETURN NUMBER;
    PRAGMA RESTRICT_REFERENCES (FIND_ELEGGIBILITA_DA_CLS_FIT, RNPS);


    FUNCTION FIND_SUPERFICI(pIdElegGis  IN SMRGAA_W_ELEGGIBILITA_GIS_DETT.ID_ELEGGIBILITA_GIS%TYPE,
                            pIdElegg    IN SMRGAA_W_ELEGGIBILITA_GIS_DETT.ID_ELEGGIBILITA%TYPE
                          )  RETURN NUMBER;
    PRAGMA RESTRICT_REFERENCES (FIND_SUPERFICI, RNPS);

    /*********************************************************************
    Scorre i record da elaborare presenti su SMRGAA_W_ELEGGIBILITA_GIS ed
    effettua l'aggiornamento / inserimento dei dati su DB_PARTICELLA_CERTIFICATA
    e DB_PARTICELLA_CERT_ELEG
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION Acquisizione_Eleggibilita RETURN NUMBER;

    /*********************************************************************
    Scorre i record di SMRGAA_W_PARTICELLA_SOSPESA ed aggiorna la DATA_SOSPENSIONE
    su DB_PARTICELLA_CERTIFICATA in caso la particella sia presente per la chiave
    catastale
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION Acquisizione_Sospensione RETURN NUMBER;

    /*********************************************************************
    Crea un file di testo contenente un data che sarà poi utilizzata da una
    procedura residente sul db SITIPIOPR di abaco per estrarre le particelle
    per le quali è stata calcolata l'eleggibilità dopo quella data inoltre
    genera un file di testo contenente le particelle oggetto di istanza di
    riesame che devono essere inserite nella lista di lavorazione del GIS
    prima di richiamare il calcolo dell'eleggibilità
    Tipo:    function
    input:  pNomeFileData, pNomeFileParticelle
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3= dipendenze non verificate)
    *********************************************************************/
    FUNCTION InviaDataUltimoRicalcolo (pNomeFileData        IN VARCHAR2,
                                       pNomeFileParticelle  IN VARCHAR2)RETURN NUMBER;


END Pck_Aggiorna_Dati_Eleggibilita;

/
--------------------------------------------------------
--  DDL for Package PCK_AGGIORNA_ISOLE_PARCELLE
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_AGGIORNA_ISOLE_PARCELLE" IS

    -- identificativo titolo possesso asservimento
    knIdTitoloPossessoAsservimento      CONSTANT DB_TIPO_TITOLO_POSSESSO.ID_TITOLO_POSSESSO%TYPE:=5;
    -- codice tipo motivo dichiarazione correttiva
    kvCodTipoMotivoDichCorrettiva       CONSTANT DB_TIPO_MOTIVO_DICHIARAZIONE.TIPO_DICHIARAZIONE%TYPE:='C';
    -- identificativo tipo motivo dichiarazione siccità 2006
    knIdTipoMotivoDichSiccita2006       CONSTANT DB_TIPO_MOTIVO_DICHIARAZIONE.ID_MOTIVO_DICHIARAZIONE%TYPE:=7;
    -- identificativo batch di acquisizione isole / parcelle
    knIdApplBatchIsoleParcelle          CONSTANT SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE:=7;
    -- codice parametro opzionale che sostituisce la data ultimo ricalcolo, mi dice da quale data prelevare le isole parcelle lato gis
    kvCodParametroDataRicalcolo         CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='DATADA';
    -- codice parametro opzionale per la percentuale da appliare alla tolleranza dell'eleggibilita
    kvCodParametroPercTolleranza        CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='PERCTOLL';
    -- codice parametro opzionale che mi indica se controllare le sole dichiarazioni protocollate o meno
    kvCodParametroProtocollazione       CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='DICHPROT';
    -- codice parametro opzionale che mi indica se storicizzare le isole dichiarate o meno
    kvCodParametroStoricizza            CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='STORICIZZA';
    -- se presente indica che l'anno riferimento inviato al GIS per la generazione delle isole deve essere almeno uguale
    kvCodParametroAnnoIsole             CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='ANNOISOLE';
    -- codice parametro per esclusione aziende con consolidamento GIS dello schedario viticolo
    kvCodParametroEsclConsolidate       CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='NOCONSGIS';
    -- identificativo tipologia unar vino
    knIdTipologiaUnarVino               CONSTANT DB_TIPO_TIPOLOGIA_UNAR.ID_TIPOLOGIA_UNAR%TYPE:=2;

    /*********************************************************************
    Crea un file di testo da caricare sul DB di abaco con i dati delle particelle
    delle dichiarazioni di consistenza per le quali non è ancora stata effettuata
    la generazione delle isole
    Tipo:  function
    input:  pNomeFileParticelle, pNomeFileParametri
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO)
    *********************************************************************/
    FUNCTION ScaricoPianiColturali(pNomeFileParticelle  IN VARCHAR2,
                                   pNomeFileParametri   IN VARCHAR2) RETURN NUMBER;


   /*********************************************************************
    Effettua l'acquisizione delle isole generate dal GIS
    utilizzando le tabelle di lavoro (popolate con SQL-Loader)
    SMRGAA_W_ISOLE_PARTICELLE, SMRGAA_W_ISOLE_PARCELLE
    SMRGAA_W_ISOLE_ANOMALIE
    Tipo:    function
    input:  nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO)
    *********************************************************************/
    FUNCTION ELABORA_ISOLE RETURN NUMBER;


END Pck_Aggiorna_Isole_Parcelle;

/
--------------------------------------------------------
--  DDL for Package PCK_AGGIORNA_PROCEDIMENTI_AZ
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_AGGIORNA_PROCEDIMENTI_AZ" IS


   FUNCTION MAIN  RETURN NUMBER;


END Pck_Aggiorna_Procedimenti_Az;

/
--------------------------------------------------------
--  DDL for Package PCK_CALCOLO_EFA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_CALCOLO_EFA" AS
/*****************************************************************************
Package che espone tutte le function / stored procedure propedeutiche al
Calcolo delle EFA (Ecologic Focus Area - Aree Ecologiche)
******************************************************************************/


    /*********************************************************************
    Calcola le EFA dell'azienda o al piano in lavorazione o alla dichiarazione
    di consistenza passata in input se presente
    Tipo: procedure
    input: pIdAzienda, pIdDichCons,  pIdUtenteIride
    output: pRisultato,pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE Calcola_Efa (pIdAzienda     IN DB_AZIENDA_EFA.ID_AZIENDA%TYPE,
                           pIdDichCons    IN DB_AZIENDA_EFA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                           pIdUtenteIride IN DB_AZIENDA_EFA.ID_UTENTE_AGGIORNAMENTO%TYPE,
                           pRisultato     OUT VARCHAR2,
                           pMessaggio     OUT VARCHAR2);

END Pck_Calcolo_Efa;

/
--------------------------------------------------------
--  DDL for Package PCK_CALCOLO_ESITO_GREENING
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_CALCOLO_ESITO_GREENING" AS
/*****************************************************************************
Package che espone tutte le function / stored procedure propedeutiche al
Calcolo dell'esito del greening
******************************************************************************/

    Type TypVetEsoneriGreening IS TABLE OF DB_AZIENDA_GREENING_ESONERO%ROWTYPE INDEX BY PLS_INTEGER;

    -- identificativo fonte certificazione particella "Catasto"
    knIdFontePratoPermanente        CONSTANT DB_TIPO_FONTE.ID_FONTE%TYPE:=9;

    --
    knIdEsitoGreeningEsente         CONSTANT DB_ESITO_GREENING.ID_ESITO_GREENING%TYPE:=1;
    knIdEsitoGreeningSi             CONSTANT DB_ESITO_GREENING.ID_ESITO_GREENING%TYPE:=2;
    knIdEsitoGreeningNo             CONSTANT DB_ESITO_GREENING.ID_ESITO_GREENING%TYPE:=3;
    knIdEsitoGreeningRispettato     CONSTANT DB_ESITO_GREENING.ID_ESITO_GREENING%TYPE:=4;
    knIdEsitoGreeningRispParz       CONSTANT DB_ESITO_GREENING.ID_ESITO_GREENING%TYPE:=5;
    knIdEsitoGreeningNonRispettato  CONSTANT DB_ESITO_GREENING.ID_ESITO_GREENING%TYPE:=6;
    knIdEsitoGreeningParziale       CONSTANT DB_ESITO_GREENING.ID_ESITO_GREENING%TYPE:=7;
    knIdEsitoGreeningRispParzPP     CONSTANT DB_ESITO_GREENING.ID_ESITO_GREENING%TYPE:=8;
    knIdEsitoGreeningNAPP           CONSTANT DB_ESITO_GREENING.ID_ESITO_GREENING%TYPE:=9;
    knIdEsitoGreeningCalc           CONSTANT DB_ESITO_GREENING.ID_ESITO_GREENING%TYPE:=10;
    knIdEsitoGreeningCalcErr        CONSTANT DB_ESITO_GREENING.ID_ESITO_GREENING%TYPE:=11;

    knEttMaxDifSeminativoUsiVari    CONSTANT INTEGER:=30;
    knPercMinRispettoAltriUsiSem    CONSTANT INTEGER:=75;

    knPercMinRispettoAltriUsiTSem   CONSTANT INTEGER:=95;


    -- identificativo tipo documento deroga mentenimento prati
    knIdTipoDocDerogaMantenimPrati  CONSTANT DB_TIPO_DOCUMENTO.ID_DOCUMENTO%TYPE:=410;


    kvCodTipoEsoneroNoPratiPerm     CONSTANT DB_TIPO_ESONERO_GREENING.CODICE_TIPO_ESONERO%TYPE:='NOPP';
    kvCodTipoEsoneroNoSeminativo    CONSTANT DB_TIPO_ESONERO_GREENING.CODICE_TIPO_ESONERO%TYPE:='NOSEM';
    kvCodTipoEsoneroEttariMin10     CONSTANT DB_TIPO_ESONERO_GREENING.CODICE_TIPO_ESONERO%TYPE:='SEM<10';
    kvCodTipoEsoneroEttariMin15     CONSTANT DB_TIPO_ESONERO_GREENING.CODICE_TIPO_ESONERO%TYPE:='SEM<15';
    kvCodTipoEsonero75PratoRipLeg   CONSTANT DB_TIPO_ESONERO_GREENING.CODICE_TIPO_ESONERO%TYPE:='FRL>75sem';
    kvCodTipoEsonero75PrSomPrPerm   CONSTANT DB_TIPO_ESONERO_GREENING.CODICE_TIPO_ESONERO%TYPE:='PFR>75sup';
    kvCodTipoEsoneroSoloRiso        CONSTANT DB_TIPO_ESONERO_GREENING.CODICE_TIPO_ESONERO%TYPE:='SOLORISO';
    kvCodTipoEsonero75PratoRip      CONSTANT DB_TIPO_ESONERO_GREENING.CODICE_TIPO_ESONERO%TYPE:='FR>75sem';


    kvIdRegionePiemonte             CONSTANT REGIONE.ID_REGIONE%TYPE:='01';

    knEttariFinoDueColtureDic       CONSTANT INTEGER:=30;


    glRecDTipoGreening              DB_TIPO_GREENING%ROWTYPE;
    glRecTAziendaGreening           DB_AZIENDA_GREENING%ROWTYPE;
    glVetEsoneriAzGreening          TypVetEsoneriGreening;

    gnRls            NUMBER := 0;
    gnUde            DB_TIPO_UDE.ID_UDE%TYPE := 0;
    gnOte            DB_TIPO_ATTIVITA_OTE.ID_ATTIVITA_OTE%TYPE := 0;
    gnPs             NUMBER := 0;
    gnReturnValInea  NUMBER := 0;
    gvDescErrInea    VARCHAR2(1000) := '';


    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    mantenimento prati permanenti
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE MPP (pIdAzienda     IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                   pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                   pRisultato    OUT VARCHAR2,
                   pMessaggio    OUT VARCHAR2);

    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    presenza di area ecologiche (Ecologic Focus Area)
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE EFA (pIdAzienda     IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                   pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                   pRisultato    OUT VARCHAR2,
                   pMessaggio    OUT VARCHAR2);

    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    presenza di area ecologiche (Ecologic Focus Area)
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE EFA_CB (pIdAzienda     IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                      pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                      pRisultato    OUT VARCHAR2,
                      pMessaggio    OUT VARCHAR2);


    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    presenza di area ecologiche (Ecologic Focus Area)
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE EFA_VAL (pIdDichCons    IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                       pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                       pRisultato    OUT VARCHAR2,
                       pMessaggio    OUT VARCHAR2);


    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    presenza di area ecologiche (Ecologic Focus Area)
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE EFA_VAL_CB (pIdDichCons    IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                          pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                          pRisultato    OUT VARCHAR2,
                          pMessaggio    OUT VARCHAR2);



    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    azienda biologica
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE BIO (pIdAzienda     IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                   pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                   pRisultato    OUT VARCHAR2,
                   pMessaggio    OUT VARCHAR2);

    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    azienda biologica
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE BIO_VAL (pIdDichCons    IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                       pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                       pRisultato    OUT VARCHAR2,
                       pMessaggio    OUT VARCHAR2);

    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    DIVERSIFICAZIONE
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE DIV (pIdAzienda     IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                   pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                   pRisultato    OUT VARCHAR2,
                   pMessaggio    OUT VARCHAR2);

    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    DIVERSIFICAZIONE
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE DIV_CB (pIdAzienda     IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                      pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                      pRisultato    OUT VARCHAR2,
                      pMessaggio    OUT VARCHAR2);

    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    DIVERSIFICAZIONE
    Tipo: function
    input: pCodFoto
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE DIV_VAL (pIdDichCons    IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                       pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                       pRisultato    OUT VARCHAR2,
                       pMessaggio    OUT VARCHAR2);

    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    DIVERSIFICAZIONE
    Tipo: function
    input: pCodFoto
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE DIV_VAL_CB (pIdDichCons    IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                          pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                          pRisultato    OUT VARCHAR2,
                          pMessaggio    OUT VARCHAR2);


    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    azienda con particelle FUORI PIEMONTE
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE FUOPIEMONT (pIdAzienda    IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                          pEscludiBio   IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                          pRisultato    OUT VARCHAR2,
                          pMessaggio    OUT VARCHAR2
                          );


    /*********************************************************************
    Effettua il calcolo degli esiti del rispetto del greening per ogni tipologia
    andando ad aggiornare la tabella DB_AZIENDA_GREENING
    Tipo: procedure
    input: pIdAzienda, pIdDichCons, pIdUtenteIride
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE Calcola_Esito_Greening (pIdAzienda        IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                                      pIdDichCons       IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                      pIdUtenteIride    IN DB_AZIENDA_GREENING.ID_UTENTE_AGGIORNAMENTO%TYPE,
                                      pRisultato       OUT VARCHAR2,
                                      pMessaggio       OUT VARCHAR2);


    /*********************************************************************
    Effettua il calcolo degli esiti del rispetto del greening per ogni tipologia
    andando ad aggiornare la tabella DB_AZIENDA_GREENING per il procedimento
    richiamante e per la pratica richiamante
    Tipo: procedure
    input: pIdDichCons, pIdUtenteIride, pIdProcedimento, pExtIdPratica, pSumRimastaInEfa
    output: pRisultato,pMessaggio
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE Calcola_Esito_Greening_Proc (pIdDichCons          IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                           pIdUtenteIride       IN DB_AZIENDA_GREENING.ID_UTENTE_AGGIORNAMENTO%TYPE,
                                           pIdProcedimento      IN DB_AZIENDA_GREENING.ID_PROCEDIMENTO%TYPE,
                                           pExtIdPratica        IN DB_AZIENDA_GREENING.EXT_ID_PRATICA%TYPE,
                                           pSumRimastaInEfa     IN DB_UTILIZZO_DICHIARATO.SUPERFICIE_UTILIZZATA%TYPE,
                                           pRisultato          OUT VARCHAR2,
                                           pMessaggio          OUT VARCHAR2
                                           );

  PROCEDURE OTE(pIdAzienda       DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                pEscludiBio      DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                pRisultato   OUT VARCHAR2,
                pMessaggio   OUT VARCHAR2);

  PROCEDURE RLS(pIdAzienda       DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                pEscludiBio      DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                pRisultato   OUT VARCHAR2,
                pMessaggio   OUT VARCHAR2);

  PROCEDURE UDE(pIdAzienda       DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                pEscludiBio      DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                pRisultato   OUT VARCHAR2,
                pMessaggio   OUT VARCHAR2);

  PROCEDURE ULU(pIdAzienda       DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                pEscludiBio      DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                pRisultato   OUT VARCHAR2,
                pMessaggio   OUT VARCHAR2);

  PROCEDURE DIM_AZ(pIdAzienda       DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                   pEscludiBio      DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                   pRisultato   OUT VARCHAR2,
                   pMessaggio   OUT VARCHAR2);

  PROCEDURE PS(pIdAzienda       DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
               pEscludiBio      DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
               pRisultato   OUT VARCHAR2,
               pMessaggio   OUT VARCHAR2);

END Pck_Calcolo_Esito_Greening;

/
--------------------------------------------------------
--  DDL for Package PCK_CALCOLO_ULU
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_CALCOLO_ULU" IS


PROCEDURE MAIN (     pIdAzienda     IN     NUMBER,
                        pIdUde        IN     NUMBER,
                        pUlu            OUT     NUMBER,
                         pRetVal         OUT     NUMBER,
                        pDeserr        OUT     VARCHAR2);

END Pck_Calcolo_Ulu;

/
--------------------------------------------------------
--  DDL for Package PCK_CARICA_MISURA_H
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_CARICA_MISURA_H" IS

    /*********************************************************************
    Dato un ID_AZIENDA inserisco tutti gli utilizzi e le condizioni
    reperite tramite il CUAA su TMP_MIGRAZIONE_H_P2 nelle tavole
    DB_CONDUZIONE_PARTICELLA e DB_UTILIZZO_PARTICELLA
    Tipo:   function
    input:  pIdAzienda , pCodErr, pMsgErr
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE MAIN (pIdAzienda IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                    pCodErr       IN OUT VARCHAR2,
                     pMsgErr    IN OUT VARCHAR2);

END Pck_Carica_Misura_H;

/
--------------------------------------------------------
--  DDL for Package PCK_CARICA_MISURA_H_ALTRO_CUAA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_CARICA_MISURA_H_ALTRO_CUAA" IS

    /*********************************************************************
    Dato un CUAA di provenienza inserisco tutti gli utilizzi e le condizioni
    reperite su TMP_MIGRAZIONE_H_P2 nelle tavole
    DB_CONDUZIONE_PARTICELLA e DB_UTILIZZO_PARTICELLA per l'azienda
    reperita tramite il CUAA di destinazione
    Tipo:   function
    input:  pCuaaProv, pCuaaDest, pCodErr, pMsgErr
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE MAIN (pCuaaProv  IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    pCuaaDest  IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    pCodErr       IN OUT VARCHAR2,
                     pMsgErr    IN OUT VARCHAR2);

END Pck_Carica_Misura_H_Altro_Cuaa ;

/
--------------------------------------------------------
--  DDL for Package PCK_EXP_PARTICELLE_OUT_CATASTO
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_EXP_PARTICELLE_OUT_CATASTO" IS

   FUNCTION MAIN (pPath            IN VARCHAR2,
                  pFileOut         IN VARCHAR2 )RETURN NUMBER;

END Pck_Exp_Particelle_Out_Catasto;

/
--------------------------------------------------------
--  DDL for Package PCK_GESTIONE_ISTANZA_RIESAME
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_GESTIONE_ISTANZA_RIESAME" AS
/*****************************************************************************
Package che espone tutte le function / stored procedure propedeutiche alla gestione
delle fasi di controllo in contradditorio e sopralluogo in campo dell'istanza di riesame
******************************************************************************/

    -- identificativo applicazione batch RPAIEA000-1
    knIdApplBatchEleggibilita     CONSTANT SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE:=1;
    -- identificativo applicazione batch di aggiornamento dati istanza di riesame
    knIdApplBatchIstanzaRiesame   CONSTANT SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE:=14;
    -- identificativo fase istanza di riesame fotointerpretazione
    knIdFaseIstRiesFotoInt        CONSTANT DB_FASE_ISTANZA_RIESAME.ID_FASE_ISTANZA_RIESAME%TYPE:=1;
    -- identificativo fase istanza di riesame contraddittorio
    knIdFaseIstRiesContradditorio CONSTANT DB_FASE_ISTANZA_RIESAME.ID_FASE_ISTANZA_RIESAME%TYPE:=2;
    -- identificativo fase istanza di riesame sopralluogo
    knIdFaseIstRiesSopraluogo     CONSTANT DB_FASE_ISTANZA_RIESAME.ID_FASE_ISTANZA_RIESAME%TYPE:=3;
    -- identificativo tipo procedimento anagrafe aziende agricole
    knIdProcedimentoSMRGAA        CONSTANT DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE:=7;
    -- codice parametro per reperimento ID_MOTIVO_DICHIARAZIONE da escludere
    kvCodParVetMotiviDich         CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='NO_MOTIV';
    -- codice parametro per reperimento categoria notifica per evasione istanza di riesame di sopralluogo in campo
    kvCodParCatNotIstSoprInCampo  CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='CATNOT_SO';
    -- codice parametro per reperimento categoria notifia per evasione istanza di riesame di controllo in contraddittorio
    kvCodParCatNotIstCtrlInContr  CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='CATNOT_CO';
    -- codice parametro per reperimento identificativi stati SITICONVOCA di conclusione istanza di riesame controllo in contraddittorio
    kvCodParStatiFineIstRiesCC    CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='STAT_CO';
    -- codice parametro per reperimento identificativi stati SITICONVOCA di conclusione istanza di riesame sopralluogo in campo
    kvCodParStatiFineIstRiesSC    CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='STAT_SO';
    -- codice parametro per reperimento identificativi stati SITICONVOCA di conclusione istanza di riesame di controllo in contradditorio per scadenza termini
    kvCodParStatiFineDCIstRiesCC  CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='STAT_TER';
    -- codice parametro per reperimento numero di giorni minimo di transizione tra una fase istanza riesame e l'altra
    kvCodParGGTraFasi             CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='GGTRAFASI';
    -- codice parametro per reperimento fasi istanza di riesame di anagrafe da inviare a siticonvoca
    kvCodParFaseAnagDaInv         CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='FASEDAANAG';
    -- codice parametro per reperimento fasi istanza di riesame SITICONVOCA da acquisire su ANAGRAFE
    kvCodParFaseSitiConvDaAcq     CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='FASESUANAG';
    -- identificativo titolo di possesso asservimento
    knIdTitPossessoAsservimento   CONSTANT DB_TIPO_TITOLO_POSSESSO.ID_TITOLO_POSSESSO%TYPE:=5;
    -- identificativo titolo di possesso conferimento
    knIdTitPossessoConferimento   CONSTANT DB_TIPO_TITOLO_POSSESSO.ID_TITOLO_POSSESSO%TYPE:=6;
    -- identificativo tipo ruolo rappresentante legale / titolare
    knIdRuoloTitolareRapprLegale  CONSTANT DB_TIPO_RUOLO.ID_RUOLO%TYPE:=1;
    -- lunghezza di un codice fiscale
    knLengthCF                    CONSTANT INTEGER:=16;
    -- identificativo stato documento storicizzato
    knIdStatoDocStoricizzato      CONSTANT DB_TIPO_STATO_DOCUMENTO.ID_STATO_DOCUMENTO%TYPE:=2;
    -- identificativo stato documento annullato
    knIdStatoDocAnnullato         CONSTANT DB_TIPO_STATO_DOCUMENTO.ID_STATO_DOCUMENTO%TYPE:=1;
    -- codice tipo motivo dichiarazione correttiva
    kvCodTipoMotivoDichCorrettiva CONSTANT DB_TIPO_MOTIVO_DICHIARAZIONE.TIPO_DICHIARAZIONE%TYPE:='C';
    -- identificativo tipo motivo dichiarazione siccità 2006
    knIdTipoMotivoDichSiccita2006 CONSTANT DB_TIPO_MOTIVO_DICHIARAZIONE.ID_MOTIVO_DICHIARAZIONE%TYPE:=7;
    -- codice per reperimento giorni di scadenza ...
    kvCodAltroDatoGGFoto          CONSTANT DB_ALTRI_DATI.CODICE%TYPE:='GGFOTO';
    knIdStatoSitiConvocaDaConv    CONSTANT DB_STATO_SITICONVOCA.ID_STATO_SITICONVOCA%TYPE:=200;
    knIdStatoSitiConvocaDaInv     CONSTANT DB_STATO_SITICONVOCA.ID_STATO_SITICONVOCA%TYPE:=0;
    knIdUtenteAggBatch            CONSTANT DB_AZIENDA_COLLEGATA.ID_UTENTE_AGGIORNAMENTO%TYPE:=9999999999;

    knIdStatoSitiConvocaRicSopr   CONSTANT DB_STATO_SITICONVOCA.ID_STATO_SITICONVOCA%TYPE:=270;


    knIdGruppoSitiConvocaAnnullato CONSTANT DB_STATO_SITICONVOCA.STATO%TYPE:=4;
    knIdGruppoSitiConvocaEvaso     CONSTANT DB_STATO_SITICONVOCA.STATO%TYPE:=3;

    gnMaxLengthMessaggioErrore     INTEGER;


    -- identificativo regione PIEMONTE
    kvIdRegionePiemonte            CONSTANT REGIONE.ID_REGIONE%TYPE:='01';

    -- cursore delle istanza di riesame da evadare
    CURSOR curIstanzaRiesameEvasa IS
    SELECT IRE.*,
           SST.STATO
      FROM SMRGAA_W_ISTANZA_RIESAME IRE,
           DB_STATO_SITICONVOCA SST
     WHERE NVL(IRE.EVASO,'N') = 'N'
       AND IRE.ID_STATO_SITICONVOCA = SST.ID_STATO_SITICONVOCA;

    CURSOR curParticellaIstanza (pIdIsta IN SMRGAA_W_PART_ISTANZA_RIESAME.ID_ISTA%TYPE) IS
    SELECT *
      FROM SMRGAA_W_PART_ISTANZA_RIESAME
     WHERE ID_ISTA = pIdIsta;


    /*********************************************************************
    Dati in input un ID_AZIENDA, un ANNO verifica se sono presenti documenti
    di istanza di riesame (qualsiasi tipo) ed in caso affermativo controlla se
    tali documenti sono posteriori all'ultima dichiarazione dell'azienda non correttiva
    se è così per tutte le particelle associate al documento e con legame valido
    verrà inserita una richiesta di riesame associata alla fase riesame
    relazionata col tipo documento (ammesso che non sia già presente su DB_ISTANZA_RIESAME)
    Tipo: procedure
    input: pIdAzienda, pAnnoDocumento
    output: pCodErr, pDesErr
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InserisciIstanza (pIdAzienda        IN DB_ISTANZA_RIESAME.ID_AZIENDA%TYPE,
                                pAnnoDocumento    IN DB_ISTANZA_RIESAME.ANNO%TYPE,
                                pCodErr       IN OUT VARCHAR2,
                                pDesErr       IN OUT VARCHAR2);

    /*********************************************************************
    Dati in input un ID_AZIENDA, un ANNO ed un fase di istanza di riesame
    verifica se ci sono particelle legate a documenti annullati o storicizzati
    riferiti alla fase dell'istanza di riesame passata in input
    dove il cambiamento di stato del documento si è verificato dopo l'ultima
    esecuzione terminata a buon fine dei batch RPAIEA o RPAIIS
    e procede ad annullare la richiesta di riesame per la particella in questione
    se tale richiesta non è già stata annullata (o non è già stata evesa)
    Tipo: procedure
    input: pIdAzienda, pAnnoDocumento, pIdFaseIstRiesame, pIdUtente
    output: pCodErr, pDesErr
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE AnnullaIstanza (pIdAzienda        IN DB_ISTANZA_RIESAME.ID_AZIENDA%TYPE,
                              pAnnoDocumento    IN DB_ISTANZA_RIESAME.ANNO%TYPE,
                              pIdFaseIstRiesame IN DB_ISTANZA_RIESAME.ID_FASE_ISTANZA_RIESAME%TYPE,
                              pIdUtente         IN DB_ISTANZA_RIESAME.ID_UTENTE_RICHIEDENTE%TYPE,
                              pCodErr       IN OUT VARCHAR2,
                              pDesErr       IN OUT VARCHAR2);

    /*********************************************************************
    Estrae i dati anagrafici delle aziende che hanno richiesto istanza di riesame per
    contradditorio o sopralluogo in campo e anche i dati particellari delle particelle
    interessate e li accoda in due file di testo che poi saranno parsificati
    dal secondo job residenti su SITIPIOPR (GIS)
    Tipo: function
    input: pNomeFileDatiAnagrafici, pNomeFileDatiParticellari, pNomeFileIstCessate
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION InvioDatiAziendeInRiesame (pNomeFileDatiAnagrafici   IN VARCHAR2,
                                        pNomeFileDatiParticellari IN VARCHAR2
                                        ) RETURN NUMBER;

    /*********************************************************************
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION Elabora_Istanza_Riesame RETURN INTEGER;


END Pck_Gestione_Istanza_Riesame;

/
--------------------------------------------------------
--  DDL for Package PCK_GESTIONE_POLIZZA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_GESTIONE_POLIZZA" AS
/*****************************************************************************
Package che espone tutte le function / stored procedure propedeutiche alla gestione
delle polizze assicurative presenti in anagrafe
******************************************************************************/

    -- identificativo batch di esecuzione dei controlli sulle polizze
    knIdApplBatchControlliPolizza CONSTANT SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE:=6;
    -- identificativo batch di esecuzione calcolo importo polizza
    knIdApplBatchEsitoPolizza     CONSTANT SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE:=8;
    -- caricamento dati annuali estratte a campione polizza
    knIdApplBatchDtAnnualiCampPol  CONSTANT SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE:=18;
    -- costante per reperimento parametro anno campagna polizza sul quale effettuare i controlli
    kvParAnnoCampagna             CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='ANNOCP';
    -- costante per reperimento parametro tipo intervento polizza sul quale effettuare i controlli
    kvParIdTipoIntervento         CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='TIPOINT';
    -- identificativo tipo fonte SIAP
    knIdTipoFonteSiap             CONSTANT DB_TIPO_FONTE.ID_FONTE%TYPE:=3;
    -- identificativo gruppo controllo assicurazioni
    knIdGcAssicurazioni           CONSTANT DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE:=17;
    -- costante per reperimento parametro tipologia dichiarazione di consistenza da considerare per il controllo ASS05
    kvParTipoRepDichConsistenza   CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='TIPODICH';
    -- costante per reperimento parametro tipologia procedimento da considerare per il controllo ASS05
    kvParTipoProcedimento         CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='TIPOPROC';
    -- costante per reperimento parametro facoltativo identificativo azienda
    kvParIdAzienda                CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='IDAZIENDA';
    -- costante per il reperimento del parametro che mi dice se devo calcolare anche il pagabile oltre all'importo proposto
    kvParCalcolaPagabile          CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='TIPOIMP';
    -- costante per il reperimento del parametro che mi dice se devo calcolare anche il pagabile oltre all'importo proposto
    kvParPercRiduzionePagabile    CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='PERCRID';
    -- costante stato pratica in corso
    kvStatoPraticaInCorso         CONSTANT DB_PROCEDIMENTO_AZIENDA.STATO%TYPE:='I';
    -- costante stato pratica in conclusa
    kvStatoPraticaConclusa        CONSTANT DB_PROCEDIMENTO_AZIENDA.STATO%TYPE:='C';
    -- costante tipo operazione invio importo proposto OP
    kvTipoOperInvImportoProposto  CONSTANT DB_INVIO_DETTAGLIO_POLIZZA.TIPO_OPERAZIONE%TYPE:='PRO';
    -- costante tipo operazione invio importo pagabile
    kvTipoOperInvImportoPagabile  CONSTANT DB_INVIO_DETTAGLIO_POLIZZA.TIPO_OPERAZIONE%TYPE:='PG';
    -- costante esito invio ok
    kvCodEsitoInvioOk             CONSTANT DB_INVIO_DETTAGLIO_POLIZZA.ESITO_INVIO%TYPE:='012';
    -- identificativo fase controlli polizze
    knIdFaseControlliPolizze      CONSTANT DB_TIPO_FASE.ID_FASE%TYPE:=5;
    -- identificativo utente aggiornamento batch
    knIdUtenteAggBatch            CONSTANT DB_AZIENDA_COLLEGATA.ID_UTENTE_AGGIORNAMENTO%TYPE:=9999999999;

    /*********************************************************************
    Effettua massivamente dei controlli sulle polizze assicurative per l'anno
    campagna prelevato come parametro da SMRGAA_R_PARAM_APPLICAZIONE
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION Controlla_Polizza RETURN NUMBER;

    /*********************************************************************
    Effettua il calcolo dell'importo proposto (ed eventualmente dell'importo pagabile)
    per le polizze assicurative estratte tramite i parametri di input del batch
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION Calcola_Importo_Polizza RETURN NUMBER;


    /*********************************************************************
    Carica i dati annuali di resa dei prodotti assicurativi di un'azienda
    estratta a campione per polizze partendo dalla tabella di appoggio
    SMRGAA_W_RIEP_PRODOTTO_ANNO sulla tabella effettiva DB_RIEPILOGO_ANNUALE_PRODOTTO
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION CaricaDatiAnnuali RETURN NUMBER;


END Pck_Gestione_Polizza;

/
--------------------------------------------------------
--  DDL for Package PCK_GESTIONE_REGISTRO_PASCOLO
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_GESTIONE_REGISTRO_PASCOLO" AS
/*****************************************************************************
Package che espone tutte le function / stored procedure propedeutiche all'aggiornamento
dei dati relaviti ai registri pascolo presenti nell'anagrafe aziende agricole
******************************************************************************/

    -- identificativo applicazione batch di aggiornamento soci
    knIdApplBatchAggRegistro CONSTANT SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE:=15;

    /*********************************************************************
    Invia a SITI la data di ultima esecuzione del batch dalla quale
    cercare se ci sono state nuove fotointerpretazione su SITI o SITICONVOCA
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION Main RETURN NUMBER;

    /*********************************************************************
    Scorre e particelle della tabella di appoggio SMRGAA_W_PARTICELLA_REGISTRO e cessa
    i record di DB_ESITO_PASCOLO_MAGRO attivi
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION Cessa_Particella_Registro RETURN NUMBER;

END Pck_Gestione_Registro_Pascolo;

/
--------------------------------------------------------
--  DDL for Package PCK_GESTIONE_SOCI
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_GESTIONE_SOCI" AS
/*****************************************************************************
Package che espone tutte le function / stored procedure propedeutiche all'aggiornamento
dei Soci presenti in SMRGAA rispetto ai flussi di soci forniti dai procedimenti
******************************************************************************/

    -- identificativo applicazione batch di aggiornamento soci
    knIdApplBatchAggiornaSoci CONSTANT SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE:=2;
    -- identificativo utente aggiornamento batch
    knIdUtenteAggBatch        CONSTANT DB_AZIENDA_COLLEGATA.ID_UTENTE_AGGIORNAMENTO%TYPE:=9999999999;
    -- costante data inizio estrazione soci GNPS
    kvParDataOffsetGNPS       CONSTANT VARCHAR2(10):='GNPSDT';
    -- costante data inizio estrazione soci ABIO
    kvParDataOffsetABIO       CONSTANT VARCHAR2(10):='ABIODT';

    /*********************************************************************
    Effettua l'aggiornamento dei soci in anagrafe pescandoli dai flussi presenti
    sui procedimenti
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION Aggiorna_Soci RETURN NUMBER;


END Pck_Gestione_Soci;

/
--------------------------------------------------------
--  DDL for Package PCK_SCARICA_ANAGRAFICA_AZIENDA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_SCARICA_ANAGRAFICA_AZIENDA" IS


    FUNCTION fnc_main (pPathFile VARCHAR2, pPrefissoNomeFile VARCHAR2) RETURN NUMBER;
    /*  Funzione principale da richiamare per eseguire lo scarico su file di testo
        degli aggiornamenti dell'Anagrafica delle aziende
    */

END Pck_Scarica_Anagrafica_Azienda;

/
--------------------------------------------------------
--  DDL for Package PCK_SCARICA_SCHEDE_AGRONOMICHE
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_SCARICA_SCHEDE_AGRONOMICHE" IS
/*****************************************************************************
Package che conterra' tutte le function / procedure propedeutiche alla
generazione dei file di testo contenenti i dati delle schede agranomiche delle
unità vitate e della frutta a guscio che verranno poi elaborati dal GIS
******************************************************************************/

    -- identificativo applicazione batch schede agronomiche
    knIdApplicazioneBatchSchede  CONSTANT SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE:=10;
    -- Codice Utilizzo Frutta a guscio Nocciole
    kvCodUtilizzoNocciole       CONSTANT DB_TIPO_UTILIZZO.CODICE%TYPE:='071';
    -- Codice Utilizzo Frutta a guscio Mandorle
    kvCodUtilizzoMandorle       CONSTANT DB_TIPO_UTILIZZO.CODICE%TYPE:='072';
    -- Codice Utilizzo Frutta a guscio Noci
    kvCodUtilizzoNoci           CONSTANT DB_TIPO_UTILIZZO.CODICE%TYPE:='073';
    -- Codice Utilizzo Frutta a guscio Pistacchi
    kvCodUtilizzoPistacchi      CONSTANT DB_TIPO_UTILIZZO.CODICE%TYPE:='074';
    -- Codice Utilizzo Frutta a guscio Carrube
    kvCodUtilizzoCarrube        CONSTANT DB_TIPO_UTILIZZO.CODICE%TYPE:='075';
    -- identificativo tipologia UNAR vino
    knIdTipologiaUnarVino       CONSTANT DB_TIPO_TIPOLOGIA_UNAR.ID_TIPOLOGIA_UNAR%TYPE:=2;
    -- identificativo tipo motivo dichiarazione siccità
    knIdMotivoDichSiccita2006   CONSTANT DB_TIPO_MOTIVO_DICHIARAZIONE.ID_MOTIVO_DICHIARAZIONE%TYPE:=7;
    -- codice tipologia unar vino
    kvCodTipologiaUnarVino      CONSTANT DB_TIPO_TIPOLOGIA_UNAR.CODICE%TYPE:=1;
    -- codice tipologia unar Frutta a Guscio
    kvCodTipologiaUnarFag       CONSTANT DB_TIPO_TIPOLOGIA_UNAR.CODICE%TYPE:=4;
    -- id titolo possesso asservimento
    knIdTitPossessoAsservimento CONSTANT NUMBER(1):= 5;
    -- id titolo possesso in conferimento
    knIdTitpossessoConferimento CONSTANT NUMBER(1):= 6;
    -- codice parametro data offset per invio variazione
    kvCodParametroDataDa        CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='DTVARDA';
    -- codice parametro gestione vigne abilitate sul GIS
    kvCodParametroGestVigne     CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='VIGNESIAN';
    -- identificativo regione piemonte
    kvIdRegionePiemonte         CONSTANT REGIONE.ID_REGIONE%TYPE:='01';

    /*********************************************************************
    Genera i file di testo con i dati delle UV e delle FAG da inviare
    al GIS per la generazione delle schede agronomiche in quanto
    ci sono state delle variazioni (compresa l'eventuale cessazione)
    Tipo:  funzione
    input:  pNomeFileUnar,pNomeFileAttUnar
    output: nessuno
    ritorno: 0 = Ok , 1 = KO
    *********************************************************************/
    FUNCTION GeneraSchedeAgronomiche (pNomeFileUnar        VARCHAR2,
                                      pNomeFileAttUnar     VARCHAR2,
                                      pNomeFileUltimaElab  VARCHAR2) RETURN INTEGER;


END PCK_SCARICA_SCHEDE_AGRONOMICHE;

/
--------------------------------------------------------
--  DDL for Package PCK_SMRGAA_LIBRERIA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_SMRGAA_LIBRERIA" AS
/*****************************************************************************
Package di libreria che espone function / procedure comuni utilizzate da altri packages
o tramite select o dal java
******************************************************************************/

    CURSOR curTypUvParcellaMultipla (pIdDichConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                     pIdEleggibilitaFit IN DB_TIPO_ELEGGIBILITA_FIT.ID_ELEGGIBILITA_FIT%TYPE,
                                     pIdParticella      IN DB_CONDUZIONE_DICHIARATA.ID_PARTICELLA%TYPE,
                                     pIdAzienda         IN DB_STORICO_UNITA_ARBOREA.ID_AZIENDA%TYPE) IS
    SELECT S.ID_UNITA_ARBOREA,
           COUNT(DISTINCT(IP.ID_ISOLA_PARCELLA)) AS QUANTI
      FROM DB_ISOLA_DICHIARATA IDC,
           DB_ISOLA I,
           DB_ISOLA_PARCELLA IP,
           DB_PARCELLA_CONDUZIONE PC,
           DB_CONDUZIONE_DICHIARATA CD,
           DB_STORICO_UNITA_ARBOREA S
     WHERE IDC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichConsistenza
       AND IDC.DATA_FINE_VALIDITA IS NULL
       AND IDC.ID_ISOLA_DICHIARATA = I.ID_ISOLA_DICHIARATA
       AND I.ID_ISOLA = IP.ID_ISOLA
       AND IP.ID_ELEGGIBILITA_FIT = pIdEleggibilitaFit
       AND IP.ID_ISOLA_PARCELLA = PC.ID_ISOLA_PARCELLA
       AND PC.ID_CONDUZIONE_DICHIARATA = CD.ID_CONDUZIONE_DICHIARATA
       AND CD.ID_PARTICELLA = pIdParticella
       AND S.ID_AZIENDA = pIdAzienda
       AND S.ID_PARTICELLA = CD.ID_PARTICELLA
       AND S.DATA_FINE_VALIDITA IS NULL
       AND S.DATA_CESSAZIONE IS NULL;

    -- costante identificativo titolo possesso in asservimento
    knIdTitPossessoAsservimento     CONSTANT DB_TIPO_TITOLO_POSSESSO.ID_TITOLO_POSSESSO%TYPE:=5;
    -- lunghessa massima parametro VARCHAR2
    knMaxLengthVarchar2             CONSTANT INTEGER:=4000;
    -- identificativo parametro data dalla quale calcolare la P26 con uguaglianza a 4 decimali per la vite
    kvIdParamDataP26                CONSTANT DB_PARAMETRO.ID_PARAMETRO%TYPE:='DP26';
    -- identificativo parametro percentuale tolleranza
    kvIdParamPercP26                CONSTANT DB_PARAMETRO.ID_PARAMETRO%TYPE:='P26P';
    -- identificativo fonte controlli in loco pascolo magro
    knIdFontePMagroEffettivo        CONSTANT DB_TIPO_FONTE.ID_FONTE%TYPE:=4;
    -- identificativo fonte registro storico pascoli
    knIdFontePMagroDichiarativo     CONSTANT DB_TIPO_FONTE.ID_FONTE%TYPE:=5;
    -- codice tipo motivo dichiarazione correttiva
    kvCodTipoMotivoDichCorrettiva   CONSTANT DB_TIPO_MOTIVO_DICHIARAZIONE.TIPO_DICHIARAZIONE%TYPE:='C';
    -- identificativo tipo motivo dichiarazione siccità 2006
    knIdTipoMotivoDichSiccita2006   CONSTANT DB_TIPO_MOTIVO_DICHIARAZIONE.ID_MOTIVO_DICHIARAZIONE%TYPE:=7;
    -- identificativo parametro per reperimento tolleranza massima area u.v. rispetto parcella a vite
    kvCodParMaxTolleranzaUv         CONSTANT DB_PARAMETRO.ID_PARAMETRO%TYPE:='MTUV';
    -- identificativo parametro per reperimento percentuale da applicare alla tolleranza della parcella a vite
    kvCodParPercTolleranzaUv        CONSTANT DB_PARAMETRO.ID_PARAMETRO%TYPE:='PTUV';
    -- costante identificativo tipologia unar vite
    knIdTipologiaUnarVite           CONSTANT DB_TIPO_TIPOLOGIA_UNAR.ID_TIPOLOGIA_UNAR%TYPE:=2;
    -- costante identificativo eleggibilità fittizia vite
    knIdEleggibilitaFitVit          CONSTANT DB_TIPO_ELEGGIBILITA_FIT.ID_ELEGGIBILITA_FIT%TYPE:=26;
    -- costante identificativo eleggibilita coltivazione arborea specializzata
    knIdEleggibilitaColtArbSpec     CONSTANT DB_TIPO_ELEGGIBILITA.ID_ELEGGIBILITA%TYPE:=4;
    -- costante identificativo per documento di ISTANZA DI RIESAME
    knIDTipoDocumento               CONSTANT DB_TIPO_DOCUMENTO.ID_DOCUMENTO%TYPE:=283;
    -- costante per reperimento parametro metri tollaranza P26 vite
    kvCodParEttariTolleranzaP26UV   CONSTANT DB_PARAMETRO.ID_PARAMETRO%TYPE:='EVTL';
    -- costante per reperimento parametro metri tollaranza P26 vite
    kvCodParEttariTolleranzaP26Alt  CONSTANT DB_PARAMETRO.ID_PARAMETRO%TYPE:='EATL';
    -- costante per reperimento parametro percentualle tolleranza P26 vite
    kvCodParPercTolleranzaP26UV     CONSTANT DB_PARAMETRO.ID_PARAMETRO%TYPE:='VTOL';
    -- costante id_procedimento domanda unica di pagamento
    knIdProcedimentoRPU             CONSTANT DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE:=12;
    -- costante id_procedimento piano di sviluppo rurale
    knIdProcedimentoPSR             CONSTANT DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE:=2;
    -- costante identificativo stato richiesta azienda trasmessa
    knIdStatoRichAziendaTrasmessa   CONSTANT DB_STATO_RICHIESTA.ID_STATO_RICHIESTA%TYPE:=40;
    -- costante identificativo stato richiesta azienda validata da PA
    knIdStatoRichAziendaValPa       CONSTANT DB_STATO_RICHIESTA.ID_STATO_RICHIESTA%TYPE:=50;
    -- costante identificativo ruolo titolare / rappresentante legale
    knIdRuoloTitolareRapprLeg       CONSTANT DB_TIPO_RUOLO.ID_RUOLO%TYPE:=1;
    -- identificativo tipo richiesta aggiornamento azienda obsoleta
    knIdTipoRichiestaAggAzObsoleta  CONSTANT DB_TIPO_RICHIESTA.ID_TIPO_RICHIESTA%TYPE:=4;
    -- identificativo tipo documento mandato
    knIdTipoDocMandato              CONSTANT DB_TIPO_DOCUMENTO.ID_DOCUMENTO%TYPE:=16;
    -- istat regione PIEMONTE
    kvIdRegionePiemonte             CONSTANT REGIONE.ID_REGIONE%TYPE:='01';
    -- istat provincia TORINO
    kvIstatProvTorino               CONSTANT PROVINCIA.ISTAT_PROVINCIA%TYPE:='001';
    
    kvCodTipoIntermediario          CONSTANT DB_INTERMEDIARIO.TIPO_INTERMEDIARIO%TYPE:='C';

    -- tipo record contenente l'id_utilizzo_particella, la superficie utilizzata riproporzionata
    -- e la eventuale superficie utilizzata secondaria
    TYPE TypTipoUtilizzo IS RECORD
        (nIdUtilizzoParticella   DB_UTILIZZO_PARTICELLA.ID_UTILIZZO_PARTICELLA%TYPE,
         nIdConduzioneParticella DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE,
         nSupUtilizzaRipr        DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE,
         nSupUtilizzataSec       DB_UTILIZZO_PARTICELLA.SUP_UTILIZZATA_SECONDARIA%TYPE,
         vAllinea                DB_TIPO_MACRO_USO.ALLINEA_A_ELEGGIBILE%TYPE
         );

    -- Tipo vettore di tipo record  TypTipoUtilizzo
    TYPE VetTypTipoUtilizzo IS TABLE OF TypTipoUtilizzo INDEX BY PLS_INTEGER;

    -- tipo record contenente l'id_Particella, la superficie condotta ed un vettore di utilizzi particella
    TYPE TypTipoParticella IS RECORD
        (nIdParticella  DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE,
         nSupGrafica    DB_STORICO_PARTICELLA.SUPERFICIE_GRAFICA%TYPE,
         nTotSupRipr    DB_CONDUZIONE_PARTICELLA.SUPERFICIE_CONDOTTA%TYPE,
         nEsito         INTEGER,
         VetUtilizzi    VetTypTipoUtilizzo);
    -- tipo vettore di tipo record TypTipoParticella
    TYPE VetTypTipoParticella IS TABLE OF TypTipoParticella INDEX BY PLS_INTEGER;

    /*********************************************************************
    Ritorna il totale di superficie eleggibile a pascolo per la particella
    certificata fornita in input
    Tipo: function
    input: pIdPartCertif
    output: nessuno
    ritorno: nTotSupEleg
    *********************************************************************/
    FUNCTION SelTotSupElegPascoloByPart (pIdPartCertif  IN DB_PARTICELLA_CERT_ELEG.ID_PARTICELLA_CERTIFICATA%TYPE) RETURN DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;

    /*********************************************************************
    Ritorna il totale di superficie eleggibile per la particella per le varietà
    passate in input
    Tipo: function
    input: pIdPartCertif,pStrVetVarieta
    output: nessuno
    ritorno: nTotSupEleg
    *********************************************************************/
    FUNCTION SelTotSupElegByPartEVetVar (pIdPartCertif  IN DB_PARTICELLA_CERT_ELEG.ID_PARTICELLA_CERTIFICATA%TYPE,
                                         pStrVetVarieta IN VARCHAR2,
                                         pIdFonte       IN DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE DEFAULT -1
                                         ) RETURN DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;

  FUNCTION SelTotSupElegByPartEVetCat(pIdPartCertif       DB_PARTICELLA_CERT_ELEG.ID_PARTICELLA_CERTIFICATA%TYPE,
                                      pIdCatalogoMatrice  DB_R_CATALOGO_MATRICE.ID_CATALOGO_MATRICE%TYPE,
                                      pIdFonte            DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE DEFAULT -1) RETURN DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;

    /*********************************************************************
    Ritorna il totale di superficie eleggibile al netto della tara
    per la particella certificata e le varietà passate in input
    passate in input
    Tipo: function
    input: pIdPartCertif,pStrVetVarieta
    output: nessuno
    ritorno: nTotSupEleg
    *********************************************************************/
    FUNCTION SelTotSupElegByPartEVetVarNTar (pIdPartCertif  IN DB_PARTICELLA_CERT_ELEG.ID_PARTICELLA_CERTIFICATA%TYPE,
                                             pStrVetCatMatr IN VARCHAR2, 
                                             pIdFonte       IN DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE DEFAULT -1
                                             ) RETURN  DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;

    /*********************************************************************
    Dati ID_PARTICELLA, ID_AZIENDA, ID_PARTICELLA_CERTIFICATA ed ID_VARIETA
    ritorna la somma della superficie utilizzata sulla particella
    delle varietà compatibili (lato GIS) con quella in input (concatenando
    in una stringa di appoggio le varietà interessate)
    Tipo: function
    input: pIdAzienda,pIdParticella,pIdPartCertif,pIdVarieta,pInEsitoPascolo
    output: pStrVarieta
    ritorno: nTotSupUtilizzata
    *********************************************************************/
    FUNCTION SelTotSupUtilVarCompatibili (pIdAzienda          DB_UTE.ID_AZIENDA%TYPE,
                                          pIdParticella       DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE,
                                          pIdPartCertif       DB_PARTICELLA_CERT_ELEG.ID_PARTICELLA_CERTIFICATA%TYPE,
                                          pIdCatalogoMatrice  DB_UTILIZZO_PARTICELLA.ID_CATALOGO_MATRICE%TYPE,
                                          pStrCatMatr         OUT VARCHAR2 ) RETURN DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;

    /*********************************************************************
    Dato un identificativo azienda ed un identificativo particella
    ritorna la percentuale di possesso totale
    Tipo: function
    input: pIdAzienda, pIdParticella
    output: nessuno
    ritorno: nTotPercPossesso
    *********************************************************************/
    FUNCTION SelTotPercPossessoAziendaPart (pIdAzienda      IN DB_UTE.ID_AZIENDA%TYPE,
                                            pIdParticella   IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE
                                            ) RETURN DB_CONDUZIONE_PARTICELLA.PERCENTUALE_POSSESSO%TYPE;

    /*********************************************************************
    Dati in input un id_storico_particella verifica se la particella
    era in P25 (USO DEL SUOLO INCOMPLETO NELLA B.I. GRAFICA (GIS)) nel periodo
    passato in input (oppure se il periodo è a null guarda se è attualmente in P25)
    Tipo: funzione
    input: pIdStoricoParticella, pDataConfronto
    output: nessuno
    ritorno: 0 = No P25, 1 = P25 , NULL = Parametri mancanti / errore oracle
    *********************************************************************/
    FUNCTION Calcola_P25 (pIdStoricoParticella IN DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE,
                          pDataConfronto       IN DB_PARTICELLA_CERTIFICATA.DATA_INIZIO_VALIDITA%TYPE) RETURN NUMBER;

    /*********************************************************************
    Calcola l'anomalia P26 riferendosi ai dati presenti per l'azienda
    sul piano di lavorazione attuale ed eventualmente applicando la tolleranza
    espressa in percentuale e passata in input (0-100)
    Tipo: funzione
    input: pIdAzienda, pIdParticella, pIdPartCertif, pPercTolleranza
    output: nessuno
    ritorno: 0 = No P26, 1 = P26 , NULL = Parametri mancanti / errore oracle
    *********************************************************************/
    FUNCTION Calcola_P26_Con_Tolleranza(pIdAzienda      IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                                        pIdParticella   IN DB_PARTICELLA.ID_PARTICELLA%TYPE,
                                        pIdPartCertif   IN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE,
                                        pPercTolleranza IN NUMBER) RETURN NUMBER;

    /*********************************************************************
    Calcola l'anomalia P26 solamente sulla parte di particella
    compratibile con l'eleggibilita' a vite
    Tipo: funzione
    input: pIdAzienda, pIdParticella, pIdPartCertif, pPercTolleranza
    output: nessuno
    ritorno: 0 = No P26, 1 = P26 , NULL = Parametri mancanti / errore oracle
    *********************************************************************/
    FUNCTION Calcola_P26_UV_Con_Tolleranza(pIdAzienda      IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                                           pIdParticella   IN DB_PARTICELLA.ID_PARTICELLA%TYPE,
                                           pIdPartCertif   IN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE,
                                           pPercTolleranza IN NUMBER) RETURN NUMBER;

    /*********************************************************************
    Calcola l'anomalia P26 riferendosi ai dati presenti per l'azienda
    sul piano di lavorazione attuale
    Tipo: funzione
    input: pIdAzienda, pIdParticella, pIdPartCertif
    output: nessuno
    ritorno: 0 = No P26, 1 = P26 , NULL = Parametri mancanti / errore oracle
    *********************************************************************/
    FUNCTION Calcola_P26 (pIdAzienda    IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                          pIdParticella IN DB_PARTICELLA.ID_PARTICELLA%TYPE,
                          pIdPartCertif IN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE) RETURN NUMBER;

    /*********************************************************************
    Calcola l'anomalia P26 riferendosi ai dati presenti per l'azienda
    e sul piano della dichiarazione di consistenza data in input,
    eventualmente applicando la tolleranza espressa in percentuale e
    passata in input (0-100)
    Tipo: funzione
    input: pIdAzienda, pIdDichCons pIdParticella, pIdPartCertif, pPercTolleranza
    output: nessuno
    ritorno: 0 = No P26, 1 = P26 , NULL = Parametri mancanti / errore oracle
    *********************************************************************/
    FUNCTION Calcola_P26_Con_Tolleranza (pIdAzienda        IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                                         pIdDichCons       IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                         pIdParticella     IN DB_PARTICELLA.ID_PARTICELLA%TYPE,
                                         pidPartCertif     IN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE,
                                         pPercTolleranza   IN NUMBER) RETURN NUMBER;

    /*********************************************************************
    Calcola l'anomalia P26 riferendosi ai dati presenti per l'azienda
    e sul piano della dichiarazione di consistenza data in input
    Tipo: funzione
    input: pIdAzienda, pIdDichCons pIdParticella, pIdPartCertif
    output: nessuno
    ritorno: 0 = No P26, 1 = P26 , NULL = Parametri mancanti / errore oracle
    *********************************************************************/
    FUNCTION Calcola_P26 (pIdAzienda    IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                          pIdDichCons   IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                          pIdParticella IN DB_PARTICELLA.ID_PARTICELLA%TYPE,
                          pidPartCertif IN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE) RETURN NUMBER;

    /*********************************************************************
    Verifica se lo storico particella dato in input era in anomalia
    P30 (PARTICELLA SENZA RISCONTRO NELLA B.I. GRAFICA (GIS)) nel periodo
    dato in input (oppure se il periodo è a null guarda se è attualmente in P25)
    Tipo: funzione
    input: pIdStoricoParticella, pDataConfronto
    output: nessuno
    ritorno: 0 = No P30, 1 = P30 , NULL = Parametri mancanti / errore oracle
    *********************************************************************/
    FUNCTION Calcola_P30 (pIdStoricoParticella IN DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE,
                          pDataConfronto       IN DB_PARTICELLA_CERTIFICATA.DATA_INIZIO_VALIDITA%TYPE) RETURN NUMBER;

    /*********************************************************************
    Dati in input un azienda e le relative particella, particella certificata
    ed utilizzo particella ritorna la superficie eleggibile riproporzionata
    per l'utilizzo
    Tipo: funzione
    input: pIdAzienda, pIdParticella, pIdPartCertif , pIdUtilizzoPart
    output: nessuno
    ritorno: nSupRipr
            (null = parametri mancanti, -1 = errore oracle, Se >= 0 =superficie eleggibile riproporzionata)
    *********************************************************************/
    FUNCTION Sup_Eleggibile_Riproporzionata (pIdAzienda       IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                                             pIdParticella    IN DB_PARTICELLA.ID_PARTICELLA%TYPE,
                                             pIdPartCertif    IN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE,
                                             pIdUtilizzoPart  IN DB_UTILIZZO_PARTICELLA.ID_UTILIZZO_PARTICELLA%TYPE
                                             ) RETURN DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;

    /*********************************************************************
    Dati in input un azienda, un id_dichiarazione consistenza e le relative particella,
    particella certificata ed utilizzo dichiarato ritorna la superficie
    eleggibile riproporzionata per l'utilizzo
    Tipo: funzione
    input: pIdAzienda, pIdDichCons, pIdParticella, pIdPartCertif , pIdUtilizzoDich
    output: nessuno
    ritorno: nSupRipr
            (null = parametri mancanti, -1 = errore oracle, Se >= 0 =superficie eleggibile riproporzionata)
    *********************************************************************/
    FUNCTION Sup_Eleggibile_Riproporzionata (pIdAzienda       IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                                             pIdDichCons      IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                             pIdParticella    IN DB_PARTICELLA.ID_PARTICELLA%TYPE,
                                             pIdPartCertif    IN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE,
                                             pIdUtilizzoDich  IN DB_UTILIZZO_DICHIARATO.ID_UTILIZZO_DICHIARATO%TYPE
                                             ) RETURN DB_UTILIZZO_DICHIARATO.SUPERFICIE_UTILIZZATA%TYPE;

    /*********************************************************************
    Effettua l'eventuale aggiornamento della superficie utilizzata per gli
    usi del suolo dell'azienda data in input se fanno parte di quelli relativi
    ai macro usi col flag ALLINEA_A_ELEGGIBILE ad 'S', se sono in P26 e
    se la superficie eleggibile è calcolabile e maggiore di zero
    Tipo: procedure
    input: pIdAzienda , pIdUtenteAgg
    output: pResult --> 0 = Elaborazione OK (COMMITTARE Da Java)
                    --> 1 = Elaborazione KO (ROLLBACKARE Da Java)
                    --> 2 = Elaborazione OK ma con anomalie (COMMITTARE Da Java)
            pMsg    --> Messaggio di errore bloccate se pResult = 1
                        Messaggio/i di anomalia concatenati nel seguente modo :
                        ID_PARTICELLA;MESSAGGIO|ID_PARTICELLA;MESSAGGIO|ETC
                        se pResult = 2
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE Allinea_Sup_Utilizzata (pIdAzienda    IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                      pIdUtenteAgg  IN DB_UTILIZZO_PARTICELLA.ID_UTENTE_AGGIORNAMENTO%TYPE,
                                      pResult      OUT VARCHAR2,
                                      pMsg         OUT VARCHAR2);


     /*********************************************************************
    Dati un codice fotografia terreni , una data di inserimento dichiarazione,
    un identificativo particella ed un identificativo varieta somma la superficie
    eleggibile eventualmente presente su DB_ELEGGIBILITA_DICHIARATA e la ritorna in output
    Tipo: function
    input: pCodiceFoto, pDataInsDich ,pIdParticella, pIdCatalogoMatrice
    output: nessuno
    ritorno: nTotSupEleg
    *********************************************************************/
    FUNCTION SelSupElegDichByFotoIdPartVar (pCodiceFoto      IN DB_ELEGGIBILITA_DICHIARATA.CODICE_FOTOGRAFIA_TERRENI%TYPE,
                                            pDataInsDich     IN DB_DICHIARAZIONE_CONSISTENZA.DATA_INSERIMENTO_DICHIARAZIONE%TYPE,
                                            pIdParticella    IN DB_ELEGGIBILITA_DICHIARATA.ID_PARTICELLA%TYPE,
                                            pIdCatalogoMatrice  DB_VARIETA_ELEGGIBILITA.ID_CATALOGO_MATRICE%TYPE
                                             ) RETURN DB_ELEGGIBILITA_DICHIARATA.SUPERFICIE%TYPE;

    /*********************************************************************
    Dati un codice fotografia terreni , una data di inserimento dichiarazione,
    un identificativo particella ed un identificativo varieta somma la superficie
    eleggibile eventualmente presente su DB_ELEGGIBILITA_DICHIARATA al netto
    della tara e la ritorna in output
    Tipo: function
    input: pCodiceFoto, pDataInsDich ,pIdParticella, pIdCatalogoMatrice
    output: nessuno
    ritorno: nTotSupEleg
    *********************************************************************/
    FUNCTION SelSupElegDichByFtIdPartVarNT (pCodiceFoto      IN DB_ELEGGIBILITA_DICHIARATA.CODICE_FOTOGRAFIA_TERRENI%TYPE,
                                            pDataInsDich     IN DB_DICHIARAZIONE_CONSISTENZA.DATA_INSERIMENTO_DICHIARAZIONE%TYPE,
                                            pIdParticella    IN DB_ELEGGIBILITA_DICHIARATA.ID_PARTICELLA%TYPE,
                                            pIdCatalogoMatrice  DB_VARIETA_ELEGGIBILITA.ID_CATALOGO_MATRICE%TYPE
                                            ) RETURN DB_ELEGGIBILITA_DICHIARATA.SUPERFICIE%TYPE;

    /********************************************************************************
    Descrizione:  CercaIstanzaRiesame
                  Restituisce l'esistenza e/o lo stato di una eventuale richiesta
                  di isanza di riesame.

    Tipo:         Function;
    Input:        pAnnoCampagna    IN DB_ISTANZA_RIESAME.ANNO%TYPE,
                  pIdAzienda       IN DB_ISTANZA_RIESAME.ID_AZIENDA%TYPE
                  pIdParticella    IN DB_ISTANZA_RIESAME.ID_PARTICELLA%TYPE

    Return:       INTEGER;
                 - 0 = non è stata richiesta alcuna istanza di riesame per la particella
                 - 1 = E' stata richiesta un'istanza di riesame per la particella
                 - 2 = l'isanza di riesame per la particella è gia stata lavorata dal GIS;
    *********************************************************************************/
    FUNCTION CercaIstanzaRiesame( pAnnoCampagna    IN DB_ISTANZA_RIESAME.ANNO%TYPE,
                                  pIdAzienda       IN DB_ISTANZA_RIESAME.ID_AZIENDA%TYPE,
                                  pIdParticella    IN DB_ISTANZA_RIESAME.ID_PARTICELLA%TYPE
                                ) RETURN INTEGER;


    /*********************************************************************
    Effettua il ribaltamento dei dati dell'azienda in proprio provvisori
    sulle tabelle effettive
    Tipo: Procedure
    input: pIdRichAzienda
    output: pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE Ribalta_Azienda (pIdRichAzienda    IN DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                               pRisultato       OUT VARCHAR2,
                               pMessaggio       OUT VARCHAR2
                               );

    /*********************************************************************
    Dato in input un cuaa ne ritorna le storicizzazione / subentri
    avvenute su DB_ANAGRAFICA_AZIENDA e/o su DB_AZIENDA_TRIBUTARIA
    Tipo: function
    input: pCuaa
    output: nessuno
    ritorno: typVetRecStatoCuaa
    *********************************************************************/
    FUNCTION VerificaStatoCuaa (pCuaa IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE) RETURN typVetRecStatoCuaa;

    /********************************************************************************
    Descrizione:  trovaNotificaEntitaByIdentif
    Tipo:         Function
    Input:        pIdAzienda

                     pCodEntita
                        Codice dell'entita' per cui sto cercando notifiche attive.

                     pIdentificativo
                        Id del campo chiave/identificativo utilizzato per cercare l'entita' sulla tabella che la contiene
                        (es. id_particella,id_unita_arborea...ecc)

                     pTipoIdentificativo
                        Tipo di chiave utilizzata: mi dice quindi la natura della chiave/identificativo che sto passando
                        (es. P = id_particella, U = id_unita_arborea...ecc)

                    pIdTipolNotifica                                                                --> RENDERE NON OBBLIGATORIO??!!
                        Id Tipologia di Notifica: vitivinicolo, warning...ecc

    N.B. quindi potrei ad esempio cercare le notifiche esistenti per le unita' arboree passando come
            chiave/identificativo l' id_unita_arborea o anche l'id_particella


    Return:       INTEGER;
                     -    1 = esiste notifica
                     -    0 = non è presente notifica
                     -   -1 = parametri in input non valorizzati
                     -   -2 = codice entita' non trovato su DB_TIPO_ENTITA
                     - NULL = parametri mancanti/errore oracle
    *********************************************************************************/
    FUNCTION trovaNotificaEntitaByIdentif(pIdAzienda           DB_AZIENDA.ID_AZIENDA%TYPE,
                                          pCodEntita           DB_TIPO_ENTITA.CODICE_TIPO_ENTITA%TYPE,
                                          pIdentificativo      DB_NOTIFICA_ENTITA.IDENTIFICATIVO%TYPE,
                                          pTipoIdentificativo  VARCHAR2,
                                          pIdTipolNotifica     DB_TIPO_TIPOLOGIA_NOTIFICA.ID_TIPOLOGIA_NOTIFICA%TYPE,
                                          pAnnoNotifica        NUMBER,
                                          pNotificaAttiva      NUMBER) RETURN INTEGER;

/*******************************************************************************
 NAME: FncIsParticallaPA
 PURPOSE: Segnala se una particella appartiene alla pubblica amministrazione
          verificando che nella denominazione del proprietario siano presenti
          determinate stringhe parametrizzate.
 Parametri:
        input: Id della particella della tabella DB_PARTICELLA
        Output: nessuno
        Valore di ritorno: 1 se la condizione è verifica 0 altrimenti
 
 *******************************************************************************/


      FUNCTION FncIsParticallaPA   (pIdParticella     IN   DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA%TYPE
                                                        ) RETURN INTEGER;

      FUNCTION RibaltaTIntermediario (pIdRichAzienda      IN DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                                     pIdAzienda          IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                     pRisultato         OUT VARCHAR2,
                                     pMessaggio         OUT VARCHAR2
                                      ) RETURN DB_INTERMEDIARIO%ROWTYPE;

      PROCEDURE RibaltaSoggCollegati (pIdRichAzienda      IN DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                                   pIdAzienda          IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                   pRisultato         OUT VARCHAR2,
                                   pMessaggio         OUT VARCHAR2
                                   );

      PROCEDURE RibaltaAziendeAssociate  (pIdRichAzienda      IN DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                               pIdAzienda          IN DB_AZIENDA.ID_AZIENDA%TYPE,
                               pRisultato         OUT VARCHAR2,
                               pMessaggio         OUT VARCHAR2
                               ) ;

  FUNCTION getListIdPraticaMantenimento(pIdCatalogoMatrice  DB_R_CATALOGO_MATRICE.ID_CATALOGO_MATRICE%TYPE,
                                        pFlagDefault        VARCHAR2 DEFAULT NULL) RETURN TYPVETRECPRATMANT;

  -- permette di inserire un vincolo su un conto corrente passato in input, rendendolo esclusivo rispetto
  -- alla pratica che pone il vincolo su di esso
  PROCEDURE vincoloContoCorrente(pIdAzienda                         DB_AZIENDA.ID_AZIENDA%TYPE,
                                 pIdContoCorrente                   DB_CONTO_CORRENTE.ID_CONTO_CORRENTE%TYPE,
                                 pIdProcedimentoVincolo             DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE,
                                 pIdPraticaVincolo                  DB_CONTO_CORRENTE_VINCOLO.EXT_ID_PRATICA_VINCOLO%TYPE,
                                 pIdentificativoPraticaVincolo      DB_CONTO_CORRENTE_VINCOLO.IDENTIFICATIVO_PRATICA_VINCOLO%TYPE,
                                 pRisultato                     OUT VARCHAR2,
                                 pMessaggio                     OUT VARCHAR2);

  -- permette di rimuovere il vincolo su un conto corrente passato in input, fornendone una motivazione
  PROCEDURE svincoloContoCorrente(pIdAzienda                DB_AZIENDA.ID_AZIENDA%TYPE,
                                  pIdContoCorrente          DB_CONTO_CORRENTE.ID_CONTO_CORRENTE%TYPE,
                                  pMotivazioneSvincolo      VARCHAR2,
                                  pRisultato            OUT VARCHAR2,
                                  pMessaggio            OUT VARCHAR2);

END Pck_Smrgaa_Libreria;

/
--------------------------------------------------------
--  DDL for Package PCK_SMRGAA_LOG
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_SMRGAA_LOG" AS
/**********************************************************************************
Libreria di gestione dei Log per le procedure Batch di SMRGAA
**********************************************************************************/

    kLevelDebug          CONSTANT NUMBER := 1; -- livello visualizzazione debug
    kLevelInfo           CONSTANT NUMBER := 5; -- livello visualizzazione info
    kLevelAnomalia       CONSTANT NUMBER := 7; -- livello visualizzazione anomalia
    kLevelError          CONSTANT NUMBER := 9; -- livello visualizzazione error

    kvLevelDebug         CONSTANT VARCHAR2(5):='DEBUG';
    kvLevelInfo          CONSTANT VARCHAR2(4):='INFO';
    kvLevelAnomalia      CONSTANT VARCHAR2(8):='ANOMALIA';
    kvLevelError         CONSTANT VARCHAR2(5):='ERROR';
    -- identificativo applicazione del batch di svecchiamento delle esecuzioni e relativi log
    knIdApplSvecchiaEsecuzioni  CONSTANT NUMBER(2):=17;
    kvCodParDataLimite          CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='RPAIDE01';
    kvCodParIdApplSvecch        CONSTANT SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE:='RPAIDE02';


    nLevel NUMBER := 0;
    nBatch NUMBER := 0;
    vStep  VARCHAR2(30);

    nIdEsecuzione     SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE;
    -- tipo record per parametro in input
    -- tipo_param = 'S' = VARCHAR2 , 'D' = DATE , 'N' = NUMBER
    TYPE TypTipoParametr IS RECORD
        (TIPO_PARAM     SMRGAA_R_PARAM_APPLICAZIONE.TIPO_PARAMETRO%TYPE,
         VAL_VARCHAR2   SMRGAA_R_PARAM_APPLICAZIONE.VALORE_VARCHAR2%TYPE,
         VAL_DATE       SMRGAA_R_PARAM_APPLICAZIONE.VALORE_DATE%TYPE,
         VAL_NUMBER     SMRGAA_R_PARAM_APPLICAZIONE.VALORE_NUMBER%TYPE
         );

    -- Tipo vettore di tipo record  TypTipoParametr
    TYPE VetTypTipoParametr IS TABLE OF TypTipoParametr INDEX BY BINARY_INTEGER;

    -- tipo record composto da un vettore VetTypTipoParametr più il singolo record
    TYPE TypTipoParametriApplicazione IS RECORD
        (TIPO_PARAM     SMRGAA_R_PARAM_APPLICAZIONE.TIPO_PARAMETRO%TYPE,
         VAL_VARCHAR2   SMRGAA_R_PARAM_APPLICAZIONE.VALORE_VARCHAR2%TYPE,
         VAL_DATE       SMRGAA_R_PARAM_APPLICAZIONE.VALORE_DATE%TYPE,
         VAL_NUMBER     SMRGAA_R_PARAM_APPLICAZIONE.VALORE_NUMBER%TYPE,
         VETTORE        VetTypTipoParametr
         );
    -- tipo vettore di TypTipoParametriApplicazione
    TYPE TypVetParametriApplicazione IS TABLE OF TypTipoParametriApplicazione INDEX BY VARCHAR2(10);

    /*********************************************************************
    Preleva l'ultimo record in ordine di DT_INIZIO_ESECUZIONE da SMRGAA_T_ESECUZIONE_BATCH
    in base ad un ID_APPLICAZIONE
    Tipo:     funzione esterna
    input:   pIdApplicazione
    output:  nessuno
    ritorno: SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE o NULL
    *********************************************************************/
    FUNCTION SelectTLastEsecuzione(pIdApplicazione SMRGAA_T_ESECUZIONE_BATCH.ID_APPLICAZIONE%TYPE) RETURN SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE;

    /*********************************************************************
    Preleva l'ultimo record in ordine di DT_INIZIO_ESECUZIONE da SMRGAA_T_ESECUZIONE_BATCH
    in base ad un ID_APPLICAZIONE che però abbia avuto esito = 0 (OK)
    Tipo:     funzione esterna
    input:   pIdApplicazione
    output:  nessuno
    ritorno: SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE o NULL
    *********************************************************************/
    FUNCTION SelectTLastEsecuzioneOK(pIdApplicazione SMRGAA_T_ESECUZIONE_BATCH.ID_APPLICAZIONE%TYPE) RETURN SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE;

    /*********************************************************************
    Preleva un record da SMRGAA_T_ESECUZIONE_BATCH in base ad un ID_APPLICAZIONE ed
    una data di riferimento prendendo un range massimo di 13 ora
    Tipo:     funzione esterna
    input:   pIdApplicazione , pDtRiferimento
    output:  nessuno
    ritorno: TRUE = Verifiche OK, FALSE = Verifiche KO
    *********************************************************************/
    FUNCTION SelectTEsecuzione(pIdApplicazione SMRGAA_T_ESECUZIONE_BATCH.ID_APPLICAZIONE%TYPE,
                                pDtRiferimento  SMRGAA_T_ESECUZIONE_BATCH.DT_INIZIO_ESECUZIONE%TYPE) RETURN SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE;

    /*********************************************************************
    Verifica se i batch da cui dipende quello corrente sono stati eseguiti in data SYSDATE
    Tipo:     funzione esterna
    input:   pIdApplicazione
    output:  nessuno
    ritorno: TRUE = Verifiche OK, FALSE = Verifiche KO
    *********************************************************************/
    FUNCTION VerificaDipendenzeBatch (pIdApplicazione SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE) RETURN BOOLEAN;

    /*********************************************************************
    Verifica di attivazione del BATCH
    Tipo:     funzione esterna
    input:   id_applicazione
    output:  pRecApplicazione
    ritorno: 0 Batch attivo, 1 Errore Oracle, 2 Batch non attivo, 3 dipendenze batch non verificate
    *********************************************************************/
    FUNCTION VerificaAttivazioneBatch( pIdApplicazione  IN  SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE,
                                       pRecApplicazione OUT SMRGAA_D_APPLICAZIONI_BATCH%ROWTYPE ) RETURN NUMBER;

    /*********************************************************************
    Inserimento nella tabella SMRGAA_T_ESECUZIONE_BATCH
    Tipo:    procedura esterna
    input:  pIdApplicazione
    output:  pIdEsecuzione
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTEsecuzione( pIdApplicazione IN SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE,
                                  pIdEsecuzione     OUT SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE );

    /*********************************************************************
    Inserimento nella tabella SMRGAA_R_SORICO_DATI
    Tipo:    procedura esterna
    input: pIdEsecuzione, pNomeFile, pDescrizione
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertRStoricoDati( pIdEsecuzione     IN SMRGAA_R_STORICODATI.ID_ESECUZIONE%TYPE,
                                   pNomeFile            IN SMRGAA_R_STORICODATI.NOME_FILE%TYPE,
                                  pDescrizioneDati  IN SMRGAA_R_STORICODATI.DESCRIZIONE_DATI%TYPE );

    /*********************************************************************
    Setta il livello di Log corrente
    Tipo:    procedura esterna
    Input:     livello di log (vedi costanti sopra)
    Output: nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE SetLogLevel( pLevel NUMBER );

    /*********************************************************************
    Inizializza il nome del batch (id applicazione) e lo step corrente
    Tipo:    procedura esterna
    Input:     id del batch, nome dello step
    Output: nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE Init( pBatch NUMBER, pStep VARCHAR2 );

    /*********************************************************************
    Scrive nel log un messaggio di debug
    Tipo:    procedura esterna
    Input:    messaggio da loggare
    Output:    nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE LogDebug( pMessage VARCHAR2 );

    /*********************************************************************
    Scrive nel log un messaggio di informazione
    Tipo:    procedura esterna
    Input:    messaggio da loggare
    Output:    nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE LogInfo( pMessage VARCHAR2 );

    /*********************************************************************
    Scrive nel log un messaggio di anomalia
    Tipo:    procedura esterna
    Input:    messaggio da loggare
    Output:    nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE LogAnomalia( pMessage VARCHAR2 );

    /*********************************************************************
    Scrive nel log un messaggio di errore
    Tipo:    procedura esterna
    Input:    messaggio da loggare
    Output:    nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE LogError( pMessage VARCHAR2 );

    /*********************************************************************
    Scrive nel log un messaggio di errore con SQLCODE e SQLERRM
    Tipo:    procedura esterna
    Input:    messaggio da loggare
    Output:    nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE LogSqlError( pMessage VARCHAR2 );

    /*********************************************************************
    Svuota la tabella SMRGAA_L_LOG_BATCH
    Tipo:    procedura esterna
    Input:     nessuno
    Output: nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE ClearAllLog;

    /***************************************************************************
    ScriviFileEsecuzione
    Tipo: procedura esterna
    Input : pFileBatchEsecuzione, pPathFileDB, pIdEsecuzione
    Output:    nessuno
    Return:    nessuno
    ***************************************************************************/
    PROCEDURE ScriviFileEsecuzione ( pFileBatchEsecuzione IN VARCHAR2,
                                          pPathFileDB          IN VARCHAR2,
                                        pIdEsecuzione         IN NUMBER );

    /***************************************************************************
    LeggiFileEsecuzione
    Tipo: procedura esterna
    Output:    nessuno
    Return:    nessuno
    ***************************************************************************/
    PROCEDURE LeggiFileEsecuzione ( pFileBatchEsecuzione IN VARCHAR2,
                                       pPathFileDB              IN VARCHAR2 );

    /*********************************************************************
    Aggiorna a zero l'esito di un'esecuzione di batch censita su SMRGAA_T_ESECUZIONE_BATCH
    Tipo:    funzione interna
    Input:    pLevel, pFileBatchEsecuzione, pPathFileDb
    Output:    nessuno
    Return:    0 = OK , 1 = KO
    *********************************************************************/
    FUNCTION ValorizzaEsitoBatch(pLevel               IN NUMBER,
                                   pFileBatchEsecuzione IN VARCHAR2,
                                 pPathFileDB           IN VARCHAR2) RETURN NUMBER;

    /*********************************************************************
    Dato un pIdEsecuzione ritorna l'esito del BATCH eseguito (0 = OK , <> 0 = KO)
    Tipo:    funzione interna
    Input:    pIdEsecuzione
    Output:    nessuno
    Return:    0 = OK , 1 = KO
    *********************************************************************/
    FUNCTION EsecuzioneOk(pIdEsecuzione IN NUMBER) RETURN NUMBER;


    /*********************************************************************
    Aggiorna a zero l'esito di un'esecuzione di batch censita su SMRGAA_T_ESECUZIONE_BATCH
    da richiamare per shell con un solo step PL/SQL
    Tipo:    procedure
    Input:    nessuno
    Output:    nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE ValorizzaEsitoBatch;

    /*********************************************************************
    Dato un id_applicazione ritorna il vettore di parametri che servono
    al batch per operare
    Tipo:    procedure
    Input:    pIdApplicazione
    Output:    nessuno
    Return:    TypVetParametriApplicazione
    *********************************************************************/
    FUNCTION CaricaParametriApplicazione (pIdApplicazione IN SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE) RETURN TypVetParametriApplicazione;

    /*********************************************************************
    Dato un id_applicazione ed un codice parametro elimina quest'ultimo
    dai parametri dell'applicazione
    Tipo:    procedure
    Input:    pIdApplicazione
    Output:    nessuno
    Return:    TypVetParametriApplicazione
    *********************************************************************/
    PROCEDURE EliminaParametroApplicazione (pIdApplicazione IN SMRGAA_R_PARAM_APPLICAZIONE.ID_APPLICAZIONE%TYPE,
                                            pCodParametro   IN SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE);

    /*********************************************************************
    Dato un id_applicazione storicizza i parametri di esecuzione su SMRGAA_T_ESECUZIONE_PARAMETRO
    e li cancella
    Tipo:    procedure
    Input:    pIdApplicazione
    Output:    nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE StoricizzaParametri (pIDApplicazione IN SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE);

    /*********************************************************************
    Reperisce i due parametri che contengono rispettivamente
    la data fino a cui svecchiare le esecuzioni e l'eventuale id_applicazione
    (facoltativo) e cancella da SMRGAA_T_ESECUZIONE e figlie i record ad essi
    relativi, poi effettua la riorganizzazione delle tabelle svecchiate e dei
    relativi indici
    Tipo:    funzione
    input:    nessuno
    output: nessuno
    ritorno: 0 OK, 1 KO
    *********************************************************************/
    FUNCTION SvecchiamentoEsecuzioni RETURN NUMBER;

    /*********************************************************************
    Data una stringa SQL in input la esegue tramite EXECUTE IMMEDIATE
    Tipo:  funzione
    input: pSqlStr
    output: nessuno
    ritorno: 0 OK, 1 KO
    *********************************************************************/
    FUNCTION EseguiComandoSql (pSqlStr IN VARCHAR2) RETURN INTEGER;

END Pck_Smrgaa_Log;

/
--------------------------------------------------------
--  DDL for Package PCK_UTILITY_FILE
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_UTILITY_FILE" IS
 ---------------
-- File Open --
---------------
FUNCTION FileOpen
(
 pFilePath      VARCHAR2,
 pFileName      VARCHAR2,
 pOpenMode       VARCHAR2 := 'w',
 pLngRiga            NUMBER DEFAULT 1500
)
RETURN UTL_FILE.FILE_TYPE;

---------------
-- File Read --
---------------
PROCEDURE FileRead
(
 PFILE   IN UTL_FILE.FILE_TYPE,
 pStr    OUT VARCHAR2
);

----------------
-- File Close --
----------------
PROCEDURE FileClose
(
 PFILE   IN OUT UTL_FILE.FILE_TYPE
);

---------------
-- FileWrite --
---------------
PROCEDURE FileWrite
(
 PFILE   IN OUT UTL_FILE.FILE_TYPE,
 pStr    IN VARCHAR2
);
-------------------
-- ControllaData --
-------------------

FUNCTION ControllaData
(
 pVal    VARCHAR2
)
RETURN BOOLEAN ;

--------------
-- IsNumber --
--------------

FUNCTION IsNumber
(
  pVal    VARCHAR2,
  pDec    BOOLEAN := FALSE   -- se TRUE accetta anche i decimali
)
RETURN BOOLEAN;

------------
-- IsNull --
------------

FUNCTION IsNull
(
 pVal    VARCHAR2
)
 RETURN BOOLEAN;

 --    kPathLog          VARCHAR2(50) := '/svil/apps/tau_uni/PLSQL/log'; --'/home/tributi/LUNEL/procedura/log';--srp/medici/log';--'/home/farma_svi/codifa/log';
--    kFile            VARCHAR2(5) := 'SOL1-';


FUNCTION Check_Codfisc (prmCodFisc VARCHAR2) RETURN BOOLEAN;

/******************************************************************************
   NAME:       Servizio
   PURPOSE:    To calculate the desired information.

   REVISIONS:
   Ver        Date        Author           Description
   ---------  ----------  ---------------  ------------------------------------
   1.0        09/09/02             1. Created this package.

   PARAMETERS:
   INPUT:
   OUTPUT:
   RETURNED VALUE:
   CALLED BY:
   CALLS:
   EXAMPLE USE:     NUMBER := Servizio.MyFuncName(Number);
                    Servizio.MyProcName(Number, Varchar2);
   ASSUMPTIONS:
   LIMITATIONS:
   ALGORITHM:
   NOTES:

   Here is the complete list of available Auto Replace Keywords:
      Object Name:     Servizio or Servizio
      Sysdate:         09/09/02
      Date/Time:       09/09/02 11.19.56
      Date:            09/09/02
      Time:            11.19.56
      Username:         (set in TOAD Options, Procedure Editor)
      Trigger Options: %TriggerOpts%
******************************************************************************/
END Pck_Utility_File;

/
--------------------------------------------------------
--  DDL for Package PCK_UTL_OBFUSCATION
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_UTL_OBFUSCATION" IS


FUNCTION FNC_ENCRYPT (    input_string     IN VARCHAR2,
                                pkey                IN    VARCHAR2    ) RETURN VARCHAR2;

FUNCTION FNC_DECRYPT (    input_string     IN VARCHAR2,
                                pkey                IN VARCHAR2    ) RETURN VARCHAR2;


END Pck_Utl_Obfuscation;

/
--------------------------------------------------------
--  DDL for Package PCK_UTL_OBJ
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_UTL_OBJ" IS

    FUNCTION TABLE_CUAA_COLL_SQL ( pCuaa  IN VARCHAR2,    pCuaaRet    IN VARCHAR2 DEFAULT NULL ) RETURN TYPCOLL_CUAA_REL;

    FUNCTION TABLE_CUAA_COLL_JAVA ( pCuaa  IN VARCHAR2, pCuaaRet    IN VARCHAR2 DEFAULT NULL ) RETURN TYPCOLL_CUAA_REL PIPELINED;

    FUNCTION TABLE_CUAA_AZIENDE_COLLEGATE_J ( pCuaa  IN VARCHAR2 ) RETURN TYPCOLL_CUAA_AZ PIPELINED;

    FUNCTION TABLE_CUAA_AZIENDE_COLLEGATE_S ( pCuaa  IN VARCHAR2 ) RETURN TYPCOLL_CUAA_AZ;

END Pck_Utl_Obj;

/
--------------------------------------------------------
--  DDL for Package PCK_VARIAZIONI_AZIENDALI
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE "SMRGAA"."PCK_VARIAZIONI_AZIENDALI" IS


    CURSOR CUR_AZI ( ParDataRif IN DATE ) IS
        SELECT     ANAX.CUAA                                    CUAA,
                    ANAX.SEDELEG_COMUNE                        SEDELEG_COMUNE,
                    ANAX.SEDELEG_INDIRIZZO                    SEDELEG_INDIRIZZO,
                    ANAX.SEDELEG_CAP                            SEDELEG_CAP,
                    ANAX.DATA_CESSAZIONE                        DATA_CESSAZIONE,
                    ANAX.ID_AZIENDA                            ID_AZIENDA,
                    ANAX.DATA_INIZIO_VALIDITA                DATA_INIZIO_VALIDITA,
                     CON.ID_SOGGETTO                            ID_SOGGETTO,
                    DIC.CODICE_FOTOGRAFIA_TERRENI            CODICE_FOTOGRAFIA_TERRENI,
                    DIC.FLAG_VARIAZIONE_VERIFICATA        FLAG_VARIAZIONE_VERIFICATA,
                    DIC.ID_DICHIARAZIONE_CONSISTENZA        ID_DICHIARAZIONE_CONSISTENZA,
                    DATA_INIZIO_RUOLO                            DATA_INIZIO_RUOLO,
                    DATA                                            DATA
        FROM     DB_ANAGRAFICA_AZIENDA            ANA,
                DB_DICHIARAZIONE_CONSISTENZA    DIC,
                DB_TIPO_MOTIVO_DICHIARAZIONE    MOT,
                DB_ANAGRAFICA_AZIENDA            ANAX,
                DB_CONTITOLARE                        CON
        WHERE ANA.DATA_FINE_VALIDITA                 IS    NULL
        AND    ANA.ID_AZIENDA                             =    DIC.ID_AZIENDA
--        AND    DIC.FLAG_VARIAZIONE_VERIFICATA        =    'N'
        AND    MOT.ID_MOTIVO_DICHIARAZIONE            =    DIC.ID_MOTIVO_DICHIARAZIONE
        AND    MOT.TIPO_DICHIARAZIONE                    !=    'C'
        AND    DIC.ID_MOTIVO_DICHIARAZIONE            !=    7
        AND    ANAX.ID_AZIENDA                             =    DIC.ID_AZIENDA
        AND    ANAX.DATA_INIZIO_VALIDITA                 <= DIC.DATA_INSERIMENTO_DICHIARAZIONE
        AND    NVL(ANAX.DATA_FINE_VALIDITA,(DIC.DATA_INSERIMENTO_DICHIARAZIONE + 1))        >     DIC.DATA_INSERIMENTO_DICHIARAZIONE
        AND    CON.ID_AZIENDA                                =     DIC.ID_AZIENDA
        AND    CON.DATA_INIZIO_RUOLO                    <= DIC.DATA_INSERIMENTO_DICHIARAZIONE
        AND    NVL(CON.DATA_FINE_RUOLO,(DIC.DATA_INSERIMENTO_DICHIARAZIONE + 1))                >     DIC.DATA_INSERIMENTO_DICHIARAZIONE
        AND    CON.ID_RUOLO                                = 1
        AND    DIC.DATA_INSERIMENTO_DICHIARAZIONE    >    ParDataRif
        AND    DIC.NUMERO_PROTOCOLLO    IS NOT NULL    -- BM001
        ORDER BY ANAX.ID_AZIENDA,DIC.DATA_INSERIMENTO_DICHIARAZIONE DESC;


   FUNCTION MAIN RETURN NUMBER;


END Pck_Variazioni_Aziendali;

/
--------------------------------------------------------
--  DDL for Package Body CABAAD778_PS_WP
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."CABAAD778_PS_WP" AS

  TYPE IntByIntMap     IS TABLE OF PLS_INTEGER INDEX BY PLS_INTEGER;
  TYPE BoolByStringMap IS TABLE OF BOOLEAN INDEX BY VARCHAR2(30);
  TYPE BoolByIntMap    IS TABLE OF BOOLEAN INDEX BY PLS_INTEGER;
  TYPE strings_sets    IS TABLE OF ORA_MINING_VARCHAR2_NT;

  TYPE CombDisposizioniFrazionate IS RECORD(abbinamenti        superfici_utilizzi_gis_tab,
                                            supUtilMancante    PLS_INTEGER,
                                            supUtilAssenti     PLS_INTEGER,
                                            supPoliAssenti     PLS_INTEGER,
                                            utilFrazionati     IntByIntMap,
                                            poliFrazionati     IntByIntMap,
                                            totTolleranza      NUMBER,
                                            numPoliFrazionati  PLS_INTEGER,
                                            numAbbinamenti     PLS_INTEGER);

  TYPE ContestoAssegnazioni IS RECORD(deusIds           ORA_MINING_NUMBER_NT,
                                      poliIds           ORA_MINING_NUMBER_NT,
                                      superfDeus        ORA_MINING_NUMBER_NT,
                                      superfPoli        ORA_MINING_NUMBER_NT,
                                      tipiDeus          ORA_MINING_VARCHAR2_NT,
                                      tipiPoli          ORA_MINING_VARCHAR2_NT,
                                      compatibilita     ORA_MINING_VARCHAR2_NT,
                                      numDeus           NUMBER,
                                      numPoli           NUMBER,
                                      currAssegnazione  CombDisposizioniFrazionate,
                                      bestAssegnazione  CombDisposizioniFrazionate,
                                      configsOK         BoolByStringMap,
                                      spazioDeus        ORA_MINING_NUMBER_NT,
                                      spazioPoli        ORA_MINING_NUMBER_NT,
                                      tolleranza        NUMBER,
                                      maxCombs          PLS_INTEGER,
                                      modoSaturazione   BOOLEAN);

  TYPE stringQueue IS RECORD(startIdx  PLS_INTEGER,
                             stopIdx   PLS_INTEGER,
                             elements  ORA_MINING_VARCHAR2_NT);

  TYPE TuplaTipiDeusPoli IS RECORD(deus  VARCHAR2(100),
                                   poli  VARCHAR2(100));

  TYPE TabTipiDeusPoli IS TABLE OF TuplaTipiDeusPoli;

  TYPE StringsSetsByStringMap IS TABLE OF ORA_MINING_VARCHAR2_NT INDEX BY varchar2(100);

-- funzione che richiama la classe java datiSuoloPerPianoGrafico
/*FUNCTION datiSuoloPerPianoGrafico(pIstatComune  VARCHAR2,
                                  pSezione      VARCHAR2,
                                  pFoglio       NUMBER,
                                  pParticella   NUMBER) RETURN tblSitiSuolo is LANGUAGE JAVA
NAME 'it.csi.smranag.storedproc.SitiDbBridge.datiSuoloPerPianoGrafico(java.lang.String,java.lang.String,java.lang.Long,java.lang.Long) return it.csi.smranag.storedproc.SitiSuoloVO';
*/
-- funzione per estrarre i dati di un soggetto a partire dal CUAA
FUNCTION getDatiSogg(pCodiUtilita  VARCHAR2,
                     pCodiCuaa     VARCHAR2) RETURN tabDatiSoggType_wp2 PIPELINED IS

  recOut  DatiSoggType_wp2 := DatiSoggType_wp2(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                                               NULL,NULL);
BEGIN
  FOR rec IN (SELECT AA.ID_AZIENDA,TFG.CODICE_SIAN,TFG.DESCRIZIONE
              FROM   DB_ACCESSO_PIANO_GRAFICO APG,DB_ANAGRAFICA_AZIENDA AA,DB_TIPO_FORMA_GIURIDICA TFG
              WHERE  APG.CODICE_UTILITA     = pCodiUtilita
              AND    APG.DATA_FINE_VALIDITA IS NULL
              AND    APG.ID_AZIENDA         = AA.ID_AZIENDA
              AND    AA.CUAA                = pCodiCuaa
              AND    TFG.ID_FORMA_GIURIDICA = AA.ID_FORMA_GIURIDICA(+)
              AND    AA.DATA_FINE_VALIDITA  IS NULL) LOOP

    BEGIN
      WITH RUOLO_STRINGA AS
      (SELECT VALORE_STRINGA AS VAL_STRINGA
       FROM   DB_ALTRI_DATI
       WHERE  CODICE             = 'RUOLI_PIANO_GRAF'
       AND    DATA_FINE_VALIDITA IS NULL),
      RUOLI_CONCATENATI AS
      (SELECT VAL_STRINGA AS TipoRuolo,LEVEL AS pos,SUBSTR(VAL_STRINGA,ROWNUM,1) AS CH,
              COUNT(CASE WHEN SUBSTR(VAL_STRINGA,ROWNUM,1) = ',' THEN '#' END) OVER (ORDER BY LEVEL) AS section
       FROM   RUOLO_STRINGA
       CONNECT BY LEVEL <= LENGTH(VAL_STRINGA)),
      TIPO_RUOLO AS
      (SELECT SUBSTR(TipoRuolo,MIN(pos), 1 + MAX(pos) - MIN(pos)) AS RUOLO
       FROM   RUOLI_CONCATENATI
       WHERE  CH <> ','
       GROUP BY TipoRuolo,section)
      SELECT C.ID_SOGGETTO,NVL(PF.CODICE_FISCALE,PG.CODICE_FISCALE),DECODE(S.FLAG_FISICO,'S',1,0),
             PF.COGNOME,PF.NOME,PG.DENOMINAZIONE,PF.NASCITA_DATA,PF.DATA_DECESSO,
             PF.SESSO,CO.CODFISC,CO.DESCOM,SUBSTR(PF.NASCITA_COMUNE,1,3)
      INTO   recOut.ID_SOGG,recOut.CODI_FISC,recOut.FLAG_PERS_FISI,
             recOut.DESC_COGN,recOut.DESC_NOME,recOut.DESC_RAGI_SOCI,recOut.DATA_NASC,recOut.DATA_MORT,
             recOut.CODI_SESS,recOut.CODI_BELF_NASC,recOut.DESC_COMU_NASC,recOut.CODI_SIGL_PROV_NASC
      FROM   DB_CONTITOLARE C,DB_PERSONA_FISICA PF,DB_PERSONA_GIURIDICA PG,DB_SOGGETTO S,COMUNE CO
      WHERE  C.ID_AZIENDA      = rec.ID_AZIENDA
      AND    C.DATA_FINE_RUOLO IS NULL
      AND    C.ID_RUOLO        IN (SELECT RUOLO
                                   FROM TIPO_RUOLO)
      AND    C.ID_SOGGETTO     = S.ID_SOGGETTO
      AND    S.ID_SOGGETTO     = PF.ID_SOGGETTO(+)
      AND    S.ID_SOGGETTO     = PG.ID_SOGGETTO(+)
      AND    CO.ISTAT_COMUNE(+)= PF.NASCITA_COMUNE;

      recOut.DECO_FORM_GIUR := rec.CODICE_SIAN;
      recOut.DESC_NATU_GIUR := rec.DESCRIZIONE;
    EXCEPTION
      WHEN OTHERS THEN
        recOut := NULL;
    END;
    Pipe Row (recOut);
  END LOOP;

  RETURN;
END getDatiSogg;

-- funzione per estrarre il catalogo prodotti a 5 codici
FUNCTION getCatalogoVari(pCodiUtilita   VARCHAR2,
                         pCodiOccu      VARCHAR2 DEFAULT NULL,
                         pCodiDestUso   VARCHAR2 DEFAULT NULL,
                         pCodiUso       VARCHAR2 DEFAULT NULL,
                         pCodiQual      VARCHAR2 DEFAULT NULL,
                         pCodiOccuVari  VARCHAR2 DEFAULT NULL) RETURN tabCataVariType PIPELINED IS

  recOut       CataVariType := CataVariType(NULL,NULL,NULL,NULL,NULL,NULL);
  nCont        SIMPLE_INTEGER := 0;
  nIdUtilizzo  DB_TIPO_UTILIZZO.ID_UTILIZZO%TYPE := NULL;
BEGIN
  SELECT COUNT(*)
  INTO   nCont
  FROM   DB_ACCESSO_PIANO_GRAFICO APG
  WHERE  APG.CODICE_UTILITA     = pCodiUtilita
  AND    APG.DATA_FINE_VALIDITA IS NULL;

  IF nCont = 0 THEN
    RETURN;
  END IF;

  IF pCodiOccuVari IS NOT NULL THEN
    SELECT ID_UTILIZZO
    INTO   nIdUtilizzo
    FROM   DB_TIPO_UTILIZZO
    WHERE  CODICE = pCodiOccuVari;
  END IF;

  FOR rec IN (SELECT NVL(TU.CODICE,'000') CODICE,NVL(TD.CODICE_DESTINAZIONE,'000') CODICE_DESTINAZIONE,
                     NVL(TDU.CODICE_DETTAGLIO_USO,'000') CODICE_DETTAGLIO_USO,
                     NVL(TQU.CODICE_QUALITA_USO,'000') CODICE_QUALITA_USO,
                     NVL(TV.CODICE_VARIETA,'000') CODICE_VARIETA,NVL(TV.DESCRIZIONE,'N.D.') DESCRIZIONE
              FROM   DB_R_CATALOGO_GRAFICO CG,DB_TIPO_UTILIZZO TU,DB_TIPO_DESTINAZIONE TD,DB_TIPO_DETTAGLIO_USO TDU,
                     DB_TIPO_QUALITA_USO TQU,DB_TIPO_VARIETA TV
              WHERE  CG.DATA_FINE_VALIDITA        IS NULL
              AND    CG.ID_UTILIZZO               = TU.ID_UTILIZZO
              AND    ((pCodiOccu IS NOT NULL AND TU.CODICE = pCodiOccu) OR
                      (pCodiOccu IS NULL))
              AND    TD.ID_TIPO_DESTINAZIONE(+)   = CG.ID_TIPO_DESTINAZIONE
              AND    ((pCodiDestUso IS NOT NULL AND TD.CODICE_DESTINAZIONE = pCodiDestUso) OR
                      (pCodiDestUso IS NULL))
              AND    TDU.ID_TIPO_DETTAGLIO_USO(+) = CG.ID_TIPO_DETTAGLIO_USO
              AND    ((pCodiUso IS NOT NULL AND TDU.CODICE_DETTAGLIO_USO = pCodiUso) OR
                      (pCodiUso IS NULL))
              AND    TQU.ID_TIPO_QUALITA_USO(+)   = CG.ID_TIPO_QUALITA_USO
              AND    ((pCodiQual IS NOT NULL AND TQU.CODICE_QUALITA_USO = pCodiQual) OR
                      (pCodiQual IS NULL))
              AND    TV.ID_VARIETA(+)             = CG.ID_VARIETA
              AND    TV.ID_UTILIZZO(+)            = nIdUtilizzo) LOOP

    recOut.CODI_OCCU      := rec.CODICE;
    recOut.CODI_DEST_USOO := rec.CODICE_DESTINAZIONE;
    recOut.CODI_USOO      := rec.CODICE_DETTAGLIO_USO;
    recOut.CODI_QUAL      := rec.CODICE_QUALITA_USO;
    recOut.CODI_OCCU_VARI := rec.CODICE_VARIETA;
    recOut.DESC_OCCU_VARI := rec.DESCRIZIONE;

    Pipe Row (recOut);
  END LOOP;
  RETURN;
END getCatalogoVari;

-- funzione per estrarre i criteri di mantenimento per prodotto
FUNCTION getPratManFromCata(pCodiUtilita   VARCHAR2,
                            pCodiOccu      VARCHAR2,
                            pCodiDestUsoo  VARCHAR2 DEFAULT NULL,
                            pCodiUsoo      VARCHAR2 DEFAULT NULL,
                            pCodiQual      VARCHAR2 DEFAULT NULL) RETURN tabPratManType PIPELINED IS

 recOut       PratManType := PratManType(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
 nCont        SIMPLE_INTEGER := 0;
 nIdUtilizzo  DB_TIPO_UTILIZZO.ID_UTILIZZO%TYPE := NULL;
BEGIN
  SELECT COUNT(*)
  INTO   nCont
  FROM   DB_ACCESSO_PIANO_GRAFICO APG
  WHERE  APG.CODICE_UTILITA     = pCodiUtilita
  AND    APG.DATA_FINE_VALIDITA IS NULL;

  IF nCont = 0 THEN
    RETURN;
  END IF;

  IF pCodiOccu IS NOT NULL THEN
    SELECT ID_UTILIZZO
    INTO   nIdUtilizzo
    FROM   DB_TIPO_UTILIZZO
    WHERE  CODICE = pCodiOccu;
  END IF;

  FOR rec IN (SELECT NVL(TU.CODICE,'000') CODICE,NVL(TD.CODICE_DESTINAZIONE,'000') CODICE_DESTINAZIONE,
                     NVL(TDU.CODICE_DETTAGLIO_USO,'000') CODICE_DETTAGLIO_USO,
                     NVL(TQU.CODICE_QUALITA_USO,'000') CODICE_QUALITA_USO,
                     NVL(GMA.CODICE_GRUPPO_MANTENIMENTO,'000') CODICE_GRUPPO_MANTENIMENTO,
                     NVL(GMA.DESCRIZIONE_GRUPPO_MANTENIMENT,'N.D.') DESCRIZIONE_GRUPPO_MANTENIMENT,
                     NVL(TPM.CODICE_PRATICA_MANTENIMENTO,'000') CODICE_PRATICA_MANTENIMENTO,
                     NVL(TPM.DESCRIZIONE_PRATICA_MANTENIMEN,'N.D.') DESCRIZIONE_PRATICA_MANTENIMEN,
                     GM.FLAG_DEFAULT
              FROM   DB_R_CATALOGO_GRAFICO CG,DB_TIPO_UTILIZZO TU,DB_TIPO_DESTINAZIONE TD,
                     DB_TIPO_DETTAGLIO_USO TDU,DB_TIPO_QUALITA_USO TQU,DB_TIPO_VARIETA TV,
                     DB_R_GRAFICO_MANTENIMENTO GM,DB_R_PRATICA_GRUPPO_MANTENIMEN PGM,
                     DB_GRUPPO_MANTENIMENTO GMA,DB_TIPO_PRATICA_MANTENIMENTO TPM
              WHERE  CG.DATA_FINE_VALIDITA        IS NULL
              AND    CG.ID_UTILIZZO               = TU.ID_UTILIZZO
              AND    ((pCodiOccu IS NOT NULL AND TU.CODICE = pCodiOccu) OR
                      (pCodiOccu IS NULL))
              AND    TD.ID_TIPO_DESTINAZIONE(+)   = CG.ID_TIPO_DESTINAZIONE
              AND    ((pCodiDestUsoo IS NOT NULL AND TD.CODICE_DESTINAZIONE = pCodiDestUsoo) OR
                      (pCodiDestUsoo IS NULL))
              AND    TDU.ID_TIPO_DETTAGLIO_USO(+) = CG.ID_TIPO_DETTAGLIO_USO
              AND    ((pCodiUsoo IS NOT NULL AND TDU.CODICE_DETTAGLIO_USO = pCodiUsoo) OR
                      (pCodiUsoo IS NULL))
              AND    TQU.ID_TIPO_QUALITA_USO(+)   = CG.ID_TIPO_QUALITA_USO
              AND    ((pCodiQual IS NOT NULL AND TQU.CODICE_QUALITA_USO = pCodiQual) OR
                      (pCodiQual IS NULL))
              AND    TV.ID_VARIETA(+)             = CG.ID_VARIETA
              AND    TV.ID_UTILIZZO(+)            = nIdUtilizzo
              AND    GM.ID_CATALOGO_GRAFICO       = CG.ID_CATALOGO_GRAFICO
              AND    PGM.DATA_FINE_VALIDITA       IS NULL
              AND    PGM.ID_GRUPPO_MANTENIMENTO   = GMA.ID_GRUPPO_MANTENIMENTO
              AND    PGM.ID_PRATICA_MANTENIMENTO  = GM.ID_PRATICA_MANTENIMENTO
              AND    GM.DATA_FINE_VALIDITA        IS NULL
              AND    TPM.ID_PRATICA_MANTENIMENTO  = GM.ID_PRATICA_MANTENIMENTO) LOOP

    recOut.CODI_TIPO_DECO := rec.CODICE_GRUPPO_MANTENIMENTO;
    recOut.DESC_TIPO_DECO := rec.DESCRIZIONE_GRUPPO_MANTENIMENT;
    recOut.CODI_OCCU      := rec.CODICE;
    recOut.CODI_DEST_USOO := rec.CODICE_DESTINAZIONE;
    recOut.CODI_USOO      := rec.CODICE_DETTAGLIO_USO;
    recOut.CODI_QUAL      := rec.CODICE_QUALITA_USO;
    recOut.ID_DECO        := rec.CODICE_PRATICA_MANTENIMENTO;
    recOut.DESC_DECO      := rec.DESCRIZIONE_PRATICA_MANTENIMEN;
    recOut.FLAG_DEFA      := rec.FLAG_DEFAULT;

    Pipe Row (recOut);
  END LOOP;

  RETURN;
END getPratManFromCata;

--  Imposta l'hashmap di compatibilita' del contesto a partire dall'array di compatibilita' gia' definito
PROCEDURE SetCompatibilitaMap(contesto  IN OUT NOCOPY ContestoAssegnazioni) IS
BEGIN
  contesto.configsOK.DELETE;
  FOR i in 1 .. contesto.compatibilita.COUNT LOOP
    contesto.configsOK(contesto.compatibilita(i)) := TRUE;
  END LOOP;
END SetCompatibilitaMap;

--  Effettua le assegnazioni con il metodo 1 Utilizzo -> (1:N) Poligoni
PROCEDURE AssegnaGisInDeus(contesto  IN OUT NOCOPY ContestoAssegnazioni,
                           poliIdx                 PLS_INTEGER := 1) IS

  configurazioneCurrComb  VARCHAR2(30);
  assegnazione_valida     BOOLEAN := TRUE;
BEGIN

  IF (poliIdx <= contesto.numPoli) THEN
    IF ((contesto.currAssegnazione.numAbbinamenti <= contesto.maxCombs OR contesto.maxCombs IS NULL) AND
        (contesto.bestAssegnazione.supUtilMancante IS NULL             OR contesto.currAssegnazione.supUtilAssenti - contesto.tolleranza <= contesto.bestAssegnazione.supUtilMancante)) THEN

      FOR deusIdx IN 1 .. contesto.numDeus LOOP
        configurazioneCurrComb := contesto.tipiDeus(deusIdx)||'='||contesto.tipiPoli(poliIdx);

        IF (contesto.configsOK.EXISTS(configurazioneCurrComb) AND contesto.spazioDeus(deusIdx) > 0 AND
            (contesto.spazioDeus(deusIdx) >= contesto.superfPoli(poliIdx) - contesto.tolleranza OR
             (not contesto.modoSaturazione AND contesto.spazioDeus(deusIdx) = contesto.superfDeus(DeusIdx) AND
              contesto.superfDeus(DeusIdx) - contesto.tolleranza <= contesto.superfPoli(poliIdx)))) THEN

          contesto.spazioDeus(deusIdx)                   := contesto.spazioDeus(deusIdx) - contesto.superfPoli(poliIdx);
          contesto.currAssegnazione.abbinamenti(poliIdx) := NEW superfici_utilizzi_gis(deusIdx, poliIdx, contesto.superfPoli(poliIdx), contesto.superfPoli(poliIdx));

          AssegnaGisInDeus(contesto,poliIdx+1);

          contesto.currAssegnazione.abbinamenti(poliIdx) := NULL;
          contesto.spazioDeus(deusIdx) := contesto.spazioDeus(deusIdx) + contesto.superfPoli(poliIdx);
        ELSE
          NULL;
        END IF;
      END LOOP;

      contesto.currAssegnazione.abbinamenti(poliIdx) := NULL;
      contesto.currAssegnazione.supUtilAssenti       := contesto.currAssegnazione.supUtilAssenti + contesto.superfPoli(poliIdx);
      contesto.currAssegnazione.supPoliAssenti       := contesto.currAssegnazione.supPoliAssenti + contesto.superfPoli(poliIdx);

      AssegnaGisInDeus(contesto,poliIdx+1);

      contesto.currAssegnazione.supUtilAssenti := contesto.currAssegnazione.supUtilAssenti - contesto.superfPoli(poliIdx);
      contesto.currAssegnazione.supPoliAssenti := contesto.currAssegnazione.supPoliAssenti - contesto.superfPoli(poliIdx);
    ELSE
      NULL;
    END IF;
  ELSE
    DECLARE
      assegnazione_valida  BOOLEAN := FALSE;
      residuo              NUMBER;
    BEGIN
      contesto.currAssegnazione.numAbbinamenti  := contesto.currAssegnazione.numAbbinamenti + 1;
      contesto.currAssegnazione.supUtilMancante := 0;
      contesto.currAssegnazione.totTolleranza   := 0;

      FOR i IN 1 .. contesto.numDeus LOOP
        IF (contesto.spazioDeus(i) < contesto.superfDeus(i)) THEN
          assegnazione_valida := TRUE;
          residuo             := ABS(contesto.spazioDeus(i));
          IF (residuo > contesto.tolleranza) THEN
            IF (contesto.modoSaturazione) THEN
              assegnazione_valida := FALSE;
              EXIT;
            ELSE
              contesto.currAssegnazione.totTolleranza   := contesto.currAssegnazione.totTolleranza + residuo;
              contesto.currAssegnazione.supUtilMancante := contesto.currAssegnazione.supUtilMancante + contesto.spazioDeus(i);
            END IF;
          ELSE
            contesto.currAssegnazione.totTolleranza   := contesto.currAssegnazione.totTolleranza + residuo;
            contesto.currAssegnazione.supUtilMancante := contesto.currAssegnazione.supUtilMancante + contesto.spazioDeus(i);
          END IF;
        ELSE
          contesto.currAssegnazione.supUtilMancante := contesto.currAssegnazione.supUtilMancante + contesto.superfDeus(i);
        END IF;
      END LOOP;

      IF (assegnazione_valida) THEN
        IF (contesto.bestAssegnazione.supUtilMancante IS NULL OR
            (contesto.currAssegnazione.supUtilMancante = contesto.bestAssegnazione.supUtilMancante AND
             contesto.currAssegnazione.totTolleranza < contesto.bestAssegnazione.totTolleranza) OR
             contesto.currAssegnazione.supUtilMancante < contesto.bestAssegnazione.supUtilMancante) THEN

          contesto.bestAssegnazione.supUtilAssenti  := contesto.currAssegnazione.supUtilAssenti;
          contesto.bestAssegnazione.supPoliAssenti  := contesto.currAssegnazione.supPoliAssenti;
          contesto.bestAssegnazione.abbinamenti     := superfici_utilizzi_gis_tab();
          contesto.bestAssegnazione.supUtilMancante := contesto.currAssegnazione.supUtilMancante;
          contesto.bestAssegnazione.totTolleranza   := contesto.currAssegnazione.totTolleranza;

          FOR i IN 1 .. contesto.currAssegnazione.abbinamenti.COUNT LOOP
            IF (contesto.currAssegnazione.abbinamenti(i) IS NOT NULL) THEN
              contesto.bestAssegnazione.abbinamenti.EXTEND;
              contesto.bestAssegnazione.abbinamenti(contesto.bestAssegnazione.abbinamenti.COUNT) := contesto.currAssegnazione.abbinamenti(i);
            END IF;
          END LOOP;
        ELSE
          NULL;
        END IF;
      ELSE
        NULL;
      END IF;
    END;
  END IF;
END AssegnaGisInDeus;

-- Restituisce un contesto inizializzato con i dati in input
FUNCTION SetVarGlobali(inpDeusIds              ORA_MINING_NUMBER_NT,
                       inpPoliIds              ORA_MINING_NUMBER_NT,
                       inpSuperfDeus           ORA_MINING_NUMBER_NT,
                       inpSuperfPoli           ORA_MINING_NUMBER_NT,
                       inpTipiDeus             ORA_MINING_VARCHAR2_NT,
                       inpTipiPoli             ORA_MINING_VARCHAR2_NT,
                       inpCompatibilita        ORA_MINING_VARCHAR2_NT,
                       inpNumDeus              NUMBER,
                       inpNumPoli              NUMBER,
                       inpTolleranza           NUMBER,
                       inpModalitaSaturazione  NUMBER,
                       inpNumPassiMassimo      NUMBER) RETURN ContestoAssegnazioni IS

  contesto  ContestoAssegnazioni;
BEGIN
  contesto.deusIds         := inpDeusIds;
  contesto.poliIds         := inpPoliIds;
  contesto.superfDeus      := inpSuperfDeus;
  contesto.superfPoli      := inpSuperfPoli;
  contesto.tipiDeus        := inpTipiDeus;
  contesto.tipiPoli        := inpTipiPoli;
  contesto.compatibilita   := inpCompatibilita;
  contesto.numDeus         := inpNumDeus;
  contesto.numPoli         := inpNumPoli;
  contesto.tolleranza      := inpTolleranza;
  contesto.modoSaturazione := (nvl(inpModalitaSaturazione,'0') != 0);
  contesto.maxCombs        := inpNumPassiMassimo;

  SetCompatibilitaMap(contesto);
  RETURN contesto;
END SetVarGlobali;

--  Prepara i campi del contesto ed effettua un'assegnazione con il metodo 1:N
FUNCTION ElaboraAssegnazioniGis(contesto  IN OUT NOCOPY ContestoAssegnazioni) RETURN CombDisposizioniFrazionate IS
BEGIN
  IF contesto.compatibilita.COUNT = 0 THEN
    NULL;
  ELSIF contesto.numDeus <= 0 THEN
    NULL;
  ELSIF contesto.numPoli <= 0 THEN
    NULL;
  ELSE
    FOR i IN 1 .. contesto.compatibilita.COUNT LOOP
      contesto.configsOK(contesto.compatibilita(i)) := TRUE;
    END LOOP;

    contesto.currAssegnazione.numAbbinamenti := 0;
    contesto.currAssegnazione.totTolleranza  := 0;
    contesto.currAssegnazione.supUtilAssenti := 0;
    contesto.currAssegnazione.supPoliAssenti := 0;
    contesto.currAssegnazione.abbinamenti    := superfici_utilizzi_gis_tab();

    contesto.currAssegnazione.abbinamenti.EXTEND(contesto.numPoli);

    contesto.bestAssegnazione.abbinamenti := superfici_utilizzi_gis_tab();

    contesto.bestAssegnazione.abbinamenti.EXTEND(contesto.numPoli);

    contesto.bestAssegnazione.supUtilMancante := NULL;
    contesto.bestAssegnazione.supUtilAssenti  := NULL;
    contesto.bestAssegnazione.supPoliAssenti  := NULL;
    contesto.spazioDeus                       := ORA_MINING_NUMBER_NT();

    contesto.spazioDeus.EXTEND(contesto.numDeus);

    FOR i IN 1..contesto.numDeus LOOP
      contesto.spazioDeus(i) := contesto.superfDeus(i);
    END LOOP;

    AssegnaGisInDeus(contesto);
  END IF;
  RETURN contesto.bestAssegnazione;
END ElaboraAssegnazioniGis;

-- Effettua le seguenti due operazioni sugli oggetti in input:
-- 1) Rimuove dal contesto i riferimenti agli elementi presenti nell'assegnazione
-- 2) sostituisce nell'assegnazione i riferimenti posizionali con gli ID presenti nel contesto (deusIds e poliIds)
PROCEDURE RiduzioneElementiAssegnati(contesto      IN OUT NOCOPY ContestoAssegnazioni,
                                     assegnazione  IN OUT NOCOPY CombDisposizioniFrazionate) IS
  n              PLS_INTEGER;
  appDeusIds     ORA_MINING_NUMBER_NT;
  appPoliIds     ORA_MINING_NUMBER_NT;
  appSuperfDeus  ORA_MINING_NUMBER_NT;
  appTipiDeus    ORA_MINING_VARCHAR2_NT;
  appSuperfPoli  ORA_MINING_NUMBER_NT;
  appTipiPoli    ORA_MINING_VARCHAR2_NT;
  deusAbbinati   BoolByIntMap;
  poliAbbinati   BoolByIntMap;
BEGIN
  IF (contesto.bestAssegnazione.abbinamenti IS NOT NULL AND contesto.bestAssegnazione.abbinamenti IS NOT EMPTY) THEN
    appDeusIds          := contesto.deusIds;
    appPoliIds          := contesto.poliIds;
    appSuperfDeus       := contesto.superfDeus;
    appTipiDeus         := contesto.tipiDeus;
    appSuperfPoli       := contesto.superfPoli;
    appTipiPoli         := contesto.tipiPoli;
    contesto.deusIds    := NEW ORA_MINING_NUMBER_NT();
    contesto.poliIds    := NEW ORA_MINING_NUMBER_NT();
    contesto.superfDeus := NEW ORA_MINING_NUMBER_NT();
    contesto.superfPoli := NEW ORA_MINING_NUMBER_NT();
    contesto.tipiDeus   := NEW ORA_MINING_VARCHAR2_NT();
    contesto.tipiPoli   := NEW ORA_MINING_VARCHAR2_NT();

    -- Identificazione utilizzi e poligoni abbinati
    FOR i IN 1 .. assegnazione.abbinamenti.COUNT LOOP
      IF (assegnazione.abbinamenti(i) IS NOT NULL AND assegnazione.abbinamenti(i).id_deus IS NOT NULL AND
          assegnazione.abbinamenti(i).id_poli IS NOT NULL) THEN
        poliAbbinati(appPoliIds(assegnazione.abbinamenti(i).id_poli)) := TRUE;
        deusAbbinati(appDeusIds(assegnazione.abbinamenti(i).id_deus)) := TRUE;
      ELSE
        NULL;
      END IF;
    END LOOP;

    --  Sostituzione dei riferimenti posizionali nell'assegnazione con gli identificativi
    SELECT CAST(COLLECT(superfici_utilizzi_gis(id_deus, id_poli, supe_deus, supe_poli)) AS superfici_utilizzi_gis_tab)
    INTO   assegnazione.abbinamenti
    FROM   (SELECT id_deus AS rn_deus, id_poli AS rn_poli, supe_deus, supe_poli
            FROM   TABLE(assegnazione.abbinamenti)
            WHERE  id_deus IS NOT NULL OR id_poli IS NOT NULL)
            LEFT JOIN
           (SELECT ROWNUM AS rn_deus, COLUMN_VALUE AS id_deus
            FROM   TABLE(appDeusIds))
            USING (rn_deus)
            LEFT JOIN
           (SELECT ROWNUM AS rn_poli, COLUMN_VALUE AS id_poli
            FROM   TABLE(appPoliIds))
            USING (rn_poli);

    -- Rimozione degli elementi abbinati dagli array del contesto che fanno riferimento ai poligoni
    n := 0;

    FOR i IN 1 .. contesto.numPoli LOOP
      IF (poliAbbinati.EXISTS(appPoliIds(i))) THEN
        NULL;
      ELSE
        contesto.tipiPoli.EXTEND;
        contesto.superfPoli.EXTEND;
        contesto.poliIds.EXTEND;

        n := n + 1;

        contesto.superfPoli(n) := appSuperfPoli(i);
        contesto.tipiPoli(n)   := appTipiPoli(i);
        contesto.poliIds(n)    := appPoliIds(i);
      END IF;
    END LOOP;

    contesto.numPoli := n;

    -- Rimozione degli elementi abbinati nell'assegnazione dagli array del contesto che fanno riferimento agli utilizzi
    n := 0;

    FOR i IN 1 .. contesto.numDeus LOOP
      IF (deusAbbinati.EXISTS(appDeusIds(i))) THEN
        NULL;
      ELSE
        contesto.superfDeus.extend;
        contesto.tipiDeus.extend;
        contesto.deusIds.extend;

        n := n + 1;

        contesto.superfDeus(n) := appSuperfDeus(i);
        contesto.tipiDeus(n)   := appTipiDeus(i);
        contesto.deusIds(n)    := appDeusIds(i);
      END IF;
    END LOOP;

    contesto.numDeus := n;
  ELSE
    NULL;
  END IF;
END RiduzioneElementiAssegnati;

-- Restutuisce i risultati di un abbinamento effettuato con il metodo di default
-- Ora impostato per metodo 1:N secco
FUNCTION EseguiAssegnazioni(deus_ids                     ORA_MINING_NUMBER_NT,
                            poli_ids                     ORA_MINING_NUMBER_NT,
                            superfici_deus               ORA_MINING_NUMBER_NT,
                            superfici_poli               ORA_MINING_NUMBER_NT,
                            tipi_deus                    ORA_MINING_VARCHAR2_NT,
                            tipi_poli                    ORA_MINING_VARCHAR2_NT,
                            compatibilita                ORA_MINING_VARCHAR2_NT,
                            num_deus                     NUMBER,
                            num_poli                     NUMBER,
                            tolleranza                   NUMBER := TolleranzaDefault,
                            modalitaSaturazioneUtilizzi  NUMBER := ModoSaturazioneUtilizziDefault,
                            numPassiMassimo              NUMBER := NumCombinazioniMassimoDefault) RETURN superfici_utilizzi_gis_tab IS

  out_abbinamenti   superfici_utilizzi_gis_tab;
  loc_assegnazione  CombDisposizioniFrazionate;
  contesto          ContestoAssegnazioni;
BEGIN
  contesto := SetVarGlobali(deus_ids,poli_ids,superfici_deus,superfici_poli,tipi_deus,tipi_poli,
                            compatibilita,num_deus,num_poli,tolleranza,modalitaSaturazioneUtilizzi,
                            numPassiMassimo);

  out_abbinamenti := NEW superfici_utilizzi_gis_tab();

  IF (contesto.numDeus > 0 AND contesto.numPoli > 0) THEN
    loc_assegnazione := ElaboraAssegnazioniGis(contesto);

    RiduzioneElementiAssegnati(contesto,loc_assegnazione);

    IF loc_assegnazione.abbinamenti IS NOT NULL THEN
      out_abbinamenti := out_abbinamenti MULTISET UNION loc_assegnazione.abbinamenti;
    END IF;

    IF (loc_assegnazione.supUtilMancante IS NULL OR loc_assegnazione.supUtilMancante > 0 ) THEN
      IF (contesto.numDeus > 0 and contesto.numPoli > 0) THEN
        NULL;
      ELSE
        NULL;
      END IF;
    ELSE
      NULL;
    END IF;
  ELSE
    NULL;
  END IF;
  RETURN out_abbinamenti;
END EseguiAssegnazioni;

-- Inizializza una coda(Queue) con l'array in input
FUNCTION initQueue(elements ORA_MINING_VARCHAR2_NT) RETURN stringQueue IS
  outVal  stringQueue;
begin
  outVal.startIdx := 1;
  outVal.elements := elements;
  outVal.stopIdx  := elements.COUNT;

  RETURN outVal;
END initQueue;

-- Rimuove un elemento dalla coda e lo restituisce in output
FUNCTION DEQUEUE(queue IN OUT NOCOPY stringQueue) RETURN VARCHAR2 IS
  element varchar2(4000);
BEGIN
  IF (queue.startIdx <= queue.stopIdx) THEN
    element := queue.elements(queue.startIdx);
    queue.startIdx := queue.startIdx + 1;
    RETURN element;
  ELSE
    RETURN NULL;
  END IF;
END DEQUEUE;

--  Accoda un elemento alla coda
PROCEDURE enQueue(queue    IN OUT NOCOPY STRINGQUEUE,
                  ELEMENT  IN VARCHAR2) IS
BEGIN
  IF (queue.stopIdx = queue.elements.COUNT) THEN
    queue.elements.EXTEND(10);
  END IF;
  queue.stopIdx                 := queue.stopIdx+1;
  queue.elements(queue.stopIdx) := element;
END enQueue;

-- Ottiene il numero di elementi della coda
FUNCTION countQueue(queue IN OUT NOCOPY stringQueue) RETURN PLS_INTEGER IS
BEGIN
  RETURN (queue.stopIdx - queue.startIdx)+1;
END countQueue;

PROCEDURE dividiGruppi(inpTipiDeus       ORA_MINING_VARCHAR2_NT,
                       inpTipiPoli       ORA_MINING_VARCHAR2_NT,
                       inpCompatibilita  ORA_MINING_VARCHAR2_NT,
                       inpNumDeus        NUMBER,
                       inpNumPoli        NUMBER,
                       outGruppi         OUT strings_sets) IS

  tipiDeus    ORA_MINING_VARCHAR2_NT;
  tipiPoli    ORA_MINING_VARCHAR2_NT;
  passo       PLS_INTEGER;
  links       TabTipiDeusPoli;
  linkHT      StringsSetsByStringMap;
  n           VARCHAR2(4000);
  deusVal     VARCHAR2(4000);
  poliVal     VARCHAR2(4000);
  strTabAppo  ORA_MINING_VARCHAR2_NT;
  vicini      ORA_MINING_VARCHAR2_NT;
  nodes       ORA_MINING_VARCHAR2_NT;
  myGroup     ORA_MINING_VARCHAR2_NT;
  toQueue     ORA_MINING_VARCHAR2_NT;
  myQueue     stringQueue;

BEGIN
  SELECT DISTINCT COLUMN_VALUE
  BULK COLLECT INTO tipiDeus
  FROM   TABLE(inpTipiDeus)
  WHERE  ROWNUM <= inpNumDeus;

  SELECT DISTINCT COLUMN_VALUE
  BULK   COLLECT INTO tipiPoli
  FROM TABLE(inpTipiPoli)
  WHERE  ROWNUM <= inpNumPoli;

  SELECT D.COLUMN_VALUE, P.COLUMN_VALUE
  BULK COLLECT INTO links
  FROM   TABLE(tipiDeus) d CROSS JOIN TABLE (tipiPoli) P
  WHERE  D.COLUMN_VALUE||'='||P.COLUMN_VALUE IN (SELECT COLUMN_VALUE
                                                 FROM TABLE(inpCompatibilita));

  FOR i IN 1 .. links.COUNT LOOP
    deusVal := links(i).deus;
    poliVal := links(i).poli;

    IF linkHT.EXISTS(deusVal) THEN
      strTabAppo := linkHT(deusVal);
      strTabAppo.EXTEND(1);
      strTabAppo(strTabAppo.COUNT) := poliVal;
      linkHT(deusVal)              := strTabAppo;
    ELSE
      linkHT(deusVal) := ORA_MINING_VARCHAR2_NT(poliVal);
    END IF;

    IF linkHT.EXISTS(poliVal) THEN
      strTabAppo := linkHT(poliVal);
      strTabAppo.EXTEND(1);
      strTabAppo(strTabAppo.COUNT) := deusVal;
      linkHT(poliVal) := strTabAppo;
    ELSE
      linkHT(poliVal) := ORA_MINING_VARCHAR2_NT(deusVal);
    END IF;
  END LOOP;

  outGruppi := NEW strings_sets();
  nodes     := tipiDeus MULTISET UNION tipiPoli;

  IF (nodes.COUNT > 0) THEN
    LOOP
      FOR i IN 1 .. nodes.COUNT LOOP
        IF (linkHT.EXISTS(nodes(i))) THEN
          strTabAppo := linkHT(nodes(i));
          FOR j IN 1 .. strTabAppo.COUNT LOOP
            NULL;
          END LOOP;
        ELSE
          NULL;
        END IF;
      END LOOP;

      n := nodes(nodes.COUNT);
      nodes.trim(1);
      passo   := 0;
      myGroup := ORA_MINING_VARCHAR2_NT(n);
      myQueue := initQueue(ORA_MINING_VARCHAR2_NT(n));

      LOOP
        passo := passo +1;
        n     := deQueue(myQueue);

        IF (linkHT.EXISTS(n)) THEN
          vicini  := linkHT(n) MULTISET EXCEPT myGroup;
          nodes   := nodes MULTISET EXCEPT vicini;
          toQueue := vicini MULTISET EXCEPT myGroup;
          myGroup := myGroup MULTISET UNION DISTINCT vicini;

          FOR i IN 1..toQueue.COUNT LOOP
            IF (toQueue(i) != n) THEN
              ENQUEUE(myQueue, toQueue(i));
            END IF;
          END LOOP;
        ELSE
          NULL;
        END IF;
        EXIT WHEN countQueue(myQueue) = 0 OR passo >= 10000;
      END LOOP;

      outGruppi.EXTEND;
      outGruppi(outGruppi.COUNT) := myGRoup;
      EXIT WHEN nodes.COUNT = 0;
    END LOOP;
  END IF;
END;


/*    Ritorna gli insiemi di tipologie reciprocamente compatibili
    Parametri:
        inpTipiDeus: array dei tipi di utilizzi
        inpTipiPoli: array dei tipi di poligoni
        inpCompatibilita: elenco delle compatibilità tra tipi di utilizzo e di poligoni, string nel formato
            <tipo_utilizzo>=<tipo_poligono>
        inpNumDeus: cardinalità dell'array degli utilizzi
        inpNumGis: cardinalità dell'array dei poligoni*/
FUNCTION GetGruppiCompatibilita(inpTipiDeus       ORA_MINING_VARCHAR2_NT,
                                inpTipiPoli       ORA_MINING_VARCHAR2_NT,
                                inpCompatibilita  ORA_MINING_VARCHAR2_NT,
                                inpNumDeus        NUMBER,
                                inpNumGis         NUMBER) RETURN strings_sets IS
  myGroups strings_sets;
BEGIN
  dividiGruppi(inpTipiDeus,inpTipiPoli,inpCompatibilita,inpNumDeus,inpNumGis,myGroups);
  RETURN myGroups;
END GetGruppiCompatibilita;


--  Restituisce i risultati di un abbinamento effettuato con il metodo di default
--  scomponendo gli array in input in gruppi piu' piccoli che riducono il numero di combinazioni da esaminare
FUNCTION EseguiAssegnazioniInGruppi(deus_ids                     ORA_MINING_NUMBER_NT,
                                    poli_ids                     ORA_MINING_NUMBER_NT,
                                    superfici_deus               ORA_MINING_NUMBER_NT,
                                    superfici_poli               ORA_MINING_NUMBER_NT,
                                    tipi_deus                    ORA_MINING_VARCHAR2_NT,
                                    tipi_poli                    ORA_MINING_VARCHAR2_NT,
                                    compatibilita                ORA_MINING_VARCHAR2_NT,
                                    num_deus                     number,
                                    num_poli                     number,
                                    tolleranza                   number := TolleranzaDefault,
                                    modalitaSaturazioneUtilizzi  number := ModoSaturazioneUtilizziDefault,
                                    numPassiMassimo              number := NumCombinazioniMassimoDefault) RETURN superfici_utilizzi_gis_tab IS

  gruppi            strings_sets;
  assegnazioni      superfici_utilizzi_gis_tab;
  assegnazioni_app  superfici_utilizzi_gis_tab;
  n                 PLS_INTEGER := 0;
BEGIN
  gruppi       := GetGruppiCompatibilita(tipi_deus,tipi_poli,compatibilita,num_deus,num_poli);
  assegnazioni := superfici_utilizzi_gis_tab();

  FOR i IN 1 .. gruppi.COUNT LOOP
    DECLARE
      deusIds     ORA_MINING_NUMBER_NT;
      poliIds     ORA_MINING_NUMBER_NT;
      superfDeus  ORA_MINING_NUMBER_NT;
      superfPoli  ORA_MINING_NUMBER_NT;
      tipiDeus    ORA_MINING_VARCHAR2_NT;
      tipiPoli    ORA_MINING_VARCHAR2_NT;
      comps       ORA_MINING_VARCHAR2_NT;
    BEGIN
      SELECT id_deus, supe_deus, tipo_deus
      BULK COLLECT INTO deusIds, superfDeus, tipiDeus
      FROM   (SELECT ROWNUM AS rn_deus, COLUMN_VALUE AS id_deus
              FROM   TABLE(CAST(deus_ids AS ORA_MINING_NUMBER_NT))
              WHERE  ROWNUM <= num_deus)
             LEFT JOIN
             (SELECT ROWNUM AS rn_deus, COLUMN_VALUE AS tipo_deus
              FROM   TABLE(CAST(tipi_deus AS ORA_MINING_VARCHAR2_NT))
              WHERE  ROWNUM <= num_deus) USING (rn_deus)
             LEFT JOIN
             (SELECT ROWNUM AS rn_deus, COLUMN_VALUE AS supe_deus
              FROM   TABLE(CAST(superfici_deus AS ORA_MINING_NUMBER_NT))
              WHERE  ROWNUM <= num_deus) USING (rn_deus)
      WHERE tipo_deus IN (SELECT COLUMN_VALUE
                          FROM   TABLE (CAST(gruppi(i) AS ORA_MINING_VARCHAR2_NT)));

      SELECT id_poli, supe_poli, tipo_poli
      BULK COLLECT INTO poliIds, superfPoli, tipiPoli
      FROM   (SELECT ROWNUM AS rn_poli, COLUMN_VALUE AS id_poli
              FROM   TABLE(CAST(poli_ids AS ORA_MINING_NUMBER_NT))
              WHERE  ROWNUM <= num_poli)
             LEFT JOIN
             (SELECT ROWNUM AS rn_poli, COLUMN_VALUE AS tipo_poli
              FROM   TABLE(CAST(tipi_poli AS ORA_MINING_VARCHAR2_NT))
              WHERE  ROWNUM <= num_poli) USING (rn_poli)
             LEFT JOIN
             (SELECT ROWNUM AS rn_poli, COLUMN_VALUE AS supe_poli
              FROM   TABLE(CAST(superfici_poli AS ORA_MINING_NUMBER_NT))
              WHERE  ROWNUM <= num_poli) USING (rn_poli)
      WHERE  tipo_poli IN (SELECT COLUMN_VALUE
                           FROM   TABLE (CAST(gruppi(i) AS ORA_MINING_VARCHAR2_NT)));

      SELECT deus||'='||poli
      BULK COLLECT INTO comps
      FROM   (SELECT DISTINCT COLUMN_VALUE AS deus
              FROM   TABLE(CAST(tipiDeus AS ORA_MINING_VARCHAR2_NT)))
             CROSS JOIN
             (SELECT DISTINCT COLUMN_VALUE poli
              FROM   TABLE(CAST(tipiPoli AS ORA_MINING_VARCHAR2_NT)))
      WHERE  deus||'='||poli IN (SELECT COLUMN_VALUE
                                 FROM   TABLE(CAST(compatibilita AS ORA_MINING_VARCHAR2_NT)));

      assegnazioni_app :=  EseguiAssegnazioni(deusIds, poliIds,superfDeus, superfPoli,tipiDeus, tipiPoli,
                                              comps,deusIds.count, poliIds.count,tolleranza,
                                              modalitaSaturazioneUtilizzi,numPassiMassimo);


      IF (assegnazioni_app IS NOT NULL) THEN
        --dbms_output.put_line('assegnazioni_app.COUNT = '||assegnazioni_app.COUNT);
        assegnazioni.EXTEND(assegnazioni_app.COUNT);
        FOR i IN 1..assegnazioni_app.COUNT LOOP
          assegnazioni(i+n) := assegnazioni_app(i);
        END LOOP;
        n := n + assegnazioni_app.COUNT;
      END IF;
    END;
  END LOOP;

  RETURN assegnazioni;
END EseguiAssegnazioniInGruppi;

-- funzione che richiama la classe java unisciShape
/*FUNCTION unisciShape(pArrayShape  SDO_GEOMETRY_ARRAY) RETURN SDO_GEOMETRY is LANGUAGE JAVA
NAME 'it.csi.smranag.storedproc.SitiDbBridge.unisciShape(oracle.sql.ARRAY) return oracle.sql.STRUCT';*/

FUNCTION preCaricamento(pIdDichiarazioneConsistenza  DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE) RETURN NUMBER IS

  TYPE recConDic IS RECORD(ID_STORICO_PARTICELLA      DB_CONDUZIONE_DICHIARATA.ID_STORICO_PARTICELLA%TYPE,
                           CODICE_FOTOGRAFIA_TERRENI  DB_CONDUZIONE_DICHIARATA.CODICE_FOTOGRAFIA_TERRENI%TYPE);

  TYPE recPart IS RECORD(ID_COPA                  DB_CONDUZIONE_DICHIARATA.ID_COPA%TYPE,
                         ID_PARTICELLA            DB_CONDUZIONE_DICHIARATA.ID_PARTICELLA%TYPE,
                         ID_PRATICA_MANTENIMENTO  DB_UTILIZZO_DICHIARATO.ID_PRATICA_MANTENIMENTO%TYPE,
                         ID_CATALOGO_GRAFICO      DB_R_CATALOGO_MATRICE.ID_CATALOGO_GRAFICO%TYPE,
                         FLAG_PRATO_PERMANENTE    DB_R_CATALOGO_MATRICE.FLAG_PRATO_PERMANENTE%TYPE);

  TYPE tblPart   IS TABLE OF recPart INDEX BY BINARY_INTEGER;
  TYPE tblConDic IS TABLE OF recConDic INDEX BY BINARY_INTEGER;

  nIdParticellaPrec   DB_STORICO_PARTICELLA.ID_PARTICELLA%TYPE := NULL;
  bRotturaPart        BOOLEAN := FALSE;
  SitiSuoloIni        tblSitiSuolo := tblSitiSuolo();
  SitiSuolo           tblSitiSuolo := tblSitiSuolo();
  deusIds             ORA_MINING_NUMBER_NT := ORA_MINING_NUMBER_NT();
  poliIds             ORA_MINING_NUMBER_NT := ORA_MINING_NUMBER_NT();
  superficiDeus       ORA_MINING_NUMBER_NT := ORA_MINING_NUMBER_NT();
  superficiPoli       ORA_MINING_NUMBER_NT := ORA_MINING_NUMBER_NT();
  tipiDeus            ORA_MINING_VARCHAR2_NT := ORA_MINING_VARCHAR2_NT();
  compatibilita       ORA_MINING_VARCHAR2_NT := ORA_MINING_VARCHAR2_NT();
  supUtilizziGis      superfici_utilizzi_gis_tab;
  tipiPoli            ORA_MINING_VARCHAR2_NT := ORA_MINING_VARCHAR2_NT();
  ConDic              tblConDic;
  Part                tblPart;
  sgShape             SDO_GEOMETRY;
  nIdDeusIns          DB_UTILIZZO_DICHIARATO.ID_DEUS%TYPE;
  nIdDeus             DB_UTILIZZO_DICHIARATO.ID_DEUS%TYPE;
  nIdShape            DB_UTILIZZO_DICHIARATO.ID_SHAPE%TYPE;
  ArrayShape          SDO_GEOMETRY_ARRAY := SDO_GEOMETRY_ARRAY();
  nIdDeusPrec         DB_UTILIZZO_DICHIARATO.ID_DEUS%TYPE := NULL;
  bRotturaDeus        BOOLEAN := FALSE;
  nSupPrec            NUMBER := 0;
  vCodiVari           VARCHAR2(3);
  vCodiProdRile       DB_UTILIZZO_DICHIARATO.CODI_PROD_RILE%TYPE;
  vCodiRile           DB_UTILIZZO_DICHIARATO.CODI_RILE%TYPE;
  bErrore             BOOLEAN := FALSE;
  nIdAzienda          DB_ACCESSO_PIANO_GRAFICO.ID_AZIENDA%TYPE;
  vCodiceUtilita      DB_ACCESSO_PIANO_GRAFICO.CODICE_UTILITA%TYPE;
  nIdUtente           DB_ACCESSO_PIANO_GRAFICO.ID_UTENTE%TYPE;
  nIdGrafico          DB_ACCESSO_PIANO_GRAFICO.ID_GRAFICO%TYPE;
  nContIdDeus         SIMPLE_INTEGER := 0;
  nIdEsitoGrafico     DB_ACCESSO_PIANO_GRAFICO.ID_ESITO_GRAFICO%TYPE;
  nIdPoli             DB_UTILIZZO_DICHIARATO.ID_POLI%TYPE;
  vCuaa               DB_ANAGRAFICA_AZIENDA.CUAA%TYPE;
  DeusPoliType        tabDeusPoliType_AG;
  ApcgTabe            tabApcgType;
  DeusPoliTabe        tabDeusPoliType_wp2 := tabDeusPoliType_wp2();
  Appezz              tblAppezz;
  nCont               SIMPLE_INTEGER := 0;
  nIdAppezPrec        NUMBER;
  nProgrAppez         NUMBER;
  nProgrIsola         NUMBER;
  nIdCatalogoGrafico  DB_R_CATALOGO_GRAFICO.ID_CATALOGO_GRAFICO%TYPE;
  nContSiti           SIMPLE_INTEGER := 0;
  nPriorita           NUMBER;
  ArrayShapeSuolo     SDO_GEOMETRY_ARRAY := SDO_GEOMETRY_ARRAY();
  vCodiVariSuolo      VARCHAR2(3);
  nPrioritaPrec       NUMBER := 99;
  nRecPrVincente      NUMBER := 1;
  nTara               NUMBER := 0;
  nAreaColt           NUMBER := 0;
BEGIN

 --dbms_output.put_line(' punto zero ');
  SELECT APG.ID_ESITO_GRAFICO,AA.CUAA,APG.CODICE_UTILITA
  INTO   nIdEsitoGrafico,vCuaa,vCodiceUtilita
  FROM   DB_ACCESSO_PIANO_GRAFICO APG,DB_ANAGRAFICA_AZIENDA AA
  WHERE  APG.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
  AND    APG.DATA_FINE_VALIDITA           IS NULL
  AND    APG.ID_AZIENDA                   = AA.ID_AZIENDA
  AND    AA.DATA_FINE_VALIDITA            IS NULL;

  -- se il piano grafico e' gia' stato caricato correttamento non si fa nulla
  IF nIdEsitoGrafico = 10 THEN
    RETURN 0;
  END IF;

  IF vCodiceUtilita = '0' THEN
    RETURN 1;
  END IF;

  -- aggiornamento ID_COPA
  SELECT CD.ID_STORICO_PARTICELLA,CD.CODICE_FOTOGRAFIA_TERRENI
  BULK COLLECT INTO ConDic
  FROM   DB_ACCESSO_PIANO_GRAFICO APG,DB_ANAGRAFICA_AZIENDA AA,DB_DICHIARAZIONE_CONSISTENZA DC,
         DB_CONDUZIONE_DICHIARATA CD
  WHERE  APG.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
  AND    APG.DATA_FINE_VALIDITA           IS NULL
  AND    APG.ID_AZIENDA                   = AA.ID_AZIENDA
  AND    AA.DATA_FINE_VALIDITA            IS NULL
  AND    APG.ID_DICHIARAZIONE_CONSISTENZA IS NOT NULL
  AND    DC.ID_DICHIARAZIONE_CONSISTENZA  = APG.ID_DICHIARAZIONE_CONSISTENZA
  AND    DC.CODICE_FOTOGRAFIA_TERRENI     = CD.CODICE_FOTOGRAFIA_TERRENI
  AND    CD.ID_TITOLO_POSSESSO            NOT IN (5,6)
  GROUP BY CD.ID_STORICO_PARTICELLA,CD.CODICE_FOTOGRAFIA_TERRENI;

  IF ConDic.FIRST IS NOT NULL THEN
    FOR i IN ConDic.FIRST..ConDic.LAST LOOP
      UPDATE DB_CONDUZIONE_DICHIARATA
      SET    ID_COPA                   = SEQ_ID_COPA.NEXTVAL
      WHERE  ID_STORICO_PARTICELLA     = ConDic(i).ID_STORICO_PARTICELLA
      AND    CODICE_FOTOGRAFIA_TERRENI = ConDic(i).CODICE_FOTOGRAFIA_TERRENI;
    END LOOP;
  END IF;

  -- Aggiornamento ID_DEUS
  SELECT CD.ID_COPA,CD.ID_PARTICELLA,UD.ID_PRATICA_MANTENIMENTO,CM.ID_CATALOGO_GRAFICO,
         CM.FLAG_PRATO_PERMANENTE
  BULK COLLECT INTO Part
  FROM   DB_DICHIARAZIONE_CONSISTENZA DC,DB_CONDUZIONE_DICHIARATA CD,
         DB_UTILIZZO_DICHIARATO UD,DB_R_CATALOGO_MATRICE CM
  WHERE  DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
  AND    DC.CODICE_FOTOGRAFIA_TERRENI    = CD.CODICE_FOTOGRAFIA_TERRENI
  AND    CD.ID_CONDUZIONE_DICHIARATA     = UD.ID_CONDUZIONE_DICHIARATA
  AND    CD.ID_TITOLO_POSSESSO           NOT IN (5,6)
  AND    CM.ID_CATALOGO_MATRICE          = UD.ID_CATALOGO_MATRICE
  GROUP BY CD.ID_COPA,CD.ID_PARTICELLA,UD.ID_PRATICA_MANTENIMENTO,CM.ID_CATALOGO_GRAFICO,
           CM.FLAG_PRATO_PERMANENTE;

  IF Part.FIRST IS NOT NULL THEN
    FOR i IN Part.FIRST..Part.LAST LOOP
      nIdDeusIns := SEQ_ID_DEUS.NEXTVAL;

      UPDATE DB_UTILIZZO_DICHIARATO
      SET    ID_DEUS                        = nIdDeusIns
      WHERE  ID_CONDUZIONE_DICHIARATA       IN (SELECT ID_CONDUZIONE_DICHIARATA
                                                FROM   DB_CONDUZIONE_DICHIARATA
                                                WHERE  ID_COPA       = Part(i).ID_COPA
                                                AND    ID_PARTICELLA = Part(i).ID_PARTICELLA)
      AND    NVL(ID_PRATICA_MANTENIMENTO,0) = NVL(Part(i).ID_PRATICA_MANTENIMENTO,0)
      AND    ID_CATALOGO_MATRICE            IN (SELECT ID_CATALOGO_MATRICE
                                                FROM   DB_R_CATALOGO_MATRICE
                                                WHERE  ID_CATALOGO_GRAFICO = Part(i).ID_CATALOGO_GRAFICO);
    END LOOP;
  END IF;
  commit;

  --dbms_output.put_line('Primo punto');

  FOR rec IN (SELECT SP.ID_PARTICELLA,C.ISTAT_COMUNE,SP.SEZIONE,SP.FOGLIO,SP.PARTICELLA,
                     CD.ID_CONDUZIONE_DICHIARATA,CD.CODICE_FOTOGRAFIA_TERRENI,CD.ID_STORICO_PARTICELLA,
                     CD.ID_COPA
              FROM   DB_ACCESSO_PIANO_GRAFICO APG,DB_ANAGRAFICA_AZIENDA AA,
                     DB_DICHIARAZIONE_CONSISTENZA DC,DB_CONDUZIONE_DICHIARATA CD,DB_STORICO_PARTICELLA SP,
                     COMUNE C
              WHERE  APG.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
              AND    APG.DATA_FINE_VALIDITA           IS NULL
              AND    APG.ID_AZIENDA                   = AA.ID_AZIENDA
              AND    AA.DATA_FINE_VALIDITA            IS NULL
              AND    APG.ID_DICHIARAZIONE_CONSISTENZA IS NOT NULL
              AND    DC.ID_DICHIARAZIONE_CONSISTENZA  = APG.ID_DICHIARAZIONE_CONSISTENZA
              AND    DC.CODICE_FOTOGRAFIA_TERRENI     = CD.CODICE_FOTOGRAFIA_TERRENI
              AND    CD.ID_TITOLO_POSSESSO            NOT IN (5,6)
              AND    SP.ID_STORICO_PARTICELLA         = CD.ID_STORICO_PARTICELLA
              AND    SP.COMUNE                        = C.ISTAT_COMUNE
              ORDER BY SP.ID_PARTICELLA) LOOP

    IF nIdParticellaPrec IS NULL THEN
      nIdParticellaPrec := rec.ID_PARTICELLA;
      bRotturaPart      := TRUE;
    ELSE
      IF nIdParticellaPrec = rec.ID_PARTICELLA THEN
        bRotturaPart := FALSE;
      ELSE
        nIdParticellaPrec := rec.ID_PARTICELLA;
        bRotturaPart      := TRUE;
      END IF;
    END IF;

    --dbms_output.put_line('Secondo  punto');
    -- a rottura di id particella
    IF bRotturaPart THEN
      SitiSuoloIni.DELETE;
      deusIds.DELETE;
      poliIds.DELETE;
      superficiDeus.DELETE;
      superficiPoli.DELETE;
      tipiPoli.DELETE;
      SitiSuolo.DELETE;
      nContSiti := 0;

      SitiSuoloIni := datiSuoloPerPianoGrafico(rec.ISTAT_COMUNE,
                                               rec.SEZIONE,
                                               rec.FOGLIO,
                                               rec.PARTICELLA);

     -- dbms_output.put_line('sitiSuoloIni.count = '||SitiSuoloIni.COUNT);

      SELECT DISTINCT UD.ID_DEUS
      BULK COLLECT INTO deusIds
      FROM  DB_UTILIZZO_DICHIARATO UD,DB_CONDUZIONE_DICHIARATA CD
      WHERE CD.ID_COPA                  = rec.ID_COPA
      AND   UD.ID_CONDUZIONE_DICHIARATA = CD.ID_CONDUZIONE_DICHIARATA;

      SELECT SUM(NVL(UD.SUPERFICIE_UTILIZZATA,0))*10000,'D'||TU.CODICE
      BULK COLLECT INTO superficiDeus,tipiDeus
      FROM  DB_UTILIZZO_DICHIARATO UD,DB_R_CATALOGO_MATRICE CM,DB_TIPO_UTILIZZO TU,
            DB_CONDUZIONE_DICHIARATA CD,DB_R_CATALOGO_GRAFICO CG
      WHERE CD.ID_COPA                  = rec.ID_COPA
      AND   UD.ID_CONDUZIONE_DICHIARATA = CD.ID_CONDUZIONE_DICHIARATA
      AND   UD.ID_CATALOGO_MATRICE      = CM.ID_CATALOGO_MATRICE
      AND   CM.ID_CATALOGO_GRAFICO      = CG.ID_CATALOGO_GRAFICO
      AND   CG.ID_UTILIZZO              = TU.ID_UTILIZZO
      GROUP BY UD.ID_DEUS,TU.CODICE;

      SELECT DISTINCT 'D'||TU.CODICE||'='|| 'P'||TEF.CODI_RILE||'-'||TER.CODI_RILE_PROD
      BULK COLLECT INTO compatibilita
      FROM  DB_UTILIZZO_DICHIARATO UD,DB_R_CATALOGO_MATRICE CM,DB_TIPO_UTILIZZO TU,DB_VARIETA_ELEGGIBILITA VE,
            DB_TIPO_ELEGGIBILITA_FIT TEF,DB_TIPO_ELEGGIBILITA_RILEVATA TER,DB_R_CATALOGO_GRAFICO CG
      WHERE UD.ID_CONDUZIONE_DICHIARATA = rec.ID_CONDUZIONE_DICHIARATA
      AND   UD.ID_CATALOGO_MATRICE      = CM.ID_CATALOGO_MATRICE
      AND   CM.ID_CATALOGO_GRAFICO      = CG.ID_CATALOGO_GRAFICO
      AND   CG.ID_UTILIZZO              = TU.ID_UTILIZZO
      AND   TEF.ID_ELEGGIBILITA_FIT     = VE.ID_ELEGGIBILITA_FIT
      AND   TEF.ID_ELEGGIBILITA_FIT     = TER.ID_ELEGGIBILITA_FIT
      AND   VE.DATA_FINE_VALIDITA       IS NULL
      AND   TEF.DATA_FINE_VALIDITA      IS NULL
      AND   TER.DATA_FINE_VALIDITA      IS NULL
      AND   VE.ID_CATALOGO_MATRICE      = CM.ID_CATALOGO_MATRICE;

      IF SitiSuoloIni.COUNT > 0 THEN
        FOR recCatGraf IN (SELECT DISTINCT CCE.ID_CATALOGO_GRAFICO
                           FROM   DB_R_CATALOGO_COMPATIBIL_ELEG CCE,DB_UTILIZZO_DICHIARATO UD,
                                  DB_R_CATALOGO_MATRICE CM,DB_CONDUZIONE_DICHIARATA CD,
                                  DB_R_CATALOGO_GRAFICO CG
                           WHERE  CCE.ID_CATALOGO_GRAFICO     = CG.ID_CATALOGO_GRAFICO
                           AND    CCE.DATA_FINE_VALIDITA      IS NULL
                           AND    CD.ID_COPA                  = rec.ID_COPA
                           AND    UD.ID_CONDUZIONE_DICHIARATA = CD.ID_CONDUZIONE_DICHIARATA
                           AND    UD.ID_CATALOGO_MATRICE      = CM.ID_CATALOGO_MATRICE
                           AND    CM.ID_CATALOGO_GRAFICO      = CG.ID_CATALOGO_GRAFICO
                           AND    CD.ID_TITOLO_POSSESSO       NOT IN (5,6)
                           AND    CCE.FLAG_PRIORITA           = (SELECT MIN(CCE.FLAG_PRIORITA)
                                                                 FROM   DB_R_CATALOGO_COMPATIBIL_ELEG CCE,DB_UTILIZZO_DICHIARATO UD,
                                                                        DB_R_CATALOGO_MATRICE CM,DB_CONDUZIONE_DICHIARATA CD,
                                                                        DB_R_CATALOGO_GRAFICO CG
                                                                 WHERE  CCE.ID_CATALOGO_GRAFICO     = CG.ID_CATALOGO_GRAFICO
                                                                 AND    CCE.DATA_FINE_VALIDITA      IS NULL
                                                                 AND    CD.ID_COPA                  = rec.ID_COPA
                                                                 AND    CD.ID_TITOLO_POSSESSO       NOT IN (5,6)
                                                                 AND    UD.ID_CONDUZIONE_DICHIARATA = CD.ID_CONDUZIONE_DICHIARATA
                                                                 AND    UD.ID_CATALOGO_MATRICE      = CM.ID_CATALOGO_MATRICE
                                                                 AND    CM.ID_CATALOGO_GRAFICO      = CG.ID_CATALOGO_GRAFICO)) LOOP

          ArrayShapeSuolo.DELETE;
          nPrioritaPrec  := 99;
          nRecPrVincente := 0;
          nTara          := 0;
          nAreaColt      := 0;

          FOR i IN 1..SitiSuoloIni.COUNT LOOP
            BEGIN
              SELECT E.PRIORITA
              INTO   nPriorita
              FROM   DB_R_CATALOGO_COMPATIBIL_ELEG CCE,SITICODS_ELVA E,DB_TIPO_ELEGGIBILITA_FIT TEF
              WHERE  CCE.ID_CATALOGO_GRAFICO = recCatGraf.ID_CATALOGO_GRAFICO
              AND    CCE.DATA_FINE_VALIDITA  IS NULL
              AND    TEF.ID_ELEGGIBILITA_FIT = CCE.ID_ELEGGIBILITA_FIT
              AND    E.COD_ELE_FITTIZIA      = TEF.CODICE
              AND    E.COD_VARI              = SitiSuoloIni(i).CODI_VARI;

--              dbms_output.put_line('-- elemento sitisuolo = '||i);
--                            dbms_output.put_line('-----codiVari = '||SitiSuoloIni(i).CODI_VARI);
--                                          dbms_output.put_line('-----areaColt = '||SitiSuoloIni(i).area_colt);
--                                          dbms_output.put_line('-----PROG_POLI = '||SitiSuoloIni(i).PROG_POLI);
--
              ArrayShapeSuolo.EXTEND(1);
              ArrayShapeSuolo(ArrayShapeSuolo.COUNT) := SitiSuoloIni(i).SHAPE;
              nTara                                  := nTara + SitiSuoloIni(i).TARA;
              nAreaColt                              := nAreaColt + SitiSuoloIni(i).AREA_COLT;

              IF nPrioritaPrec > nPriorita THEN
                vCodiVariSuolo := SitiSuoloIni(i).CODI_VARI;
                nPrioritaPrec  := nPriorita;
                nRecPrVincente := i;
              END IF;
            EXCEPTION
              WHEN NO_DATA_FOUND THEN
                SitiSuolo.EXTEND;
                nContSiti            := nContSiti + 1;
                SitiSuolo(nContSiti) := SitiSuoloIni(i);

--                dbms_output.put_line('--EXCEPTION elemento sitisuolo = '||i);
--                            dbms_output.put_line('-----EXCEPTION codiVari = '||SitiSuoloIni(i).CODI_VARI);
--                                          dbms_output.put_line('-----EXCEPTION areaColt = '||SitiSuoloIni(i).area_colt);
--                                          dbms_output.put_line('-----EXCEPTION PROG_POLI = '||SitiSuoloIni(i).PROG_POLI);
            END;
          END LOOP;

          IF nRecPrVincente != 0 THEN
            SitiSuolo.EXTEND;
            nContSiti                      := nContSiti + 1;
            SitiSuolo(nContSiti)           := SitiSuoloIni(nRecPrVincente);
            SitiSuolo(nContSiti).CODI_VARI := vCodiVariSuolo;
            SitiSuolo(nContSiti).SHAPE     := unisciShape(ArrayShapeSuolo);
            SitiSuolo(nContSiti).TARA      := nTara;
            SitiSuolo(nContSiti).AREA_COLT := nAreaColt;
          END IF;
        END LOOP;

        FOR i IN 1..SitiSuoloIni.COUNT LOOP
          BEGIN
            SELECT DISTINCT E.PRIORITA
            INTO   nPriorita
            FROM   DB_R_CATALOGO_COMPATIBIL_ELEG CCE,SITICODS_ELVA E,DB_TIPO_ELEGGIBILITA_FIT TEF
            WHERE  CCE.DATA_FINE_VALIDITA  IS NULL
            AND    TEF.ID_ELEGGIBILITA_FIT = CCE.ID_ELEGGIBILITA_FIT
            AND    E.COD_ELE_FITTIZIA      = TEF.CODICE
            AND    E.COD_VARI              = SitiSuoloIni(i).CODI_VARI
            AND    CCE.ID_CATALOGO_GRAFICO IN (SELECT CCE.ID_CATALOGO_GRAFICO
                                               FROM   DB_R_CATALOGO_COMPATIBIL_ELEG CCE1,DB_UTILIZZO_DICHIARATO UD,
                                                      DB_R_CATALOGO_MATRICE CM,DB_CONDUZIONE_DICHIARATA CD,
                                                      DB_R_CATALOGO_GRAFICO CG
                                               WHERE  CCE1.ID_CATALOGO_GRAFICO     = CG.ID_CATALOGO_GRAFICO
                                               AND    CCE1.DATA_FINE_VALIDITA      IS NULL
                                               AND    CD.ID_COPA                  = rec.ID_COPA
                                               AND    UD.ID_CONDUZIONE_DICHIARATA = CD.ID_CONDUZIONE_DICHIARATA
                                               AND    UD.ID_CATALOGO_MATRICE      = CM.ID_CATALOGO_MATRICE
                                               AND    CM.ID_CATALOGO_GRAFICO      = CG.ID_CATALOGO_GRAFICO
                                               AND    CD.ID_TITOLO_POSSESSO       NOT IN (5,6)
                                               AND    CCE1.FLAG_PRIORITA           = (SELECT MIN(CCE.FLAG_PRIORITA)
                                                                                      FROM   DB_R_CATALOGO_COMPATIBIL_ELEG CCE2,DB_UTILIZZO_DICHIARATO UD2,
                                                                                             DB_R_CATALOGO_MATRICE CM2,DB_CONDUZIONE_DICHIARATA CD2,
                                                                                             DB_R_CATALOGO_GRAFICO CG2
                                                                                      WHERE  CCE2.ID_CATALOGO_GRAFICO     = CG2.ID_CATALOGO_GRAFICO
                                                                                      AND    CCE2.DATA_FINE_VALIDITA      IS NULL
                                                                                      AND    CD2.ID_COPA                  = rec.ID_COPA
                                                                                      AND    UD2.ID_CONDUZIONE_DICHIARATA = CD2.ID_CONDUZIONE_DICHIARATA
                                                                                      AND    UD2.ID_CATALOGO_MATRICE      = CM2.ID_CATALOGO_MATRICE
                                                                                      AND    CM2.ID_CATALOGO_GRAFICO      = CG2.ID_CATALOGO_GRAFICO));
          EXCEPTION
            WHEN NO_DATA_FOUND THEN
              SitiSuolo.EXTEND;
              nContSiti            := nContSiti + 1;
              SitiSuolo(nContSiti) := SitiSuoloIni(i);
          END;
        END LOOP;
      END IF;

--      dbms_output.put_line('sitiSuolo.count = '||SitiSuolo.COUNT);

      IF SitiSuolo.COUNT > 0 THEN
        FOR i IN 1..SitiSuolo.COUNT LOOP
          poliIds.EXTEND;
          superficiPoli.EXTEND;
          tipiPoli.EXTEND;

          poliIds(i)       := SitiSuolo(i).PROG_POLI;
          superficiPoli(i) := ROUND(SitiSuolo(i).AREA_COLT);

--          DBMS_OUTPUT.PUT_LINE('SitiSuolo(i).CODI_VARI = '||SitiSuolo(i).CODI_VARI);
--          DBMS_OUTPUT.PUT_LINE('SitiSuolo(i).area_colt = '||SitiSuolo(i).area_colt);
--          DBMS_OUTPUT.PUT_LINE('SitiSuolo(i).PROG_POLI = '||SitiSuolo(i).PROG_POLI);

          SELECT DISTINCT 'P'||TEF.CODI_RILE||'-'||TER.CODI_RILE_PROD
          INTO   tipiPoli(i)
          FROM   DB_TIPO_ELEGGIBILITA_RILEVATA TER,DB_TIPO_ELEGGIBILITA_FIT TEF
          WHERE  TEF.ID_ELEGGIBILITA_FIT = TER.ID_ELEGGIBILITA_FIT
          AND    TEF.DATA_FINE_VALIDITA  IS NULL
          AND    TER.DATA_FINE_VALIDITA  IS NULL
          AND    TER.CODI_RILE_PROD      = SitiSuolo(i).CODI_VARI;

--          DBMS_OUTPUT.PUT_LINE('poliIds(i) = '||poliIds(i));
--          DBMS_OUTPUT.PUT_LINE('superficiPoli(i) = '||superficiPoli(i));
--          DBMS_OUTPUT.PUT_LINE('tipiPoli(i) = '||tipiPoli(i));

        END LOOP;
      END IF;

      bErrore := FALSE;

      /*for x in deusIds.first..deusIds.last loop
        dbms_output.put_line('deusIds = '||deusIds(x));
      end loop;

      for x in poliIds.first..poliIds.last loop
        dbms_output.put_line('poliIds = '||poliIds(x));
      end loop;*/

--      for x in superficiDeus.first..superficiDeus.last loop
--    --    dbms_output.put_line('superficiDeus = '||superficiDeus(x));
--      end loop;
--
--      for x in superficiPoli.first..superficiPoli.last loop
--   --     dbms_output.put_line('superficiPoli = '||superficiPoli(x));
--      end loop;
--
--      for x in tipiDeus.first..tipiDeus.last loop
--   --     dbms_output.put_line('tipiDeus = '||tipiDeus(x));
--      end loop;

      /*for x in tipiPoli.first..tipiPoli.last loop
        dbms_output.put_line('tipiPoli = '||tipiPoli(x));
      end loop;*/
      /*
     for x in compatibilita.first..compatibilita.last loop
        dbms_output.put_line('compatibilita = '||compatibilita(x));
      end loop;
      */
      supUtilizziGis := EseguiAssegnazioniInGruppi(deusIds,
                                                   poliIds,
                                                   superficiDeus,
                                                   superficiPoli,
                                                   tipiDeus,
                                                   tipiPoli,
                                                   compatibilita,
                                                   deusIds.COUNT,
                                                   poliIds.COUNT,
                                                   1,
                                                   1,
                                                   1000);

      -- gestione casistiche di errore
      SELECT COUNT(*)
      INTO   nContIdDeus
      FROM   (SELECT DISTINCT ID_DEUS
              FROM   TABLE(supUtilizziGis));


--      DBMS_OUTPUT.PUT_LINE('supUtilizziGis.COUNT = '||supUtilizziGis.COUNT);
--      DBMS_OUTPUT.PUT_LINE('nContIdDeus = '||nContIdDeus);
--      DBMS_OUTPUT.PUT_LINE('deusIds.COUNT = '||deusIds.COUNT);
      IF supUtilizziGis.COUNT = 0 OR nContIdDeus != deusIds.COUNT THEN
        /*bErrore := TRUE;
        EXIT;*/
  --      DBMS_OUTPUT.PUT_LINE('RICHIAMO EseguiAssegnazioniInGruppi CON SitiSuoloIni');
        poliIds.DELETE;
        superficiPoli.DELETE;
        tipiPoli.DELETE;
        SitiSuolo.DELETE;

        SitiSuolo := SitiSuoloIni;
      --  nVeri := 0;

        IF SitiSuolo.COUNT > 0 THEN
          FOR i IN 1..SitiSuolo.COUNT LOOP
           -- if SitiSuolo(i).CODI_VARI = 651 or SitiSuolo(i).CODI_VARI = 690 then
            poliIds.EXTEND;
            superficiPoli.EXTEND;
            tipiPoli.EXTEND;
           -- nVeri:= nVeri + 1;

            --poliIds(nVeri)       := SitiSuolo(i).PROG_POLI;
            --superficiPoli(nVeri) := ROUND(SitiSuolo(i).AREA_COLT);
            poliIds(i)       := SitiSuolo(i).PROG_POLI;
            superficiPoli(i) := ROUND(SitiSuolo(i).AREA_COLT);

--            DBMS_OUTPUT.PUT_LINE('SitiSuolo(i).CODI_VARI = '||SitiSuolo(i).CODI_VARI);
--            DBMS_OUTPUT.PUT_LINE('SitiSuolo(i).area_colt = '||SitiSuolo(i).area_colt);
--            DBMS_OUTPUT.PUT_LINE('SitiSuolo(i).PROG_POLI = '||SitiSuolo(i).PROG_POLI);

            SELECT DISTINCT 'P'||TEF.CODI_RILE||'-'||TER.CODI_RILE_PROD
            INTO   tipiPoli(i)
            FROM   DB_TIPO_ELEGGIBILITA_RILEVATA TER,DB_TIPO_ELEGGIBILITA_FIT TEF
            WHERE  TEF.ID_ELEGGIBILITA_FIT = TER.ID_ELEGGIBILITA_FIT
            AND    TEF.DATA_FINE_VALIDITA  IS NULL
            AND    TER.DATA_FINE_VALIDITA  IS NULL
            AND    TER.CODI_RILE_PROD      = SitiSuolo(i).CODI_VARI;

--            DBMS_OUTPUT.PUT_LINE('poliIds(i) = '||poliIds(i));
--            DBMS_OUTPUT.PUT_LINE('superficiPoli(i) = '||superficiPoli(i));
--            DBMS_OUTPUT.PUT_LINE('tipiPoli(i) CON SitiSuoloIni = '||tipiPoli(i));
           -- end if;
          END LOOP;
        END IF;

--        for x in tipiDeus.first..tipiDeus.last loop
--   --       dbms_output.put_line('tipiDeus CON SitiSuoloIni = '||tipiDeus(x));
--        end loop;
--
--        for x in superficiDeus.first..superficiDeus.last loop
--     --     dbms_output.put_line('superficiDeus CON SitiSuoloIni = '||superficiDeus(x));
--        end loop;
--
--        for x in superficiPoli.first..superficiPoli.last loop
--    --      dbms_output.put_line('superficiPoli CON SitiSuoloIni = '||superficiPoli(x));
--        end loop;

        supUtilizziGis := EseguiAssegnazioniInGruppi(deusIds,
                                                     poliIds,
                                                     superficiDeus,
                                                     superficiPoli,
                                                     tipiDeus,
                                                     tipiPoli,
                                                     compatibilita,
                                                     deusIds.COUNT,
                                                     poliIds.COUNT,
                                                     1,
                                                     1,
                                                     1000);

        -- gestione casistiche di errore
        SELECT COUNT(*)
        INTO   nContIdDeus
        FROM   (SELECT DISTINCT ID_DEUS
                FROM   TABLE(supUtilizziGis));

--        DBMS_OUTPUT.PUT_LINE('supUtilizziGis.COUNT CON SitiSuoloIni = '||supUtilizziGis.COUNT);
--        DBMS_OUTPUT.PUT_LINE('nContIdDeus CON SitiSuoloIni = '||nContIdDeus);
--        DBMS_OUTPUT.PUT_LINE('deusIds.COUNT CON SitiSuoloIni = '||deusIds.COUNT);
--        DBMS_OUTPUT.PUT_LINE('supUtilizziGis(1).ID_DEUS = '||supUtilizziGis(1).ID_DEUS);


        IF supUtilizziGis.COUNT = 0 OR nContIdDeus != deusIds.COUNT THEN
          bErrore := TRUE;
          --EXIT;
          RETURN 6;
        END IF;
      END IF;

      IF supUtilizziGis.COUNT = 1 THEN
        --DBMS_OUTPUT.PUT_LINE('supUtilizziGis(1).ID_DEUS = '||supUtilizziGis(1).ID_DEUS);
        FOR k IN 1..SitiSuolo.COUNT LOOP
          IF supUtilizziGis(1).ID_POLI = SitiSuolo(k).PROG_POLI THEN
            sgShape   := SitiSuolo(k).SHAPE;
            nIdDeus   := supUtilizziGis(1).ID_DEUS;
            nIdShape  := SitiSuolo(k).ID_SHAPE;
            vCodiVari := SitiSuolo(k).CODI_VARI;
            nIdPoli   := SitiSuolo(k).PROG_POLI;
          END IF;
        END LOOP;

        SELECT CODI_RILE_PROD, CODI_RILE
        INTO   vCodiProdRile,vCodiRile
        FROM   DB_TIPO_ELEGGIBILITA_RILEVATA TER,DB_TIPO_ELEGGIBILITA_FIT TEF
        WHERE  TEF.ID_ELEGGIBILITA_FIT = TER.ID_ELEGGIBILITA_FIT
        AND    TEF.DATA_FINE_VALIDITA  IS NULL
        AND    TER.DATA_FINE_VALIDITA  IS NULL
        AND    TER.CODI_RILE_PROD      = vCodiVari;

        UPDATE DB_UTILIZZO_DICHIARATO
        SET    SHAPE          = sgShape,
               ID_SHAPE       = nIdShape,
               CODI_PROD_RILE = vCodiProdRile,
               CODI_RILE      = vCodiRile,
               ID_POLI        = nIdPoli
        WHERE  ID_DEUS        = nIdDeus;

        /*dbms_output.put_line('-----primo-----');
        dbms_output.put_line('nIdDeus = '||nIdDeus);
        dbms_output.put_line('nIdPoli = '||nIdPoli);
        dbms_output.put_line('-----primo-----');*/
      ELSE
        nSupPrec     := 0;
        vCodiVari    := NULL;
        nIdDeusPrec  := NULL;
        bRotturaDeus := FALSE;

        FOR j IN 1..supUtilizziGis.COUNT loop
      --    DBMS_OUTPUT.PUT_LINE('supUtilizziGis(j).ID_DEUS = '||supUtilizziGis(j).ID_DEUS);
          IF nIdDeusPrec IS NULL THEN
            nIdDeusPrec  := supUtilizziGis(j).ID_DEUS;
            bRotturaDeus := FALSE;
          ELSE
            IF nIdDeusPrec = supUtilizziGis(j).ID_DEUS THEN
              bRotturaDeus := FALSE;
            ELSE
              bRotturaDeus := TRUE;
            END IF;
          END IF;

          IF bRotturaDeus THEN
            sgShape := unisciShape(ArrayShape);

            SELECT CODI_RILE_PROD, CODI_RILE
            INTO   vCodiProdRile,vCodiRile
            FROM   DB_TIPO_ELEGGIBILITA_RILEVATA TER,DB_TIPO_ELEGGIBILITA_FIT TEF
            WHERE  TEF.ID_ELEGGIBILITA_FIT = TER.ID_ELEGGIBILITA_FIT
            AND    TEF.DATA_FINE_VALIDITA  IS NULL
            AND    TER.DATA_FINE_VALIDITA  IS NULL
            AND    TER.CODI_RILE_PROD      = vCodiVari;

            UPDATE DB_UTILIZZO_DICHIARATO
            SET    SHAPE          = sgShape,
                   ID_SHAPE       = nIdShape,
                   CODI_PROD_RILE = vCodiProdRile,
                   CODI_RILE      = vCodiRile,
                   ID_POLI        = nIdPoli
            WHERE  ID_DEUS        = nIdDeusPrec;

            /*dbms_output.put_line('-----secondo-----');
            dbms_output.put_line('nIdDeus = '||nIdDeusPrec);
            dbms_output.put_line('nIdPoli = '||nIdPoli);
            dbms_output.put_line('-----secondo-----');*/

            ArrayShape.DELETE;
            nSupPrec    := 0;
            vCodiVari   := NULL;
            nIdDeusPrec := supUtilizziGis(j).ID_DEUS;
          END IF;

          FOR k IN 1..SitiSuolo.COUNT LOOP
            IF supUtilizziGis(j).ID_POLI = SitiSuolo(k).PROG_POLI THEN
              ArrayShape.EXTEND(1);
              ArrayShape(ArrayShape.COUNT) := SitiSuolo(k).SHAPE;
              nIdShape                     := SitiSuolo(k).ID_SHAPE;
              nIdPoli                      := SitiSuolo(k).PROG_POLI;
              vCodiVari                    := SitiSuolo(k).CODI_VARI;

              IF nSupPrec < SitiSuolo(k).AREA_COLT THEN
                nSupPrec := SitiSuolo(k).AREA_COLT;
              END IF;
            END IF;
          END LOOP;
        END LOOP;

        sgShape := unisciShape(ArrayShape);

        SELECT CODI_RILE_PROD, CODI_RILE
        INTO   vCodiProdRile,vCodiRile
        FROM   DB_TIPO_ELEGGIBILITA_RILEVATA TER,DB_TIPO_ELEGGIBILITA_FIT TEF
        WHERE  TEF.ID_ELEGGIBILITA_FIT = TER.ID_ELEGGIBILITA_FIT
        AND    TEF.DATA_FINE_VALIDITA  IS NULL
        AND    TER.DATA_FINE_VALIDITA  IS NULL
        AND    TER.CODI_RILE_PROD      = vCodiVari;

        UPDATE DB_UTILIZZO_DICHIARATO
        SET    SHAPE          = sgShape,
               ID_SHAPE       = nIdShape,
               CODI_PROD_RILE = vCodiProdRile,
               CODI_RILE      = vCodiRile,
               ID_POLI        = nIdPoli
        WHERE  ID_DEUS        = nIdDeusPrec;

        /*dbms_output.put_line('-----terzo-----');
        dbms_output.put_line('nIdDeus = '||nIdDeusPrec);
        dbms_output.put_line('nIdPoli = '||nIdPoli);
        dbms_output.put_line('-----terzo-----');*/
      END IF;
    END IF;
  END LOOP;

  IF bErrore THEN
    ROLLBACK;

    UPDATE DB_ACCESSO_PIANO_GRAFICO
    SET    DATA_FINE_VALIDITA           = SYSDATE
    WHERE  ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
    AND    DATA_FINE_VALIDITA           IS NULL
    RETURNING ID_AZIENDA,CODICE_UTILITA,ID_UTENTE,ID_GRAFICO INTO
              nIdAzienda,vCodiceUtilita,nIdUtente,nIdGrafico;

    INSERT INTO DB_ACCESSO_PIANO_GRAFICO
    (ID_ACCESSO_PIANO_GRAFICO, ID_AZIENDA, DATA_ACCESSO, CODICE_UTILITA, ID_UTENTE,
     ID_GRAFICO,ID_DICHIARAZIONE_CONSISTENZA, ID_ESITO_GRAFICO)
    VALUES
    (SEQ_DB_ACCESSO_PIANO_GRAFICO.NEXTVAL,nIdAzienda, SYSDATE, vCodiceUtilita, nIdUtente,
     nIdGrafico,pIdDichiarazioneConsistenza, 5);

    COMMIT;
    RETURN 5;
  END IF;
  --DBMS_OUTPUT.PUT_LINE('getUtilizziCuaa = '||vCodiceUtilita||' - '||vCuaa);
  FOR rec IN (SELECT * FROM TABLE(getUtilizziCuaa(vCodiceUtilita,vCuaa))) LOOP
    DeusPoliTabe.EXTEND;
    nCont := nCont + 1;

    SELECT DISTINCT ID_POLI
    INTO   nIdPoli
    FROM   DB_UTILIZZO_DICHIARATO
    WHERE  ID_DEUS = rec.ID_DEUS;

    DeusPoliTabe(nCont) := recDeusPoliType_wp2(rec.ID_FASC,
                                               rec.CUAA,
                                               rec.ID_COPA,
                                               rec.ID_PART,
                                               rec.CODI_NAZI,
                                               rec.CODI_BELF,
                                               rec.DESC_COMU,
                                               rec.SEZI_CENS,
                                               rec.NUME_FOGL,
                                               rec.NUME_PART,
                                               rec.CODI_SUBA,
                                               rec.ID_DEUS,
                                               rec.CODI_DEST_UTIL,
                                               rec.CODI_PROD,
                                               rec.CODI_VARI,
                                               rec.CODI_OCCU,
                                               rec.CODI_DEST_USO,
                                               rec.CODI_USOO,
                                               rec.CODI_QUAL,
                                               rec.CODI_OCCU_VARI,
                                               rec.SUPE_UTIL,
                                               rec.DATA_INIZ_UTIL,
                                               rec.DATA_FINE_UTIL,
                                               rec.FLAG_UTIL_TOTA,
                                               rec.FLAG_COLT_PRIN,
                                               rec.CODI_PRAT_PERM,
                                               rec.CODI_PRAT_ALTR,
                                               rec.FLAG_COLT_BIOL,
                                               rec.FLAG_PROD_INTE,
                                               rec.ID_SHAPE,
                                               nIdPoli,
                                               rec.CODI_RILE,
                                               rec.CODI_PROD_RILE,
                                               rec.ID_ISOLA,
                                               rec.PROG_ISOLA,
                                               rec.ID_APPEZ,
                                               rec.PROG_APPEZ,
                                               rec.SHAPE);
  END LOOP;

  IF DeusPoliTabe.COUNT != 0 THEN
    calcolaAppezzamento(1,DeusPoliTabe,ApcgTabe,Appezz);
    nIdAppezPrec := NULL;
    nProgrAppez  := 0;

    IF Appezz.COUNT != 0 THEN
      FOR i IN Appezz.FIRST..Appezz.LAST LOOP
        IF nIdAppezPrec IS NULL THEN
          nIdAppezPrec := Appezz(i).idAppezzamento;
          nProgrAppez  := 1;
        ELSE
          IF nIdAppezPrec != Appezz(i).idAppezzamento THEN
            nIdAppezPrec := Appezz(i).idAppezzamento;
            nProgrAppez  := nProgrAppez + 1;
          END IF;
        END IF;
--dbms_output.put_line('Appezz(i).idAppezzamento = '||Appezz(i).idAppezzamento);
        UPDATE DB_UTILIZZO_DICHIARATO
        SET    ID_APPEZ   = Appezz(i).idAppezzamento,
               PROG_APPEZ = nProgrAppez
        WHERE  ID_DEUS    = Appezz(i).idDeus;
      END LOOP;
    END IF;

    ApcgTabe.DELETE;
    Appezz.DELETE;

    calcolaIsola(1,DeusPoliTabe,ApcgTabe,Appezz);
    nIdAppezPrec := NULL;
    nProgrIsola  := 0;

    IF Appezz.COUNT != 0 THEN
      FOR i IN Appezz.FIRST..Appezz.LAST LOOP
        IF nIdAppezPrec IS NULL THEN
          nIdAppezPrec := Appezz(i).idAppezzamento;
          nProgrIsola  := 1;
        ELSE
          IF nIdAppezPrec != Appezz(i).idAppezzamento THEN
            nIdAppezPrec := Appezz(i).idAppezzamento;
            nProgrIsola  := nProgrIsola + 1;
          END IF;
        END IF;

        UPDATE DB_UTILIZZO_DICHIARATO
        SET    ID_ISOLA_GRAFICA = Appezz(i).idAppezzamento,
               PROG_ISOLA       = nProgrIsola
        WHERE  ID_DEUS          = Appezz(i).idDeus;
      END LOOP;
    END IF;

    UPDATE DB_ACCESSO_PIANO_GRAFICO
    SET    DATA_FINE_VALIDITA           = SYSDATE
    WHERE  ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
    AND    DATA_FINE_VALIDITA           IS NULL
    RETURNING ID_AZIENDA,CODICE_UTILITA,ID_UTENTE,ID_GRAFICO INTO
              nIdAzienda,vCodiceUtilita,nIdUtente,nIdGrafico;

    INSERT INTO DB_ACCESSO_PIANO_GRAFICO
    (ID_ACCESSO_PIANO_GRAFICO, ID_AZIENDA, DATA_ACCESSO, CODICE_UTILITA, ID_UTENTE,
     ID_GRAFICO,ID_DICHIARAZIONE_CONSISTENZA, ID_ESITO_GRAFICO)
    VALUES
    (SEQ_DB_ACCESSO_PIANO_GRAFICO.NEXTVAL,nIdAzienda, SYSDATE, vCodiceUtilita, nIdUtente,
     nIdGrafico,pIdDichiarazioneConsistenza, 10);

    COMMIT;
  END IF;

  RETURN 0;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    DBMS_OUTPUT.PUT_LINE('ERRORE preCaricamento = '||SQLERRM||' - RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
    RETURN 1;
END preCaricamento;

-- funzione per estrarre i dati di utilizzo del suolo di un CUAA
FUNCTION getUtilizziCuaa(pCodiUtilita  VARCHAR2,
                         pCodiCuaa     VARCHAR2,
                         pCodiBelf     VARCHAR2 DEFAULT NULL,
                         pSeziCens     VARCHAR2 DEFAULT NULL,
                         pNumeFogl     NUMBER   DEFAULT NULL) RETURN tabDeusPoliType_AG PIPELINED IS

  TYPE recPart IS RECORD(ID_COPA                  DB_CONDUZIONE_DICHIARATA.ID_COPA%TYPE,
                         ID_PARTICELLA            DB_CONDUZIONE_DICHIARATA.ID_PARTICELLA%TYPE,
                         ID_PRATICA_MANTENIMENTO  DB_UTILIZZO_DICHIARATO.ID_PRATICA_MANTENIMENTO%TYPE,
                         ID_CATALOGO_GRAFICO      DB_R_CATALOGO_MATRICE.ID_CATALOGO_GRAFICO%TYPE,
                         FLAG_PRATO_PERMANENTE    DB_R_CATALOGO_MATRICE.FLAG_PRATO_PERMANENTE%TYPE,
                         ID_DEUS                  DB_UTILIZZO_DICHIARATO.ID_DEUS%TYPE,
                         ID_APPEZ                 DB_UTILIZZO_DICHIARATO.ID_APPEZ%TYPE,
                         PROG_APPEZ               DB_UTILIZZO_DICHIARATO.PROG_APPEZ%TYPE,
                         ID_ISOLA_GRAFICA         DB_UTILIZZO_DICHIARATO.ID_ISOLA_GRAFICA%TYPE,
                         PROG_ISOLA               DB_UTILIZZO_DICHIARATO.PROG_ISOLA%TYPE);

  TYPE tblPart IS TABLE OF recPart INDEX BY BINARY_INTEGER;


  recOut  recDeusPoliType_AG := recDeusPoliType_AG(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                                                   NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                                                   NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);

  vIstatComune  DB_STORICO_PARTICELLA.COMUNE%TYPE;
  Part          tblPart;
BEGIN
  FOR rec IN (SELECT AA.ID_AZIENDA,APG.ID_DICHIARAZIONE_CONSISTENZA,AA.CUAA
              FROM   DB_ACCESSO_PIANO_GRAFICO APG,DB_ANAGRAFICA_AZIENDA AA
              WHERE  APG.CODICE_UTILITA               = pCodiUtilita
              AND    APG.DATA_FINE_VALIDITA           IS NULL
              AND    APG.ID_AZIENDA                   = AA.ID_AZIENDA
              AND    AA.CUAA                          = pCodiCuaa
              AND    AA.DATA_FINE_VALIDITA            IS NULL
              AND    APG.ID_DICHIARAZIONE_CONSISTENZA IS NOT NULL) LOOP

    Part.DELETE;

    SELECT CD.ID_COPA,CD.ID_PARTICELLA,UD.ID_PRATICA_MANTENIMENTO,CM.ID_CATALOGO_GRAFICO,
           CM.FLAG_PRATO_PERMANENTE,UD.ID_DEUS,UD.ID_APPEZ,UD.PROG_APPEZ,UD.ID_ISOLA_GRAFICA,
           UD.PROG_ISOLA
    BULK COLLECT INTO Part
    FROM   DB_DICHIARAZIONE_CONSISTENZA DC,DB_CONDUZIONE_DICHIARATA CD,
           DB_UTILIZZO_DICHIARATO UD,DB_R_CATALOGO_MATRICE CM
    WHERE  DC.ID_DICHIARAZIONE_CONSISTENZA = rec.ID_DICHIARAZIONE_CONSISTENZA
    AND    DC.CODICE_FOTOGRAFIA_TERRENI    = CD.CODICE_FOTOGRAFIA_TERRENI
    AND    CD.ID_CONDUZIONE_DICHIARATA     = UD.ID_CONDUZIONE_DICHIARATA
    AND    CD.ID_TITOLO_POSSESSO           NOT IN (5,6)
    AND    CM.ID_CATALOGO_MATRICE          = UD.ID_CATALOGO_MATRICE
    GROUP BY CD.ID_COPA,CD.ID_PARTICELLA,UD.ID_PRATICA_MANTENIMENTO,CM.ID_CATALOGO_GRAFICO,
             CM.FLAG_PRATO_PERMANENTE,UD.ID_DEUS,UD.ID_APPEZ,UD.PROG_APPEZ,UD.ID_ISOLA_GRAFICA,
             UD.PROG_ISOLA;

    IF Part.FIRST IS NOT NULL THEN
      FOR i IN Part.FIRST..Part.LAST LOOP
        recOut.ID_FASC        := rec.ID_AZIENDA;
        recOut.CUAA           := rec.CUAA;
        recOut.ID_COPA        := Part(i).ID_COPA;
        recOut.ID_PART        := Part(i).ID_PARTICELLA;
        recOut.ID_DEUS        := Part(i).ID_DEUS;
        recOut.FLAG_COLT_PRIN := 'S';
        recOut.FLAG_PROD_INTE := 0;
        recOut.ID_APPEZ       := Part(i).ID_APPEZ;
        recOut.PROG_APPEZ     := Part(i).PROG_APPEZ;
        recOut.ID_ISOLA       := Part(i).ID_ISOLA_GRAFICA;
        recOut.CODI_DEST_UTIL := NULL;
        recOut.CODI_PROD      := NULL;
        recOut.CODI_VARI      := NULL;
        recOut.FLAG_UTIL_TOTA := NULL;
        recOut.PROG_ISOLA     := Part(i).PROG_ISOLA;

        SELECT C.CODFISC,C.DESCOM,SP.SEZIONE,SP.FOGLIO,LPAD(SP.PARTICELLA,5,'0'),
               SP.SUBALTERNO,SP.COMUNE
        INTO   recOut.CODI_BELF,recOut.DESC_COMU,recOut.SEZI_CENS,recOut.NUME_FOGL,recOut.NUME_PART,
               recOut.CODI_SUBA,vIstatComune
        FROM   DB_STORICO_PARTICELLA SP,COMUNE C
        WHERE  SP.ID_PARTICELLA      = Part(i).ID_PARTICELLA
        AND    SP.DATA_FINE_VALIDITA IS NULL
        AND    SP.COMUNE             = C.ISTAT_COMUNE
        AND    ((pCodiBelf IS NOT NULL AND pCodiBelf = C.CODFISC) OR
                (pCodiBelf IS NULL))
        AND    ((pSeziCens IS NOT NULL AND pSeziCens = SP.SEZIONE) OR
                (pSeziCens IS NULL))
        AND    ((pNumeFogl IS NOT NULL AND pNumeFogl = SP.FOGLIO) OR
                (pNumeFogl IS NULL));

        BEGIN
          SELECT CP.COD_NAZIONALE
          INTO   recOut.CODI_NAZI
          FROM   DB_COPIA_SITICOMU CP
          WHERE  CP.ISTATP||CP.ISTATC = vIstatComune
          AND    NVL(CP.ID_SEZC,'0')  = NVL(recOut.SEZI_CENS,'0');
        EXCEPTION
          WHEN NO_DATA_FOUND THEN
            recOut.CODI_NAZI := recOut.CODI_BELF;
        END;

        BEGIN
          SELECT NVL((SELECT TU.CODICE FROM DB_TIPO_UTILIZZO TU WHERE TU.ID_UTILIZZO = CG.ID_UTILIZZO),'000'),
                 NVL((SELECT TD.CODICE_DESTINAZIONE FROM DB_TIPO_DESTINAZIONE TD WHERE TD.ID_TIPO_DESTINAZIONE = CG.ID_TIPO_DESTINAZIONE),'000'),
                 NVL((SELECT TDU.CODICE_DETTAGLIO_USO FROM DB_TIPO_DETTAGLIO_USO TDU WHERE TDU.ID_TIPO_DETTAGLIO_USO = CG.ID_TIPO_DETTAGLIO_USO),'000'),
                 NVL((SELECT TQU.CODICE_QUALITA_USO FROM DB_TIPO_QUALITA_USO TQU WHERE TQU.ID_TIPO_QUALITA_USO = CG.ID_TIPO_QUALITA_USO),'000'),
                 NVL((SELECT TV.CODICE_VARIETA FROM DB_TIPO_VARIETA TV WHERE TV.ID_VARIETA = CG.ID_VARIETA),'000'),
                 CASE WHEN Part(i).FLAG_PRATO_PERMANENTE = 'S' THEN (SELECT CODICE_PRATICA_MANTENIMENTO
                                                                     FROM   DB_TIPO_PRATICA_MANTENIMENTO
                                                                     WHERE  ID_PRATICA_MANTENIMENTO = Part(i).ID_PRATICA_MANTENIMENTO)
                 ELSE NULL END,
                 CASE WHEN Part(i).FLAG_PRATO_PERMANENTE = 'N' THEN (SELECT CODICE_PRATICA_MANTENIMENTO
                                                                     FROM   DB_TIPO_PRATICA_MANTENIMENTO
                                                                     WHERE  ID_PRATICA_MANTENIMENTO = Part(i).ID_PRATICA_MANTENIMENTO)
                 ELSE NULL END
          INTO   recOut.CODI_OCCU,
                 recOut.CODI_DEST_USO,
                 recOut.CODI_USOO,
                 recOut.CODI_QUAL,
                 recOut.CODI_OCCU_VARI,
                 recOut.CODI_PRAT_PERM,
                 recOut.CODI_PRAT_ALTR
          FROM   DB_R_CATALOGO_GRAFICO CG
          WHERE  CG.ID_CATALOGO_GRAFICO = Part(i).ID_CATALOGO_GRAFICO;
        EXCEPTION
          WHEN NO_DATA_FOUND THEN
            recOut.CODI_OCCU      := '000';
            recOut.CODI_DEST_USO  := '000';
            recOut.CODI_USOO      := '000';
            recOut.CODI_QUAL      := '000';
            recOut.CODI_OCCU_VARI := '000';
            recOut.CODI_PRAT_PERM := NULL;
            recOut.CODI_PRAT_ALTR := NULL;
        END;

        SELECT DECODE(COUNT(*),0,0,1)
        INTO   recOut.FLAG_COLT_BIOL
        FROM   DB_PARTICELLA_BIO PB,DB_DICHIARAZIONE_CONSISTENZA DC
        WHERE  PB.ID_AZIENDA                   = rec.ID_AZIENDA
        AND    DC.ID_DICHIARAZIONE_CONSISTENZA = rec.ID_DICHIARAZIONE_CONSISTENZA
        AND    DATA                            BETWEEN PB.DATA_INIZIO_VALIDITA AND
                                                       NVL(PB.DATA_FINE_VALIDITA,DATA)
        AND    (PB.SUP_BIOLOGICO > 0 OR PB.SUP_IN_CONVERSIONE > 0);

        SELECT NVL(SUM(NVL(SUPERFICIE_UTILIZZATA,0)),0)*10000,NVL(MIN(DATA_INIZIO_DESTINAZIONE),SYSDATE),
               NVL(MAX(DATA_FINE_DESTINAZIONE),SYSDATE)
        INTO   recOut.SUPE_UTIL,recOut.DATA_INIZ_UTIL,
               recOut.DATA_FINE_UTIL
        FROM   DB_UTILIZZO_DICHIARATO
        WHERE  ID_DEUS = Part(i).ID_DEUS;

        BEGIN
          SELECT SHAPE,ID_SHAPE,CODI_RILE,CODI_PROD_RILE
          INTO   recOut.SHAPE,recOut.ID_SHAPE,recOut.CODI_RILE,recOut.CODI_PROD_RILE
          FROM   DB_UTILIZZO_DICHIARATO
          WHERE  ID_DEUS = Part(i).ID_DEUS
          AND    ROWNUM  < 2;
        EXCEPTION
          WHEN OTHERS THEN
            recOut.SHAPE          := NULL;
            recOut.ID_SHAPE       := NULL;
            recOut.CODI_RILE      := NULL;
            recOut.CODI_PROD_RILE := NULL;
        END;

        Pipe Row (recOut);
      END LOOP;
    END IF;
  END LOOP;

  RETURN;
END getUtilizziCuaa;

-- La procedura e' utilizzata per riportare i dati del piano colturale grafico sul piano colturale alfanumerico
PROCEDURE scriviPColtGrafico(pCodiUtilita   VARCHAR2,
                             pCodiCuaa      VARCHAR2,
                             pUtenApplGraf  VARCHAR2,
                             pListUtil      tabUtilType) IS

  nCont                  SIMPLE_INTEGER := 0;
  bErrore                BOOLEAN := FALSE;
  nSuperficieUtilizzata  NUMBER;
BEGIN
  null;
  /*FOR rec IN (SELECT AA.ID_AZIENDA,APG.ID_DICHIARAZIONE_CONSISTENZA,AA.CUAA
              FROM   DB_ACCESSO_PIANO_GRAFICO APG,DB_ANAGRAFICA_AZIENDA AA
              WHERE  APG.CODICE_UTILITA               = pCodiUtilita
              AND    APG.DATA_FINE_VALIDITA           IS NULL
              AND    AA.CUAA                          = pCodiCuaa
              AND    APG.ID_AZIENDA                   = AA.ID_AZIENDA
              AND    AA.DATA_FINE_VALIDITA            IS NULL
              AND    APG.ID_DICHIARAZIONE_CONSISTENZA IS NOT NULL) LOOP

    bErrore := FALSE;

    FOR i IN 1..pListUtil.COUNT LOOP
      SELECT NVL(SUM(NVL(UD.SUPERFICIE_UTILIZZATA,0)),0)
      INTO   nSuperficieUtilizzata
      FROM   DB_DICHIARAZIONE_CONSISTENZA DC,DB_CONDUZIONE_DICHIARATA CD,DB_UTILIZZO_DICHIARATO UD
      WHERE  DC.ID_DICHIARAZIONE_CONSISTENZA = rec.ID_DICHIARAZIONE_CONSISTENZA
      AND    DC.CODICE_FOTOGRAFIA_TERRENI    = CD.CODICE_FOTOGRAFIA_TERRENI
      AND    CD.ID_CONDUZIONE_DICHIARATA     = UD.ID_CONDUZIONE_DICHIARATA
      AND    CD.ID_COPA                      = pListUtil(i).ID_COPA
      AND    UD.ID_DEUS                      = pListUtil(i).ID_DEUS
      GROUP BY CD.ID_COPA,UD.ID_DEUS;

      IF nSuperficieUtilizzata != pListUtil(i).SUPE_UTIL THEN
        bErrore := TRUE;
        EXIT;
      END IF;

      SELECT COUNT(*)
      INTO   nCont
      FROM   DB_DICHIARAZIONE_CONSISTENZA DC,DB_CONDUZIONE_DICHIARATA CD,DB_UTILIZZO_DICHIARATO UD,
             DB_R_CATALOGO_MATRICE CM,DB_R_CATALOGO_GRAFICO CG,DB_TIPO_UTILIZZO TU,DB_TIPO_DESTINAZIONE TD,
             DB_TIPO_QUALITA_USO TQU,DB_TIPO_VARIETA TV
      WHERE  DC.ID_DICHIARAZIONE_CONSISTENZA = rec.ID_DICHIARAZIONE_CONSISTENZA
      AND    DC.CODICE_FOTOGRAFIA_TERRENI    = CD.CODICE_FOTOGRAFIA_TERRENI
      AND    CD.ID_CONDUZIONE_DICHIARATA     = UD.ID_CONDUZIONE_DICHIARATA
      AND    CD.ID_COPA                      = pListUtil(i).ID_COPA
      AND    UD.ID_DEUS                      = pListUtil(i).ID_DEUS
      AND    CM.ID_CATALOGO_MATRICE          = UD.ID_CATALOGO_MATRICE
      AND    CM.ID_CATALOGO_GRAFICO          = CG.ID_CATALOGO_GRAFICO
      AND    CG.ID_UTILIZZO                  = TU.ID_UTILIZZO
      AND    TU.CODICE                       = pListUtil(i).CODI_OCCU
      AND    CG.ID_TIPO_DESTINAZIONE         = TD.ID_TIPO_DESTINAZIONE(+)
      AND    NVL(TD.CODICE_DESTINAZIONE,'0') = NVL(pListUtil(i).CODI_DEST_USO,'0')
      AND    CG.ID_TIPO_QUALITA_USO          = TQU.ID_TIPO_QUALITA_USO(+)
      AND    NVL(TQU.CODICE_QUALITA_USO,'0') = NVL(pListUtil(i).CODI_QUAL,'0')
      AND    CG.ID_VARIETA                   = TV.ID_VARIETA(+)
      AND    NVL(TV.CODICE_VARIETA,'0')      = NVL(pListUtil(i).CODI_OCCU_VARI,'0');

      IF nCont = 0 THEN
        bErrore := TRUE;
        EXIT;
      END IF;
    END LOOP;

    IF NOT bErrore THEN
      FOR i IN 1..pListUtil.COUNT LOOP
        UPDATE DB_UTILIZZO_DICHIARATO
        SET    ID_ISOLA_GRAFICA         = pListUtil(i).ID_ISOLA,
               ID_APPEZ                 = pListUtil(i).ID_APPEZ,
               PROG_APPEZ               = pListUtil(i).PROG_APPEZ,
               ID_SHAPE                 = pListUtil(i).ID_SHAPE,
               SHAPE                    = pListUtil(i).SHAPE
        WHERE  ID_UTILIZZO_DICHIARATO   = pListUtil(i).ID_DEUS
        AND    ID_CONDUZIONE_DICHIARATA = pListUtil(i).ID_COPA;

      END LOOP;

      COMMIT;
    END IF;
  END LOOP;*/
END scriviPColtGrafico;

-- funzione per estrarre i dati del suolo GIS richiamera' una classe java deployata sul db
FUNCTION getSuoliGisCuaa(pCodiUtilita  VARCHAR2,
                         pCodiCuaa     VARCHAR2,
                         pCodiBelf     VARCHAR2 DEFAULT NULL,
                         pSeziCens     VARCHAR2 DEFAULT NULL,
                         pNumeFogl     NUMBER   DEFAULT NULL) RETURN TabSuoliGisType PIPELINED IS

  recOut  SuoliGisType := SuoliGisType(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                                       NULL,NULL,NULL,NULL);

  SitiSuolo  tblSitiSuolo := tblSitiSuolo();
BEGIN
  FOR rec IN (SELECT AA.ID_AZIENDA,APG.ID_DICHIARAZIONE_CONSISTENZA,AA.CUAA
              FROM   DB_ACCESSO_PIANO_GRAFICO APG,DB_ANAGRAFICA_AZIENDA AA
              WHERE  APG.CODICE_UTILITA               = pCodiUtilita
              AND    APG.DATA_FINE_VALIDITA           IS NULL
              AND    AA.CUAA                          = pCodiCuaa
              AND    APG.ID_AZIENDA                   = AA.ID_AZIENDA
              AND    AA.DATA_FINE_VALIDITA            IS NULL
              AND    APG.ID_DICHIARAZIONE_CONSISTENZA IS NOT NULL) LOOP

    FOR recPart IN (SELECT SP.ID_PARTICELLA,C.CODFISC,C.DESCOM,SP.SEZIONE,SP.FOGLIO,
                           LPAD(SP.PARTICELLA,5,'0') PARTICELLA,SP.SUBALTERNO,C.ISTAT_COMUNE
                    FROM   DB_DICHIARAZIONE_CONSISTENZA DC,DB_CONDUZIONE_DICHIARATA CD,DB_STORICO_PARTICELLA SP,COMUNE C
                    WHERE  DC.ID_DICHIARAZIONE_CONSISTENZA = rec.ID_DICHIARAZIONE_CONSISTENZA
                    AND    DC.CODICE_FOTOGRAFIA_TERRENI    = CD.CODICE_FOTOGRAFIA_TERRENI
                    AND    CD.ID_TITOLO_POSSESSO           NOT IN (5,6)
                    AND    SP.ID_STORICO_PARTICELLA        = CD.ID_STORICO_PARTICELLA
                    AND    SP.COMUNE                       = C.ISTAT_COMUNE
                    AND    ((pCodiBelf IS NOT NULL AND pCodiBelf = C.CODFISC) OR
                            (pCodiBelf IS NULL))
                    AND    ((pSeziCens IS NOT NULL AND pSeziCens = SP.SEZIONE) OR
                            (pSeziCens IS NULL))
                    AND    ((pNumeFogl IS NOT NULL AND pNumeFogl = SP.FOGLIO) OR
                            (pNumeFogl IS NULL))
                    ORDER BY SP.COMUNE,SP.SEZIONE,SP.FOGLIO,SP.PARTICELLA,SP.SUBALTERNO) LOOP

      SitiSuolo.DELETE;
      SitiSuolo := datiSuoloPerPianoGrafico(recPart.ISTAT_COMUNE,
                                            recPart.SEZIONE,
                                            recPart.FOGLIO,
                                            recPart.PARTICELLA);

      IF SitiSuolo.COUNT = 0 THEN
        recOut.ID_FASC        := rec.ID_AZIENDA;
        recOut.CUAA           := rec.CUAA;
        recOut.ID_PART        := recPart.ID_PARTICELLA;
        recOut.CODI_BELF      := recPart.CODFISC;
        recOut.DESC_COMU      := recPart.DESCOM;
        recOut.SEZI_CENS      := recPart.SEZIONE;
        recOut.NUME_FOGL      := recPart.FOGLIO;
        recOut.NUME_PART      := recPart.PARTICELLA;
        recOut.CODI_SUBA      := recPart.SUBALTERNO;
        recOut.CODI_NAZI      := NULL;
        recOut.PROG_POLI      := NULL;
        recOut.ID_SHAPE       := NULL;
        recOut.CODI_VARI      := NULL;
        recOut.CODI_PROD      := NULL;
        recOut.AREA_COLT      := NULL;
        recOut.TARA           := NULL;
        recOut.DATA_INIZ_VALI := NULL;
        recOut.SHAPE          := NULL;

        Pipe Row (recOut);
      ELSE
        FOR i IN 1..SitiSuolo.COUNT LOOP
          recOut.ID_FASC        := rec.ID_AZIENDA;
          recOut.CUAA           := rec.CUAA;
          recOut.ID_PART        := recPart.ID_PARTICELLA;
          recOut.CODI_BELF      := recPart.CODFISC;
          recOut.DESC_COMU      := recPart.DESCOM;
          recOut.SEZI_CENS      := recPart.SEZIONE;
          recOut.NUME_FOGL      := recPart.FOGLIO;
          recOut.NUME_PART      := recPart.PARTICELLA;
          recOut.CODI_SUBA      := recPart.SUBALTERNO;
          recOut.CODI_NAZI      := SitiSuolo(i).CODI_NAZI;
          recOut.PROG_POLI      := SitiSuolo(i).PROG_POLI;
          recOut.ID_SHAPE       := SitiSuolo(i).ID_SHAPE;
          recOut.CODI_VARI      := SitiSuolo(i).CODI_VARI;
          recOut.CODI_PROD      := NULL;
          recOut.AREA_COLT      := SitiSuolo(i).AREA_COLT;
          recOut.TARA           := SitiSuolo(i).TARA;
          recOut.DATA_INIZ_VALI := SitiSuolo(i).DATA_INIZ_VALI;
          recOut.SHAPE          := SitiSuolo(i).SHAPE;

          Pipe Row (recOut);
        END LOOP;
      END IF;
    END LOOP;
  END LOOP;
  RETURN;
END getSuoliGisCuaa;

-- funzione per estrarre il catalogo prodotti a 5 codici
FUNCTION getMatB1FromGISCata(pCodiUtilita   VARCHAR2,
                             pCodiRile      VARCHAR2 DEFAULT NULL,
                             pCodiProdRile  VARCHAR2 DEFAULT NULL) RETURN tabMatB1CataType PIPELINED IS

  recOut  MatB1CataType := MatB1CataType(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                                         NULL,NULL);
  nCont   SIMPLE_INTEGER := 0;
BEGIN
  SELECT COUNT(*)
  INTO   nCont
  FROM   DB_ACCESSO_PIANO_GRAFICO APG
  WHERE  APG.CODICE_UTILITA     = pCodiUtilita
  AND    APG.DATA_FINE_VALIDITA IS NULL;

  IF nCont = 0 THEN
    RETURN;
  END IF;

  FOR rec IN (SELECT Cg.ID_UTILIZZO, Cg.ID_TIPO_DESTINAZIONE,Cg.ID_TIPO_DETTAGLIO_USO, Cg.ID_TIPO_QUALITA_USO,
                     TEF.CODI_RILE,TEF.DESCRIZIONE,TER.CODI_RILE_PROD,TER.DESC_RILE_PROD,
                     DECODE(TER.FLAG_DEFAULT,'S',1,0) FLAG_DEFAULT
              FROM   DB_R_CATALOGO_GRAFICO CG,DB_VARIETA_ELEGGIBILITA VE,DB_TIPO_ELEGGIBILITA_FIT TEF,
                     DB_TIPO_ELEGGIBILITA_RILEVATA TER,DB_R_CATALOGO_MATRICE CM
              WHERE  TEF.ID_ELEGGIBILITA_FIT = VE.ID_ELEGGIBILITA_FIT
              AND    TEF.ID_ELEGGIBILITA_FIT = TER.ID_ELEGGIBILITA_FIT
              AND    VE.DATA_FINE_VALIDITA   IS NULL
              AND    ((pCodiRile IS NOT NULL AND TEF.CODI_RILE = pCodiRile) OR
                      (pCodiRile IS NULL))
              AND    TEF.DATA_FINE_VALIDITA  IS NULL
              AND    TER.DATA_FINE_VALIDITA  IS NULL
              AND    CG.ID_CATALOGO_GRAFICO  = CM.ID_CATALOGO_GRAFICO
              AND    VE.ID_CATALOGO_MATRICE  = CM.ID_CATALOGO_MATRICE
              GROUP BY cg.ID_UTILIZZO, cg.ID_TIPO_DESTINAZIONE,cg.ID_TIPO_DETTAGLIO_USO, cg.ID_TIPO_QUALITA_USO,
                       TEF.CODI_RILE,TEF.DESCRIZIONE,TER.CODI_RILE_PROD,TER.DESC_RILE_PROD,TER.FLAG_DEFAULT) LOOP

    recOut.CODI_RILE      := rec.CODI_RILE;
    recOut.DESC_RILE      := rec.DESCRIZIONE;
    recOut.CODI_PROD_RILE := rec.CODI_RILE_PROD;
    recOut.DESC_PROD_RILE := rec.DESC_RILE_PROD;
    recOut.FLAG_DEFA      := rec.FLAG_DEFAULT;
    recOut.CODI_CGIS      := recOut.CODI_RILE;
    recOut.DESC_CGIS      := recOut.DESC_RILE;

    SELECT CODICE,DESCRIZIONE
    INTO   recOut.CODI_OCCU,recOut.DESC_OCCU
    FROM   DB_TIPO_UTILIZZO
    WHERE  ID_UTILIZZO = rec.ID_UTILIZZO;

    BEGIN
      SELECT CODICE_DESTINAZIONE,DESCRIZIONE_DESTINAZIONE
      INTO   recOut.CODI_DEST_USOO,recOut.DESC_DEST_USOO
      FROM   DB_TIPO_DESTINAZIONE
      WHERE  ID_TIPO_DESTINAZIONE = rec.ID_TIPO_DESTINAZIONE;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        recOut.CODI_DEST_USOO := '000';
        recOut.DESC_DEST_USOO := 'N.D.';
    END;

    BEGIN
      SELECT CODICE_DETTAGLIO_USO,DESCRIZIONE_DETTAGLIO_USO
      INTO   recOut.CODI_USOO,recOut.DESC_USOO
      FROM   DB_TIPO_DETTAGLIO_USO
      WHERE  ID_TIPO_DETTAGLIO_USO = rec.ID_TIPO_DETTAGLIO_USO;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        recOut.CODI_USOO := '000';
        recOut.DESC_USOO := 'N.D.';
    END;

    BEGIN
      SELECT CODICE_QUALITA_USO,DESCRIZIONE_QUALITA_USO
      INTO   recOut.CODI_QUAL,recOut.DESC_QUAL
      FROM   DB_TIPO_QUALITA_USO
      WHERE  ID_TIPO_QUALITA_USO = rec.ID_TIPO_QUALITA_USO;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        recOut.CODI_QUAL := '000';
        recOut.DESC_QUAL := 'N.D.';
    END;

    Pipe Row (recOut);
  END LOOP;

  RETURN;
END getMatB1FromGISCata;

-- funzione per estrarre i dati di conduzione di un CUAA
FUNCTION getConduzioneCuaa(pCodiUtilita  VARCHAR2,
                           pCodiCuaa     VARCHAR2,
                           pCodiBelf     VARCHAR2 DEFAULT NULL,
                           pSeziCens     VARCHAR2 DEFAULT NULL,
                           pNumeFogl     NUMBER   DEFAULT NULL) RETURN tabCopaPoliType_AG PIPELINED IS

  recOut  recCopaPoliType_AG := recCopaPoliType_AG(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                                                   NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
  vIstatComune  COMUNE.ISTAT_COMUNE%TYPE;
  ArrayShape    SDO_GEOMETRY_ARRAY;
BEGIN
  FOR rec IN (SELECT AA.ID_AZIENDA,APG.ID_DICHIARAZIONE_CONSISTENZA,AA.CUAA
              FROM   DB_ACCESSO_PIANO_GRAFICO APG,DB_ANAGRAFICA_AZIENDA AA
              WHERE  APG.CODICE_UTILITA               = pCodiUtilita
              AND    APG.DATA_FINE_VALIDITA           IS NULL
              AND    AA.CUAA                          = pCodiCuaa
              AND    APG.ID_AZIENDA                   = AA.ID_AZIENDA
              AND    AA.DATA_FINE_VALIDITA            IS NULL
              AND    APG.ID_DICHIARAZIONE_CONSISTENZA IS NOT NULL) LOOP

    FOR recCopa IN (SELECT CD.ID_COPA
                    FROM   DB_DICHIARAZIONE_CONSISTENZA DC,DB_CONDUZIONE_DICHIARATA CD
                    WHERE  DC.ID_DICHIARAZIONE_CONSISTENZA = rec.ID_DICHIARAZIONE_CONSISTENZA
                    AND    DC.CODICE_FOTOGRAFIA_TERRENI    = CD.CODICE_FOTOGRAFIA_TERRENI
                    AND    CD.ID_TITOLO_POSSESSO           NOT IN (5,6)
                    GROUP BY CD.ID_COPA) LOOP

      recOut.ID_FASC        := rec.ID_AZIENDA;
      recOut.CUAA           := rec.CUAA;
      recOut.ID_COPA        := recCopa.ID_COPA;
      recOut.DATA_FINE_COND := NULL;
      recOut.DATA_FINE_COND := TO_DATE('31/12/9999','DD/MM/YYYY');

      SELECT NVL(MIN(UD.ID_POLI),1)
      INTO   recOut.ID_POLI
      FROM   DB_CONDUZIONE_DICHIARATA CD,DB_UTILIZZO_DICHIARATO UD
      WHERE  CD.ID_COPA                  = recCopa.ID_COPA
      AND    UD.ID_CONDUZIONE_DICHIARATA = CD.ID_CONDUZIONE_DICHIARATA;

      SELECT SP.ID_PARTICELLA,C.CODFISC,C.DESCOM,SP.SEZIONE,SP.FOGLIO,
             LPAD(SP.PARTICELLA,5,'0') PARTICELLA,SP.SUBALTERNO,C.ISTAT_COMUNE,SP.SUPERFICIE_GRAFICA*10000,
             SP.SUP_CATASTALE *10000
      INTO   recOut.ID_PART,recOut.CODI_BELF,recOut.DESC_COMU,recOut.SEZI_CENS,recOut.NUME_FOGL,
             recOut.NUME_PART,recOut.CODI_SUBA,vIstatComune,recOut.SUPE_GRAF_VALI,
             recOut.SUPE_CATA_VALI
      FROM   DB_CONDUZIONE_DICHIARATA CD,DB_STORICO_PARTICELLA SP,COMUNE C
      WHERE  CD.ID_COPA               = recCopa.ID_COPA
      AND    SP.ID_STORICO_PARTICELLA = CD.ID_STORICO_PARTICELLA
      AND    SP.COMUNE                = C.ISTAT_COMUNE
      AND    ((pCodiBelf IS NOT NULL AND pCodiBelf = C.CODFISC) OR
              (pCodiBelf IS NULL))
      AND    ((pSeziCens IS NOT NULL AND pSeziCens = SP.SEZIONE) OR
              (pSeziCens IS NULL))
      AND    ((pNumeFogl IS NOT NULL AND pNumeFogl = SP.FOGLIO) OR
              (pNumeFogl IS NULL))
      AND    ROWNUM                   < 2;

      BEGIN
        SELECT CP.COD_NAZIONALE
        INTO   recOut.CODI_NAZI
        FROM   DB_COPIA_SITICOMU CP
        WHERE  CP.ISTATP||CP.ISTATC = vIstatComune
        AND    NVL(CP.ID_SEZC,'0')  = NVL(recOut.SEZI_CENS,'0');
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          recOut.CODI_NAZI := recOut.CODI_BELF;
      END;

      SELECT CASE WHEN MIN(ID_TITOLO_POSSESSO) = 9 THEN 5
                  WHEN MIN(ID_TITOLO_POSSESSO) = 8 THEN 4
                  WHEN MIN(ID_TITOLO_POSSESSO) IN (10,11,12) THEN 1
             ELSE MIN(ID_TITOLO_POSSESSO) END,MIN(DATA_INIZIO_CONDUZIONE),
             NVL(SUM(NVL(SUPERFICIE_CONDOTTA,0))*10000,0)
      INTO   recOut.DECO_TIPO_COND,recOut.DATA_INIZ_COND,recOut.SUPE_COND
      FROM   DB_CONDUZIONE_DICHIARATA
      WHERE  ID_COPA = recCopa.ID_COPA;

      SELECT UD.SHAPE
      BULK COLLECT INTO ArrayShape
      FROM   DB_CONDUZIONE_DICHIARATA CD,DB_UTILIZZO_DICHIARATO UD
      WHERE  CD.ID_COPA                  = recCopa.ID_COPA
      AND    UD.ID_CONDUZIONE_DICHIARATA = CD.ID_CONDUZIONE_DICHIARATA;

      recOut.SHAPE := unisciShape(ArrayShape);

      Pipe Row (recOut);
    END LOOP;
  END LOOP;

  RETURN;
END getConduzioneCuaa;

PROCEDURE calcolaAppezzamento(pUserInse             VARCHAR2,
                              pDeusPoliTabe  IN OUT tabDeusPoliType_wp2,
                              pApcgTabe         OUT tabApcgType,
                              pAppezz           OUT tblAppezz) IS

  myShape     SDO_GEOMETRY;
  myArray     SDO_GEOMETRY_ARRAY;
  myIdApcg    NUMBER;
  mySupeUtil  NUMBER;
  nCont       SIMPLE_INTEGER := 0;
BEGIN
  EXECUTE IMMEDIATE ('TRUNCATE TABLE CABAAPCG_TAB');
   --dbms_output.put_line('entro in calcola appezzamento');
  pApcgTabe := tabApcgType();
  pAppezz.DELETE;
  FOR rAppe IN (SELECT r1.ID_FASC, r1.CODI_NAZI, r1.NUME_FOGL, r1.CODI_OCCU, r1.CODI_DEST_USO, r1.CODI_USOO,
                       r1.CODI_QUAL, r1.CODI_OCCU_VARI, r1.DATA_INIZ_UTIL, r1.DATA_FINE_UTIL,
                       r1.FLAG_COLT_PRIN, r1.CODI_PRAT_PERM, r1.CODI_PRAT_ALTR, r1.FLAG_COLT_BIOL,
                       r1.FLAG_PROD_INTE, sdo_aggr_union(sdoaggrtype (r1.shape, 0.005)) AS shape,
                       CAST(COLLECT (nume_elem) AS ORA_MINING_NUMBER_NT) AS tabe_elem,
                       SUM(supe_util) AS supe_util
                FROM  (SELECT *
                       FROM (SELECT ROWNUM AS nume_elem, r.*
                             FROM   TABLE (CAST(pDeusPoliTabe AS tabDeusPoliType_wp2)) r)
                       ORDER BY nume_elem) r1
                GROUP BY r1.ID_FASC, r1.CODI_NAZI, r1.NUME_FOGL, r1.CODI_OCCU, r1.CODI_DEST_USO, r1.CODI_USOO,
                         r1.CODI_QUAL, r1.CODI_OCCU_VARI, r1.DATA_INIZ_UTIL, r1.DATA_FINE_UTIL,
                         r1.FLAG_COLT_PRIN, r1.CODI_PRAT_PERM, r1.CODI_PRAT_ALTR, r1.FLAG_COLT_BIOL,
                         r1.FLAG_PROD_INTE)  LOOP

    myArray := SDO_UTIL.EXTRACT_ALL(rAppe.shape, 0);
    IF myArray IS NOT NULL THEN
      IF myArray.COUNT = 1 THEN
        myShape    := myArray(1);
        myIdApcg   := SEQ_ID_APPEZZAMENTO.NEXTVAL;
        mySupeUtil := 0;

        FOR i IN 1..rAppe.tabe_elem.COUNT LOOP
          pDeusPoliTabe(rAppe.tabe_elem(i)).ID_APPEZ := myIdApcg;
          mySupeUtil := mySupeUtil + pDeusPoliTabe(rAppe.tabe_elem(i)).SUPE_UTIL;
        END LOOP;

        pApcgTabe.EXTEND;

        --dbms_output.put_line('rAppe.FLAG_COLT_PRIN = '||rAppe.FLAG_COLT_PRIN);

        SELECT myIdApcg, rAppe.id_fasc,rAppe.CODI_OCCU, rAppe.CODI_USOO, rAppe.CODI_DEST_USO, rAppe.CODI_QUAL,
               rAppe.CODI_OCCU_VARI,rAppe.FLAG_COLT_BIOL, DECODE(rAppe.FLAG_COLT_PRIN,'S',1,0), rAppe.CODI_PRAT_PERM,
               rAppe.CODI_PRAT_ALTR,mySupeUtil, myShape, pUserInse, rAppe.DATA_INIZ_UTIL,
               rAppe.DATA_FINE_UTIL, rAppe.FLAG_PROD_INTE,rAppe.CODI_NAZI, rAppe.NUME_FOGL
        INTO   pApcgTabe(pApcgTabe.COUNT)
        FROM   DUAL;

        INSERT INTO CABAAPCG_TAB
        (ID_APCG, ID_FASC, CODI_PROD, CODI_USO, CODI_DSUT, CODI_TQUA, CODI_VRPR, FLAG_COLT_BIOL,
         FLAG_COLT_PRIN, CODI_PRAT_PERM, CODI_PRAT_ALTR, SUPE_COLT, SHAPE_APCG, USER_INSE,
         DATA_INIZ_VALI_APCG, DATA_FINE_VALI_APCG, FLAG_PROD_INTE, CODI_NAZI, NUME_FOGL)
        VALUES
        (myIdApcg, rAppe.id_fasc,rAppe.CODI_OCCU, rAppe.CODI_USOO, rAppe.CODI_DEST_USO, rAppe.CODI_QUAL,
         rAppe.CODI_OCCU_VARI,rAppe.FLAG_COLT_BIOL, DECODE(rAppe.FLAG_COLT_PRIN,'S',1,0), rAppe.CODI_PRAT_PERM,
         rAppe.CODI_PRAT_ALTR,mySupeUtil, myShape, pUserInse, rAppe.DATA_INIZ_UTIL,
         rAppe.DATA_FINE_UTIL, rAppe.FLAG_PROD_INTE,rAppe.CODI_NAZI, rAppe.NUME_FOGL);
      ELSE
        FOR j in 1..myArray.COUNT LOOP
          myShape    := myArray(j);
          myIdApcg   := SEQ_ID_APPEZZAMENTO.nextval;
          mySupeUtil := 0;

          FOR i IN 1..rAppe.tabe_elem.COUNT LOOP
            DECLARE
              eleIdx     NUMBER := rAppe.tabe_elem(i);
              eleShape   SDO_GEOMETRY;
              resRelate  VARCHAR2(100);
            BEGIN
              eleShape  := pDeusPoliTabe(eleIdx).shape;
              resRelate := SDO_GEOM.RELATE( myShape, 'determine', eleShape, 0.005 );

              IF resRelate IN ('EQUAL', 'COVERS', 'CONTAINS') THEN
                pDeusPoliTabe(eleIdx).ID_APPEZ := myIdApcg;
                mySupeUtil                     := mySupeUtil + pDeusPoliTabe(eleIdx).SUPE_UTIL;
              END IF;
            END;
          END LOOP;

          pApcgTabe.EXTEND;

          SELECT myIdApcg, rAppe.id_fasc,rAppe.CODI_OCCU, rAppe.CODI_USOO, rAppe.CODI_DEST_USO,
                 rAppe.CODI_QUAL, rAppe.CODI_OCCU_VARI,rAppe.FLAG_COLT_BIOL, DECODE(rAppe.FLAG_COLT_PRIN,'S',1,0),
                 rAppe.CODI_PRAT_PERM, rAppe.CODI_PRAT_ALTR,mySupeUtil, myShape, pUserInse,
                 rAppe.DATA_INIZ_UTIL, rAppe.DATA_FINE_UTIL, rAppe.FLAG_PROD_INTE,rAppe.CODI_NAZI,
                 rAppe.NUME_FOGL
          INTO   pApcgTabe(pApcgTabe.COUNT)
          FROM   DUAL;

          INSERT INTO CABAAPCG_TAB
          (ID_APCG, ID_FASC, CODI_PROD, CODI_USO, CODI_DSUT, CODI_TQUA, CODI_VRPR, FLAG_COLT_BIOL,
           FLAG_COLT_PRIN, CODI_PRAT_PERM, CODI_PRAT_ALTR, SUPE_COLT, SHAPE_APCG, USER_INSE,
           DATA_INIZ_VALI_APCG, DATA_FINE_VALI_APCG, FLAG_PROD_INTE, CODI_NAZI, NUME_FOGL)
          VALUES
          (myIdApcg, rAppe.id_fasc,rAppe.CODI_OCCU, rAppe.CODI_USOO, rAppe.CODI_DEST_USO,
           rAppe.CODI_QUAL, rAppe.CODI_OCCU_VARI,rAppe.FLAG_COLT_BIOL, DECODE(rAppe.FLAG_COLT_PRIN,'S',1,0),
           rAppe.CODI_PRAT_PERM, rAppe.CODI_PRAT_ALTR,mySupeUtil, myShape, pUserInse,
           rAppe.DATA_INIZ_UTIL, rAppe.DATA_FINE_UTIL, rAppe.FLAG_PROD_INTE,rAppe.CODI_NAZI,
           rAppe.NUME_FOGL);
        END LOOP;
      END IF;
    END IF;
  END LOOP;

  COMMIT;
  nCont := 0;

  FOR rec in (SELECT ID_APCG,ID_DEUS
              FROM (SELECT ROWNUM AS nume_elem, r.*
                    FROM   TABLE (CAST(pDeusPoliTabe AS tabDeusPoliType_wp2)) r) TAB,CABAAPCG_TAB T
              WHERE  T.ID_FASC                   = TAB.ID_FASC
              AND    NVL(RTRIM(T.CODI_PROD),'0') = NVL(TAB.CODI_OCCU,'0')
              AND    NVL(RTRIM(T.CODI_USO),'0')  = NVL(TAB.CODI_USOO,'0')
              AND    NVL(RTRIM(T.CODI_DSUT),'0') = NVL(TAB.CODI_DEST_USO,'0')
              AND    NVL(RTRIM(T.CODI_TQUA),'0') = NVL(TAB.CODI_QUAL,'0')
              AND    NVL(RTRIM(T.CODI_VRPR),'0') = NVL(TAB.CODI_OCCU_VARI,'0')
              AND    NVL(T.FLAG_COLT_BIOL,0)     = NVL(TAB.FLAG_COLT_BIOL,0)
              AND    NVL(T.FLAG_COLT_PRIN,0)     = NVL(DECODE(TAB.FLAG_COLT_PRIN,'S',1,0),0)
              AND    NVL(T.CODI_PRAT_PERM,'0')   = NVL(TAB.CODI_PRAT_PERM,'0')
              AND    NVL(T.CODI_PRAT_ALTR,'0')   = NVL(TAB.CODI_PRAT_ALTR,'0')
              AND    T.DATA_INIZ_VALI_APCG       = TAB.DATA_INIZ_UTIL
              AND    T.DATA_FINE_VALI_APCG       = TAB.DATA_FINE_UTIL
              AND    NVL(T.FLAG_PROD_INTE,0)     = NVL(TAB.FLAG_PROD_INTE,0)
              AND    NVL(T.CODI_NAZI,'0')        = NVL(TAB.CODI_NAZI ,'0')
              AND    NVL(T.NUME_FOGL,0)          = NVL(TAB.NUME_FOGL,0)
              ORDER BY ID_APCG) LOOP

    --dbms_output.put_line('salvo una coppia di appezzamenti per= '||rec.Id_deus);
    nCont                         := nCont + 1;
    pAppezz(nCont).idAppezzamento := REC.ID_APCG;
    pAppezz(nCont).idDeus         := REC.ID_DEUS;
  END LOOP;

END calcolaAppezzamento;

-- funzione che richiama la classe java datiSuoloPerPianoGrafico
FUNCTION datiParticellePerPianoGrafico(pIstatComune  VARCHAR2,
                                       pSezione      VARCHAR2,
                                       pFoglio       NUMBER,
                                       pParticella   NUMBER) RETURN tblSitiPart is LANGUAGE JAVA
NAME 'it.csi.smranag.storedproc.SitiDbBridge.datiParticellePerPianoGrafico(java.lang.String,java.lang.String,java.lang.Long,java.lang.Long) return it.csi.smranag.storedproc.SitiPartVO';

-- RC 29/04/2016
FUNCTION getParticelleGisCuaa(pCodiUtilita  VARCHAR2,
                              pCodiCuaa     VARCHAR2,
                              pCodiBelf     VARCHAR2 DEFAULT NULL,
                              pSeziCens     VARCHAR2 DEFAULT NULL,
                              pNumeFogl     VARCHAR2 DEFAULT NULL) RETURN tabParticelleGisType_AG PIPELINED IS

  recOut  recParticelleGisType_AG := recParticelleGisType_AG(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
                                                             NULL,NULL,NULL);

  SitiPart  tblSitiPart := tblSitiPart();
BEGIN
  FOR rec IN (SELECT AA.ID_AZIENDA,APG.ID_DICHIARAZIONE_CONSISTENZA,AA.CUAA
              FROM   DB_ACCESSO_PIANO_GRAFICO APG,DB_ANAGRAFICA_AZIENDA AA
              WHERE  APG.CODICE_UTILITA               = pCodiUtilita
              AND    APG.DATA_FINE_VALIDITA           IS NULL
              AND    AA.CUAA                          = pCodiCuaa
              AND    APG.ID_AZIENDA                   = AA.ID_AZIENDA
              AND    AA.DATA_FINE_VALIDITA            IS NULL
              AND    APG.ID_DICHIARAZIONE_CONSISTENZA IS NOT NULL) LOOP

    FOR recPart IN (SELECT SP.ID_PARTICELLA,C.CODFISC,C.DESCOM,SP.SEZIONE,SP.FOGLIO,
                           LPAD(SP.PARTICELLA,5,'0') PARTICELLA,SP.SUBALTERNO,C.ISTAT_COMUNE
                    FROM   DB_DICHIARAZIONE_CONSISTENZA DC,DB_CONDUZIONE_DICHIARATA CD,DB_STORICO_PARTICELLA SP,COMUNE C
                    WHERE  DC.ID_DICHIARAZIONE_CONSISTENZA = rec.ID_DICHIARAZIONE_CONSISTENZA
                    AND    DC.CODICE_FOTOGRAFIA_TERRENI    = CD.CODICE_FOTOGRAFIA_TERRENI
                    AND    CD.ID_TITOLO_POSSESSO           NOT IN (5,6)
                    AND    SP.ID_STORICO_PARTICELLA        = CD.ID_STORICO_PARTICELLA
                    AND    SP.COMUNE                       = C.ISTAT_COMUNE
                    AND    ((pCodiBelf IS NOT NULL AND pCodiBelf = C.CODFISC) OR
                            (pCodiBelf IS NULL))
                    AND    ((pSeziCens IS NOT NULL AND pSeziCens = SP.SEZIONE) OR
                            (pSeziCens IS NULL))
                    AND    ((pNumeFogl IS NOT NULL AND pNumeFogl = SP.FOGLIO) OR
                            (pNumeFogl IS NULL))
                    ORDER BY SP.COMUNE,SP.SEZIONE,SP.FOGLIO,SP.PARTICELLA,SP.SUBALTERNO) LOOP

      SitiPart.DELETE;
      SitiPart := datiParticellePerPianoGrafico(recPart.ISTAT_COMUNE,
                                                recPart.SEZIONE,
                                                recPart.FOGLIO,
                                                recPart.PARTICELLA);

      IF SitiPart.COUNT = 0 THEN
        recOut.ID_FASC   := rec.ID_AZIENDA;
        recOut.CUAA      := rec.CUAA;
        recOut.ID_PART   := recPart.ID_PARTICELLA;
        recOut.CODI_NAZI := NULL;
        recOut.CODI_BELF := recPart.CODFISC;
        recOut.DESC_COMU := recPart.DESCOM;
        recOut.SEZI_CENS := recPart.SEZIONE;
        recOut.NUME_FOGL := recPart.FOGLIO;
        recOut.NUME_PART := recPart.PARTICELLA;
        recOut.CODI_SUBA := recPart.SUBALTERNO;
        recOut.SUPE_PART := NULL;
        recOut.SHAPE     := NULL;

        Pipe Row (recOut);
      ELSE
        FOR i IN SitiPart.FIRST..SitiPart.LAST LOOP
          recOut.ID_FASC   := rec.ID_AZIENDA;
          recOut.CUAA      := rec.CUAA;
          recOut.ID_PART   := recPart.ID_PARTICELLA;
          recOut.CODI_NAZI := SitiPart(i).codNazionale;
          recOut.CODI_BELF := recPart.CODFISC;
          recOut.DESC_COMU := recPart.DESCOM;
          recOut.SEZI_CENS := recPart.SEZIONE;
          recOut.NUME_FOGL := recPart.FOGLIO;
          recOut.NUME_PART := recPart.PARTICELLA;
          recOut.CODI_SUBA := recPart.SUBALTERNO;
          recOut.SUPE_PART := SitiPart(i).supePart;
          recOut.SHAPE     := SitiPart(i).shape;

          Pipe Row (recOut);
        END LOOP;
      END IF;
    END LOOP;
  END LOOP;

  RETURN;
END getParticelleGisCuaa;

PROCEDURE calcolaIsola(pUserInse             VARCHAR2,
                       pDeusPoliTabe  IN OUT tabDeusPoliType_wp2,
                       pApcgTabe         OUT tabApcgType,
                       pAppezz           OUT tblAppezz) IS

  myShape     SDO_GEOMETRY;
  myArray     SDO_GEOMETRY_ARRAY;
  myIdApcg    NUMBER;
  mySupeUtil  NUMBER;
  nCont       SIMPLE_INTEGER := 0;
BEGIN
  EXECUTE IMMEDIATE ('TRUNCATE TABLE CABAAPCG_TAB');

  pApcgTabe := tabApcgType();
  FOR rAppe IN (SELECT r1.ID_FASC, r1.CODI_NAZI, r1.NUME_FOGL, r1.CODI_OCCU,
                       sdo_aggr_union(sdoaggrtype (r1.shape, 0.005)) AS shape,
                       CAST(COLLECT (nume_elem) AS ORA_MINING_NUMBER_NT) AS tabe_elem,
                       SUM(supe_util) AS supe_util
                FROM  (SELECT *
                       FROM (SELECT ROWNUM AS nume_elem, r.*
                             FROM   TABLE (CAST(PDeusPoliTabe AS tabDeusPoliType_wp2)) r)
                       ORDER BY nume_elem) r1
                GROUP BY r1.ID_FASC, r1.CODI_NAZI, r1.NUME_FOGL, r1.CODI_OCCU)  LOOP

    myArray := SDO_UTIL.EXTRACT_ALL(rAppe.shape, 0);
    IF myArray IS NOT NULL THEN
      IF myArray.COUNT = 1 THEN
        myShape    := myArray(1);
        myIdApcg   := SEQ_ID_APPEZZAMENTO.NEXTVAL;
        mySupeUtil := 0;

        FOR i IN 1..rAppe.tabe_elem.COUNT LOOP
          pDeusPoliTabe(rAppe.tabe_elem(i)).ID_APPEZ := myIdApcg;
          mySupeUtil := mySupeUtil + pDeusPoliTabe(rAppe.tabe_elem(i)).SUPE_UTIL;
        END LOOP;

        pApcgTabe.EXTEND;

        SELECT myIdApcg, rAppe.id_fasc,rAppe.CODI_OCCU, NULL, NULL, NULL,
               NULL,NULL, NULL, NULL,
               NULL,mySupeUtil, myShape, pUserInse, NULL,
               NULL, NULL,rAppe.CODI_NAZI, rAppe.NUME_FOGL
        INTO   pApcgTabe(pApcgTabe.COUNT)
        FROM   DUAL;

        INSERT INTO CABAAPCG_TAB
        (ID_APCG, ID_FASC,CODI_PROD ,CODI_NAZI, NUME_FOGL)
        VALUES
        (myIdApcg, rAppe.id_fasc,rAppe.CODI_OCCU,rAppe.CODI_NAZI, rAppe.NUME_FOGL);
      ELSE
        FOR j in 1..myArray.COUNT LOOP
          myShape    := myArray(j);
          myIdApcg   := SEQ_ID_ISOLA.NEXTVAL;
          mySupeUtil := 0;

          FOR i IN 1..rAppe.tabe_elem.COUNT LOOP
            DECLARE
              eleIdx     NUMBER := rAppe.tabe_elem(i);
              eleShape   SDO_GEOMETRY;
              resRelate  VARCHAR2(100);
            BEGIN
              eleShape  := pDeusPoliTabe(eleIdx).shape;
              resRelate := SDO_GEOM.RELATE( myShape, 'determine', eleShape, 0.005 );

              IF resRelate IN ('EQUAL', 'COVERS', 'CONTAINS') THEN
                pDeusPoliTabe(eleIdx).ID_APPEZ := myIdApcg;
                mySupeUtil                     := mySupeUtil + pDeusPoliTabe(eleIdx).SUPE_UTIL;
              END IF;
            END;
          END LOOP;

          pApcgTabe.EXTEND;

          SELECT myIdApcg, rAppe.id_fasc,rAppe.CODI_OCCU, NULL, NULL,
                 NULL, NULL,NULL, NULL,
                 NULL, NULL,mySupeUtil, myShape, pUserInse,
                 NULL, NULL, NULL,rAppe.CODI_NAZI,
                 rAppe.NUME_FOGL
          INTO   pApcgTabe(pApcgTabe.COUNT)
          FROM   DUAL;

          INSERT INTO CABAAPCG_TAB
          (ID_APCG, ID_FASC,CODI_PROD ,CODI_NAZI, NUME_FOGL)
          VALUES
          (myIdApcg, rAppe.id_fasc,rAppe.CODI_OCCU,rAppe.CODI_NAZI, rAppe.NUME_FOGL);
        END LOOP;
      END IF;
    END IF;
  END LOOP;

  COMMIT;
  nCont := 0;

  FOR rec in (SELECT T.ID_APCG,TAB.ID_DEUS
              FROM (SELECT ROWNUM AS nume_elem, r.*
                    FROM   TABLE (CAST(PDeusPoliTabe AS tabDeusPoliType_wp2)) r) TAB,CABAAPCG_TAB T
              WHERE  T.ID_FASC                   = TAB.ID_FASC
              AND    NVL(RTRIM(T.CODI_PROD),'0') = NVL(TAB.CODI_OCCU,'0')
              AND    NVL(T.CODI_NAZI,'0')        = NVL(TAB.CODI_NAZI,'0')
              AND    NVL(T.NUME_FOGL,0)          = NVL(TAB.NUME_FOGL,0)
              ORDER BY ID_APCG) LOOP

    nCont                         := nCont + 1;
    pAppezz(nCont).idAppezzamento := REC.ID_APCG;
    pAppezz(nCont).idDeus         := REC.ID_DEUS;
  END LOOP;

END calcolaIsola;

END CABAAD778_PS_WP;

/
--------------------------------------------------------
--  DDL for Package Body PACK_AGGIORNA_ATTESTAZIONI
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PACK_AGGIORNA_ATTESTAZIONI" IS

EsciRountine       EXCEPTION;
ERRORE          EXCEPTION;

-- 03/03/2009 PR-GAA23-02 Controlli attestazione - v3. doc modifica parametri             -- BM001
-- 06/03/2009 PR-GAA23-02 Controlli attestazione - v4  SMRANAG-652  modifica cursori     -- BM002
-- 09/03/2009 PR-GAA23-02 Controlli attestazione - v5  SMRANAG-655  asservimento            -- BM003
-- 16/03/2009 PR-GAA23-02 Controlli attestazione - v6  SMRANAG-662  mod.gestione id        -- BM004
-- 19/03/2009 PR-GAA23-02 Controlli attestazione - v7  SMRANAG-662  mod.gestione id        -- BM005
-- 02/04/2009 PR-GAA23-02 Controlli attestazione - v8  SMRANAG-695                              -- BM006
-- 02/04/2009 PR-GAA23-02 Controlli attestazione - v9  SMRANAG-699                              -- BM007
-- 08/04/2009 PR-GAA23-02 Controlli attestazione - v10 SMRANAG-711                              -- BM008
-- 22/04/2009 PR-GAA23-02 Controlli attestazione - v11 SMRANAG-723                              -- BM009
-- 16/06/2010 Aggiuto il parametro P_ID_DICHIARAZIONE_CONSISTENZA



PROCEDURE PRC_InserisciAttestazioni (pIdAzienda IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                     pIdAttestazione IN DB_TIPO_ATTESTAZIONE.ID_ATTESTAZIONE%TYPE,
                                     pIdUtenteAggiornamento IN DB_ATTESTAZIONE_AZIENDA.ID_UTENTE_AGGIORNAMENTO%TYPE,
                                     pCodiceFotografia IN DB_DICHIARAZIONE_CONSISTENZA.CODICE_FOTOGRAFIA_TERRENI%TYPE,
                                     pIdDicConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                     P_CODERR IN OUT VARCHAR2,
                                     P_MSGERR IN OUT VARCHAR2) IS

nAttestazioneAttiva    NUMBER(10);

BEGIN

--  **** inizio
 /* --Prima di inserire l'attestazione verifico che sia ancora attiva
    SELECT COUNT(*)
    INTO nAttestazioneAttiva
    FROM DB_TIPO_ATTESTAZIONE
    WHERE ID_ATTESTAZIONE=pIdAttestazione
    AND DATA_FINE_VALIDITA IS NULL;

    IF nAttestazioneAttiva>0 THEN
        IF pIdDicConsistenza IS NULL OR pIdDicConsistenza=0 THEN
          --Sul piano in lavorazione.
          INSERT INTO DB_ATTESTAZIONE_AZIENDA (ID_ATTESTAZIONE_AZIENDA, ID_AZIENDA, ID_ATTESTAZIONE,
          DATA_ULTIMO_AGGIORNAMENTO, ID_UTENTE_AGGIORNAMENTO)
          VALUES ( SEQ_ATTESTAZIONE_AZIENDA.NEXTVAL, pIdAzienda, pIdAttestazione, SYSDATE, pIdUtenteAggiornamento );
        ELSE
          --Sul piano della dichiarazione.
          INSERT INTO DB_ATTESTAZIONE_DICHIARATA
          (ID_ATTESTAZIONE_DICHIARATA, CODICE_FOTOGRAFIA_TERRENI, ID_ATTESTAZIONE, DATA_AGGIORNAMENTO, ID_UTENTE_AGGIORNAMENTO, DATA_INIZIO_VALIDITA)
                VALUES (SEQ_ATTESTAZIONE_DICHIARATA.NEXTVAL, pCodiceFotografia, pIdAttestazione, SYSDATE, pIdUtenteAggiornamento, SYSDATE);
        END IF;
    END IF; */

    IF pIdDicConsistenza IS NULL OR pIdDicConsistenza=0 THEN

        --Sul piano in lavorazione.
        --Prima di inserire l'attestazione verifico che sia ancora attiva
        SELECT COUNT(*)
        INTO nAttestazioneAttiva
        FROM DB_TIPO_ATTESTAZIONE
        WHERE ID_ATTESTAZIONE=pIdAttestazione
          AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);

        IF nAttestazioneAttiva>0 THEN
            INSERT INTO DB_ATTESTAZIONE_AZIENDA (ID_ATTESTAZIONE_AZIENDA, ID_AZIENDA, ID_ATTESTAZIONE,
            DATA_ULTIMO_AGGIORNAMENTO, ID_UTENTE_AGGIORNAMENTO)
            VALUES ( SEQ_ATTESTAZIONE_AZIENDA.NEXTVAL, pIdAzienda, pIdAttestazione, SYSDATE, pIdUtenteAggiornamento );
        END IF;
    ELSE

        --Sul piano della dichiarazione.
        --Prima di inserire l'attestazione verifico che sia ancora attiva
        SELECT COUNT(*)
        INTO nAttestazioneAttiva
        FROM DB_TIPO_ATTESTAZIONE TA
           , DB_DICHIARAZIONE_CONSISTENZA DC
        WHERE TA.ID_ATTESTAZIONE=pIdAttestazione
          AND DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDicConsistenza
          AND TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY')  BETWEEN TRUNC(TA.DATA_INIZIO_VALIDITA) AND NVL(TRUNC(TA.DATA_FINE_VALIDITA),TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY'));
--          AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN TA.DATA_INIZIO_VALIDITA AND NVL(TA.DATA_FINE_VALIDITA,SYSDATE);

        IF nAttestazioneAttiva>0 THEN
          INSERT INTO DB_ATTESTAZIONE_DICHIARATA
          (ID_ATTESTAZIONE_DICHIARATA, CODICE_FOTOGRAFIA_TERRENI, ID_ATTESTAZIONE, DATA_AGGIORNAMENTO, ID_UTENTE_AGGIORNAMENTO, DATA_INIZIO_VALIDITA)
                VALUES (SEQ_ATTESTAZIONE_DICHIARATA.NEXTVAL, pCodiceFotografia, pIdAttestazione, SYSDATE, pIdUtenteAggiornamento, SYSDATE);
        END IF;
    END IF;

--  **** fine
EXCEPTION
    WHEN OTHERS THEN
    P_CODERR:= 1;
    P_MSGERR   := 'ERRORE IN PRC_InserisciAttestazioni: ' ||SQLERRM;
    RAISE;
END PRC_InserisciAttestazioni;


PROCEDURE CARICA_ATTESTAZIONI(P_ID_AZIENDA                      IN DB_AZIENDA.ID_AZIENDA%TYPE,
                              P_ID_UTENTE_AGGIORNAMENTO         IN DB_ATTESTAZIONE_AZIENDA.ID_UTENTE_AGGIORNAMENTO%TYPE,
                              P_COD_ATTESTAZIONE                IN DB_TIPO_ATTESTAZIONE.CODICE_ATTESTAZIONE%TYPE,
                              P_ID_DICHIARAZIONE_CONSISTENZA    IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                              P_CODERR                          IN OUT VARCHAR2,
                              P_MSGERR                          IN OUT VARCHAR2) IS

-- Attestazione (DICHIARAZIONI/ALLEGATI) automatiche riferite alle colture
-- dell'azienda sul piano in lavorazione
CURSOR cur_particelle (par_nIdAzienda   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                       pCodAttestazione IN DB_TIPO_ATTESTAZIONE.CODICE_ATTESTAZIONE%TYPE) IS
      SELECT DISTINCT  TA.ID_ATTESTAZIONE_PADRE
      FROM DB_CONDUZIONE_PARTICELLA CP,
           DB_UTILIZZO_PARTICELLA UP,
           DB_UTE UTE,
           DB_TIPO_ATTESTAZIONE_VARIETA TAV,
           DB_TIPO_ATTESTAZIONE TA
      WHERE CP.DATA_FINE_CONDUZIONE IS NULL
        AND UP.ID_CONDUZIONE_PARTICELLA=CP.ID_CONDUZIONE_PARTICELLA
        AND CP.ID_UTE=UTE.ID_UTE
        AND UTE.DATA_FINE_ATTIVITA IS NULL
        AND UTE.ID_AZIENDA = par_nIdAzienda
        AND UP.ID_VARIETA    = TAV.ID_VARIETA
--        AND TAV.DATA_FINE_VALIDITA IS NULL
        AND SYSDATE BETWEEN TAV.DATA_INIZIO_VALIDITA AND NVL(TAV.DATA_FINE_VALIDITA,SYSDATE)
        AND TA.ID_ATTESTAZIONE = TAV.ID_ATTESTAZIONE
--        AND TA.DATA_FINE_VALIDITA IS NULL
        AND SYSDATE BETWEEN TA.DATA_INIZIO_VALIDITA AND NVL(TA.DATA_FINE_VALIDITA,SYSDATE)
        AND TA.CODICE_ATTESTAZIONE = pCodAttestazione 
        AND CP.ID_TITOLO_POSSESSO != knIdTitPossessoAsservimento;

    -- Attestazione (DICHIARAZIONI/ALLEGATI) automatiche riferite alle colture
    -- dell'azienda riferite alla dichiarazione di consistenza
    CURSOR cur_particelle_dichiarazione (PAR_ID_DIC_CONSISTENZA IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                         pCodAttestazione IN DB_TIPO_ATTESTAZIONE.CODICE_ATTESTAZIONE%TYPE) IS
    SELECT DISTINCT  TA.ID_ATTESTAZIONE_PADRE
      FROM DB_DICHIARAZIONE_CONSISTENZA DC,
           DB_CONDUZIONE_DICHIARATA CD,
           DB_UTILIZZO_DICHIARATO UD,
           DB_TIPO_ATTESTAZIONE_VARIETA TAV,
           DB_TIPO_ATTESTAZIONE TA
     WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = PAR_ID_DIC_CONSISTENZA
       AND CD.CODICE_FOTOGRAFIA_TERRENI = DC.CODICE_FOTOGRAFIA_TERRENI
       AND CD.ID_TITOLO_POSSESSO != knIdTitPossessoAsservimento
       AND UD.ID_CONDUZIONE_DICHIARATA = CD.ID_CONDUZIONE_DICHIARATA
       AND UD.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
       AND UD.ID_VARIETA = TAV.ID_VARIETA
       AND TAV.ID_ATTESTAZIONE = TA.ID_ATTESTAZIONE
       AND TA.CODICE_ATTESTAZIONE = pCodAttestazione 
       --AND TA.VOCE_MENU = PAR_VOCE_MENU
       -- la condizionalita' servendo ai fini dell'istruttoria delle domande di pagamento, non deve essere caricata in basa alla data
       -- della dich di consistenza, ma in base all'anno campagna di riferimento della dich di consistenza. Se creo una dich di cons
       -- nel 2012 come correttiva per una DU 2011 l'anno campagna di riferimento è 2011, cosi' la sua condizionalità.
       --
       -- aggiungo solo che, siccome ANNO_CAMPAGNA è NULLABLE, pesco il campo ANNO in caso di NULL
       AND TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY')  BETWEEN TRUNC(TA.DATA_INIZIO_VALIDITA) AND NVL(TRUNC(TA.DATA_FINE_VALIDITA),TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY'))
       AND TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY') BETWEEN TRUNC(TAV.DATA_INIZIO_VALIDITA) AND NVL(TRUNC(TAV.DATA_FINE_VALIDITA),TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY'));
--       AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN TA.DATA_INIZIO_VALIDITA AND NVL(TA.DATA_FINE_VALIDITA, SYSDATE) 
--       AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN TAV.DATA_INIZIO_VALIDITA AND NVL(TAV.DATA_FINE_VALIDITA, SYSDATE); 

-- Attestazione (DICHIARAZIONI/ALLEGATI) automatiche riferite agli allevamenti
-- dell'azienda sul piano in lavorazione.
-- Sono escluse le attestazioni riferite alla coltura
CURSOR C_ALLEVAMENTI (par_nIdAzienda    IN DB_AZIENDA.ID_AZIENDA%TYPE,
                      pCodAttestazione  IN DB_TIPO_ATTESTAZIONE.CODICE_ATTESTAZIONE%TYPE) IS
  SELECT DISTINCT SAA.ID_ATTESTAZIONE
    FROM DB_ALLEVAMENTO A,
         DB_TIPO_SP_ANIM_ATTESTAZIONE SAA,
         DB_TIPO_ATTESTAZIONE TA,
         DB_UTE U
   WHERE A.ID_SPECIE_ANIMALE = SAA.ID_SPECIE_ANIMALE
     AND A.DATA_FINE IS NULL
     AND U.ID_AZIENDA =    par_nIdAzienda
     AND U.ID_UTE = A.ID_UTE
     AND U.DATA_FINE_ATTIVITA IS NULL
--     AND SAA.DATA_FINE_VALIDITA IS NULL
     AND SYSDATE BETWEEN SAA.DATA_INIZIO_VALIDITA AND NVL(SAA.DATA_FINE_VALIDITA,SYSDATE)
     AND SAA.ID_ATTESTAZIONE = TA.ID_ATTESTAZIONE
--     AND TA.DATA_FINE_VALIDITA IS NULL
     AND SYSDATE BETWEEN TA.DATA_INIZIO_VALIDITA AND NVL(TA.DATA_FINE_VALIDITA,SYSDATE)
     AND TA.CODICE_ATTESTAZIONE = pCodAttestazione 
     --AND TA.VOCE_MENU=PAR_VOCE_MENU
  MINUS
  SELECT DISTINCT  TA.ID_ATTESTAZIONE_PADRE
    FROM DB_CONDUZIONE_PARTICELLA CP,
         DB_UTILIZZO_PARTICELLA UP,
         DB_UTE UTE,
         DB_TIPO_ATTESTAZIONE_VARIETA TAV,
         DB_TIPO_ATTESTAZIONE TA
   WHERE CP.DATA_FINE_CONDUZIONE IS NULL
     AND UP.ID_CONDUZIONE_PARTICELLA=CP.ID_CONDUZIONE_PARTICELLA
     AND CP.ID_UTE=UTE.ID_UTE
     AND UTE.DATA_FINE_ATTIVITA IS NULL
     AND UTE.ID_AZIENDA = par_nIdAzienda
     AND UP.ID_VARIETA  = TAV.ID_VARIETA
--     AND TAV.DATA_FINE_VALIDITA IS NULL
     AND SYSDATE BETWEEN TAV.DATA_INIZIO_VALIDITA AND NVL(TAV.DATA_FINE_VALIDITA,SYSDATE)
     AND TA.ID_ATTESTAZIONE = TAV.ID_ATTESTAZIONE
--    AND TA.DATA_FINE_VALIDITA IS NULL
     AND SYSDATE BETWEEN TA.DATA_INIZIO_VALIDITA AND NVL(TA.DATA_FINE_VALIDITA,SYSDATE)
     AND TA.CODICE_ATTESTAZIONE = pCodAttestazione 
     --AND TA.VOCE_MENU=PAR_VOCE_MENU
     AND CP.ID_TITOLO_POSSESSO != knIdTitPossessoAsservimento;


-- Attestazione (DICHIARAZIONI/ALLEGATI) automatiche riferite agli allevamenti
-- dell'azienda riferite alla dichiarazione di consistenza
-- Sono escluse le attestazioni riferite alla coltura
CURSOR C_ALLEVAMENTI_DICHIARAZIONE (PAR_ID_DIC_CONSISTENZA IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                    pCodAttestazione       IN DB_TIPO_ATTESTAZIONE.CODICE_ATTESTAZIONE%TYPE) IS
    SELECT DISTINCT SAA.ID_ATTESTAZIONE
      FROM DB_DICHIARAZIONE_CONSISTENZA DC,
           DB_UTE U,
           DB_ALLEVAMENTO A,
           DB_TIPO_SP_ANIM_ATTESTAZIONE SAA,
           DB_TIPO_ATTESTAZIONE TA
     WHERE DC.ID_DICHIARAZIONE_CONSISTENZA=PAR_ID_DIC_CONSISTENZA
       AND DC.ID_AZIENDA=U.ID_AZIENDA
       AND U.ID_UTE=A.ID_UTE
       AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN A.DATA_INIZIO AND NVL(A.DATA_FINE,SYSDATE)
       -- vedi sopra
       AND TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY')  BETWEEN TRUNC(SAA.DATA_INIZIO_VALIDITA) AND NVL(TRUNC(SAA.DATA_FINE_VALIDITA),TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY'))
       AND TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY') BETWEEN TRUNC(TA.DATA_INIZIO_VALIDITA) AND NVL(TRUNC(TA.DATA_FINE_VALIDITA),TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY'))
--       AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN SAA.DATA_INIZIO_VALIDITA AND NVL(SAA.DATA_FINE_VALIDITA, SYSDATE) 
--       AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN TA.DATA_INIZIO_VALIDITA AND NVL(TA.DATA_FINE_VALIDITA, SYSDATE); 
       AND A.ID_SPECIE_ANIMALE = SAA.ID_SPECIE_ANIMALE
       AND SAA.ID_ATTESTAZIONE = TA.ID_ATTESTAZIONE
       AND TA.CODICE_ATTESTAZIONE = pCodAttestazione 
       -- AND TA.VOCE_MENU=PAR_VOCE_MENU
    MINUS
    SELECT DISTINCT  TA.ID_ATTESTAZIONE_PADRE
      FROM DB_DICHIARAZIONE_CONSISTENZA DC,
           DB_CONDUZIONE_DICHIARATA CD,
           DB_UTILIZZO_DICHIARATO UD,
           DB_TIPO_ATTESTAZIONE_VARIETA TAV,
           DB_TIPO_ATTESTAZIONE TA
     WHERE DC.ID_DICHIARAZIONE_CONSISTENZA=PAR_ID_DIC_CONSISTENZA
       AND CD.CODICE_FOTOGRAFIA_TERRENI=DC.CODICE_FOTOGRAFIA_TERRENI
       AND CD.ID_TITOLO_POSSESSO != knIdTitPossessoAsservimento
       AND UD.ID_CONDUZIONE_DICHIARATA=CD.ID_CONDUZIONE_DICHIARATA
       AND UD.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
       AND UD.ID_VARIETA=TAV.ID_VARIETA
       AND TAV.ID_ATTESTAZIONE=TA.ID_ATTESTAZIONE
       AND TA.CODICE_ATTESTAZIONE = pCodAttestazione 
       --AND TA.VOCE_MENU=PAR_VOCE_MENU
       AND TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY')  BETWEEN TRUNC(TAV.DATA_INIZIO_VALIDITA) AND NVL(TRUNC(TAV.DATA_FINE_VALIDITA),TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY'))
       AND TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY') BETWEEN TRUNC(TA.DATA_INIZIO_VALIDITA) AND NVL(TRUNC(TA.DATA_FINE_VALIDITA),TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY'));
--       AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN TAV.DATA_INIZIO_VALIDITA AND NVL(TAV.DATA_FINE_VALIDITA, SYSDATE) 
--       AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN TA.DATA_INIZIO_VALIDITA AND NVL(TA.DATA_FINE_VALIDITA, SYSDATE); 

-- Recupera le attestazioni (DICHIARAZIONI/ALLEGATI)
-- da inserire sul piano in lavorazione
-- legate all'atto A3 se le stesse sono state sottoscritte
-- nell'ultima dichiarazione di consistenza dell'anno presendente
-- legata alla domanda unica escludendo le domande annullate.
CURSOR CUR_A3(par_nIdAzienda   IN DB_AZIENDA.ID_AZIENDA%TYPE,
              pCodAttestazione IN DB_TIPO_ATTESTAZIONE.CODICE_ATTESTAZIONE%TYPE) IS
  SELECT DISTINCT VALORE_NUMERICO1
    FROM DB_TIPO_CONTROLLO_PARAMETRO PAR,
         DB_ATTESTAZIONE_DICHIARATA ATT,
         DB_DICHIARAZIONE_CONSISTENZA CONS
   WHERE PAR.ID_CONTROLLO = 700
     AND PAR.CODICE = pCodAttestazione || '_'    || 'COND9' 
     AND SYSDATE BETWEEN PAR.DATA_INIZIO_VALIDITA AND NVL(PAR.DATA_FINE_VALIDITA,SYSDATE) 
     AND ATT.ID_ATTESTAZIONE = PAR.VALORE_NUMERICO
     AND CONS.CODICE_FOTOGRAFIA_TERRENI = ATT.CODICE_FOTOGRAFIA_TERRENI
     AND CONS.ID_AZIENDA = P_ID_AZIENDA
     AND DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DATA_INSERIMENTO_DICHIARAZIONE)
                                                                                   FROM DB_DICHIARAZIONE_CONSISTENZA CONS1,
                                                                                        DB_PROCEDIMENTO_AZIENDA PROC
                                                                                  WHERE CONS1.ID_AZIENDA = par_nIdAzienda
                                                                                    AND TO_NUMBER(TO_CHAR(DATA_INSERIMENTO_DICHIARAZIONE,'YYYY')) <= TO_NUMBER(TO_CHAR(SYSDATE,'YYYY')-1)
                                                                                    AND CONS1.ID_DICHIARAZIONE_CONSISTENZA =  PROC.ID_DICHIARAZIONE_CONSISTENZA
                                                                                    AND PROC.ID_PROCEDIMENTO = knIdProcedimentoRPU
                                                                                    AND PROC.ID_AZIENDA = CONS1.ID_AZIENDA
                                                                                    AND PROC.STATO    != 'A'
                                                                                );


-- Recupera le attestazioni (DICHIARAZIONI/ALLEGATI)
-- da inserire alla dichiarazione di consistenza
-- legate all'atto A3 se le stesse sono state sottoscritte
-- nell'ultima dichiarazione di consistenza dell'anno presendente
-- legata alla domanda unica escludendo le domande annullate.
-- Le attestazione dell'atto A3 sono censite nella tavola db_tipo_controllo_parametro
CURSOR CUR_A3_DICHIARAZIONE(PAR_ID_DIC_CONSISTENZA IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                            pCodAttestazione       IN DB_TIPO_ATTESTAZIONE.CODICE_ATTESTAZIONE%TYPE) IS
--                                                           PAR_DATA_DIC IN DATE) IS
    SELECT DISTINCT VALORE_NUMERICO1
      FROM DB_TIPO_CONTROLLO_PARAMETRO PAR,
           DB_ATTESTAZIONE_DICHIARATA ATT,
           DB_DICHIARAZIONE_CONSISTENZA CONS
    WHERE PAR.ID_CONTROLLO = 700
      AND PAR.CODICE =pCodAttestazione || '_'    || 'COND9' -
      AND TO_DATE('31/12' || NVL(CONS.ANNO_CAMPAGNA,CONS.ANNO),'DD/MM/YYYY')  BETWEEN TRUNC(PAR.DATA_INIZIO_VALIDITA) AND NVL(TRUNC(PAR.DATA_FINE_VALIDITA),TO_DATE('31/12' || NVL(CONS.ANNO_CAMPAGNA,CONS.ANNO),'DD/MM/YYYY'))
      -- AND PAR_DATA_DIC BETWEEN PAR.DATA_INIZIO_VALIDITA AND NVL(PAR.DATA_FINE_VALIDITA, SYSDATE) 
      AND ATT.ID_ATTESTAZIONE = PAR.VALORE_NUMERICO
      AND CONS.CODICE_FOTOGRAFIA_TERRENI = ATT.CODICE_FOTOGRAFIA_TERRENI
      AND CONS.ID_AZIENDA = (SELECT ID_AZIENDA
                                                   FROM DB_DICHIARAZIONE_CONSISTENZA
                                                  WHERE ID_DICHIARAZIONE_CONSISTENZA=PAR_ID_DIC_CONSISTENZA
                                                  )
      AND DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DATA_INSERIMENTO_DICHIARAZIONE)
                                                                                    FROM DB_DICHIARAZIONE_CONSISTENZA CONS1,
                                                                                         DB_PROCEDIMENTO_AZIENDA    PROC
                                                                                   WHERE CONS1.ID_AZIENDA = (SELECT ID_AZIENDA
                                                                                                               FROM DB_DICHIARAZIONE_CONSISTENZA
                                                                                                              WHERE ID_DICHIARAZIONE_CONSISTENZA=PAR_ID_DIC_CONSISTENZA)
                                                                                     AND TO_NUMBER(TO_CHAR(DATA_INSERIMENTO_DICHIARAZIONE,'YYYY')) <=TO_NUMBER(TO_CHAR((SELECT DATA_INSERIMENTO_DICHIARAZIONE
                                                                                                                                                                          FROM DB_DICHIARAZIONE_CONSISTENZA
                                                                                                                                                                         WHERE ID_DICHIARAZIONE_CONSISTENZA=PAR_ID_DIC_CONSISTENZA),'YYYY')-1)
                                                                                     AND CONS1.ID_DICHIARAZIONE_CONSISTENZA =  PROC.ID_DICHIARAZIONE_CONSISTENZA
                                                                                     AND PROC.ID_PROCEDIMENTO = knIdProcedimentoRPU
                                                                                     AND PROC.ID_AZIENDA = CONS1.ID_AZIENDA
                                                                                     AND PROC.STATO != 'A'
                                                                                  );

ERR_AGGIORNA_PRATICA_AZIENDA    EXCEPTION;

N_CONTA_ZPS                   NUMBER(10);
N_CONTA_SIC                   NUMBER(10);
N_CONTA_ZONA_MONTANA          NUMBER(10);                                          -- GS2012
N_CONTA_PSR                   NUMBER(10);                                          -- GS2012
N_CONTATORE                   NUMBER(10);
N_CONTA_TERRENI               NUMBER(10);
N_TOT_CONDOTTA_ZVN            DB_CONDUZIONE_DICHIARATA.SUPERFICIE_CONDOTTA%TYPE;
N_TOT_CONDOTTA                DB_CONDUZIONE_DICHIARATA.SUPERFICIE_CONDOTTA%TYPE;

N_ZONA_NAT_2000               NUMBER(10);                                          -- BM004
nCond                         DB_TIPO_CONTROLLO_PARAMETRO.VALORE_NUMERICO%TYPE;    -- BM004
nCountUma                     NUMBER(10);                                          -- BM006
nNoZonaNat2000                NUMBER(10);                                          -- BM006
nCond10                       DB_TIPO_CONTROLLO_PARAMETRO.VALORE_NUMERICO%TYPE;    -- BM007
nCond11                       DB_TIPO_CONTROLLO_PARAMETRO.VALORE_NUMERICO%TYPE;    -- BM007
nCount10                      DB_TIPO_CONTROLLO_PARAMETRO.VALORE_NUMERICO%TYPE;    -- BM007
nCount11                      DB_TIPO_CONTROLLO_PARAMETRO.VALORE_NUMERICO%TYPE;    -- BM007
nFab                          NUMBER(10);                                          -- BM008
nCountA3                      NUMBER(10);                                          -- BM009

nCodiceFotografia           DB_DICHIARAZIONE_CONSISTENZA.CODICE_FOTOGRAFIA_TERRENI%TYPE;
dDataInsDichiarazione       DB_DICHIARAZIONE_CONSISTENZA.DATA_INSERIMENTO_DICHIARAZIONE%TYPE;
-- è la data dell'ultimo gg del'anno campagna della dich o anno della dich se il campo anno campagna è null
lastDayDich                        DATE;

BEGIN
    P_CODERR              := NULL;
    P_MSGERR              := NULL;
    N_CONTA_ZPS           := 0;
    N_CONTA_SIC           := 0;
    N_CONTATORE           := 0;
    N_CONTA_ZONA_MONTANA  := 0;
    N_CONTA_PSR           := 0;
    nCodiceFotografia     := 0;
    dDataInsDichiarazione := NULL;

    BEGIN

      --Elimina le attestazioni (DICHIARAZIONI/ALLEGATI) gestite in automatico
      --da questa procedura.
      IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
      --Sul piano in lavorazione.
        DELETE DB_ATTESTAZIONE_AZIENDA
        WHERE ID_AZIENDA = P_ID_AZIENDA
        AND ID_ATTESTAZIONE IN (SELECT ID_ATTESTAZIONE
                                  FROM DB_TIPO_ATTESTAZIONE
                                 WHERE DISABILITATO = 'S'
                                   AND CODICE_ATTESTAZIONE = P_COD_ATTESTAZIONE); 
      ELSE
      --Sul piano della dichiarazione.
      --Recupero alcune informazioni della dichiarazione
        SELECT
          CODICE_FOTOGRAFIA_TERRENI,
          DATA_INSERIMENTO_DICHIARAZIONE,
          TO_DATE('31/12' || NVL(ANNO_CAMPAGNA,ANNO),'DD/MM/YYYY') LASTDAY
        INTO nCodiceFotografia,
                 dDataInsDichiarazione,
                 lastDayDich
        FROM DB_DICHIARAZIONE_CONSISTENZA
        WHERE ID_DICHIARAZIONE_CONSISTENZA=P_ID_DICHIARAZIONE_CONSISTENZA;

        -- trasformo la DELETE in UPDATE che setta la DATA_FINE_VALIDITA
        UPDATE DB_ATTESTAZIONE_DICHIARATA
           SET DATA_FINE_VALIDITA = SYSDATE
         WHERE CODICE_FOTOGRAFIA_TERRENI = nCodiceFotografia
           AND ID_ATTESTAZIONE IN ( SELECT ID_ATTESTAZIONE
                                      FROM DB_TIPO_ATTESTAZIONE
                                     WHERE DISABILITATO = 'S'
                                       AND CODICE_ATTESTAZIONE = P_COD_ATTESTAZIONE) 
           AND DATA_FINE_VALIDITA IS NULL;

      END IF;


      --Elimino determinate attestazioni (DICHIARAZIONI/ALLEGATI)
      --censite sulla tavola DB_TIPO_CONTROLLO_PARAMETRO
      IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
      --sul piano in lavorazione
        DELETE DB_ATTESTAZIONE_AZIENDA
        WHERE ID_AZIENDA = P_ID_AZIENDA
        AND ID_ATTESTAZIONE IN (SELECT VALORE_NUMERICO
                                  FROM DB_TIPO_CONTROLLO_PARAMETRO
                                 WHERE ID_CONTROLLO    = 700
                                   AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND1' 
                                   AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE));
      ELSE
        --Sul piano della dichiarazione.
        -- trasformo la DELETE in UPDATE che setta la DATA_FINE_VALIDITA
        UPDATE DB_ATTESTAZIONE_DICHIARATA
           SET DATA_FINE_VALIDITA = SYSDATE
         WHERE CODICE_FOTOGRAFIA_TERRENI = nCodiceFotografia
           AND DATA_FINE_VALIDITA IS NULL
           AND ID_ATTESTAZIONE IN (SELECT VALORE_NUMERICO
                                                         FROM DB_TIPO_CONTROLLO_PARAMETRO
                                                        WHERE ID_CONTROLLO    = 700
                                                          AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND1' 
                                                          
                                                          AND lastDayDich  BETWEEN TRUNC(DATA_INIZIO_VALIDITA) AND NVL(TRUNC(DATA_FINE_VALIDITA),lastDayDich)
                                                         );
--                                      AND dDataInsDichiarazione BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE));
      END IF;

    EXCEPTION
        WHEN OTHERS THEN
            P_CODERR := '999999';
            P_MSGERR := 'ERRORE NELLA CANCELLAZIONE INIZIALE DELLE ATTESTAZIONI.';
            RAISE ERRORE;
    END;

    --Inserisco automaticamente le attestazioni (DICHIARAZIONI/ALLEGATI)
    --legate al piano colturale dell'azienda
    IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
      --Sul piano in lavorazione
      FOR recParticelle IN cur_particelle (P_ID_AZIENDA,P_COD_ATTESTAZIONE) LOOP 
          PRC_InserisciAttestazioni (P_ID_AZIENDA,recParticelle.ID_ATTESTAZIONE_PADRE,P_ID_UTENTE_AGGIORNAMENTO,nCodiceFotografia,P_ID_DICHIARAZIONE_CONSISTENZA,P_CODERR,P_MSGERR );
      END LOOP;
    ELSE
      --Sul piano della dichiarazione.
      FOR recParticelle IN cur_particelle_dichiarazione (P_ID_DICHIARAZIONE_CONSISTENZA,P_COD_ATTESTAZIONE) LOOP 
          PRC_InserisciAttestazioni (P_ID_AZIENDA,recParticelle.ID_ATTESTAZIONE_PADRE,P_ID_UTENTE_AGGIORNAMENTO,nCodiceFotografia,P_ID_DICHIARAZIONE_CONSISTENZA,P_CODERR,P_MSGERR );
      END LOOP;
    END IF;


    BEGIN
      --Inserisce specifiche attestazioni (DICHIARAZIONI/ALLEGATI) nel caso esistano
      --particelle che ricadono in zona protezione speciale (ZPS).
      --Escludere le conduzioni in asservimento
      IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
        --Sul piano in lavorazione
        SELECT COUNT(*)
        INTO N_CONTA_ZPS
        FROM DB_STORICO_PARTICELLA SP, DB_CONDUZIONE_PARTICELLA CP, DB_UTE U,
             DB_R_PARTICELLA_AREA PA,DB_TIPO_VALORE_AREA TVA
        WHERE SP.ID_PARTICELLA = CP.ID_PARTICELLA
          AND      SP.DATA_FINE_VALIDITA IS NULL
          AND CP.DATA_FINE_CONDUZIONE IS NULL
          AND CP.ID_UTE = U.ID_UTE
          AND U.DATA_FINE_ATTIVITA IS NULL
          AND U.ID_AZIENDA = P_ID_AZIENDA
          --AND SP.ID_AREA_C IN (2,4)
          AND    CP.ID_TITOLO_POSSESSO            !=    knIdTitPossessoAsservimento
          AND SP.ID_PARTICELLA = PA.ID_PARTICELLA
          and PA.ID_TIPO_VALORE_AREA = TVA.ID_TIPO_VALORE_AREA
          and PA.DATA_FINE_VALIDITA IS NULL
          AND TVA.ID_TIPO_AREA = 4
          and TVA.VALORE IN (2,4);

        IF N_CONTA_ZPS > 0 THEN
            SELECT VALORE_NUMERICO
              INTO nCond
              FROM DB_TIPO_CONTROLLO_PARAMETRO
             WHERE ID_CONTROLLO = 700
               AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND2'
               AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);
        END IF;


      ELSE
        --Sul piano della dichiarazione.
        SELECT COUNT(*)
        INTO N_CONTA_ZPS
        FROM  DB_STORICO_PARTICELLA SP,
              DB_CONDUZIONE_DICHIARATA CD,DB_R_PARTICELLA_AREA PA,DB_TIPO_VALORE_AREA TVA
        WHERE SP.ID_STORICO_PARTICELLA = CD.ID_STORICO_PARTICELLA
        AND CD.CODICE_FOTOGRAFIA_TERRENI=nCodiceFotografia
        --AND SP.ID_AREA_C IN (2,4)
        AND    CD.ID_TITOLO_POSSESSO            !=    knIdTitPossessoAsservimento
          AND SP.ID_PARTICELLA = PA.ID_PARTICELLA
          and PA.ID_TIPO_VALORE_AREA = TVA.ID_TIPO_VALORE_AREA
          and PA.DATA_FINE_VALIDITA IS NULL
          AND TVA.ID_TIPO_AREA = 4
          and TVA.VALORE IN (2,4);

        IF N_CONTA_ZPS > 0 THEN
            SELECT VALORE_NUMERICO
              INTO nCond
              FROM DB_TIPO_CONTROLLO_PARAMETRO
             WHERE ID_CONTROLLO = 700
               AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND2' 
               AND lastDayDich  BETWEEN TRUNC(DATA_INIZIO_VALIDITA) AND NVL(TRUNC(DATA_FINE_VALIDITA),lastDayDich);
  --             AND dDataInsDichiarazione BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);
        END IF;

      END IF;


      IF N_CONTA_ZPS > 0 THEN
        PRC_InserisciAttestazioni (P_ID_AZIENDA,nCond,P_ID_UTENTE_AGGIORNAMENTO,nCodiceFotografia,P_ID_DICHIARAZIONE_CONSISTENZA,P_CODERR,P_MSGERR );
      END IF;


    --Inserisce specifiche attestazioni (DICHIARAZIONI/ALLEGATI) nel caso esistano
    --particelle che ricadono in siti di importanza comunitaria (SIC).
    --Escludere le conduzioni in asservimento
    IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
      --Sul piano in lavorazione
          SELECT COUNT(*)
          INTO N_CONTA_SIC
          FROM  DB_STORICO_PARTICELLA SP,
                DB_CONDUZIONE_PARTICELLA CP,
                DB_UTE U,DB_R_PARTICELLA_AREA PA,DB_TIPO_VALORE_AREA TVA
          WHERE SP.ID_PARTICELLA = CP.ID_PARTICELLA
          AND SP.DATA_FINE_VALIDITA IS NULL
          AND CP.DATA_FINE_CONDUZIONE IS NULL
          AND CP.ID_UTE = U.ID_UTE
          AND U.DATA_FINE_ATTIVITA IS NULL
          AND U.ID_AZIENDA = P_ID_AZIENDA
          --AND SP.ID_AREA_C IN (3,4)
          AND    CP.ID_TITOLO_POSSESSO            !=    knIdTitPossessoAsservimento
          AND SP.ID_PARTICELLA = PA.ID_PARTICELLA
          and PA.ID_TIPO_VALORE_AREA = TVA.ID_TIPO_VALORE_AREA
          and PA.DATA_FINE_VALIDITA IS NULL
          AND TVA.ID_TIPO_AREA = 4
          and TVA.VALORE IN (3,4);

          IF N_CONTA_SIC > 0 THEN
              SELECT VALORE_NUMERICO INTO nCond
              FROM DB_TIPO_CONTROLLO_PARAMETRO
              WHERE ID_CONTROLLO = 700
              AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND3' 
              AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);
          END IF;
    ELSE
      --Sul piano della dichiarazione.
          SELECT COUNT(*)
          INTO N_CONTA_SIC
          FROM  DB_STORICO_PARTICELLA SP,
                DB_CONDUZIONE_DICHIARATA CD,DB_R_PARTICELLA_AREA PA,DB_TIPO_VALORE_AREA TVA
          WHERE SP.ID_STORICO_PARTICELLA = CD.ID_STORICO_PARTICELLA
          AND CD.CODICE_FOTOGRAFIA_TERRENI=nCodiceFotografia
          --AND SP.ID_AREA_C IN (3,4)
          AND    CD.ID_TITOLO_POSSESSO            !=    knIdTitPossessoAsservimento
          AND SP.ID_PARTICELLA = PA.ID_PARTICELLA
          and PA.ID_TIPO_VALORE_AREA = TVA.ID_TIPO_VALORE_AREA
          and PA.DATA_FINE_VALIDITA IS NULL
          AND TVA.ID_TIPO_AREA = 4
          and TVA.VALORE IN (3,4);

          IF N_CONTA_SIC > 0 THEN
              SELECT VALORE_NUMERICO INTO nCond
              FROM DB_TIPO_CONTROLLO_PARAMETRO
              WHERE ID_CONTROLLO = 700
              AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND3'
               AND lastDayDich  BETWEEN TRUNC(DATA_INIZIO_VALIDITA) AND NVL(TRUNC(DATA_FINE_VALIDITA),lastDayDich);
  --            AND dDataInsDichiarazione BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);
          END IF;

    END IF;

    IF N_CONTA_SIC > 0 THEN
      PRC_InserisciAttestazioni (P_ID_AZIENDA,nCond,P_ID_UTENTE_AGGIORNAMENTO,nCodiceFotografia,P_ID_DICHIARAZIONE_CONSISTENZA,P_CODERR,P_MSGERR );
    END IF;

    -- 1) Ricava il numero di conduzioni che
    -- ricadono in ZVN (considero anche le fasce fluviali)
    IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
       -- Sul piano in lavorazione
       -- SELECT NVL(ROUND(SUM(NVL(CP.SUPERFICIE_CONDOTTA,0)),2),0)
       SELECT NVL(SUM(CP.SUPERFICIE_CONDOTTA),0)
         INTO N_TOT_CONDOTTA_ZVN
         FROM DB_STORICO_PARTICELLA SP,
              DB_CONDUZIONE_PARTICELLA CP,
              DB_UTE U,
              DB_FOGLIO F,DB_R_PARTICELLA_AREA PA,DB_TIPO_VALORE_AREA TVA
        WHERE U.ID_AZIENDA = P_ID_AZIENDA
          AND    SP.ID_PARTICELLA = CP.ID_PARTICELLA
          AND SP.DATA_FINE_VALIDITA IS NULL
          AND CP.DATA_FINE_CONDUZIONE IS NULL
          AND CP.ID_UTE = U.ID_UTE
          AND U.DATA_FINE_ATTIVITA IS NULL
          AND CP.ID_TITOLO_POSSESSO != knIdTitPossessoAsservimento
          AND NVL(F.SEZIONE(+),-1) = NVL(SP.SEZIONE,-1)
          AND F.FOGLIO(+) = SP.FOGLIO
          AND F.COMUNE(+) = SP.COMUNE
          AND SP.ID_PARTICELLA = PA.ID_PARTICELLA
          AND PA.DATA_FINE_VALIDITA IS NULL
          and PA.ID_TIPO_VALORE_AREA = TVA.ID_TIPO_VALORE_AREA
          AND (TVA.ID_TIPO_AREA = 14 OR (TVA.ID_TIPO_AREA = 6 AND TVA.VALORE = 2));
          --AND (SP.ID_FASCIA_FLUVIALE IS NOT NULL OR NVL(F.ID_AREA_E,0) = 2);
    ELSE
       -- Sul piano della dichiarazione.
       -- SELECT NVL(ROUND(SUM(NVL(CD.SUPERFICIE_CONDOTTA,0)),2),0)
       SELECT NVL(SUM(CD.SUPERFICIE_CONDOTTA),0)
         INTO N_TOT_CONDOTTA_ZVN
         FROM DB_CONDUZIONE_DICHIARATA CD,
              DB_STORICO_PARTICELLA SP,
              DB_FOGLIO F,DB_R_PARTICELLA_AREA PA,DB_TIPO_VALORE_AREA TVA
        WHERE CD.CODICE_FOTOGRAFIA_TERRENI = nCodiceFotografia
          AND    SP.ID_STORICO_PARTICELLA = CD.ID_STORICO_PARTICELLA
          AND CD.ID_TITOLO_POSSESSO != knIdTitPossessoAsservimento
          AND NVL(F.SEZIONE(+),-1) = NVL(SP.SEZIONE,-1)
          AND F.FOGLIO(+) = SP.FOGLIO
          AND F.COMUNE(+) = SP.COMUNE
          AND SP.ID_PARTICELLA = PA.ID_PARTICELLA
          AND PA.DATA_FINE_VALIDITA IS NULL
          and PA.ID_TIPO_VALORE_AREA = TVA.ID_TIPO_VALORE_AREA
          AND (TVA.ID_TIPO_AREA = 14 OR (TVA.ID_TIPO_AREA = 6 AND TVA.VALORE = 2));
          --AND (SP.ID_FASCIA_FLUVIALE IS NOT NULL OR NVL(F.ID_AREA_E,0) = 2);
    END IF;

    -- 2) Ricavo la superficie totale condotta dall'azienda
    IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
       -- Sul piano in lavorazione
       -- SELECT NVL(ROUND(SUM(NVL(CP.SUPERFICIE_CONDOTTA,0)),2),0)
       SELECT NVL(SUM(CP.SUPERFICIE_CONDOTTA),0)
         INTO N_TOT_CONDOTTA
         FROM DB_STORICO_PARTICELLA SP,
              DB_CONDUZIONE_PARTICELLA CP,
              DB_UTE U
        WHERE U.ID_AZIENDA = P_ID_AZIENDA
          AND    SP.ID_PARTICELLA = CP.ID_PARTICELLA
          AND SP.DATA_FINE_VALIDITA IS NULL
          AND CP.DATA_FINE_CONDUZIONE IS NULL
          AND CP.ID_UTE = U.ID_UTE
          AND U.DATA_FINE_ATTIVITA IS NULL
          AND CP.ID_TITOLO_POSSESSO != knIdTitPossessoAsservimento;
    ELSE
       -- Sul piano della dichiarazione
       -- SELECT NVL(ROUND(SUM(NVL(CD.SUPERFICIE_CONDOTTA,0)),2),0)
       SELECT NVL(SUM(CD.SUPERFICIE_CONDOTTA),0)
         INTO N_TOT_CONDOTTA
         FROM DB_CONDUZIONE_DICHIARATA CD
        WHERE CD.CODICE_FOTOGRAFIA_TERRENI = nCodiceFotografia
          AND CD.ID_TITOLO_POSSESSO != knIdTitPossessoAsservimento;
    END IF;

    --    Se N_TOT_CONDOTTA è 0 non deve essere eseguita la INSERT
   IF N_TOT_CONDOTTA > 0 THEN
      IF (N_TOT_CONDOTTA_ZVN / N_TOT_CONDOTTA) * 100 > 25 THEN
        --Recupero l'attestazione
        --da inserire
        IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
            SELECT VALORE_NUMERICO
            INTO nCond
            FROM DB_TIPO_CONTROLLO_PARAMETRO
            WHERE ID_CONTROLLO    = 700
            AND    CODICE = P_COD_ATTESTAZIONE || '_' || 'COND5' 
            AND   SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 
        ELSE
            SELECT VALORE_NUMERICO
            INTO nCond
            FROM DB_TIPO_CONTROLLO_PARAMETRO
            WHERE ID_CONTROLLO    = 700
            AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND5' 
            AND lastDayDich  BETWEEN TRUNC(DATA_INIZIO_VALIDITA) AND NVL(TRUNC(DATA_FINE_VALIDITA),lastDayDich);
  --          AND dDataInsDichiarazione BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 
        END IF;

        PRC_InserisciAttestazioni (P_ID_AZIENDA,nCond,P_ID_UTENTE_AGGIORNAMENTO,nCodiceFotografia,P_ID_DICHIARAZIONE_CONSISTENZA,P_CODERR,P_MSGERR );

      END IF;


      IF NOT ( N_TOT_CONDOTTA_ZVN    / N_TOT_CONDOTTA ) *    100  BETWEEN 0 AND 25 THEN
        --Recupero l'attestazione
        --da eliminare

        IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
            BEGIN
                SELECT VALORE_NUMERICO
                INTO nCond
                FROM DB_TIPO_CONTROLLO_PARAMETRO
                WHERE ID_CONTROLLO    = 700
                AND    CODICE = P_COD_ATTESTAZIONE || '_' || 'COND4' 
                AND   SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    nCond := NULL;
            END;
        ELSE
            BEGIN
                SELECT VALORE_NUMERICO
                INTO nCond
                FROM DB_TIPO_CONTROLLO_PARAMETRO
                WHERE ID_CONTROLLO    = 700
                AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND4' 
                AND lastDayDich  BETWEEN TRUNC(DATA_INIZIO_VALIDITA) AND NVL(TRUNC(DATA_FINE_VALIDITA),lastDayDich);
      --          AND dDataInsDichiarazione BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    nCond := NULL;
            END;
        END IF;
        IF nCond IS NOT NULL THEN
           PRC_InserisciAttestazioni (P_ID_AZIENDA,nCond,P_ID_UTENTE_AGGIORNAMENTO,nCodiceFotografia,P_ID_DICHIARAZIONE_CONSISTENZA,P_CODERR,P_MSGERR );
        END IF;
      END IF;
    END IF;


      --Inserisco automaticamente le attestazioni (DICHIARAZIONI/ALLEGATI)
      --legate alla consistenza zootecnica dell'azienda.
      IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
          --Sul piano in lavorazione
          FOR REC_ALLEVAMENTI IN C_ALLEVAMENTI(P_ID_AZIENDA,P_COD_ATTESTAZIONE )  LOOP  
              PRC_InserisciAttestazioni (P_ID_AZIENDA,REC_ALLEVAMENTI.ID_ATTESTAZIONE,P_ID_UTENTE_AGGIORNAMENTO,nCodiceFotografia,P_ID_DICHIARAZIONE_CONSISTENZA,P_CODERR,P_MSGERR );
          END LOOP;
      ELSE
          --Sul piano della dichiarazione.
          FOR REC_ALLEVAMENTI IN C_ALLEVAMENTI_DICHIARAZIONE(P_ID_DICHIARAZIONE_CONSISTENZA,P_COD_ATTESTAZIONE )  LOOP 
             PRC_InserisciAttestazioni (P_ID_AZIENDA,REC_ALLEVAMENTI.ID_ATTESTAZIONE,P_ID_UTENTE_AGGIORNAMENTO,nCodiceFotografia,P_ID_DICHIARAZIONE_CONSISTENZA,P_CODERR,P_MSGERR );
          END LOOP;
      END IF;


      --Inserisco una determinata attestazione (DICHIARAZIONI/ALLEGATI)
      --nel caso in cui esistono per l'azienda degli usi del suolo diversi da quelli
      --identificati nella tavola DB_TIPO_CONTROLLO_PARAMETRO.
      --Non considerare le conduzioni con titolo di possesso asservimento.
      IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
          --Sul piano in lavorazione
          SELECT COUNT(*) INTO N_CONTA_TERRENI
          FROM
            (SELECT CODICE CODICE_UTILIZZO, CODICE_VARIETA
            FROM DB_CONDUZIONE_PARTICELLA CP,
              DB_UTILIZZO_PARTICELLA UP,
              DB_UTE UTE,
              DB_TIPO_VARIETA TVA,
              DB_TIPO_UTILIZZO TUT
            WHERE CP.DATA_FINE_CONDUZIONE IS NULL
            AND UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
            AND CP.ID_UTE = UTE.ID_UTE
            AND UTE.DATA_FINE_ATTIVITA IS NULL
            AND UTE.ID_AZIENDA = P_ID_AZIENDA
            AND UP.ID_VARIETA = TVA.ID_VARIETA
            AND    UP.ID_UTILIZZO = TUT.ID_UTILIZZO
            AND    CP.ID_TITOLO_POSSESSO != knIdTitPossessoAsservimento
            MINUS
            SELECT VALORE_STRINGA, VALORE_STRINGA1
            FROM DB_TIPO_CONTROLLO_PARAMETRO
            WHERE ID_CONTROLLO = 700
            AND    CODICE = P_COD_ATTESTAZIONE || '_' || 'COND_USO' 
            AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE)); 
      ELSE
          --Sul piano della dichiarazione.
          SELECT COUNT(*)
          INTO N_CONTA_TERRENI
          FROM
            (SELECT CODICE CODICE_UTILIZZO, CODICE_VARIETA
            FROM DB_CONDUZIONE_DICHIARATA CD,
              DB_UTILIZZO_DICHIARATO UD,
              DB_TIPO_VARIETA TVA,
              DB_TIPO_UTILIZZO TUT
            WHERE CD.CODICE_FOTOGRAFIA_TERRENI=nCodiceFotografia
            AND UD.ID_CONDUZIONE_DICHIARATA = CD.ID_CONDUZIONE_DICHIARATA
            AND UD.ID_VARIETA = TVA.ID_VARIETA
            AND    UD.ID_UTILIZZO = TUT.ID_UTILIZZO
            AND    CD.ID_TITOLO_POSSESSO != knIdTitPossessoAsservimento
            MINUS
            SELECT VALORE_STRINGA, VALORE_STRINGA1
            FROM DB_TIPO_CONTROLLO_PARAMETRO
            WHERE ID_CONTROLLO = 700
            AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND_USO' 
            AND lastDayDich  BETWEEN TRUNC(DATA_INIZIO_VALIDITA) AND NVL(TRUNC(DATA_FINE_VALIDITA),lastDayDich)
            );
  --          AND dDataInsDichiarazione BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE)); 
      END IF;

      IF N_CONTA_TERRENI > 0 THEN
          IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
              SELECT VALORE_NUMERICO
              INTO nCond
              FROM DB_TIPO_CONTROLLO_PARAMETRO
              WHERE ID_CONTROLLO    = 700
              AND    CODICE = P_COD_ATTESTAZIONE || '_'|| 'COND7' 
              AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 
          ELSE
              SELECT VALORE_NUMERICO
              INTO nCond
              FROM DB_TIPO_CONTROLLO_PARAMETRO
              WHERE ID_CONTROLLO    = 700
              AND    CODICE = P_COD_ATTESTAZIONE || '_'|| 'COND7' 
              AND lastDayDich  BETWEEN TRUNC(DATA_INIZIO_VALIDITA) AND NVL(TRUNC(DATA_FINE_VALIDITA),lastDayDich);
  --            AND dDataInsDichiarazione BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 
          END IF;

          PRC_InserisciAttestazioni (P_ID_AZIENDA,nCond,P_ID_UTENTE_AGGIORNAMENTO,nCodiceFotografia,P_ID_DICHIARAZIONE_CONSISTENZA,P_CODERR,P_MSGERR );

      END IF;



      --Elimina determinate attestazioni (DICHIARAZIONI/ALLEGATI)
      --se tutte le particelle ricadono in Zona Natura 2000.
      --Escludere le conduzioni in asservimento
      IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
         --Sul piano in lavorazione
          SELECT COUNT(*)
          INTO N_ZONA_NAT_2000
          FROM     DB_CONDUZIONE_PARTICELLA     CP,
                DB_STORICO_PARTICELLA         ST,
                DB_UTE UTE,DB_R_PARTICELLA_AREA PA,DB_TIPO_VALORE_AREA TVA
          WHERE CP.DATA_FINE_CONDUZIONE         IS NULL
          AND ST.ID_PARTICELLA =    CP.ID_PARTICELLA
          AND    st.DATA_FINE_VALIDITA IS NULL
          --AND    NVL(ID_AREA_C,1) =    1
          AND CP.ID_UTE =    UTE.ID_UTE
          AND UTE.DATA_FINE_ATTIVITA IS NULL
          AND UTE.ID_AZIENDA =    P_ID_AZIENDA
          AND    CP.ID_TITOLO_POSSESSO !=    knIdTitPossessoAsservimento
          AND st.ID_PARTICELLA = PA.ID_PARTICELLA
          and PA.ID_TIPO_VALORE_AREA = TVA.ID_TIPO_VALORE_AREA
          and PA.DATA_FINE_VALIDITA IS NULL
          AND TVA.ID_TIPO_AREA = 4
          and TVA.VALORE = 1;
      ELSE
          --Sul piano della dichiarazione.
          SELECT COUNT(*)
          INTO N_ZONA_NAT_2000
          FROM     DB_CONDUZIONE_DICHIARATA     CD,
                DB_STORICO_PARTICELLA         ST,DB_R_PARTICELLA_AREA PA,DB_TIPO_VALORE_AREA TVA
          WHERE CD.CODICE_FOTOGRAFIA_TERRENI=nCodiceFotografia
          AND ST.ID_STORICO_PARTICELLA =    CD.ID_STORICO_PARTICELLA
          --AND    NVL(ID_AREA_C,1) =    1
          AND    CD.ID_TITOLO_POSSESSO !=    knIdTitPossessoAsservimento
          AND st.ID_PARTICELLA = PA.ID_PARTICELLA
          and PA.ID_TIPO_VALORE_AREA = TVA.ID_TIPO_VALORE_AREA
          and PA.DATA_FINE_VALIDITA IS NULL
          AND TVA.ID_TIPO_AREA = 4
          and TVA.VALORE = 1;
      END IF;

      IF N_ZONA_NAT_2000 = 0 THEN
        IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
             SELECT VALORE_NUMERICO
             INTO nCond
             FROM DB_TIPO_CONTROLLO_PARAMETRO
             WHERE ID_CONTROLLO    = 700
             AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND8' 
             AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 
            --Sul piano in lavorazione
             DELETE DB_ATTESTAZIONE_AZIENDA
             WHERE     ID_AZIENDA            =     P_ID_AZIENDA
             AND     ID_ATTESTAZIONE    =    nCond;
        ELSE
             SELECT VALORE_NUMERICO
             INTO nCond
             FROM DB_TIPO_CONTROLLO_PARAMETRO
             WHERE ID_CONTROLLO    = 700
             AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND8' 
             AND lastDayDich  BETWEEN TRUNC(DATA_INIZIO_VALIDITA) AND NVL(TRUNC(DATA_FINE_VALIDITA),lastDayDich);
  --           AND dDataInsDichiarazione BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 

             -- Sul piano della dichiarazione.
             -- trasformo la DELETE in UPDATE che setta la DATA_FINE_VALIDITA
             UPDATE DB_ATTESTAZIONE_DICHIARATA
                SET DATA_FINE_VALIDITA = SYSDATE
              WHERE CODICE_FOTOGRAFIA_TERRENI = nCodiceFotografia
                AND ID_ATTESTAZIONE = nCond
                AND DATA_FINE_VALIDITA IS NULL;
        END IF;
      END IF;



      --Inserisco una determinata attestazione (DICHIARAZIONI/ALLEGATI)
      --nel caso in cui esista o meno una ditta UMA attiva.
      IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
          --Sul piano in lavorazione
          SELECT COUNT(*)
          INTO nCountUma
          FROM DB_DITTA_UMA
          WHERE EXT_ID_AZIENDA = P_ID_AZIENDA
          AND    DATA_CESSAZIONE    IS NULL;
      ELSE
          --Sul piano della dichiarazione.
          SELECT COUNT(*)
          INTO nCountUma
          FROM DB_DITTA_UMA
          WHERE EXT_ID_AZIENDA = P_ID_AZIENDA
          AND dDataInsDichiarazione BETWEEN DATA_ISCRIZIONE AND NVL(DATA_CESSAZIONE,SYSDATE);
      END IF;

      IF nCountUma > 0 THEN
          IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
             SELECT VALORE_NUMERICO INTO nCond
               FROM DB_TIPO_CONTROLLO_PARAMETRO
              WHERE ID_CONTROLLO    = 700
                AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND6' 
                AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 

          ELSE
             SELECT VALORE_NUMERICO INTO nCond
               FROM DB_TIPO_CONTROLLO_PARAMETRO
              WHERE ID_CONTROLLO    = 700
                AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND6' 
                AND lastDayDich  BETWEEN TRUNC(DATA_INIZIO_VALIDITA) AND NVL(TRUNC(DATA_FINE_VALIDITA),lastDayDich);
  --              AND dDataInsDichiarazione BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 
          END IF;
      ELSE
          IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
             SELECT VALORE_NUMERICO1 INTO nCond
               FROM DB_TIPO_CONTROLLO_PARAMETRO
              WHERE ID_CONTROLLO    = 700
                AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND6' 
                AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 
          ELSE
             SELECT VALORE_NUMERICO1 INTO nCond
               FROM DB_TIPO_CONTROLLO_PARAMETRO
              WHERE ID_CONTROLLO    = 700
                AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND6' 
                AND lastDayDich  BETWEEN TRUNC(DATA_INIZIO_VALIDITA) AND NVL(TRUNC(DATA_FINE_VALIDITA),lastDayDich);
  --              AND dDataInsDichiarazione BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 
          END IF;
      END IF;

      PRC_InserisciAttestazioni (P_ID_AZIENDA,nCond,P_ID_UTENTE_AGGIORNAMENTO,nCodiceFotografia,P_ID_DICHIARAZIONE_CONSISTENZA,P_CODERR,P_MSGERR );


      --Inserire le attestazioni (DICHIARAZIONI/ALLEGATI) legate all'atto A3 se le stesse sono state sottoscritte
      --nell'ultima dichiarazione di consistenza dell'anno presendente legata alla domanda unica
      --escludendo le domande annullate.
      --Se non ci sono attestazioni da inserire allora inserire le attestazione relative all'attoA3

      --Refresh della tabella db_procedimento_azienda contenente le pratiche dell'azienda
      Pack_Pratica_Azienda.AGGIORNA_PRATICA_AZIENDA(P_ID_AZIENDA,P_CODERR,P_MSGERR);

      IF P_CODERR IS NOT NULL THEN
          RAISE ERR_AGGIORNA_PRATICA_AZIENDA;
      END IF;

      nCountA3 := 0;
      IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
          --Sul piano in lavorazione
          FOR RECA3 IN CUR_A3(P_ID_AZIENDA,P_COD_ATTESTAZIONE) LOOP 
              nCountA3 := nCountA3 + 1;
             PRC_InserisciAttestazioni (P_ID_AZIENDA,RECA3.VALORE_NUMERICO1,P_ID_UTENTE_AGGIORNAMENTO,nCodiceFotografia,P_ID_DICHIARAZIONE_CONSISTENZA,P_CODERR,P_MSGERR );
          END LOOP;
      ELSE
          FOR RECA3 IN CUR_A3_DICHIARAZIONE(P_ID_DICHIARAZIONE_CONSISTENZA,P_COD_ATTESTAZIONE) LOOP--,dDataInsDichiarazione) LOOP
              nCountA3 := nCountA3 + 1;
              PRC_InserisciAttestazioni (P_ID_AZIENDA,RECA3.VALORE_NUMERICO1,P_ID_UTENTE_AGGIORNAMENTO,nCodiceFotografia,P_ID_DICHIARAZIONE_CONSISTENZA,P_CODERR,P_MSGERR );
          END LOOP;
      END IF;

      IF nCountA3 = 0 THEN
          IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
              SELECT VALORE_NUMERICO1
              INTO nCond
              FROM DB_TIPO_CONTROLLO_PARAMETRO
              WHERE ID_CONTROLLO    = 700
              AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND_EXT' 
              AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 
          ELSE
              SELECT VALORE_NUMERICO1
              INTO nCond
              FROM DB_TIPO_CONTROLLO_PARAMETRO
              WHERE ID_CONTROLLO    = 700
              AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND_EXT' 
              AND lastDayDich  BETWEEN TRUNC(DATA_INIZIO_VALIDITA) AND NVL(TRUNC(DATA_FINE_VALIDITA),lastDayDich);
  --            AND dDataInsDichiarazione BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 
          END IF;

          PRC_InserisciAttestazioni (P_ID_AZIENDA,nCond,P_ID_UTENTE_AGGIORNAMENTO,nCodiceFotografia,P_ID_DICHIARAZIONE_CONSISTENZA,P_CODERR,P_MSGERR );
      END IF;

      --Inserisce/ Elimina le attestazioni (DICHIARAZIONI/ALLEGATI)
      --a seconda se esistono o meno particelle in zona Naturale 2000
      IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN

          SELECT VALORE_NUMERICO
          INTO nCond10
          FROM DB_TIPO_CONTROLLO_PARAMETRO
          WHERE ID_CONTROLLO    = 700
          AND    CODICE = P_COD_ATTESTAZIONE || '_' || 'COND10' 
          AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 

          SELECT VALORE_NUMERICO
          INTO nCond11
          FROM DB_TIPO_CONTROLLO_PARAMETRO
          WHERE ID_CONTROLLO    = 700
          AND    CODICE = P_COD_ATTESTAZIONE || '_' || 'COND11' 
          AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 

          --Sul piano in lavorazione
          SELECT COUNT(*) INTO nNoZonaNat2000
          FROM     DB_CONDUZIONE_PARTICELLA     CP,
                DB_STORICO_PARTICELLA         ST,
                DB_UTE UTE,DB_R_PARTICELLA_AREA PA,DB_TIPO_VALORE_AREA TVA
          WHERE CP.DATA_FINE_CONDUZIONE IS NULL
          AND     ST.ID_PARTICELLA =    CP.ID_PARTICELLA
          AND    st.DATA_FINE_VALIDITA IS NULL
          --AND    NVL(ID_AREA_C,-1) IN (2,3,4,5)
          AND     CP.ID_UTE =    UTE.ID_UTE
          AND     UTE.DATA_FINE_ATTIVITA IS NULL
          AND     UTE.ID_AZIENDA =    P_ID_AZIENDA
          AND    CP.ID_TITOLO_POSSESSO !=    knIdTitPossessoAsservimento
          AND St.ID_PARTICELLA = PA.ID_PARTICELLA
          and PA.ID_TIPO_VALORE_AREA = TVA.ID_TIPO_VALORE_AREA
          and PA.DATA_FINE_VALIDITA IS NULL
          AND TVA.ID_TIPO_AREA = 4
          and TVA.VALORE IN (2,3,4,5);
      ELSE
          SELECT VALORE_NUMERICO
          INTO nCond10
          FROM DB_TIPO_CONTROLLO_PARAMETRO
          WHERE ID_CONTROLLO    = 700
          AND    CODICE = P_COD_ATTESTAZIONE || '_' || 'COND10' 
          AND lastDayDich  BETWEEN TRUNC(DATA_INIZIO_VALIDITA) AND NVL(TRUNC(DATA_FINE_VALIDITA),lastDayDich);
  --        AND dDataInsDichiarazione BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 

          SELECT VALORE_NUMERICO
          INTO nCond11
          FROM DB_TIPO_CONTROLLO_PARAMETRO
          WHERE ID_CONTROLLO    = 700
          AND    CODICE = P_COD_ATTESTAZIONE || '_' || 'COND11' 
          AND lastDayDich  BETWEEN TRUNC(DATA_INIZIO_VALIDITA) AND NVL(TRUNC(DATA_FINE_VALIDITA),lastDayDich);
  --        AND dDataInsDichiarazione BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 

          SELECT COUNT(*) INTO nNoZonaNat2000
          FROM     DB_CONDUZIONE_DICHIARATA     CD,
                DB_STORICO_PARTICELLA         ST,DB_R_PARTICELLA_AREA PA,DB_TIPO_VALORE_AREA TVA
          WHERE CD.CODICE_FOTOGRAFIA_TERRENI=nCodiceFotografia
          AND     ST.ID_STORICO_PARTICELLA =    CD.ID_STORICO_PARTICELLA
          --AND    NVL(ST.ID_AREA_C,-1) IN (2,3,4,5)
          AND    CD.ID_TITOLO_POSSESSO !=    knIdTitPossessoAsservimento
          AND st.ID_PARTICELLA = PA.ID_PARTICELLA
          and PA.ID_TIPO_VALORE_AREA = TVA.ID_TIPO_VALORE_AREA
          and PA.DATA_FINE_VALIDITA IS NULL
          AND TVA.ID_TIPO_AREA = 4
          and TVA.VALORE IN (2,3,4,5);
      END IF;

      IF nNoZonaNat2000 = 0 THEN
          IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
              --Sul piano in lavorazione
              DELETE DB_ATTESTAZIONE_AZIENDA
              WHERE     ID_AZIENDA    =     P_ID_AZIENDA
              AND    ID_ATTESTAZIONE    =    nCond10;
          ELSE
             UPDATE DB_ATTESTAZIONE_DICHIARATA
                 SET DATA_FINE_VALIDITA = SYSDATE
               WHERE CODICE_FOTOGRAFIA_TERRENI = nCodiceFotografia
                 AND ID_ATTESTAZIONE = nCond10
                 AND DATA_FINE_VALIDITA IS NULL;
          END IF;
      END IF;

      IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
          --Sul piano in lavorazione
          SELECT COUNT(*)
          INTO nCount10
          FROM DB_ATTESTAZIONE_AZIENDA
          WHERE     ID_AZIENDA = P_ID_AZIENDA
          AND    ID_ATTESTAZIONE    =    nCond10;

          SELECT COUNT(*)
          INTO nCount11
          FROM DB_ATTESTAZIONE_AZIENDA
          WHERE     ID_AZIENDA = P_ID_AZIENDA
          AND    ID_ATTESTAZIONE    =    nCond11;
      ELSE
          --Sul piano della dichiarazione.
          SELECT COUNT(*)
          INTO nCount10
          FROM DB_ATTESTAZIONE_DICHIARATA
          WHERE     CODICE_FOTOGRAFIA_TERRENI = nCodiceFotografia
          AND    ID_ATTESTAZIONE    =    nCond10;

          SELECT COUNT(*)
          INTO nCount11
          FROM DB_ATTESTAZIONE_DICHIARATA
          WHERE     CODICE_FOTOGRAFIA_TERRENI = nCodiceFotografia
          AND    ID_ATTESTAZIONE    =    nCond11;
      END IF;


      IF nCount10 = 0 THEN
          IF nCount11 = 0 THEN

              PRC_InserisciAttestazioni (P_ID_AZIENDA,nCond11,P_ID_UTENTE_AGGIORNAMENTO,nCodiceFotografia,P_ID_DICHIARAZIONE_CONSISTENZA,P_CODERR,P_MSGERR );

          END IF;
      ELSIF nCount10 > 0 THEN
          IF nCount11 > 0 THEN
              IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
                  DELETE DB_ATTESTAZIONE_AZIENDA
                  WHERE    ID_AZIENDA = P_ID_AZIENDA
                  AND    ID_ATTESTAZIONE    =    nCond11;
              ELSE
                  UPDATE DB_ATTESTAZIONE_DICHIARATA
                     SET DATA_FINE_VALIDITA = SYSDATE
                   WHERE CODICE_FOTOGRAFIA_TERRENI = nCodiceFotografia
                     AND ID_ATTESTAZIONE = nCond11
                     AND DATA_FINE_VALIDITA IS NULL;
              END IF;
          END IF;
      END IF;


     -- la condizionalita'  si evolve nel tempo ma non deve perdere lo storico degli anni passati, quindi mantengo tutto il pregresso
     --
     --Inserisce l' attestazione dell'atto A4 se sono
     --presenti fabbricati ad uso stoccaggio.
      nFab := 0;
      IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN

          --Sul piano in lavorazione
          BEGIN
              SELECT VALORE_NUMERICO
                INTO nCond
              FROM DB_TIPO_CONTROLLO_PARAMETRO
              WHERE ID_CONTROLLO    = 700
              AND    CODICE = P_COD_ATTESTAZIONE || '_' || 'COND12' 
              AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 
          EXCEPTION
              WHEN NO_DATA_FOUND THEN
                  nCond := NULL;
          END;

          IF nCond IS NOT NULL THEN
              SELECT COUNT(*)
              INTO nFab
              FROM
                DB_FABBRICATO FB,
                DB_TIPO_TIPOLOGIA_FABBRICATO TI,
                DB_UTE UT
              WHERE
                FB.DATA_FINE_VALIDITA IS NULL
                AND    FB.ID_TIPOLOGIA_FABBRICATO =    TI.ID_TIPOLOGIA_FABBRICATO
                AND    TI.FLAG_PER_STOCCAGGIO =    'S'
                AND    UT.ID_UTE =    FB.ID_UTE
                AND    UT.ID_AZIENDA =     P_ID_AZIENDA
                AND    UT.DATA_FINE_ATTIVITA IS NULL;
          END IF;
      ELSE
          --Sul piano della dichiarazione.
          BEGIN
              SELECT VALORE_NUMERICO
                INTO nCond
              FROM DB_TIPO_CONTROLLO_PARAMETRO
              WHERE ID_CONTROLLO    = 700
              AND    CODICE = P_COD_ATTESTAZIONE || '_' || 'COND12' 
              AND lastDayDich  BETWEEN TRUNC(DATA_INIZIO_VALIDITA) AND NVL(TRUNC(DATA_FINE_VALIDITA),lastDayDich);
    --          AND dDataInsDichiarazione BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE); 
          EXCEPTION
              WHEN NO_DATA_FOUND THEN
                  nCond := NULL;
          END;

          IF nCond IS NOT NULL THEN
              SELECT COUNT(*)
              INTO nFab
              FROM DB_FABBRICATO FB,
                   DB_TIPO_TIPOLOGIA_FABBRICATO TI,
                   DB_UTE UT
              WHERE UT.ID_AZIENDA = P_ID_AZIENDA
              AND    UT.ID_UTE =    FB.ID_UTE
              AND dDataInsDichiarazione BETWEEN FB.DATA_INIZIO_VALIDITA AND NVL(FB.DATA_FINE_VALIDITA,SYSDATE)
              AND    FB.ID_TIPOLOGIA_FABBRICATO =TI.ID_TIPOLOGIA_FABBRICATO
              AND    TI.FLAG_PER_STOCCAGGIO =    'S';
          END IF;
      END IF;

      IF nFab > 0 THEN
          PRC_InserisciAttestazioni (P_ID_AZIENDA,nCond,P_ID_UTENTE_AGGIORNAMENTO,nCodiceFotografia,P_ID_DICHIARAZIONE_CONSISTENZA,P_CODERR,P_MSGERR );
      END IF;


      --Inserisce specifiche attestazioni (ALLEGATI) nel caso esistano
      --particelle che ricadono aree montane .
      --Escludere le conduzioni in asservimento

      IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
        --Sul piano in lavorazione
          SELECT COUNT(*)
            INTO N_CONTA_ZONA_MONTANA
            FROM DB_STORICO_PARTICELLA SP
               , DB_CONDUZIONE_PARTICELLA CP
               , DB_UTE U
           WHERE SP.ID_PARTICELLA = CP.ID_PARTICELLA
             AND SP.DATA_FINE_VALIDITA IS NULL
             AND CP.DATA_FINE_CONDUZIONE IS NULL
             AND CP.ID_UTE = U.ID_UTE
             AND U.DATA_FINE_ATTIVITA IS NULL
             AND U.ID_AZIENDA = P_ID_AZIENDA
             AND SP.ID_ZONA_ALTIMETRICA IN (knAreaMontana)
             AND CP.ID_TITOLO_POSSESSO != knIdTitPossessoAsservimento;
      ELSE
        --Sul piano della dichiarazione.
          SELECT COUNT(*)
            INTO N_CONTA_ZONA_MONTANA
            FROM  DB_STORICO_PARTICELLA SP,
                  DB_CONDUZIONE_DICHIARATA CD
            WHERE SP.ID_STORICO_PARTICELLA = CD.ID_STORICO_PARTICELLA
              AND CD.CODICE_FOTOGRAFIA_TERRENI = nCodiceFotografia
              AND SP.ID_ZONA_ALTIMETRICA IN (knAreaMontana)
              AND CD.ID_TITOLO_POSSESSO != knIdTitPossessoAsservimento;
      END IF;

      IF N_CONTA_ZONA_MONTANA > 0 THEN
          IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
                SELECT VALORE_NUMERICO INTO nCond
                FROM DB_TIPO_CONTROLLO_PARAMETRO
                WHERE ID_CONTROLLO = 700
                AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND_MONT' 
                AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);
          ELSE
                SELECT VALORE_NUMERICO INTO nCond
                FROM DB_TIPO_CONTROLLO_PARAMETRO
                WHERE ID_CONTROLLO = 700
                AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND_MONT' 
                AND lastDayDich  BETWEEN TRUNC(DATA_INIZIO_VALIDITA) AND NVL(TRUNC(DATA_FINE_VALIDITA),lastDayDich);
  --              AND dDataInsDichiarazione BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);
          END IF;

          PRC_InserisciAttestazioni (P_ID_AZIENDA,nCond,P_ID_UTENTE_AGGIORNAMENTO,nCodiceFotografia,P_ID_DICHIARAZIONE_CONSISTENZA,P_CODERR,P_MSGERR );
      END IF;
      --

      --Inserisce specifiche attestazioni (ALLEGATI) nel caso esistano
      --pratiche PSR 214 .
      --Escludere le conduzioni in asservimento
      IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
        --Sul piano in lavorazione
            SELECT COUNT(*)
              INTO N_CONTA_PSR
              FROM DB_PROCEDIMENTO_AZIENDA A
             WHERE A.DESCRIZIONE LIKE '%214.%'
               AND A.ID_PROCEDIMENTO = knIdProcedimentoPSR
               AND A.ANNO_CAMPAGNA = TO_NUMBER(TO_CHAR(SYSDATE,'YYYY'))
               AND A.STATO NOT IN ('A', 'B')
               AND UPPER(A.DESCRIZIONE_STATO) NOT LIKE '%RINUNCIA%'
               AND A.ID_AZIENDA = P_ID_AZIENDA;
      ELSE
        --Sul piano della dichiarazione.
            SELECT COUNT(*)
              INTO N_CONTA_PSR
              FROM DB_PROCEDIMENTO_AZIENDA A
             WHERE A.DESCRIZIONE LIKE '%214.%'
               AND A.ID_PROCEDIMENTO = knIdProcedimentoPSR
               AND A.ID_DICHIARAZIONE_CONSISTENZA = P_ID_DICHIARAZIONE_CONSISTENZA
               AND A.STATO NOT IN ('A', 'B')
               AND UPPER(A.DESCRIZIONE_STATO) NOT LIKE '%RINUNCIA%'
               AND A.ID_AZIENDA = P_ID_AZIENDA;
      END IF;

      IF N_CONTA_PSR > 0 THEN
          IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
                SELECT VALORE_NUMERICO INTO nCond
                FROM DB_TIPO_CONTROLLO_PARAMETRO
                WHERE ID_CONTROLLO = 700
                AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND_FER' 
                AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);
          ELSE
                SELECT VALORE_NUMERICO INTO nCond
                FROM DB_TIPO_CONTROLLO_PARAMETRO
                WHERE ID_CONTROLLO = 700
                AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND_FER' 
                AND lastDayDich  BETWEEN TRUNC(DATA_INIZIO_VALIDITA) AND NVL(TRUNC(DATA_FINE_VALIDITA),lastDayDich);
  --              AND dDataInsDichiarazione BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);
          END IF;

          PRC_InserisciAttestazioni (P_ID_AZIENDA,nCond,P_ID_UTENTE_AGGIORNAMENTO,nCodiceFotografia,P_ID_DICHIARAZIONE_CONSISTENZA,P_CODERR,P_MSGERR );

           IF P_ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
                SELECT VALORE_NUMERICO INTO nCond
                FROM DB_TIPO_CONTROLLO_PARAMETRO
                WHERE ID_CONTROLLO = 700
                AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND_FIT' 
                AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);
          ELSE
                SELECT VALORE_NUMERICO INTO nCond
                FROM DB_TIPO_CONTROLLO_PARAMETRO
                WHERE ID_CONTROLLO = 700
                AND CODICE = P_COD_ATTESTAZIONE || '_' || 'COND_FIT' 
                AND lastDayDich  BETWEEN TRUNC(DATA_INIZIO_VALIDITA) AND NVL(TRUNC(DATA_FINE_VALIDITA),lastDayDich);
  --              AND dDataInsDichiarazione BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);
          END IF;

          PRC_InserisciAttestazioni (P_ID_AZIENDA,nCond,P_ID_UTENTE_AGGIORNAMENTO,nCodiceFotografia,P_ID_DICHIARAZIONE_CONSISTENZA,P_CODERR,P_MSGERR );
      END IF;

    -- ..gestisco il mancato recupero dei controlli specifici ..
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        NULL;
    END;
    --

EXCEPTION
    WHEN ERR_AGGIORNA_PRATICA_AZIENDA THEN
        NULL;
    WHEN ERRORE THEN
        P_CODERR := '1';
        IF P_MSGERR IS NULL THEN
            P_MSGERR := 'ERRORE GRAVE: ' ||SQLERRM;
        END IF;
    WHEN OTHERS THEN
        P_CODERR := '1';
        IF P_MSGERR IS NULL THEN
            P_MSGERR := 'ERRORE GRAVE: ' ||SQLERRM;
        END IF;

END CARICA_ATTESTAZIONI;

/*********************************************************************
Dato un ID_DICHIARAZIONE_CONSISTENZA controlla se sono presenti
su DB_ATTESTAZIONE_DICHIARATA degli ID_ATTESTAZIONE con occorrenze
multiple aggiornatate nella data di sistema ed elimina tutte le occorrenze
multiple tranne la più recente
Tipo: procedure
input: P_ID_DICHIARAZIONE_CONSISTENZA
output: P_COD_ERR , P_MSG_ERR
ritorno: nessuno
*********************************************************************/
PROCEDURE RAGGRUPPA_ATTESTAZIONI (P_ID_DICHIARAZIONE_CONSISTENZA IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                  P_COD_ERR                  IN OUT VARCHAR2,
                                  P_MSG_ERR                  IN OUT VARCHAR2) IS
    vCodFoto  DB_DICHIARAZIONE_CONSISTENZA.CODICE_FOTOGRAFIA_TERRENI%TYPE;
BEGIN

    -- cerco il codice fotografia terreni
    SELECT CODICE_FOTOGRAFIA_TERRENI
      INTO vCodFoto
      FROM DB_DICHIARAZIONE_CONSISTENZA
     WHERE ID_DICHIARAZIONE_CONSISTENZA = P_ID_DICHIARAZIONE_CONSISTENZA;

    -- cerco per il codice fotografia terreni tutti gli ID_ATTESTAZIONE che
    -- alla data di sistema hanno più di un ID_ATTESTAZIONE_DICHIARATA
    -- su DB_ATTESTAZIONE_DICHIARATA , prendo l'ultimo (MAX) ID_ATTESTAZIONE_DICHIARATA
    -- che sarà quello che terrò e cancello tutti gli altri
    -- N.B. = Vedere se si può riscrivere
    DELETE
      FROM DB_ATTESTAZIONE_DICHIARATA
     WHERE ID_ATTESTAZIONE_DICHIARATA IN (
                    WITH ATT_MULTIPLA AS (
                    SELECT ID_ATTESTAZIONE, MAX(ID_ATTESTAZIONE_DICHIARATA) AS MAX_ATTESTAZIONE
                      FROM DB_ATTESTAZIONE_DICHIARATA
                     WHERE CODICE_FOTOGRAFIA_TERRENI = vCodFoto
                       AND TRUNC(DATA_AGGIORNAMENTO) = TRUNC(SYSDATE)
                    GROUP BY ID_ATTESTAZIONE
                    HAVING COUNT(*) > 1)
                    SELECT AD.ID_ATTESTAZIONE_DICHIARATA
                      FROM DB_ATTESTAZIONE_DICHIARATA AD,
                           ATT_MULTIPLA AM
                     WHERE AD.CODICE_FOTOGRAFIA_TERRENI = vCodFoto
                       AND TRUNC(AD.DATA_AGGIORNAMENTO) = TRUNC(SYSDATE)
                       AND AD.ID_ATTESTAZIONE = AM.ID_ATTESTAZIONE
                       AND AD.ID_ATTESTAZIONE_DICHIARATA <> MAX_ATTESTAZIONE);

EXCEPTION
    WHEN OTHERS THEN
        P_COD_ERR := '1';
        P_MSG_ERR := 'ERRORE GRAVE IN RAGGRUPPA_ATTESTAZIONI : ' ||SQLERRM;
END RAGGRUPPA_ATTESTAZIONI;

END Pack_Aggiorna_Attestazioni;

/
--------------------------------------------------------
--  DDL for Package Body PACK_AGGIORNA_UV
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PACK_AGGIORNA_UV" IS
EsciRountine       EXCEPTION;
ERRORE              EXCEPTION;


PROCEDURE AGGIORNA_STATO_UV(P_ELENCO_PARTICELLE IN NUM_VARRAY,
                              P_CODERR        IN OUT VARCHAR2,
                              P_MSGERR       IN OUT VARCHAR2) IS

I BINARY_INTEGER;
N_CONTA_STATO NUMBER(10);
I_TOTALE BINARY_INTEGER;

BEGIN
     I := 1;
     I_TOTALE := P_ELENCO_PARTICELLE.COUNT;
     P_CODERR          := NULL;
     P_MSGERR          := NULL;
--     P_ELENCO_PARTICELLE.EXTEND;
--     P_ELENCO_PARTICELLE:= NUM_VARRAY(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);

--     P_ELENCO_PARTICELLE(1) := 7444684;

-- IL RECORD PUò CONTETENE MAX 25 ELEMENTI IN QUANTO NUM_VARRAY è DEFINITO COSì

     WHILE I <= I_TOTALE  LOOP
          SELECT COUNT(*)
           INTO N_CONTA_STATO
           FROM DB_STORICO_UNITA_ARBOREA SUA
          WHERE SUA.DATA_FINE_VALIDITA IS NULL
            AND SUA.ID_PARTICELLA = P_ELENCO_PARTICELLE(I)
            AND NVL(SUA.STATO_UNITA_ARBOREA,'P') = 'P';

          IF N_CONTA_STATO <= 0 THEN
               UPDATE DB_PARTICELLA SET FLAG_SCHEDARIO = 'S' WHERE ID_PARTICELLA = P_ELENCO_PARTICELLE(I);
          ELSE
               UPDATE DB_PARTICELLA SET FLAG_SCHEDARIO = 'M' WHERE ID_PARTICELLA = P_ELENCO_PARTICELLE(I);
          END IF;
          I := I + 1;
     END LOOP;


EXCEPTION
 WHEN OTHERS THEN
   P_CODERR := 999999;
   IF P_MSGERR IS NULL THEN
      P_MSGERR := 'AGGIORNA_STATO_UV ERRORE GRAVE: ' ||SQLERRM;
   END IF;
END AGGIORNA_STATO_UV;

PROCEDURE AGGIORNA_STATO_UV_DICH(P_ELENCO_UV IN     NUM_VARRAY,
                                   P_CODERR        IN OUT VARCHAR2,
                                   P_MSGERR       IN OUT VARCHAR2) IS

I               BINARY_INTEGER;
I_TOTALE BINARY_INTEGER;
N_CONTA_STATO NUMBER(10);
N_ID_STORICO_UNITA_ARBOREA DB_STORICO_UNITA_ARBOREA.ID_STORICO_UNITA_ARBOREA%TYPE;
N_ID_PARTICELLA DB_STORICO_PARTICELLA.ID_PARTICELLA%TYPE;
BEGIN
     I := 1;
     I_TOTALE := P_ELENCO_UV.COUNT;
     P_CODERR          := NULL;
     P_MSGERR          := NULL;

     WHILE I <= I_TOTALE LOOP

          SELECT UAD.ID_STORICO_UNITA_ARBOREA, SP.ID_PARTICELLA
            INTO N_ID_STORICO_UNITA_ARBOREA, N_ID_PARTICELLA
            FROM DB_UNITA_ARBOREA_DICHIARATA UAD, DB_STORICO_PARTICELLA SP
           WHERE ID_UNITA_ARBOREA_DICHIARATA  = P_ELENCO_UV(I)
             AND SP.ID_STORICO_PARTICELLA = UAD.ID_STORICO_PARTICELLA;

           UPDATE DB_UNITA_ARBOREA_DICHIARATA SET STATO_UNITA_ARBOREA = 'V'
          WHERE ID_UNITA_ARBOREA_DICHIARATA  = P_ELENCO_UV(I);

          UPDATE DB_STORICO_UNITA_ARBOREA SET STATO_UNITA_ARBOREA = 'V'
          WHERE ID_STORICO_UNITA_ARBOREA  = N_ID_STORICO_UNITA_ARBOREA;

          SELECT COUNT(*)
           INTO N_CONTA_STATO
           FROM DB_STORICO_UNITA_ARBOREA SUA
          WHERE SUA.DATA_FINE_VALIDITA IS NULL
            AND SUA.ID_PARTICELLA = N_ID_PARTICELLA
            AND NVL(SUA.STATO_UNITA_ARBOREA,'P') = 'P';

          IF N_CONTA_STATO <= 0 THEN
               UPDATE DB_PARTICELLA SET FLAG_SCHEDARIO = 'S' WHERE ID_PARTICELLA = N_ID_PARTICELLA;
          ELSE
               UPDATE DB_PARTICELLA SET FLAG_SCHEDARIO = 'M' WHERE ID_PARTICELLA = N_ID_PARTICELLA;
          END IF;

           I := I + 1;
     END LOOP;
EXCEPTION
 WHEN OTHERS THEN
   P_CODERR := 999999;
   IF P_MSGERR IS NULL THEN
      P_MSGERR := 'AGGIORNA_STATO_UV_DICH ERRORE GRAVE: ' ||SQLERRM;
   END IF;
END AGGIORNA_STATO_UV_DICH;

END;

/
--------------------------------------------------------
--  DDL for Package Body PACK_COMUNICAZIONE_10R
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PACK_COMUNICAZIONE_10R" AS



    /*********************************************************************
    Ricerca l'ultima dichiarazione di consistenza dell'azienda per
    la tipologia di motivo di dichiarazione
    Tipo: function
    input: pIdAzienda, pIdTipoMot
    output: nessuno
    ritorno: DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE
    *********************************************************************/
    FUNCTION SelLastDichConsByIdAziendaEMot (pIdAzienda  IN DB_DICHIARAZIONE_CONSISTENZA.ID_AZIENDA%TYPE,
                                             pIdTipoMot  IN DB_DICHIARAZIONE_CONSISTENZA.ID_MOTIVO_DICHIARAZIONE%TYPE
                                             ) RETURN DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE IS
        recDichCons DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE;
    BEGIN

        SELECT DC.*
          INTO recDichCons
          FROM DB_DICHIARAZIONE_CONSISTENZA DC
         WHERE DC.ID_AZIENDA = pIdAzienda
           AND DC.ID_MOTIVO_DICHIARAZIONE = pIdTipoMot
           AND DC.DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DATA_INSERIMENTO_DICHIARAZIONE)
                                                      FROM DB_DICHIARAZIONE_CONSISTENZA
                                                     WHERE ID_AZIENDA = pIdAzienda
                                                       AND ID_MOTIVO_DICHIARAZIONE = pIdTipoMot);

        RETURN recDichCons;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelLastDichConsByIdAziendaEMot;

    /*********************************************************************
    Data una sottocategoria animale ritorna il minimo coefficiente per
    il calcolo dell'azoto inteso come somma dei coefficienti palabili e non
    Tipo: function
    input: pIdSottoCategoriaAnimale
    output: nessuno
    ritorno: nTotCoefAzoto
    *********************************************************************/
    FUNCTION SelDCoefAzotoForIdStCategAnim (pIdSottoCategoriaAnimale IN DB_SOTTOCATEGORIA_ANIM_STAB.ID_SOTTOCATEGORIA_ANIMALE%TYPE)
    RETURN DB_SOTTOCATEGORIA_ANIM_STAB.COEFF_AZOTO_MAX%TYPE IS
        nTotCoefAzoto DB_SOTTOCATEGORIA_ANIM_STAB.COEFF_AZOTO_MAX%TYPE;
    BEGIN
        SELECT NVL(MIN(CFF_AZOTO_NON_PAL+ CFF_AZOTO_PAL),0)
          INTO nTotCoefAzoto
          FROM (
            SELECT A.ID_SOTTOCATEGORIA_ANIMALE,
                   A.ID_STABULAZIONE,
                   (SELECT B.COEFF_AZOTO_MIN
                      FROM DB_SOTTOCATEGORIA_ANIM_STAB B,
                           DB_TIPO_EFFLUENTE C
                     WHERE A.ID_STABULAZIONE=B.ID_STABULAZIONE
                       AND A.ID_SOTTOCATEGORIA_ANIMALE=B.ID_SOTTOCATEGORIA_ANIMALE
                       AND B.ID_EFFLUENTE=C.ID_EFFLUENTE
                       AND C.FLAG_PALABILE='N'
                       AND B.DATA_FINE_VALIDITA IS NULL
                       AND C.DATA_FINE_VALIDITA IS NULL) AS CFF_AZOTO_NON_PAL,
                   (SELECT D.COEFF_AZOTO_MIN
                      FROM DB_SOTTOCATEGORIA_ANIM_STAB D,
                           DB_TIPO_EFFLUENTE E
                     WHERE A.ID_STABULAZIONE=D.ID_STABULAZIONE
                       AND A.ID_SOTTOCATEGORIA_ANIMALE=D.ID_SOTTOCATEGORIA_ANIMALE
                       AND D.ID_EFFLUENTE=E.ID_EFFLUENTE
                       AND E.FLAG_PALABILE='S'
                       AND D.DATA_FINE_VALIDITA IS NULL
                       AND E.DATA_FINE_VALIDITA IS NULL) AS CFF_AZOTO_PAL
              FROM DB_SOTTOCATEGORIA_ANIM_STAB A
             WHERE A.ID_SOTTOCATEGORIA_ANIMALE= PIDSOTTOCATEGORIAANIMALE
               AND A.DATA_FINE_VALIDITA IS NULL
          GROUP BY A.ID_SOTTOCATEGORIA_ANIMALE, A.ID_STABULAZIONE);

        RETURN nTotCoefAzoto;

    END SelDCoefAzotoForIdStCategAnim;

    /*********************************************************************
    Dato un codice altro dato seleziona il corrispettivo record attivo (data fine validita a null)
    sulla tabella DB_ALTRI_DATI
    Tipo: function
    input: pCodAltroDato
    output: nessuno
    ritorno: DB_ALTRI_DATI%ROWTYPE
    *********************************************************************/
    FUNCTION SelDAltroDatoByCodice (pCodAltroDato IN DB_ALTRI_DATI.CODICE%TYPE)
    RETURN DB_ALTRI_DATI%ROWTYPE IS
        recDAltriDati DB_ALTRI_DATI%ROWTYPE;
    BEGIN

        SELECT *
          INTO recDAltriDati
          FROM DB_ALTRI_DATI
         WHERE CODICE = pCodAltroDato
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recDAltriDati;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelDAltroDatoByCodice;

    /*********************************************************************
    Verifica se ad una comunicazione 10R sono stati associati degli effluenti
    Tipo: function
    input: pIdComunicazione10R
    output: nessuno
    ritorno: TRUE / FALSE
    *********************************************************************/
    FUNCTION ExistsEffluenteForIdComunicaz (pIdComunicazione10R IN DB_EFFLUENTE_10R.ID_COMUNICAZIONE_10R%TYPE)
    RETURN BOOLEAN IS
        nRec INTEGER:=0;
        bRet BOOLEAN:=FALSE;
    BEGIN

        SELECT COUNT(ID_EFFLUENTE_10R)
          INTO nRec
          FROM DB_EFFLUENTE_10R
         WHERE ID_COMUNICAZIONE_10R = pIdComunicazione10R;

        IF nRec > 0 THEN
           bRet := TRUE;
        END IF;

        RETURN bRet;

    END ExistsEffluenteForIdComunicaz;

/*********************************************************************
Effettua il calcolo dell'azoto escreto al pascolo dati ID_COMUNICAZIONE_10R
ed identificativo ute
Tipo: procedure
input: pIdComunicazione10R, pIdUte
output: pTotAzoto, pCodErr, pDesErr
ritorno: nessuno
*********************************************************************/

/*
PROCEDURE AZOTO_ESCRETO_PASCOLO (pIdComunicazione10R     IN NUMBER,
                                 pIdUte                  IN NUMBER,
                                 pTotAzoto              OUT NUMBER,
                                 pCodErr                OUT VARCHAR2,
                                 pDesErr                OUT VARCHAR2) IS


    CURSOR curAllevamentoUte (pIdUte IN DB_ALLEVAMENTO.ID_UTE%TYPE) IS
    SELECT SCA.ID_SOTTOCATEGORIA_ANIMALE, NVL(SCA.PESO_VIVO,0) PESO_VIVO, SCA.QUANTITA
      FROM DB_ALLEVAMENTO A,
           DB_CATEGORIE_ALLEVAMENTO CA,
           DB_SOTTOCATEGORIA_ALLEVAMENTO SCA
     WHERE A.ID_UTE = pIdUte
       AND A.DATA_FINE IS NULL
       AND A.ID_ALLEVAMENTO = CA.ID_ALLEVAMENTO
       AND CA.ID_CATEGORIE_ALLEVAMENTO = SCA.ID_CATEGORIE_ALLEVAMENTO
       AND (NVL(GIORNI_PASCOLO_ESTATE,0) > 0 OR
            NVL(GIORNI_PASCOLO_INVERNO,0) > 0)
  ORDER BY SCA.ID_SOTTOCATEGORIA_ALLEVAMENTO;

    nTotCoefAzoto DB_SOTTOCATEGORIA_ANIM_STAB.COEFF_AZOTO_MAX%TYPE;
BEGIN
    -- controllo se per la comunicazione 10 righe in esame esistono effluenti
    IF ExistsEffluenteForIdComunicaz (pIdComunicazione10R) THEN
        -- se si posso calcolare l'azoto escreto al pascolo
        -- come la somma per ogni effluente della differenza del peso in Kg di azoto per il refluo post trattamento
        -- conprensivo dell'escreto al pascolo meno il peso in Kg di azoto per il refluo post
        -- trattamento decurtato dell'escreto al pascolo
        SELECT NVL(SUM(E.AZOTO_POST_TRATTAMENTO -
                   NVL(E.AZOTO_POST_TRATTAMENTO_DEC,0)),0)
          INTO pTotAzoto
          FROM DB_EFFLUENTE_10R E
         WHERE E.ID_COMUNICAZIONE_10R = pIdComunicazione10R;

    ELSE
        -- altrimenti per ogni allevamento dell'ute
        FOR recAllevamentoUte IN curAllevamentoUte (pIdUte) LOOP
            -- ricerco il coefficiente di calcolo dell'azoto per la sottocategoria animale
            nTotCoefAzoto := SelDCoefAzotoForIdStCategAnim (recAllevamentoUte.ID_SOTTOCATEGORIA_ANIMALE);
            -- ed eseguo la seguente formula  (peso_vivo/1000) * quantita * coefficiente azoto
            pTotAzoto := NVL(pTotAzoto,0) +((recAllevamentoUte.PESO_VIVO / 1000) * recAllevamentoUte.QUANTITA * nTotCoefAzoto);
        END LOOP;
    END IF;

EXCEPTION
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);
END AZOTO_ESCRETO_PASCOLO;
*/

/*********************************************************************
Effettua il calcolo dell'azoto escreto al pascolo dato l'identificativo ute
Tipo: procedure
input:  pIdUte
output: pTotAzoto, pCodErr, pDesErr
ritorno: nessuno
*********************************************************************/
PROCEDURE AZOTO_ESCRETO_PASCOLO (pIdUte                  IN NUMBER,
                                 pTotAzoto              OUT NUMBER,
                                 pCodErr                OUT VARCHAR2,
                                 pDesErr                OUT VARCHAR2) IS


BEGIN

    SELECT ROUND(SUM(NVL((NVL(SCA.PESO_VIVO,0) * SCA.QUANTITA)  /1000 * SA.PESO_VIVO_AZOTO * (1- ( (365-((SCA.GIORNI_PASCOLO_ESTATE * SCA.ORE_PASCOLO_ESTATE / 24) + ( SCA.GIORNI_PASCOLO_INVERNO * SCA.ORE_PASCOLO_INVERNO / 24)))/365)),0)),1)
      INTO pTotAzoto
      FROM DB_ALLEVAMENTO A,
           DB_CATEGORIE_ALLEVAMENTO CA,
           DB_SOTTOCATEGORIA_ALLEVAMENTO SCA,
           DB_TIPO_SOTTOCATEGORIA_ANIMALE SA
     WHERE A.ID_UTE = pIdUte
       AND A.DATA_FINE IS NULL
       AND A.ID_ALLEVAMENTO = CA.ID_ALLEVAMENTO
       AND CA.ID_CATEGORIE_ALLEVAMENTO = SCA.ID_CATEGORIE_ALLEVAMENTO
       AND SA.ID_SOTTOCATEGORIA_ANIMALE = SCA.ID_SOTTOCATEGORIA_ANIMALE
       AND (NVL(GIORNI_PASCOLO_ESTATE,0) > 0 OR NVL(GIORNI_PASCOLO_INVERNO,0) > 0) ;

EXCEPTION
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);
END AZOTO_ESCRETO_PASCOLO;



FUNCTION FNC_COEFFICENTE_PIOGGIA (pIdFabbricato IN NUMBER) RETURN NUMBER IS

nMinParticella NUMBER;
nCoeffPioggia    NUMBER;

BEGIN

    SELECT MIN(ID_STORICO_PARTICELLA) INTO nMinParticella
    FROM DB_FABBRICATO_PARTICELLA      FP,
          DB_STORICO_PARTICELLA            SP
    WHERE    FP.ID_FABBRICATO = pIdFabbricato
    AND    FP.DATA_FINE_VALIDITA IS NULL
    AND     FP.ID_PARTICELLA = SP.ID_PARTICELLA
    AND    SP.DATA_FINE_VALIDITA IS NULL;

    SELECT NVL(COEFF_PIOGGIA,0) INTO nCoeffPioggia
    FROM DB_STORICO_PARTICELLA            SP,
          COMUNE                                CO
    WHERE  SP.ID_STORICO_PARTICELLA = nMinParticella
    AND     SP.COMUNE = CO.ISTAT_COMUNE;

RETURN (NVL(nCoeffPioggia,0)/1000);

EXCEPTION
    WHEN OTHERS THEN
        RETURN(0);
END;

PROCEDURE CALCOLA_VOLUME_PIOGGIE_M3 (     --pIdAzienda                 IN NUMBER,
                                                    pIdUte                    IN NUMBER,
                                                      pSuperficeScoperta    OUT NUMBER,
                                                      pCodErr                    OUT VARCHAR2,
                                                      pDesErr                    OUT VARCHAR2) IS

EXC_PARAMETRO_NULL EXCEPTION;
BEGIN

    IF pIdUte IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;

    BEGIN
        SELECT NVL(SUM((NVL(SUPERFICIE_SCOPERTA,0) + NVL(SUPERFICIE_SCOPERTA_EXTRA,0)) * FNC_COEFFICENTE_PIOGGIA (FA.ID_FABBRICATO)/2),0)
        INTO pSuperficeScoperta
        FROM    DB_UTE UT,
                DB_FABBRICATO FA,
                DB_TIPO_TIPOLOGIA_FABBRICATO TI
        WHERE UT.ID_UTE = pIdUte --UT.ID_AZIENDA = pIdAzienda
--        AND    UT.DATA_FINE_ATTIVITA IS NULL
        AND    FA.ID_UTE = UT.ID_UTE
        AND    FA.DATA_FINE_VALIDITA IS NULL
        AND    TI.ID_TIPOLOGIA_FABBRICATO = FA.ID_TIPOLOGIA_FABBRICATO
        AND   TI.FLAG_PER_STOCCAGGIO = 'S';
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            pSuperficeScoperta := 0;
    END;


    pCodErr := '0';

EXCEPTION
    WHEN EXC_PARAMETRO_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRO INPUT NULL';
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);
END CALCOLA_VOLUME_PIOGGIE_M3;


PROCEDURE CALCOLA_EFFLUENTI_M3 (    --pIdAzienda                 IN NUMBER,
                                            pIdUte                    IN NUMBER,
                                            pFlagPalabile            IN VARCHAR2 DEFAULT NULL,
                                            pFlagTrattamento        IN VARCHAR2,
                                            pIdEffluente            IN    NUMBER DEFAULT NULL,
                                            pVolumeProdotto       OUT NUMBER,
                                            pVolumeProdottoAz        OUT NUMBER,
                                            pAzotoProdotto            OUT NUMBER,
                                            pAzotoProdottoAz        OUT NUMBER,
                                            pCodErr                    OUT VARCHAR2,
                                            pDesErr                    OUT VARCHAR2) IS

n    NUMBER;
EXC_PARAMETRO_NULL         EXCEPTION;
EXC_PARAMETRO_NOT_NULL    EXCEPTION;
BEGIN

    IF pIdUte IS NULL OR pFlagTrattamento IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;

    IF pFlagPalabile IS NULL AND pIdEffluente IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;

    IF pFlagPalabile IS NOT NULL AND pIdEffluente IS NOT NULL THEN
        RAISE EXC_PARAMETRO_NOT_NULL;
    END IF;

    BEGIN
        SELECT     NVL(SUM(NVL(EF.VOLUME_PRODOTTO,0)),0),
                    NVL(SUM(NVL(EF.VOLUME_PRODOTTO_AZIENDALE,0)),0),
                    NVL(SUM(NVL(EF.AZOTO_PRODOTTO,0)),0),
                    NVL(SUM(NVL(EF.AZOTO_PRODOTTO_AZIENDALE,0)),0)
        INTO     pVolumeProdotto,
                pVolumeProdottoAz,
                pAzotoProdotto,
                pAzotoProdottoAz
        FROM  DB_UTE UT,
                DB_ALLEVAMENTO AL,
                DB_CATEGORIE_ALLEVAMENTO CA,
                DB_SOTTOCATEGORIA_ALLEVAMENTO SO,
                DB_STABULAZIONE_TRATTAMENTO   ST,
                DB_EFFLUENTE_PRODOTTO   EF,
                DB_TIPO_EFFLUENTE         TI
        WHERE UT.ID_UTE = pIdUte --UT.ID_AZIENDA = pIdAzienda
--        AND    UT.DATA_FINE_ATTIVITA                 IS NULL
        AND    AL.DATA_FINE                             IS NULL
        AND    AL.ID_UTE                                 = UT.ID_UTE
        AND    CA.ID_ALLEVAMENTO                     = AL.ID_ALLEVAMENTO
        AND    SO.ID_CATEGORIE_ALLEVAMENTO        = CA.ID_CATEGORIE_ALLEVAMENTO
        AND    ST.ID_SOTTOCATEGORIA_ALLEVAMENTO = SO.ID_SOTTOCATEGORIA_ALLEVAMENTO
        AND    EF.ID_STABULAZIONE_TRATTAMENTO    = ST.ID_STABULAZIONE_TRATTAMENTO
        AND    EF.FLAG_TRATTAMENTO                     = pFlagTrattamento
        AND    TI.ID_EFFLUENTE                        = EF.ID_EFFLUENTE
        AND    TI.FLAG_PALABILE                        = NVL(pFlagPalabile,TI.FLAG_PALABILE)
        AND    TI.ID_EFFLUENTE                        =  NVL(pIdEffluente,TI.ID_EFFLUENTE)
        AND    TI.DATA_FINE_VALIDITA                 IS NULL;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            pVolumeProdotto:=0;
            pVolumeProdottoAz:=0;
            pAzotoProdotto:=0;
            pAzotoProdottoAz:=0;
    END;


EXCEPTION
    WHEN EXC_PARAMETRO_NOT_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRI INPUT INCONGRUENTI FRA LORO';
    WHEN EXC_PARAMETRO_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRO INPUT NULL';
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);

END CALCOLA_EFFLUENTI_M3;



PROCEDURE CALCOLA_SUPERFICI_AGRONOMICA      ( --pIdAzienda                 IN NUMBER,
                                                            pIdUte                    IN NUMBER,
                                                              pSuperficeAgromica_Z        OUT NUMBER,
                                                            pSuperficeAgromica_NoZ    OUT NUMBER,
                                                              pCodErr                        OUT VARCHAR2,
                                                              pDesErr                        OUT VARCHAR2) IS

EXC_PARAMETRO_NULL EXCEPTION;
BEGIN

    IF pIdUte IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;


    BEGIN
        SELECT NVL(SUM(NVL(SUPERFICIE_AGRONOMICA,0)),0)
        INTO pSuperficeAgromica_Z
        FROM  DB_UTE UT,
                DB_CONDUZIONE_PARTICELLA CO,
                DB_STORICO_PARTICELLA    ST,
                DB_FOGLIO                     FO
        WHERE UT.ID_UTE = pIdUte --UT.ID_AZIENDA = pIdAzienda
--        AND    UT.DATA_FINE_ATTIVITA     IS NULL
        AND    CO.ID_UTE                     = UT.ID_UTE
        AND    CO.DATA_FINE_CONDUZIONE IS NULL
        AND    ID_TITOLO_POSSESSO         != 5
        AND    ST.ID_PARTICELLA            = CO.ID_PARTICELLA
        AND    ST.DATA_FINE_VALIDITA     IS NULL
        AND   NVL(FO.SEZIONE(+),-1)    = NVL(ST.SEZIONE,-1)
        AND    FO.FOGLIO(+)                 = ST.FOGLIO
        AND    FO.COMUNE(+)                 = ST.COMUNE
        AND    (ID_FASCIA_FLUVIALE IS NOT NULL OR NVL(FO.ID_AREA_E,0) = 2);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            pSuperficeAgromica_Z:=0;
    END;


    BEGIN
        SELECT NVL(SUM(NVL(SUPERFICIE_AGRONOMICA,0)),0)
        INTO pSuperficeAgromica_NoZ
        FROM  DB_UTE UT,
                DB_CONDUZIONE_PARTICELLA CO,
                DB_STORICO_PARTICELLA    ST,
                DB_FOGLIO                     FO
        WHERE UT.ID_UTE = pIdUte --UT.ID_AZIENDA = pIdAzienda
--        AND    UT.DATA_FINE_ATTIVITA     IS NULL
        AND    CO.ID_UTE                     = UT.ID_UTE
        AND    CO.DATA_FINE_CONDUZIONE IS NULL
        AND    ID_TITOLO_POSSESSO         != 5
        AND    ST.ID_PARTICELLA            = CO.ID_PARTICELLA
        AND    ST.DATA_FINE_VALIDITA     IS NULL
        AND NVL(FO.SEZIONE(+),-1)    = NVL(ST.SEZIONE,-1)
        AND    FO.FOGLIO(+)                 = ST.FOGLIO
        AND    FO.COMUNE(+)                 = ST.COMUNE
        AND    ID_FASCIA_FLUVIALE IS NULL
        AND    NVL(FO.ID_AREA_E,1) = 1;
    EXCEPTION
         WHEN NO_DATA_FOUND THEN
              pSuperficeAgromica_NoZ:=0;
    END;


EXCEPTION
    WHEN EXC_PARAMETRO_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRO INPUT NULL';
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);
END CALCOLA_SUPERFICI_AGRONOMICA;


PROCEDURE CALCOLA_SUPERFICI_CONDOTTA ( --pIdAzienda                 IN NUMBER,
                                                    pIdUte                    IN NUMBER,
                                                    pSuperficieCondotta_Z    OUT NUMBER,
                                                    pSuperficieCondotta_NoZ    OUT NUMBER,
                                                      pCodErr                        OUT VARCHAR2,
                                                      pDesErr                        OUT VARCHAR2) IS

EXC_PARAMETRO_NULL EXCEPTION;
BEGIN

    IF pIdUte IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;


    BEGIN
        SELECT NVL(SUM(NVL(SUPERFICIE_CONDOTTA,0)),0)
        INTO pSuperficieCondotta_Z
        FROM  DB_UTE UT,
                DB_CONDUZIONE_PARTICELLA CO,
                DB_STORICO_PARTICELLA    ST,
                DB_FOGLIO                     FO
        WHERE UT.ID_UTE = pIdUte --UT.ID_AZIENDA = pIdAzienda
--        AND    UT.DATA_FINE_ATTIVITA     IS NULL
        AND    CO.ID_UTE                     = UT.ID_UTE
        AND    CO.DATA_FINE_CONDUZIONE IS NULL
        AND    ID_TITOLO_POSSESSO         = 5
        AND    ST.ID_PARTICELLA            = CO.ID_PARTICELLA
        AND    ST.DATA_FINE_VALIDITA     IS NULL
        AND NVL(FO.SEZIONE(+),-1)    = NVL(ST.SEZIONE,-1)
        AND    FO.FOGLIO(+)                 = ST.FOGLIO
        AND    FO.COMUNE(+)                 = ST.COMUNE
        AND    (ID_FASCIA_FLUVIALE IS NOT NULL OR NVL(FO.ID_AREA_E,0) = 2);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            pSuperficieCondotta_Z:=0;
    END;


    BEGIN
        SELECT NVL(SUM(NVL(SUPERFICIE_CONDOTTA,0)),0)
        INTO pSuperficieCondotta_NoZ
        FROM  DB_UTE UT,
                DB_CONDUZIONE_PARTICELLA CO,
                DB_STORICO_PARTICELLA    ST,
                DB_FOGLIO                     FO
        WHERE UT.ID_UTE = pIdUte --UT.ID_AZIENDA = pIdAzienda
--        AND    UT.DATA_FINE_ATTIVITA     IS NULL
        AND    CO.ID_UTE                     = UT.ID_UTE
        AND    CO.DATA_FINE_CONDUZIONE IS NULL
        AND    ID_TITOLO_POSSESSO         = 5
        AND    ST.ID_PARTICELLA            = CO.ID_PARTICELLA
        AND    ST.DATA_FINE_VALIDITA     IS NULL
        AND NVL(FO.SEZIONE(+),-1)     = NVL(ST.SEZIONE,-1)
        AND    FO.FOGLIO(+)                 = ST.FOGLIO
        AND    FO.COMUNE(+)                 = ST.COMUNE
        AND    ID_FASCIA_FLUVIALE IS NULL
        AND    NVL(FO.ID_AREA_E,1) = 1;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            pSuperficieCondotta_NoZ:=0;
    END;


EXCEPTION
    WHEN EXC_PARAMETRO_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRO INPUT NULL';
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);
END CALCOLA_SUPERFICI_CONDOTTA;


PROCEDURE CALCOLA_UTILE_FAB_STOCCAGGIO (     --pIdAzienda                 IN NUMBER,
                                                        pIdUte                    IN NUMBER,
                                                        pFlagPalabile            IN VARCHAR2,
                                                          pUtileFabStock            OUT NUMBER,
                                                          pCodErr                    OUT VARCHAR2,
                                                          pDesErr                    OUT VARCHAR2) IS

EXC_PARAMETRO_NULL EXCEPTION;
BEGIN

    IF pIdUte IS NULL OR pFlagPalabile IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;


    BEGIN
        SELECT NVL(SUM(NVL(VOLUME_UTILE_PRESUNTO,0)),0)
        INTO pUtileFabStock
        FROM  DB_UTE UT,
                DB_FABBRICATO FA,
                DB_TIPO_TIPOLOGIA_FABBRICATO TI
        WHERE UT.ID_UTE = pIdUte --UT.ID_AZIENDA = pIdAzienda
--        AND    UT.DATA_FINE_ATTIVITA         IS NULL
        AND    FA.ID_UTE                         = UT.ID_UTE
        AND    FA.DATA_FINE_VALIDITA         IS NULL
        AND    TI.ID_TIPOLOGIA_FABBRICATO = FA.ID_TIPOLOGIA_FABBRICATO
        AND   TI.FLAG_PER_STOCCAGGIO         = 'S'
        AND    TI.FLAG_PALABILE                 = pFlagPalabile;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            pUtileFabStock:=0;
    END;


EXCEPTION
    WHEN EXC_PARAMETRO_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRO INPUT NULL';
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);
END CALCOLA_UTILE_FAB_STOCCAGGIO;

PROCEDURE CALCOLA_LETTIERA_PERM_ALLEVAM (     --pIdAzienda                 IN NUMBER,
                                                            pIdUte                    IN NUMBER,
                                                              pTotLettiera            OUT NUMBER,
                                                              pCodErr                    OUT VARCHAR2,
                                                              pDesErr                    OUT VARCHAR2) IS

EXC_PARAMETRO_NULL EXCEPTION;
BEGIN

    IF pIdUte IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;


    BEGIN

        SELECT NVL(SUM(NVL(ALTEZZA_LETTIERA_PERMANENTE,0)),0) * NVL(SUM(NVL(SUPERFICIE_LETTIERA_PERMANENTE,0)),0)
            INTO pTotLettiera
        FROM  DB_UTE UT,
                DB_ALLEVAMENTO AL
        WHERE UT.ID_UTE = pIdUte --UT.ID_AZIENDA = pIdAzienda
--        AND    UT.DATA_FINE_ATTIVITA         IS NULL
        AND    AL.DATA_FINE                     IS NULL
        AND    AL.ID_UTE                         = UT.ID_UTE;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            pTotLettiera:=0;
    END;


EXCEPTION
    WHEN EXC_PARAMETRO_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRO INPUT NULL';
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);
END CALCOLA_LETTIERA_PERM_ALLEVAM;


PROCEDURE CALCOLA_STOCCAGGIO_EXTRA_AZ (     pIdComunicazione        IN NUMBER,
                                                        pFlagPalabile            IN VARCHAR2,
                                                          pStockExtraAz            OUT NUMBER,
                                                          pCodErr                    OUT VARCHAR2,
                                                          pDesErr                    OUT VARCHAR2) IS

EXC_PARAMETRO_NULL EXCEPTION;
BEGIN

    IF pIdComunicazione IS NULL OR pFlagPalabile IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;

    BEGIN
        SELECT NVL(SUM(NVL(QUANTITA,0)),0)
        INTO pStockExtraAz
        FROM  DB_EFFLUENTE_STOC_EXT_10R EF,
                DB_TIPO_TIPOLOGIA_FABBRICATO TI
        WHERE EF.ID_COMUNICAZIONE_10R        = pIdComunicazione
        AND    TI.ID_TIPOLOGIA_FABBRICATO = EF.ID_TIPOLOGIA_FABBRICATO
        AND    TI.FLAG_PALABILE                 = pFlagPalabile;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            pStockExtraAz:=0;
    END;


EXCEPTION
    WHEN EXC_PARAMETRO_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRO INPUT NULL';
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);
END CALCOLA_STOCCAGGIO_EXTRA_AZ;


PROCEDURE CALCOLA_CES_ACQUISIZIONE     (         pIdComunicazione        IN NUMBER,
                                            pFlagPalabile            IN VARCHAR2 DEFAULT NULL,
                                            pCausaleEffluente        IN NUMBER,
                                            pIdEffluente            IN    NUMBER DEFAULT NULL,
                                            pStockAcqAz                OUT NUMBER,
                                            pStockAcqAzSto            OUT NUMBER,
                                            pCodErr                    OUT VARCHAR2,
                                            pDesErr                    OUT VARCHAR2) IS

EXC_PARAMETRO_NULL EXCEPTION;
EXC_PARAMETRO_NOT_NULL    EXCEPTION;
BEGIN

    IF pIdComunicazione IS NULL OR pCausaleEffluente IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;

    IF pFlagPalabile IS NULL AND pIdEffluente IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;

    IF pFlagPalabile IS NOT NULL AND pIdEffluente IS NOT NULL THEN
        RAISE EXC_PARAMETRO_NOT_NULL;
    END IF;

    BEGIN
        SELECT NVL(SUM(NVL(QUANTITA,0)),0)
        INTO pStockAcqAz
        FROM  DB_EFFLUENTE_CES_ACQ_10R EF,
                DB_TIPO_EFFLUENTE        TI
        WHERE EF.ID_COMUNICAZIONE_10R        = pIdComunicazione
        AND    EF.ID_CAUSALE_EFFLUENTE        = pCausaleEffluente
        AND    TI.ID_EFFLUENTE                 = EF.ID_EFFLUENTE
        AND    TI.ID_EFFLUENTE                =  NVL(pIdEffluente,TI.ID_EFFLUENTE)
        AND    TI.DATA_FINE_VALIDITA        IS NULL
        AND    TI.FLAG_PALABILE                = NVL(pFlagPalabile,TI.FLAG_PALABILE)
        AND    TI.DATA_FINE_VALIDITA         IS NULL;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            pStockAcqAz:=0;
    END;

    BEGIN
        SELECT NVL(SUM(NVL(QUANTITA,0)),0)
        INTO pStockAcqAzSto
        FROM  DB_EFFLUENTE_CES_ACQ_10R EF,
              DB_TIPO_EFFLUENTE        TI
        WHERE EF.ID_COMUNICAZIONE_10R        = pIdComunicazione
        AND    EF.ID_CAUSALE_EFFLUENTE        = pCausaleEffluente
        AND    TI.ID_EFFLUENTE                 = EF.ID_EFFLUENTE
        AND    TI.ID_EFFLUENTE                =  NVL(pIdEffluente,TI.ID_EFFLUENTE)
        AND    TI.DATA_FINE_VALIDITA        IS NULL
        AND    TI.FLAG_PALABILE                = NVL(pFlagPalabile,TI.FLAG_PALABILE)
        AND    TI.DATA_FINE_VALIDITA         IS NULL
        AND EF.FLAG_STOCCAGGIO                 = DECODE(pCausaleEffluente,1,'N',2,'S'); 
        --AND EF.FLAG_STOCCAGGIO = 'S'; 



    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            pStockAcqAzSto:=0;
    END;


EXCEPTION
    WHEN EXC_PARAMETRO_NOT_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRI INPUT INCONGRUENTI FRA LORO';
    WHEN EXC_PARAMETRO_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRO INPUT NULL';
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);
END CALCOLA_CES_ACQUISIZIONE;



PROCEDURE CALCOLA_ACQUE_MUNGITURA (    --pIdAzienda                 IN NUMBER,
                                                pIdUte                    IN NUMBER,
                                                pTotMungitura            OUT NUMBER,
                                                  pCodErr                    OUT VARCHAR2,
                                                  pDesErr                    OUT VARCHAR2) IS

EXC_PARAMETRO_NULL EXCEPTION;
BEGIN

    IF pIdUte IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;

        -- sostituisce select di cui sotto
        SELECT NVL(SUM(AAL.QUANTITA_ACQUA_LAVAGGIO),0)
          INTO pTotMungitura
          FROM DB_ALLEVAMENTO AL,
               DB_ALLEVAMENTO_ACQUA_LAVAGGIO AAL,
               DB_TIPO_DESTINO_ACQUA_LAVAGGIO TDAL
         WHERE AL.ID_UTE = pIdUte
           AND AL.DATA_FINE IS NULL
           AND AL.ID_ALLEVAMENTO = AAL.ID_ALLEVAMENTO
           AND AAL.ID_DESTINO_ACQUA_LAVAGGIO = TDAL.ID_DESTINO_ACQUA_LAVAGGIO
           AND TDAL.CONSIDERA_IN_10R = 'S';

    /*
    BEGIN

        SELECT     NVL(SUM(NVL(QUANTITA_ACQUA_LAVAGGIO,0)),0)
        INTO  pTotMungitura
        FROM  DB_UTE UT,
                DB_ALLEVAMENTO AL
        WHERE UT.ID_UTE                                 = pIdUte
        AND    AL.DATA_FINE                             IS NULL
        AND    AL.ID_UTE                                 =     UT.ID_UTE
        AND    NVL(AL.FLAG_ACQUE_EFFLUENTI,'N')    =    'S';


    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            pTotMungitura:=0;
    END; */

EXCEPTION
    WHEN EXC_PARAMETRO_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRO INPUT NULL';
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);
END CALCOLA_ACQUE_MUNGITURA;

------------------------------------------------------------------
PROCEDURE CALCOLA_SUPERF_SAU_SPANDIBILE (    --pIdAzienda                 IN NUMBER,
                                                        pIdUte                    IN NUMBER,
                                                        pTotSup                    OUT NUMBER,
                                                          pCodErr                    OUT VARCHAR2,
                                                          pDesErr                    OUT VARCHAR2) IS


EXC_PARAMETRO_NULL EXCEPTION;
pTotSupTmp1    NUMBER;
pTotSupTmp2    NUMBER;
nIdAzienda        NUMBER;
BEGIN

    IF pIdUte IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;

    SELECT ID_AZIENDA
    INTO nIdAzienda
    FROM  DB_UTE UT
    WHERE UT.ID_UTE = pIdUte;

    BEGIN
        SELECT NVL(SUM(NVL(SUPERFICIE_UTILIZZATA,0)),0)
        INTO pTotSupTmp1
        FROM  DB_UTE UT,
                DB_CONDUZIONE_PARTICELLA CO,
                DB_UTILIZZO_PARTICELLA   UT,
                DB_TIPO_UTILIZZO             TI
        WHERE UT.ID_UTE = pIdUte --UT.ID_AZIENDA = pIdAzienda
--        AND    UT.DATA_FINE_ATTIVITA             IS NULL
        AND    CO.ID_UTE                             =     UT.ID_UTE
        AND    CO.DATA_FINE_CONDUZIONE         IS NULL
        AND    ID_TITOLO_POSSESSO                 != 5
        AND    UT.ID_CONDUZIONE_PARTICELLA    = CO.ID_CONDUZIONE_PARTICELLA
        AND    UT.ID_UTILIZZO                        = TI.ID_UTILIZZO
        AND    TI.FLAG_USO_AGRONOMICO            = 'S';
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            pTotSupTmp1 := 0;
    END;


    BEGIN
        /*
        SELECT  NVL(SUM(NVL(FNC_SOMMA_SUPERFICI_SPAN (ID_PARTICELLA,pIdAzienda),0)),0)
        INTO pTotSupTmp2
        FROM  DB_UTE UT,
                DB_CONDUZIONE_PARTICELLA CO,
                DB_UTILIZZO_PARTICELLA   UT
        WHERE UT.ID_AZIENDA                         = pIdAzienda
        AND    UT.DATA_FINE_ATTIVITA             IS NULL
        AND    CO.ID_UTE                             = UT.ID_UTE
        AND    CO.DATA_FINE_CONDUZIONE         IS NULL
        AND    ID_TITOLO_POSSESSO                 = 5
        AND    UT.ID_CONDUZIONE_PARTICELLA    = CO.ID_CONDUZIONE_PARTICELLA
        GROUP BY ID_PARTICELLA;
        */
        SELECT
        NVL(SUM(NVL(UT.SUPERFICIE_UTILIZZATA,0)),0)
        INTO pTotSupTmp2
        FROM       DB_CONDUZIONE_DICHIARATA CD,
                    DB_DICHIARAZIONE_CONSISTENZA DC,
                    DB_ANAGRAFICA_AZIENDA AA,
                    DB_UTILIZZO_DICHIARATO   UT,
                    DB_TIPO_UTILIZZO             TI
        WHERE CD.CODICE_FOTOGRAFIA_TERRENI             = DC.CODICE_FOTOGRAFIA_TERRENI
        AND    AA.ID_AZIENDA                                 = DC.ID_AZIENDA
        AND   AA.DATA_FINE_VALIDITA                     IS NULL
        AND   AA.DATA_CESSAZIONE                         IS NULL
        AND    AA.ID_AZIENDA                                 <> nIdAzienda
        AND    DC.ID_MOTIVO_DICHIARAZIONE             <> 7
        AND    DC.DATA_INSERIMENTO_DICHIARAZIONE     =  (    SELECT MAX(DATA_INSERIMENTO_DICHIARAZIONE)
                                                                        FROM   DB_DICHIARAZIONE_CONSISTENZA
                                                                        WHERE  ID_AZIENDA = DC.ID_AZIENDA
                                                                        AND       ID_MOTIVO_DICHIARAZIONE <> 7
                                                                    )
        AND    ID_TITOLO_POSSESSO                 != 5
        --AND    UT.ID_CONDUZIONE_PARTICELLA    = CD.ID_CONDUZIONE_PARTICELLA
        AND UT.ID_CONDUZIONE_DICHIARATA=CD.ID_CONDUZIONE_DICHIARATA
        AND    UT.ID_UTILIZZO                        = TI.ID_UTILIZZO
        AND    (TI.FLAG_USO_AGRONOMICO    = 'S')
        AND CD.ID_PARTICELLA IN (SELECT  DISTINCT (CO1.ID_PARTICELLA)
                        FROM  DB_UTE UT1,
                                DB_CONDUZIONE_PARTICELLA CO1
                        WHERE UT1.ID_UTE = pIdUte --UT.ID_AZIENDA = pIdAzienda
                        AND    CO1.ID_UTE     = UT1.ID_UTE
                        AND    CO1.DATA_FINE_CONDUZIONE         IS NULL
                        AND    CO1.ID_TITOLO_POSSESSO                 = 5
                        AND    UT1.DATA_FINE_ATTIVITA IS NULL);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            pTotSupTmp2 := 0;
    END;


    pTotSup := pTotSupTmp1 + pTotSupTmp2;

EXCEPTION
    WHEN EXC_PARAMETRO_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRO INPUT NULL';
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);
END CALCOLA_SUPERF_SAU_SPANDIBILE;


-----
PROCEDURE CALCOLA_SUPERF_SAU_BIS (            pIdUte                    IN NUMBER,
                                                        pTotSup                    OUT NUMBER,
                                                          pCodErr                    OUT VARCHAR2,
                                                          pDesErr                    OUT VARCHAR2) IS


EXC_PARAMETRO_NULL EXCEPTION;
pTotSupTmp1    NUMBER;
pTotSupTmp2    NUMBER;
nIdAzienda        NUMBER;
BEGIN

    IF pIdUte IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;

    BEGIN
        SELECT NVL(SUM(NVL(SUPERFICIE_UTILIZZATA,0)),0)
        INTO pTotSupTmp1
        FROM  DB_UTE UTE,
                DB_CONDUZIONE_PARTICELLA CO,
                DB_UTILIZZO_PARTICELLA   UT,
                DB_TIPO_UTILIZZO             TI,
                DB_STORICO_PARTICELLA    ST,
                COMUNE CM,
                PROVINCIA PR
        WHERE UTE.ID_UTE = pIdUte
        AND    CO.ID_UTE = UTE.ID_UTE
        AND    CO.DATA_FINE_CONDUZIONE IS NULL
        AND    ID_TITOLO_POSSESSO != 5
        AND    UT.ID_CONDUZIONE_PARTICELLA    = CO.ID_CONDUZIONE_PARTICELLA
        AND    UT.ID_UTILIZZO = TI.ID_UTILIZZO
        AND    TI.FLAG_SAU = 'S'
        AND    ST.ID_PARTICELLA = CO.ID_PARTICELLA
         AND    ST.DATA_FINE_VALIDITA IS NULL
        AND    ST.COMUNE = CM.ISTAT_COMUNE
        AND CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
        AND PR.ID_REGIONE =  kvCodIstatPiemonte; 
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            pTotSupTmp1 := 0;
    END;


    pTotSup := pTotSupTmp1;

EXCEPTION
    WHEN EXC_PARAMETRO_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRO INPUT NULL';
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);
END CALCOLA_SUPERF_SAU_BIS;

-----

PROCEDURE CALCOLA_SUPERF_ZVN_SAU_SPAND (    --pIdAzienda                 IN NUMBER,
                                                        pIdUte                    IN NUMBER,
                                                        pTotSupZvn                OUT NUMBER,
                                                          pCodErr                    OUT VARCHAR2,
                                                        pDesErr                    OUT VARCHAR2) IS

EXC_PARAMETRO_NULL EXCEPTION;
pTotSupTmp1    NUMBER;
pTotSupTmp2    NUMBER;
nIdAzienda        NUMBER;
BEGIN

    IF pIdUte IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;

    SELECT ID_AZIENDA
    INTO nIdAzienda
    FROM  DB_UTE UT
    WHERE UT.ID_UTE = pIdUte;

    BEGIN
        SELECT NVL(SUM(NVL(SUPERFICIE_UTILIZZATA,0)),0)
        INTO pTotSupTmp1
        FROM  DB_UTE UTE,
                DB_CONDUZIONE_PARTICELLA CO,
                DB_UTILIZZO_PARTICELLA   UT,
                DB_STORICO_PARTICELLA    ST,
                DB_FOGLIO                     FO,
                DB_TIPO_UTILIZZO             TI,
                COMUNE CM,
                PROVINCIA PR
        WHERE UTE.ID_UTE = pIdUte --UT.ID_AZIENDA = pIdAzienda
--        AND    UT.DATA_FINE_ATTIVITA             IS NULL
        AND    CO.ID_UTE                             =     UTE.ID_UTE
        AND    CO.DATA_FINE_CONDUZIONE         IS NULL
        AND    ID_TITOLO_POSSESSO                 != 5
        AND    UT.ID_CONDUZIONE_PARTICELLA    = CO.ID_CONDUZIONE_PARTICELLA
        AND    UT.ID_UTILIZZO                        = TI.ID_UTILIZZO
        AND    TI.FLAG_USO_AGRONOMICO            = 'S'
        AND    ST.ID_PARTICELLA                    = CO.ID_PARTICELLA
         AND    ST.DATA_FINE_VALIDITA             IS NULL
        AND NVL(FO.SEZIONE(+),-1)             = NVL(ST.SEZIONE,-1)
        AND    FO.FOGLIO(+)                         = ST.FOGLIO
        AND    FO.COMUNE(+)                         = ST.COMUNE
        AND    ST.COMUNE                            = CM.ISTAT_COMUNE
        AND CM.ISTAT_PROVINCIA                 = PR.ISTAT_PROVINCIA
        AND PR.ID_REGIONE = kvCodIstatPiemonte 
        AND    (ST.ID_FASCIA_FLUVIALE IS NOT NULL OR NVL(FO.ID_AREA_E,0) = 2);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            pTotSupTmp1 := 0;
    END;


    BEGIN
    /*
        SELECT NVL(SUM(NVL(FNC_SOMMA_SUPERFICI_SPAN (CO.ID_PARTICELLA,pIdAzienda),0)),0)
        INTO pTotSupTmp2
        FROM  DB_UTE UT,
                DB_CONDUZIONE_PARTICELLA CO,
                DB_UTILIZZO_PARTICELLA   UT,
                DB_STORICO_PARTICELLA    ST,
                DB_FOGLIO                     FO
        WHERE UT.ID_AZIENDA                         =     pIdAzienda
        AND    UT.DATA_FINE_ATTIVITA             IS NULL
        AND    CO.ID_UTE                             =     UT.ID_UTE
        AND    CO.DATA_FINE_CONDUZIONE         IS NULL
        AND    ID_TITOLO_POSSESSO                 = 5
        AND    UT.ID_CONDUZIONE_PARTICELLA    = CO.ID_CONDUZIONE_PARTICELLA
        AND    ST.ID_PARTICELLA                    = CO.ID_PARTICELLA
         AND    ST.DATA_FINE_VALIDITA             IS NULL
      AND   NVL(FO.SEZIONE(+),-1)             = NVL(ST.SEZIONE,-1)
        AND    FO.FOGLIO(+)                         = ST.FOGLIO
        AND    FO.COMUNE(+)                         = ST.COMUNE
        AND    (ID_FASCIA_FLUVIALE IS NOT NULL OR NVL(FO.ID_AREA_E,2) = 2)
        GROUP BY CO.ID_PARTICELLA;
        */
        SELECT
        NVL(SUM(NVL(UT.SUPERFICIE_UTILIZZATA,0)),0)
        INTO pTotSupTmp2
        FROM       DB_CONDUZIONE_DICHIARATA CD,
                    DB_DICHIARAZIONE_CONSISTENZA DC,
                    DB_ANAGRAFICA_AZIENDA AA,
                    DB_UTILIZZO_DICHIARATO   UT,
                    DB_TIPO_UTILIZZO             TI
        WHERE CD.CODICE_FOTOGRAFIA_TERRENI             = DC.CODICE_FOTOGRAFIA_TERRENI
        AND    AA.ID_AZIENDA                                 = DC.ID_AZIENDA
        AND   AA.DATA_FINE_VALIDITA                     IS NULL
        AND   AA.DATA_CESSAZIONE                         IS NULL
        AND    AA.ID_AZIENDA                                 <> nIdAzienda
        AND    DC.ID_MOTIVO_DICHIARAZIONE             <> 7
        AND    DC.DATA_INSERIMENTO_DICHIARAZIONE     =  (    SELECT MAX(DATA_INSERIMENTO_DICHIARAZIONE)
                                                                        FROM   DB_DICHIARAZIONE_CONSISTENZA
                                                                        WHERE  ID_AZIENDA = DC.ID_AZIENDA
                                                                        AND       ID_MOTIVO_DICHIARAZIONE <> 7
                                                                    )
        AND    ID_TITOLO_POSSESSO                 != 5
        AND    UT.ID_CONDUZIONE_DICHIARATA    = CD.ID_CONDUZIONE_DICHIARATA
        AND    UT.ID_UTILIZZO                        = TI.ID_UTILIZZO
        AND    (TI.FLAG_USO_AGRONOMICO    = 'S')
        AND CD.ID_PARTICELLA IN (SELECT  DISTINCT (CO1.ID_PARTICELLA)
                        FROM  DB_UTE UT1,
                              DB_CONDUZIONE_PARTICELLA CO1,
                              DB_STORICO_PARTICELLA    ST1,
                              DB_FOGLIO                     FO1,
                                          COMUNE CM,
                                        PROVINCIA PR
                        WHERE UT1.ID_UTE = pIdUte --UT.ID_AZIENDA = pIdAzienda
                        AND    CO1.ID_UTE                             = UT1.ID_UTE
                        AND    CO1.DATA_FINE_CONDUZIONE         IS NULL
                        AND    CO1.ID_TITOLO_POSSESSO                 = 5
                        AND    ST1.ID_PARTICELLA                    = CO1.ID_PARTICELLA
                        AND    ST1.DATA_FINE_VALIDITA             IS NULL
                        AND NVL(FO1.SEZIONE(+),-1)             = NVL(ST1.SEZIONE,-1)
                        AND    FO1.FOGLIO(+)                         = ST1.FOGLIO
                        AND    FO1.COMUNE(+)                         = ST1.COMUNE
                        AND    ST1.COMUNE                            = CM.ISTAT_COMUNE
                        AND CM.ISTAT_PROVINCIA                 = PR.ISTAT_PROVINCIA
                        AND PR.ID_REGIONE = kvCodIstatPiemonte 
                        AND    (ST1.ID_FASCIA_FLUVIALE IS NOT NULL OR NVL(FO1.ID_AREA_E,0) = 2));

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            pTotSupTmp2 := 0;
    END;

    pTotSupZvn := pTotSupTmp1 + pTotSupTmp2;

EXCEPTION
    WHEN EXC_PARAMETRO_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRO INPUT NULL';
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);
END CALCOLA_SUPERF_ZVN_SAU_SPAND;


--------
PROCEDURE CALCOLA_SUPERF_ZVN_SAU_BIS (        pIdUte                    IN NUMBER,
                                                        pTotSupZvn                OUT NUMBER,
                                                          pCodErr                    OUT VARCHAR2,
                                                        pDesErr                    OUT VARCHAR2) IS

EXC_PARAMETRO_NULL EXCEPTION;
pTotSupTmp1    NUMBER;
pTotSupTmp2    NUMBER;
nIdAzienda        NUMBER;
BEGIN

    IF pIdUte IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;

    BEGIN
        SELECT NVL(SUM(NVL(SUPERFICIE_UTILIZZATA,0)),0)
        INTO pTotSupTmp1
        FROM  DB_UTE UTE,
                DB_CONDUZIONE_PARTICELLA CO,
                DB_UTILIZZO_PARTICELLA   UT,
                DB_STORICO_PARTICELLA    ST,
                DB_FOGLIO                     FO,
                DB_TIPO_UTILIZZO             TI,
                COMUNE CM,
                PROVINCIA PR
        WHERE UTE.ID_UTE                             = pIdUte
        AND    CO.ID_UTE                             =     UTE.ID_UTE
        AND    CO.DATA_FINE_CONDUZIONE         IS NULL
        AND    ID_TITOLO_POSSESSO                 != 5
        AND    UT.ID_CONDUZIONE_PARTICELLA    = CO.ID_CONDUZIONE_PARTICELLA
        AND    UT.ID_UTILIZZO                        = TI.ID_UTILIZZO
        AND    TI.FLAG_SAU                            = 'S'
        AND    ST.ID_PARTICELLA                    = CO.ID_PARTICELLA
         AND    ST.DATA_FINE_VALIDITA             IS NULL
        AND NVL(FO.SEZIONE(+),-1)             = NVL(ST.SEZIONE,-1)
        AND    FO.FOGLIO(+)                         = ST.FOGLIO
        AND    FO.COMUNE(+)                         = ST.COMUNE
        AND    ST.COMUNE                            = CM.ISTAT_COMUNE
        AND CM.ISTAT_PROVINCIA                 = PR.ISTAT_PROVINCIA
        AND PR.ID_REGIONE = kvCodIstatPiemonte 
        AND    (ST.ID_FASCIA_FLUVIALE IS NOT NULL OR NVL(FO.ID_AREA_E,0) = 2);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            pTotSupTmp1 := 0;
    END;


    pTotSupZvn := pTotSupTmp1;

EXCEPTION
    WHEN EXC_PARAMETRO_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRO INPUT NULL';
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);
END CALCOLA_SUPERF_ZVN_SAU_BIS;


--------


PROCEDURE CALCOLA_GIORNI_STOC_NECESSARI (    pIdUte                IN NUMBER,
                                            pIdEffluente        IN NUMBER,
                                            pMaxAzoto           IN NUMBER,
                                            pTotGg                OUT NUMBER,
                                            pCodErr                OUT VARCHAR2,
                                            pDesErr                OUT VARCHAR2) IS

EXC_PARAMETRO_NULL EXCEPTION;
EXC_ERR                                 EXCEPTION;
pTotTmp1                    NUMBER;
pTotTmp2                    NUMBER;
pTmp1                        NUMBER;        --BM003
pTmp2                        NUMBER;        --BM003
vFlagPalabile            VARCHAR2(1);
nCountAllAvicoli        NUMBER;
nPratoTmp1                NUMBER;
nPratoTmp2                NUMBER;
vFlagPrato                VARCHAR2(1);
vFlagZvn                 VARCHAR2(1);
nIdSpecieAnimale        NUMBER;
nIdAzienda                NUMBER;
nIdZonaAltimetrica      DB_UTE.ID_ZONA_ALTIMETRICA%TYPE;
nTotAzoto               DB_COMUNICAZIONE_10R.TOTALE_AZOTO_AZIENDALE%TYPE;
nTotAzotoIniziale       DB_EFFLUENTE_10R.AZOTO_INIZIALE%TYPE;
nTotAzotoPostDichiarato DB_EFFLUENTE_10R.AZOTO_POST_DICHIARATO%TYPE;
BEGIN

    IF pIdUte IS NULL THEN
    RAISE EXC_PARAMETRO_NULL;
    END IF;

    SELECT ID_AZIENDA ,
           ID_ZONA_ALTIMETRICA
      INTO nIdAzienda,
           nIdZonaAltimetrica
      FROM DB_UTE UT
     WHERE UT.ID_UTE = pIdUte;

    -- seleziono la somma dell'azoto aziendale prodotto
    -- mi servirà per calcolare i giorni di stocaggio
    SELECT NVL(SUM(EF.AZOTO_PRODOTTO_AZIENDALE),0)
      INTO nTotAzoto
      FROM DB_UTE UT,
           DB_ALLEVAMENTO AL,
           DB_CATEGORIE_ALLEVAMENTO CA,
           DB_SOTTOCATEGORIA_ALLEVAMENTO SO,
           DB_STABULAZIONE_TRATTAMENTO   ST,
           DB_EFFLUENTE_PRODOTTO   EF,
           DB_TIPO_EFFLUENTE         TI
     WHERE UT.ID_AZIENDA = nIdAzienda
       AND UT.DATA_FINE_ATTIVITA IS NULL
       AND AL.DATA_FINE IS NULL
       AND AL.ID_UTE = UT.ID_UTE
       AND CA.ID_ALLEVAMENTO = AL.ID_ALLEVAMENTO
       AND SO.ID_CATEGORIE_ALLEVAMENTO = CA.ID_CATEGORIE_ALLEVAMENTO
       AND ST.ID_SOTTOCATEGORIA_ALLEVAMENTO = SO.ID_SOTTOCATEGORIA_ALLEVAMENTO
       AND EF.ID_STABULAZIONE_TRATTAMENTO= ST.ID_STABULAZIONE_TRATTAMENTO
       AND EF.FLAG_TRATTAMENTO = 'N' 
       AND TI.ID_EFFLUENTE = EF.ID_EFFLUENTE
       AND TI.DATA_FINE_VALIDITA IS NULL;

    -- azoto post dichiarato aziendale
    SELECT NVL(SUM(EF10R.AZOTO_POST_DICHIARATO),0)
      INTO nTotAzotoPostDichiarato
      FROM DB_EFFLUENTE_10R EF10R,
           DB_COMUNICAZIONE_10R CO10R,
           DB_UTE UT
     WHERE EF10R.ID_COMUNICAZIONE_10R = CO10R.ID_COMUNICAZIONE_10R
       AND CO10R.DATA_FINE_VALIDITA IS NULL
       AND CO10R.ID_UTE = UT.ID_UTE
       AND UT.DATA_FINE_ATTIVITA IS NULL
       AND UT.ID_AZIENDA = nIdAzienda
       AND EF10R.ID_TRATTAMENTO IS NOT NULL;

    -- azoto iniziale aziendale
    SELECT NVL(SUM(AZOTO_INIZIALE),0)
      INTO nTotAzotoIniziale
      FROM (
    SELECT EF10R.ID_EFFLUENTE_ORIGINE,
           MAX(EF10R.AZOTO_INIZIALE) AS AZOTO_INIZIALE
      FROM DB_EFFLUENTE_10R EF10R,
           DB_COMUNICAZIONE_10R CO10R,
           DB_UTE UT
     WHERE EF10R.ID_COMUNICAZIONE_10R = CO10R.ID_COMUNICAZIONE_10R
       AND CO10R.DATA_FINE_VALIDITA IS NULL
       AND CO10R.ID_UTE = UT.ID_UTE
       AND UT.DATA_FINE_ATTIVITA IS NULL
       AND UT.ID_AZIENDA = nIdAzienda
       AND EF10R.ID_TRATTAMENTO IS NOT NULL
  GROUP BY EF10R.ID_EFFLUENTE_ORIGINE);


    nTotAzoto := nTotAzoto  - nTotAzotoIniziale + nTotAzotoPostDichiarato;

    pTotTmp1    := 0;
    pTotTmp2    :=    0;
    /* BM003*/
    FOR REC_U IN (SELECT ID_UTE FROM DB_UTE WHERE DATA_FINE_ATTIVITA IS NULL AND ID_AZIENDA = nIdAzienda) LOOP

    --    CALCOLA_SUPERF_SAU_SPANDIBILE (    pIdUte,pTotTmp1,pCodErr,pDesErr);
        CALCOLA_SUPERF_SAU_BIS (    REC_U.ID_UTE,pTmp1,pCodErr,pDesErr);
        pTotTmp1 := pTotTmp1 + pTmp1;    -- BM003
        IF pCodErr = 1 THEN
            pDesErr :=     'procedura CALCOLA_SUPERF_SAU_SPANDIBILE '||pDesErr;
            RAISE EXC_ERR;
        END IF;

    --    CALCOLA_SUPERF_ZVN_SAU_SPAND (    pIdUte,pTotTmp2,pCodErr,pDesErr);
        CALCOLA_SUPERF_ZVN_SAU_BIS (    REC_U.ID_UTE,pTmp2,pCodErr,pDesErr);
        pTotTmp2 := pTotTmp2 + pTmp2;    -- BM003
        IF pCodErr = 1 THEN
            pDesErr :=     'procedura CALCOLA_SUPERF_ZVN_SAU_SPAND '||pDesErr;
            RAISE EXC_ERR;
        END IF;

    END LOOP;

    SELECT FLAG_PALABILE
    INTO vFlagPalabile
    FROM     DB_TIPO_EFFLUENTE
    WHERE ID_EFFLUENTE = pIdEffluente;

    BEGIN
        SELECT DISTINCT ANI.ID_SPECIE_ANIMALE
        INTO nIdSpecieAnimale
        FROM     DB_TIPO_EFFLUENTE                        EFF,
                DB_SOTTOCATEGORIA_ANIM_STAB        STA,
                DB_TIPO_SOTTOCATEGORIA_ANIMALE    SOT,
                DB_TIPO_CATEGORIA_ANIMALE            CAT,
                DB_TIPO_SPECIE_ANIMALE                ANI,
                DB_ALLEVAMENTO                         ALV,
                DB_UTE                                     UT
        WHERE EFF.ID_EFFLUENTE                     IN (    SELECT  pIdEffluente FROM dual    -- BM003
                                                                UNION
                                                                SELECT ID_EFFLUENTE FROM DB_LEGAME_EFFLUENTE WHERE ID_EFFLUENTE_TRATTATO = pIdEffluente)
        AND    STA.ID_EFFLUENTE                     = EFF.ID_EFFLUENTE
        AND    SOT.ID_SOTTOCATEGORIA_ANIMALE = STA.ID_SOTTOCATEGORIA_ANIMALE
        AND    CAT.ID_CATEGORIA_ANIMALE        = SOT.ID_CATEGORIA_ANIMALE
        AND    ANI.ID_SPECIE_ANIMALE            = CAT.ID_SPECIE_ANIMALE
--        AND     UT.ID_UTE = pIdUte                                                     -- BM003
        AND    UT.ID_AZIENDA                         = nIdAzienda                    -- BM003
        AND    UT.DATA_FINE_ATTIVITA             IS NULL                            -- BM003
        AND    ALV.DATA_FINE                         IS NULL
        AND    ALV.ID_UTE                             = UT.ID_UTE
        AND    ANI.ID_SPECIE_ANIMALE            = ALV.ID_SPECIE_ANIMALE
        AND ROWNUM < 2
        ORDER BY ID_SPECIE_ANIMALE;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
                SELECT DISTINCT ANI.ID_SPECIE_ANIMALE
                INTO nIdSpecieAnimale
                FROM     DB_TIPO_EFFLUENTE                        EFF,
                        DB_SOTTOCATEGORIA_ANIM_STAB        STA,
                        DB_TIPO_SOTTOCATEGORIA_ANIMALE    SOT,
                        DB_TIPO_CATEGORIA_ANIMALE            CAT,
                        DB_TIPO_SPECIE_ANIMALE                ANI
                WHERE EFF.ID_EFFLUENTE                     IN (    SELECT  pIdEffluente FROM dual    -- BM003
                                                                        UNION
                                                                        SELECT ID_EFFLUENTE FROM DB_LEGAME_EFFLUENTE WHERE ID_EFFLUENTE_TRATTATO = pIdEffluente)
                AND    STA.ID_EFFLUENTE                     = EFF.ID_EFFLUENTE
                AND    SOT.ID_SOTTOCATEGORIA_ANIMALE = STA.ID_SOTTOCATEGORIA_ANIMALE
                AND    CAT.ID_CATEGORIA_ANIMALE        = SOT.ID_CATEGORIA_ANIMALE
                AND    ANI.ID_SPECIE_ANIMALE            = CAT.ID_SPECIE_ANIMALE
                AND ROWNUM < 2
                ORDER BY ID_SPECIE_ANIMALE;
    END;


    SELECT     COUNT(*)
    INTO nCountAllAvicoli
    FROM  DB_UTE UT,
            DB_ALLEVAMENTO AL,
            DB_TIPO_SPECIE_ANIMALE SP
    WHERE UT.ID_AZIENDA                     = nIdAzienda            -- BM003
            --UT.ID_UTE = pIdUte                                     -- BM003
    AND    UT.DATA_FINE_ATTIVITA         IS NULL                    -- BM003
    AND    AL.DATA_FINE                     IS NULL
    AND    AL.ID_UTE                         = UT.ID_UTE
    AND    Al.FLAG_DEIEZIONE_AVICOLI = 'S'
    AND    SP.ID_SPECIE_ANIMALE = AL.ID_SPECIE_ANIMALE
    AND    sp.ID_SPECIE_ANIMALE = nIdSpecieAnimale;


    BEGIN
        SELECT NVL(SUM(NVL(SUPERFICIE_UTILIZZATA,0)),0)
        INTO nPratoTmp1
        FROM  DB_UTE UTE,
                DB_CONDUZIONE_PARTICELLA CO,
                DB_UTILIZZO_PARTICELLA   UT,
                DB_TIPO_UTILIZZO             TI
--        WHERE UT.ID_UTE = pIdUte                                    -- BM003
        WHERE    UTE.ID_AZIENDA                         = nIdAzienda    -- BM003
        AND    UTE.DATA_FINE_ATTIVITA             IS NULL            -- BM003
        AND    CO.ID_UTE                             =     UTE.ID_UTE
        AND    CO.DATA_FINE_CONDUZIONE         IS NULL
        AND    ID_TITOLO_POSSESSO                 != 5
        AND    UT.ID_CONDUZIONE_PARTICELLA    = CO.ID_CONDUZIONE_PARTICELLA
        AND    UT.ID_UTILIZZO                        = TI.ID_UTILIZZO
        AND    (TI.FLAG_AUTUNNO_VERNINI        = 'S' OR FLAG_PRATO_PASCOLO = 'S');
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            nPratoTmp1 := 0;
    END;

    BEGIN

        SELECT
        NVL(SUM(NVL(UT.SUPERFICIE_UTILIZZATA,0)),0)
        INTO nPratoTmp2
        FROM       DB_CONDUZIONE_DICHIARATA CD,
                    DB_DICHIARAZIONE_CONSISTENZA DC,
                    DB_ANAGRAFICA_AZIENDA AA,
                    DB_UTILIZZO_DICHIARATO   UT,
                    DB_TIPO_UTILIZZO             TI
        WHERE CD.CODICE_FOTOGRAFIA_TERRENI             = DC.CODICE_FOTOGRAFIA_TERRENI
        AND    AA.ID_AZIENDA                                     = DC.ID_AZIENDA
        AND   AA.DATA_FINE_VALIDITA                     IS NULL
        AND   AA.DATA_CESSAZIONE                         IS NULL
        AND    AA.ID_AZIENDA                                     <> nIdAzienda
        AND    DC.ID_MOTIVO_DICHIARAZIONE                 <> 7
        AND    DC.DATA_INSERIMENTO_DICHIARAZIONE         =  (    SELECT MAX(DATA_INSERIMENTO_DICHIARAZIONE)
                                                         FROM   DB_DICHIARAZIONE_CONSISTENZA
                                                         WHERE  ID_AZIENDA = DC.ID_AZIENDA
                                                          AND       ID_MOTIVO_DICHIARAZIONE <> 7
                                                      )
        AND    ID_TITOLO_POSSESSO                             != 5
        AND    UT.ID_CONDUZIONE_DICHIARATA                = CD.ID_CONDUZIONE_DICHIARATA
        AND    UT.ID_UTILIZZO                                    = TI.ID_UTILIZZO
        AND    (TI.FLAG_AUTUNNO_VERNINI = 'S' OR FLAG_PRATO_PASCOLO = 'S')
        AND CD.ID_PARTICELLA IN (
            SELECT DISTINCT (CO1.ID_PARTICELLA)
            FROM  DB_UTE UT1,
                    DB_CONDUZIONE_PARTICELLA CO1
            WHERE UT1.ID_UTE = pIdUte --UT1.ID_AZIENDA                         = pIdAzienda
            AND    UT1.DATA_FINE_ATTIVITA             IS NULL
            AND    CO1.ID_UTE                             = UT1.ID_UTE
            AND    CO1.DATA_FINE_CONDUZIONE         IS NULL
            AND    CO1.ID_TITOLO_POSSESSO                 = 5);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            nPratoTmp2 := 0;
    END;


    IF nPratoTmp1 + nPratoTmp2 > 0 THEN
        vFlagPrato := 'S';
    END IF;

    IF pTotTmp1<>0 THEN
        IF pTotTmp2 / pTotTmp1 * 100 >= 25  THEN
            vFlagZvn := 'S';
        END IF;
    ELSE
        vFlagZvn := 'S';
    END IF;


    IF vFlagPalabile = 'S' THEN
        IF NIdSpecieAnimale =  7 THEN --'Avicoli'
            IF vFlagZvn = 'S' THEN
                IF nCountAllAvicoli > 0 THEN
                    pTotGg := 120;
                ELSE
                    pTotGg := 90;
                END IF;
            ELSE
                pTotGg := 90;
            END IF;
        ELSE
            pTotGg := 90;
        END IF;
    ELSE
        IF nIdZonaAltimetrica = knIdTipoZonaAltMontagna OR
           nTotAzoto < pMaxAzoto THEN
           pTotGg := 90; -- assegno 90 giorni di stocaggio
        ELSE
            -- altrimenti effettuo il calcolo in base alla tipologia di effluente e di specie
            IF pIdEffluente IN (17,18,41,43) THEN        -- BM003
                pTotGg := 90;
            ELSE
                IF nIdSpecieAnimale IN (1,13,5,6,3) THEN --('Bovini allevamento','Bufali','Ovini','Caprini','Equini')
                    IF vFlagZvn = 'S' THEN
                        IF vFlagPrato = 'S' THEN
                            pTotGg := 120;
                        ELSE
                            pTotGg := 180;
                        END IF;
                    ELSE
                        IF vFlagPrato = 'S' THEN
                            pTotGg := 90;
                        ELSE
                            pTotGg := 120;
                        END IF;
                    END IF;
                ELSIF nIdSpecieAnimale IN (2,4,8,7) THEN  --('Bovini carne','Suini','Conigli','Avicoli')
                    IF vFlagZvn = 'S' THEN
                        pTotGg := 180;
                    ELSE
                        pTotGg := 120;
                    END IF;
                ELSE
                    pTotGg := 90;
                END IF;
            END IF;
        END IF;
    END IF;

EXCEPTION
    WHEN EXC_ERR THEN
        pCodErr        := '1';
    WHEN EXC_PARAMETRO_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRO INPUT NULL';
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);
END CALCOLA_GIORNI_STOC_NECESSARI;


------------------------------------------------------------------
PROCEDURE TROVA_CES_ACQ_10R (pIdUte                IN DB_COMUNICAZIONE_10R.ID_UTE%TYPE,
                             pIdComunicazione        IN NUMBER,
                             pCausaleEffluente        IN NUMBER,
                             pIdEffluente            IN NUMBER,
                             pQuantitaIn                IN NUMBER,
                             pQuantitaOut            OUT NUMBER,
                             pCodErr                    OUT VARCHAR2,
                             pDesErr                    OUT VARCHAR2) IS


nVolumeProdotto        NUMBER;
nVolumeProdottoAz        NUMBER;
nAzotoProdotto            NUMBER;
nAzotoProdottoAz        NUMBER;
nSuperficeScoperta    NUMBER;
nTotMungitura            NUMBER;
nCoeffAzoto                NUMBER;
EXC_PARAMETRO_NULL     EXCEPTION;
EXC_ERR                     EXCEPTION;

/* Calcola l'azoto ceduto o acquisito in relazione al volume dichiarato dall'utente */

BEGIN

    pQuantitaOut:=0;

    IF pIdComunicazione IS NULL OR pCausaleEffluente IS NULL OR pIdEffluente IS NULL OR pQuantitaIn    IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;

    SELECT COEFF_AZOTO INTO nCoeffAzoto FROM DB_TIPO_EFFLUENTE WHERE ID_EFFLUENTE = pIdEffluente;

    -- Cessione
    IF pCausaleEffluente = 1 THEN
        CALCOLA_EFFLUENTI_M3 (    pIdUte,NULL,'N',pIdEffluente,nVolumeProdotto,nVolumeProdottoAz,nAzotoProdotto,nAzotoProdottoAz,pCodErr,pDesErr);

        IF pCodErr = 1 THEN
            pDesErr :=     'procedura CALCOLA_EFFLUENTI_M3 '||pDesErr;
            RAISE EXC_ERR;
        END IF;

        IF nVolumeProdotto <> 0 THEN
           pQuantitaOut:= ROUND((pQuantitaIn * (nAzotoProdotto / (nVolumeProdotto))),1);
        ELSE
           pQuantitaOut := 0;
        END IF;

    ELSIF  pCausaleEffluente = 2 THEN   -- Acquisizione
        pQuantitaOut :=  pQuantitaIn * nCoeffAzoto * 10;
    END IF;
EXCEPTION
    WHEN EXC_ERR THEN
        pCodErr        := '1';
    WHEN EXC_PARAMETRO_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRO INPUT NULL';
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);

END TROVA_CES_ACQ_10R;


------------------------------------------------------------------
PROCEDURE TROVA_AZOTO_CES_ACQ_10R (     pIdComunicazione        IN NUMBER,
                                                    pFlagPalabile            IN VARCHAR2 DEFAULT NULL,
                                                    pCausaleEffluente        IN NUMBER,
                                                    pIdEffluente            IN NUMBER DEFAULT NULL,
--                                                      pQuantitaAzoto            OUT NUMBER,    -- BM001
                                                      pQuantitaAzotoDic        OUT NUMBER,    -- BM001
                                                      pCodErr                    OUT VARCHAR2,
                                                      pDesErr                    OUT VARCHAR2) IS

EXC_PARAMETRO_NULL EXCEPTION;
EXC_PARAMETRO_NOT_NULL    EXCEPTION;
BEGIN

    IF pIdComunicazione IS NULL OR pCausaleEffluente IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;

    IF pFlagPalabile IS NULL AND pIdEffluente IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;

    IF pFlagPalabile IS NOT NULL AND pIdEffluente IS NOT NULL THEN
        RAISE EXC_PARAMETRO_NOT_NULL;
    END IF;

    BEGIN
--        SELECT NVL(SUM(NVL(QUANTITA_AZOTO,0)),0)                    --    BM001
        SELECT NVL(SUM(NVL(QUANTITA_AZOTO_DICHIARATO,0)),0)     --    BM001
        INTO pQuantitaAzotoDic
        FROM  DB_EFFLUENTE_CES_ACQ_10R EF,
                DB_TIPO_EFFLUENTE        TI
        WHERE EF.ID_COMUNICAZIONE_10R        = pIdComunicazione
        AND    EF.ID_CAUSALE_EFFLUENTE        = pCausaleEffluente
        AND    TI.ID_EFFLUENTE                 = EF.ID_EFFLUENTE
        AND    TI.FLAG_PALABILE                = NVL(pFlagPalabile,TI.FLAG_PALABILE)
        AND    TI.DATA_FINE_VALIDITA         IS NULL
        AND    EF.ID_EFFLUENTE                = NVL(pIdEffluente,EF.ID_EFFLUENTE);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            pQuantitaAzotoDic    :=    0;
    END;


EXCEPTION
    WHEN EXC_PARAMETRO_NOT_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRI INPUT INCONGRUENTI FRA LORO';
    WHEN EXC_PARAMETRO_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRO INPUT NULL';
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);

END TROVA_AZOTO_CES_ACQ_10R;


PROCEDURE RICALCOLA (    --pIdAzienda                 IN NUMBER,
                                pIdUte                    IN NUMBER,
                                pIdUtente                IN NUMBER,
                                pOutIdComunicazione        OUT NUMBER,
                                  pCodErr                    OUT VARCHAR2,
                                  pDesErr                    OUT VARCHAR2) IS


 CURSOR CUR_EFFLU (pIdComu IN DB_EFFLUENTE_10R.ID_COMUNICAZIONE_10R%TYPE) IS
 SELECT EF.ID_EFFLUENTE ID_EFFLUENTE,
        TI.FLAG_PALABILE    FLAG_PALABILE, 'N' AS TRATTAMENTO,
        NVL(SUM(VOLUME_PRODOTTO),0) TOT_VOLUME,
        NVL(SUM(AZOTO_PRODOTTO),0) TOT_AZOTO
    FROM  DB_UTE UT,
            DB_ALLEVAMENTO AL,
            DB_CATEGORIE_ALLEVAMENTO CA,
            DB_SOTTOCATEGORIA_ALLEVAMENTO SO,
            DB_STABULAZIONE_TRATTAMENTO   ST,
            DB_EFFLUENTE_PRODOTTO   EF,
            DB_TIPO_EFFLUENTE         TI
    WHERE UT.ID_UTE = pIdUte --UT.ID_AZIENDA = pIdAzienda
    --                                                AND    UT.DATA_FINE_ATTIVITA                 IS NULL
    AND    AL.DATA_FINE                             IS NULL
    AND    AL.ID_UTE                                 = UT.ID_UTE
    AND    CA.ID_ALLEVAMENTO                     = AL.ID_ALLEVAMENTO
    AND    SO.ID_CATEGORIE_ALLEVAMENTO        = CA.ID_CATEGORIE_ALLEVAMENTO
    AND    ST.ID_SOTTOCATEGORIA_ALLEVAMENTO = SO.ID_SOTTOCATEGORIA_ALLEVAMENTO
    AND    EF.ID_STABULAZIONE_TRATTAMENTO    = ST.ID_STABULAZIONE_TRATTAMENTO
    AND    TI.ID_EFFLUENTE                        = EF.ID_EFFLUENTE
    AND    TI.DATA_FINE_VALIDITA                IS NULL
    AND    EF.FLAG_TRATTAMENTO                    = 'N'
GROUP BY EF.ID_EFFLUENTE, TI.FLAG_PALABILE


        -- BM003
    /*
    AND NOT EXISTS (SELECT E10R.ID_EFFLUENTE_10R
                      FROM DB_EFFLUENTE_10R  E10R
                     WHERE E10R.ID_COMUNICAZIONE_10R = pIdComu
                       AND E10R.ID_EFFLUENTE_ORIGINE = EF.ID_EFFLUENTE
                       )*/

UNION ALL

SELECT DISTINCT E10R.ID_EFFLUENTE, TE.FLAG_PALABILE, 'S' AS TRATTAMENTO,
       NULL AS TOT_VOLUME, NULL AS TOT_AZOTO
  FROM DB_EFFLUENTE_10R E10R,
       DB_TIPO_EFFLUENTE TE
 WHERE E10R.ID_COMUNICAZIONE_10R = pIdComu
   AND E10R.ID_EFFLUENTE = TE.ID_EFFLUENTE
   AND E10R.ID_TRATTAMENTO IS NOT NULL;

/* MS 30/09/2014
il cursore escludeva dagli effluenti acquisiti tutti gli effluenti
con ID_EFFLUETNE gia' presente su DB_EFFLUENTE_10R
ora invece esclude solo quelli delle tipologie
passate in input */

CURSOR C_EFF_ACQUISITI (nIdComunicazione IN NUMBER,
                        pVetEffluenti    IN VARCHAR2) IS
        WITH EFFLUENTI_CONCATENATI AS
           ( SELECT pVetEffluenti AS EfflConc,
                    LEVEL AS pos,
                    SUBSTR(pVetEffluenti,ROWNUM,1) AS CH,
                    COUNT(CASE WHEN SUBSTR(pVetEffluenti,ROWNUM,1) = ',' THEN '#' END)
                    OVER (ORDER BY LEVEL) AS section
               FROM dual
         CONNECT BY LEVEL <= LENGTH(pVetEffluenti)),
             EFFLUENTI AS
           ( SELECT SUBSTR(EfflConc,MIN(pos), 1 + MAX(pos) - MIN(pos)) AS EFFLUENTE
               FROM EFFLUENTI_CONCATENATI
              WHERE CH <> ','
           GROUP BY EfflConc,section )
        SELECT ACQ.ID_EFFLUENTE,
                    SUM(ACQ.QUANTITA) QUANTITA,
--                    SUM(ACQ.QUANTITA_AZOTO) QUANTITA_AZOTO,
                    SUM(ACQ.QUANTITA_AZOTO_DICHIARATO) QUANTITA_AZOTO_DICHIARATO,
                    SUM(DECODE(FLAG_STOCCAGGIO,'S',ACQ.QUANTITA,0)) QUANTITA_STOC
        FROM DB_EFFLUENTE_CES_ACQ_10R ACQ
        WHERE   ACQ.ID_COMUNICAZIONE_10R=nIdComunicazione AND
                ACQ.ID_CAUSALE_EFFLUENTE = 2  AND
                ACQ.ID_EFFLUENTE NOT IN (SELECT EFFLUENTE
                                           FROM EFFLUENTI) AND
                ACQ.ID_EFFLUENTE != 19
        GROUP BY ACQ.ID_EFFLUENTE ;



CURSOR C_RICALCOLO_AZOTO(nIdComunicazione IN NUMBER) IS
            SELECT ID_EFFLUENTE_CES_ACQ_10R, ID_EFFLUENTE, ID_CAUSALE_EFFLUENTE, QUANTITA
            FROM DB_EFFLUENTE_CES_ACQ_10R
            WHERE ID_COMUNICAZIONE_10R = nIdComunicazione
            AND    ID_CAUSALE_EFFLUENTE = 1;


CURSOR C_AGGIORNAMENTO_AZOTO(nIdComunicazione IN NUMBER) IS
            SELECT ID_EFFLUENTE,ID_EFFLUENTE_10R
            FROM DB_EFFLUENTE_10R
            WHERE ID_COMUNICAZIONE_10R=nIdComunicazione;



EXC_PARAMETRO_NULL                 EXCEPTION;
EXC_ERR                                 EXCEPTION;
RecComunicazione10r                 DB_COMUNICAZIONE_10R%ROWTYPE;
dDataDich                            DATE;
dDay                                    DATE;
nNewIdCom                            DB_COMUNICAZIONE_10R.ID_COMUNICAZIONE_10R%TYPE;

-- calcoli
nSuperficieConduzioneZvn          DB_COMUNICAZIONE_10R.SUPERFICIE_CONDUZIONE_ZVN%TYPE;
nSuperficieAsservimentoZvn      DB_COMUNICAZIONE_10R.SUPERFICIE_ASSERVIMENTO_ZVN%TYPE;
nSuperficieConduzioneNoZvn      DB_COMUNICAZIONE_10R.SUPERFICIE_CONDUZIONE_NO_ZVN%TYPE;
nSuperficieAsservimentoNoZvn    DB_COMUNICAZIONE_10R.SUPERFICIE_ASSERVIMENTO_NO_ZVN %TYPE;
nAzotoConduzioneZvn              DB_COMUNICAZIONE_10R.AZOTO_CONDUZIONE_ZVN%TYPE;
nAzotoConduzioneNoZvn              DB_COMUNICAZIONE_10R.AZOTO_CONDUZIONE_NO_ZVN%TYPE;
nAzotoAsservimentoZvn              DB_COMUNICAZIONE_10R.AZOTO_ASSERVIMENTO_ZVN%TYPE;
nAzotoAsservimentoNoZvn          DB_COMUNICAZIONE_10R.AZOTO_ASSERVIMENTO_NO_ZVN%TYPE;
nTotaleAzotoAziendale              DB_COMUNICAZIONE_10R.TOTALE_AZOTO_AZIENDALE%TYPE;
nStocNettoPalabile              DB_COMUNICAZIONE_10R.STOC_NETTO_PALABILE%TYPE;
nStocNettoNonpalabile              DB_COMUNICAZIONE_10R.STOC_NETTO_NONPALABILE%TYPE;
nStocDispPalabileVol              DB_COMUNICAZIONE_10R.STOC_DISP_PALABILE_VOL%TYPE;
nStocDispNonpalabileVol          DB_COMUNICAZIONE_10R.STOC_DISP_NONPALABILE_VOL%TYPE;

nSuperficeScopertaTmp              DB_COMUNICAZIONE_10R.VOLUME_PIOGGE%TYPE;
nTotMungituraTmp                   DB_COMUNICAZIONE_10R.ACQUE_LAVAGGIO%TYPE;
nTotAzoto                        DB_COMUNICAZIONE_10R.TOTALE_AZOTO%TYPE;         --BM003

n10RA                            NUMBER;
n10RB                            NUMBER;
n10RC                            NUMBER;
n10RD                            NUMBER;

nVolumeProdottoTmp1                NUMBER;
nVolumeProdottoAzTmp1            NUMBER;
nAzotoProdottoTmp1                NUMBER;
nAzotoProdottoAzTmp1            NUMBER;

nVolumeProdottoTmp2                NUMBER;
nVolumeProdottoAzTmp2            NUMBER;
nAzotoProdottoTmp2                NUMBER;
nAzotoProdottoAzTmp2            NUMBER;

nStockAcqAzTmp                    NUMBER;
nStockAcqAzStoTmp                NUMBER;
nUtileFabStockTmp                NUMBER;
nTotLettieraTmp                    NUMBER;
nStockExtraAzTmp                NUMBER;

nQuaOut                            NUMBER;
---------------------------------------------
nVolumeRefluoExtra                DB_ACQUA_EXTRA_10R.VOLUME_REFLUO%TYPE;

nVolumeIniziale                 DB_EFFLUENTE_10R.VOLUME_INIZIALE%TYPE;
nVolumeInizialeCon                DB_EFFLUENTE_10R.VOLUME_INIZIALE_CON%TYPE;            --BM003
nAzotoIniziale                     DB_EFFLUENTE_10R.AZOTO_INIZIALE%TYPE;
nAzotoInizialeDec                DB_EFFLUENTE_10R.AZOTO_INIZIALE_DEC%TYPE;                --BM003
nVolumePostTrattamento             DB_EFFLUENTE_10R.VOLUME_POST_TRATTAMENTO%TYPE;
nVolumePostTrattamentoCon        DB_EFFLUENTE_10R.VOLUME_POST_TRATTAMENTO_CON%TYPE;    --BM003
nAzotoPostTrattamento             DB_EFFLUENTE_10R.AZOTO_POST_TRATTAMENTO%TYPE;
nAzotoPostTrattamentoDec        DB_EFFLUENTE_10R.AZOTO_POST_TRATTAMENTO_DEC%TYPE;    --BM003
nVolumeCessione                 DB_EFFLUENTE_10R.VOLUME_CESSIONE%TYPE;
nAzotoCessione                  DB_EFFLUENTE_10R.AZOTO_CESSIONE%TYPE;
nVolumeAcquisizione             DB_EFFLUENTE_10R.VOLUME_ACQUISIZIONE%TYPE;
nAzotoAcquisizione                 DB_EFFLUENTE_10R.AZOTO_ACQUISIZIONE%TYPE;
nVolumePostDichiarato             DB_EFFLUENTE_10R.VOLUME_POST_DICHIARATO%TYPE;
nAzotoPostDichiarato             DB_EFFLUENTE_10R.AZOTO_POST_DICHIARATO%TYPE;
nGgStocDisponibile                 DB_EFFLUENTE_10R.STOC_DISPONIBILE_GG%TYPE;
nStocNecessarioVol                 DB_EFFLUENTE_10R.STOC_NECESSARIO_VOL%TYPE;
nTotGgNec                         DB_EFFLUENTE_10R.STOC_NECESSARIO_GG%TYPE;
nVolumeCessioneStok             DB_EFFLUENTE_10R.VOLUME_CESSIONE_STOCCATO%TYPE;
nVolumeAcquisizioneStok            DB_EFFLUENTE_10R.VOLUME_ACQUISIZIONE_STOCCATO%TYPE;

nQuantitaAzotoTmp                NUMBER;


nMinIdEffluente10R              DB_EFFLUENTE_10R.ID_EFFLUENTE_10R%TYPE;
nMaxIdEffluente10R              DB_EFFLUENTE_10R.ID_EFFLUENTE_10R%TYPE;


nStocAcqueNettoCessione            DB_COMUNICAZIONE_10R.STOC_ACQUE_NETTO_CESSIONE%TYPE;
nStocAcqueNecGg                    DB_COMUNICAZIONE_10R.STOC_ACQUE_NEC_GG%TYPE;
nStocAcqueNecVol                DB_COMUNICAZIONE_10R.STOC_ACQUE_NEC_VOL%TYPE;

nQuantitaAzotoAltreAcq            NUMBER;

nTotAcqEx                         NUMBER;
nContaDichiarato                 NUMBER;
bAggiornamento                     BOOLEAN;
recDAltroDato                   DB_ALTRI_DATI%ROWTYPE;
nTotSupSauPiemonte              DB_COMUNICAZIONE_10R.SUPERFICIE_SAU_PIEMONTE%TYPE;
nTotSupSauPiemonteZvn           DB_COMUNICAZIONE_10R.SUPERFICIE_SAU_PIEMONTE_ZVN%TYPE;
nTotAzotoEscreto                DB_COMUNICAZIONE_10R.AZOTO_ESCRETO_PASCOLO%TYPE;
nLimiteMinAzoto                 DB_ALTRI_DATI.VALORE_NUMERICO%TYPE;

nTotAzotoIniziale               DB_EFFLUENTE_10R.AZOTO_INIZIALE%TYPE;
nTotAzotoPostDichiarato         DB_EFFLUENTE_10R.AZOTO_POST_DICHIARATO%TYPE;
nTotAzotoCeduto                 DB_EFFLUENTE_10R.AZOTO_INIZIALE%TYPE;
nTotAzotoAcquisito              DB_EFFLUENTE_10R.AZOTO_INIZIALE%TYPE;


nNumEfflGenTrattamento          INTEGER;
-- bTuttoTrattato                  BOOLEAN:=FALSE;

nVolumeAcqEffluente             DB_EFFLUENTE_10R.VOLUME_ACQUISIZIONE%TYPE;
nAzotoAcqEffluente              DB_EFFLUENTE_10R.AZOTO_ACQUISIZIONE%TYPE;

nVolumeDaTrattareInsUtente      DB_EFFLUENTE_10R.VOLUME_INIZIALE%TYPE;
nAzotoDaTrattareInsUtente       DB_EFFLUENTE_10R.VOLUME_INIZIALE%TYPE;
vStrSql                         VARCHAR2(4000);


BEGIN

    IF pIdUte IS NULL OR pIdUtente IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;

    bAggiornamento             :=    FALSE;
    nMinIdEffluente10R      := 0;
    nMaxIdEffluente10R      := 0;

    RecComunicazione10r := NULL;
    dDay := SYSDATE;

    -- le superfici non in zvn invece hanno un solo coefficiente che vale sia
    -- in caso di deroga che non
    recDAltroDato := SelDAltroDatoByCodice (kvCdAlDtCoefRctMaxAzotoNoZvnSA);
    IF recDAltroDato.ID_ALTRI_DATI IS NOT NULL THEN
       n10RB := recDAltroDato.VALORE_NUMERICO;
    ELSE
       pDesErr := 'Altro dato con codice : ' || kvCdAlDtCoefRctMaxAzotoNoZvnSA || ' non presente';
       RAISE EXC_ERR;
    END IF;

/* MS 07/07/2014 commentato doppione
    recDAltroDato := SelDAltroDatoByCodice (kvCdAlDtCoefRctMaxAzotoNoZvnSC);
    IF recDAltroDato.ID_ALTRI_DATI IS NOT NULL THEN
       n10RD := recDAltroDato.VALORE_NUMERICO;
    ELSE
       pDesErr := 'Altro dato con codice : ' || kvCdAlDtCoefRctMaxAzotoNoZvnSC || ' non presente';
       RAISE EXC_ERR;
    END IF;
*/
    recDAltroDato := SelDAltroDatoByCodice (kvCdAlDtCoefRctMaxAzotoNoZvnSC);
    IF recDAltroDato.ID_ALTRI_DATI IS NOT NULL THEN
       n10RD := recDAltroDato.VALORE_NUMERICO;
    ELSE
       pDesErr := 'Altro dato con codice : ' || kvCdAlDtCoefRctMaxAzotoNoZvnSC || ' non presente';
       RAISE EXC_ERR;
    END IF;

    recDAltroDato := SelDAltroDatoByCodice (kvCdAlDtMinAzotoForCalcGGStoc);
    IF recDAltroDato.ID_ALTRI_DATI IS NOT NULL THEN
       nLimiteMinAzoto := recDAltroDato.VALORE_NUMERICO;
    ELSE
       pDesErr := 'Altro dato con codice : ' || kvCdAlDtMinAzotoForCalcGGStoc || ' non presente';
       RAISE EXC_ERR;
    END IF;

    BEGIN
        SELECT * INTO RecComunicazione10r FROM DB_COMUNICAZIONE_10R WHERE ID_UTE  = pIdUte AND DATA_FINE_VALIDITA IS NULL;
        -- se non siamo in caso di adesione con deroga
        IF NVL(RecComunicazione10r.ADESIONE_DEROGA,'N') = 'N' THEN
           -- prelevo il coefficiente per il calcolo della superficie agronomica in ZVN
           -- dall'altro dato con costante 10RA attivo alla sysdate
           recDAltroDato := SelDAltroDatoByCodice (kvCdAlDtCoefRctMaxAzotoZvnSA);
           IF recDAltroDato.ID_ALTRI_DATI IS NOT NULL THEN
              n10RA := recDAltroDato.VALORE_NUMERICO;
           ELSE
              -- se non lo trovo do apposita segnalazione
              pDesErr := 'Altro dato con codice : ' || kvCdAlDtCoefRctMaxAzotoZvnSA || ' non presente';
              RAISE EXC_ERR;
           END IF;

           recDAltroDato := SelDAltroDatoByCodice (kvCdAlDtCoefRctMaxAzotoZvnSC);
           IF recDAltroDato.ID_ALTRI_DATI IS NOT NULL THEN
              n10RC := recDAltroDato.VALORE_NUMERICO;
           ELSE
              pDesErr := 'Altro dato con codice : ' || kvCdAlDtCoefRctMaxAzotoZvnSC || ' non presente';
              RAISE EXC_ERR;
           END IF;

        ELSE
           -- se son in caso di adesione con deroga
           recDAltroDato := SelDAltroDatoByCodice (kvCdAlDtCoefRctMaxAzotoZvnSAD);
           -- prelevo il coefficiente per il calcolo della superficie agronomica in ZVN
           -- dall'altro dato con costante 10RE attivo alla sysdate
           IF recDAltroDato.ID_ALTRI_DATI IS NOT NULL THEN
              n10RA := recDAltroDato.VALORE_NUMERICO;
           ELSE
              pDesErr := 'Altro dato con codice : ' || kvCdAlDtCoefRctMaxAzotoZvnSAD || ' non presente';
              RAISE EXC_ERR;
           END IF;

           -- idem dicasi per la superficie condotta in asservimento in ZVN
           recDAltroDato := SelDAltroDatoByCodice (kvCdAlDtCoefRctMaxAzotoZvnSCD);
           IF recDAltroDato.ID_ALTRI_DATI IS NOT NULL THEN
              n10RC := recDAltroDato.VALORE_NUMERICO;
           ELSE
              pDesErr := 'Altro dato con codice : ' || kvCdAlDtCoefRctMaxAzotoZvnSCD || ' non presente';
              RAISE EXC_ERR;
           END IF;
        END IF;

        SELECT NVL(MAX(CONS.DATA_INSERIMENTO_DICHIARAZIONE),SYSDATE-(365*100)) INTO dDataDich
        FROM     DB_DICHIARAZIONE_CONSISTENZA CONS,
                DB_UTE UT
        WHERE UT.ID_UTE  = pIdUte
        AND    CONS.ID_AZIENDA    = UT.ID_AZIENDA;


        IF  RecComunicazione10r.DATA_INIZIO_VALIDITA > dDataDich THEN
            bAggiornamento := TRUE;
            UPDATE DB_COMUNICAZIONE_10R SET ID_UTENTE_AGGIORNAMENTO = pIdUtente, DATA_RICALCOLO = dDay WHERE ID_COMUNICAZIONE_10R = RecComunicazione10r.ID_COMUNICAZIONE_10R;
            nNewIdCom := RecComunicazione10r.ID_COMUNICAZIONE_10R;

        ELSE

            UPDATE DB_COMUNICAZIONE_10R SET DATA_FINE_VALIDITA = dDay WHERE ID_COMUNICAZIONE_10R = RecComunicazione10r.ID_COMUNICAZIONE_10R;

            SELECT SEQ_COMUNICAZIONE_10R.NEXTVAL INTO nNewIdCom FROM DUAL;
            INSERT INTO DB_COMUNICAZIONE_10R (    ID_COMUNICAZIONE_10R,             ID_UTENTE_AGGIORNAMENTO,     DATA_INIZIO_VALIDITA,     DATA_FINE_VALIDITA,     DATA_AGGIORNAMENTO,     DATA_RICALCOLO, VOLUME_SOTTOGRIGLIATO,                             VOLUME_REFLUO_AZIENDA,                                 NOTE,                                SUPERFICIE_CONDUZIONE_ZVN, SUPERFICIE_ASSERVIMENTO_ZVN,     SUPERFICIE_CONDUZIONE_NO_ZVN, SUPERFICIE_ASSERVIMENTO_NO_ZVN,     AZOTO_CONDUZIONE_ZVN,     AZOTO_ASSERVIMENTO_ZVN, AZOTO_CONDUZIONE_NO_ZVN,     AZOTO_ASSERVIMENTO_NO_ZVN, STOC_NETTO_PALABILE, STOC_NETTO_NONPALABILE, STOC_DISP_PALABILE_VOL, STOC_DISP_NONPALABILE_VOL,     TOTALE_AZOTO_AZIENDALE,    VOLUME_PIOGGE, ACQUE_LAVAGGIO,    ID_UTE, ADESIONE_DEROGA)
            VALUES                         (  nNewIdCom,                            pIdUtente,                        dDay,                             NULL,                        dDay,                        dDay,                 RecComunicazione10r.VOLUME_SOTTOGRIGLIATO,     RecComunicazione10r.VOLUME_REFLUO_AZIENDA,     RecComunicazione10r.NOTE,    0,                                    0,                                        0,                                        0,                                            0,                                0,                                0,                                    0,                                    0,                            0,                                0,                                0,                                        0,                                0,                    0,                        pIdUte, RecComunicazione10r.ADESIONE_DEROGA);

            INSERT INTO DB_EFFLUENTE_STOC_EXT_10R (ID_EFFLUENTE_STOC_EXT_10R, ID_COMUNICAZIONE_10R, ID_AZIENDA, CUAA, DENOMINAZIONE, ISTAT_COMUNE, ID_TIPOLOGIA_FABBRICATO, QUANTITA)
            SELECT SEQ_EFFLUENTE_STOC_EXT_10R.NEXTVAL,  nNewIdCom,ID_AZIENDA, CUAA, DENOMINAZIONE, ISTAT_COMUNE, ID_TIPOLOGIA_FABBRICATO, QUANTITA
              FROM DB_EFFLUENTE_STOC_EXT_10R
             WHERE ID_COMUNICAZIONE_10R = RecComunicazione10r.ID_COMUNICAZIONE_10R;

            INSERT INTO DB_EFFLUENTE_CES_ACQ_10R (ID_EFFLUENTE_CES_ACQ_10R, ID_COMUNICAZIONE_10R, ID_AZIENDA, CUAA, ISTAT_COMUNE, DENOMINAZIONE, ID_EFFLUENTE, ID_CAUSALE_EFFLUENTE, QUANTITA, QUANTITA_AZOTO)
            SELECT  SEQ_EFFLUENTE_CES_ACQ_10R.NEXTVAL,     nNewIdCom,    ID_AZIENDA, CUAA, ISTAT_COMUNE, DENOMINAZIONE, ID_EFFLUENTE, ID_CAUSALE_EFFLUENTE, QUANTITA, QUANTITA_AZOTO
             FROM DB_EFFLUENTE_CES_ACQ_10R
            WHERE ID_COMUNICAZIONE_10R = RecComunicazione10r.ID_COMUNICAZIONE_10R;

            -- ribaltare DB_EFFLUENTE_10R sulla nuova comunicazione
            -- solo gli effluenti con trattamento
            INSERT INTO DB_EFFLUENTE_10R (ID_EFFLUENTE_10R, ID_COMUNICAZIONE_10R, ID_EFFLUENTE, VOLUME_INIZIALE, AZOTO_INIZIALE, VOLUME_POST_TRATTAMENTO, AZOTO_POST_TRATTAMENTO, VOLUME_CESSIONE, AZOTO_CESSIONE, VOLUME_ACQUISIZIONE, AZOTO_ACQUISIZIONE, VOLUME_POST_DICHIARATO, AZOTO_POST_DICHIARATO, STOC_DISPONIBILE_GG, STOC_NECESSARIO_VOL, STOC_NECESSARIO_GG, VOLUME_CESSIONE_STOCCATO, VOLUME_ACQUISIZIONE_STOCCATO, VOLUME_INIZIALE_CON, AZOTO_INIZIALE_DEC, VOLUME_POST_TRATTAMENTO_CON, AZOTO_POST_TRATTAMENTO_DEC, ID_TRATTAMENTO, ID_EFFLUENTE_ORIGINE)
            SELECT SEQ_EFFLUENTE_10R.nextval, nNewIdCom, ID_EFFLUENTE, VOLUME_INIZIALE, AZOTO_INIZIALE, VOLUME_POST_TRATTAMENTO, AZOTO_POST_TRATTAMENTO, VOLUME_CESSIONE, AZOTO_CESSIONE, VOLUME_ACQUISIZIONE, AZOTO_ACQUISIZIONE, VOLUME_POST_DICHIARATO, AZOTO_POST_DICHIARATO, STOC_DISPONIBILE_GG, STOC_NECESSARIO_VOL, STOC_NECESSARIO_GG, VOLUME_CESSIONE_STOCCATO, VOLUME_ACQUISIZIONE_STOCCATO, VOLUME_INIZIALE_CON, AZOTO_INIZIALE_DEC, VOLUME_POST_TRATTAMENTO_CON, AZOTO_POST_TRATTAMENTO_DEC, ID_TRATTAMENTO, ID_EFFLUENTE_ORIGINE
              FROM DB_EFFLUENTE_10R
             WHERE ID_COMUNICAZIONE_10R = RecComunicazione10r.ID_COMUNICAZIONE_10R
               AND ID_TRATTAMENTO IS NOT NULL; 



        END IF;

        UPDATE DB_EFFLUENTE_STOC_EXT_10R EFS
           SET (EFS.CUAA, EFS.DENOMINAZIONE)  = (SELECT CUAA, DENOMINAZIONE
                                                   FROM DB_ANAGRAFICA_AZIENDA
                                                  WHERE ID_AZIENDA = EFS.ID_AZIENDA
                                                    AND DATA_FINE_VALIDITA IS NULL
                                                    AND DATA_CESSAZIONE IS NOT NULL),
               EFS.ID_AZIENDA = NULL
         WHERE EFS.ID_COMUNICAZIONE_10R = nNewIdCom
           AND EXISTS (SELECT ID_ANAGRAFICA_AZIENDA
                         FROM DB_ANAGRAFICA_AZIENDA
                        WHERE ID_AZIENDA = EFS.ID_AZIENDA
                          AND DATA_FINE_VALIDITA IS NULL
                          AND DATA_CESSAZIONE IS NOT NULL);


        UPDATE DB_EFFLUENTE_CES_ACQ_10R EFC
           SET (EFC.CUAA, EFC.DENOMINAZIONE)  = (SELECT CUAA, DENOMINAZIONE
                                                   FROM DB_ANAGRAFICA_AZIENDA
                                                  WHERE ID_AZIENDA = EFC.ID_AZIENDA
                                                    AND DATA_FINE_VALIDITA IS NULL
                                                    AND DATA_CESSAZIONE IS NOT NULL),
               EFC.ID_AZIENDA = NULL
         WHERE EFC.ID_COMUNICAZIONE_10R = nNewIdCom
           AND EXISTS (SELECT ID_ANAGRAFICA_AZIENDA
                         FROM DB_ANAGRAFICA_AZIENDA
                        WHERE ID_AZIENDA = EFC.ID_AZIENDA
                          AND DATA_FINE_VALIDITA IS NULL
                          AND DATA_CESSAZIONE IS NOT NULL);


    EXCEPTION
        WHEN NO_DATA_FOUND THEN

           -- prelevo il coefficiente per il calcolo della superficie agronomica in ZVN
           -- dall'altro dato con costante 10RA attivo alla sysdate
           recDAltroDato := SelDAltroDatoByCodice (kvCdAlDtCoefRctMaxAzotoZvnSA);
           IF recDAltroDato.ID_ALTRI_DATI IS NOT NULL THEN
              n10RA := recDAltroDato.VALORE_NUMERICO;
           ELSE
              -- se non lo trovo do apposita segnalazione
              pDesErr := 'Altro dato con codice : ' || kvCdAlDtCoefRctMaxAzotoZvnSA || ' non presente';
              RAISE EXC_ERR;
           END IF;

           recDAltroDato := SelDAltroDatoByCodice (kvCdAlDtCoefRctMaxAzotoZvnSC);
           IF recDAltroDato.ID_ALTRI_DATI IS NOT NULL THEN
              n10RC := recDAltroDato.VALORE_NUMERICO;
           ELSE
              pDesErr := 'Altro dato con codice : ' || kvCdAlDtCoefRctMaxAzotoZvnSC || ' non presente';
              RAISE EXC_ERR;
           END IF;


            SELECT SEQ_COMUNICAZIONE_10R.NEXTVAL INTO nNewIdCom FROM DUAL;

            INSERT INTO DB_COMUNICAZIONE_10R (    ID_COMUNICAZIONE_10R,             ID_UTENTE_AGGIORNAMENTO,     DATA_INIZIO_VALIDITA,     DATA_FINE_VALIDITA,     DATA_AGGIORNAMENTO,     DATA_RICALCOLO, VOLUME_SOTTOGRIGLIATO,                             VOLUME_REFLUO_AZIENDA,                                 NOTE,                                SUPERFICIE_CONDUZIONE_ZVN, SUPERFICIE_ASSERVIMENTO_ZVN,     SUPERFICIE_CONDUZIONE_NO_ZVN, SUPERFICIE_ASSERVIMENTO_NO_ZVN,     AZOTO_CONDUZIONE_ZVN,     AZOTO_ASSERVIMENTO_ZVN, AZOTO_CONDUZIONE_NO_ZVN,     AZOTO_ASSERVIMENTO_NO_ZVN, STOC_NETTO_PALABILE, STOC_NETTO_NONPALABILE, STOC_DISP_PALABILE_VOL, STOC_DISP_NONPALABILE_VOL,     TOTALE_AZOTO_AZIENDALE,    VOLUME_PIOGGE, ACQUE_LAVAGGIO,    ID_UTE)
            VALUES                                     (  nNewIdCom,                            pIdUtente,                        dDay,                             NULL,                        dDay,                        dDay,                 RecComunicazione10r.VOLUME_SOTTOGRIGLIATO,     RecComunicazione10r.VOLUME_REFLUO_AZIENDA,     RecComunicazione10r.NOTE,    0,                                    0,                                        0,                                        0,                                            0,                                0,                                0,                                    0,                                    0,                            0,                                0,                                0,                                        0,                                0,                    0,                        pIdUte);

    END;

    -- calcoli:
    CALCOLA_SUPERFICI_AGRONOMICA (pIdUte,nSuperficieConduzioneZvn,nSuperficieConduzioneNoZvn,pCodErr,pDesErr);
    CALCOLA_SUPERFICI_CONDOTTA (pIdUte,nSuperficieAsservimentoZvn,nSuperficieAsservimentoNoZvn,pCodErr,pDesErr);

    nAzotoConduzioneZvn        := nSuperficieConduzioneZvn * n10RA;
    nAzotoConduzioneNoZvn    := nSuperficieConduzioneNoZvn * n10RB;
    nAzotoAsservimentoZvn    := nSuperficieAsservimentoZvn * n10RC;
    nAzotoAsservimentoNoZvn    := nSuperficieAsservimentoNoZvn * n10RD;


    CALCOLA_EFFLUENTI_M3 (    pIdUte,'S','N',NULL,nVolumeProdottoTmp1,nVolumeProdottoAzTmp1,nAzotoProdottoTmp1,nAzotoProdottoAzTmp1,pCodErr,pDesErr);
    IF pCodErr = '1' THEN
        pDesErr :=     'procedura CALCOLA_EFFLUENTI_M3 '||pDesErr;
        RAISE EXC_ERR;
    END IF;
    CALCOLA_EFFLUENTI_M3 (    pIdUte,'N','N',NULL,nVolumeProdottoTmp2,nVolumeProdottoAzTmp2,nAzotoProdottoTmp2,nAzotoProdottoAzTmp2,pCodErr,pDesErr);
    IF pCodErr = '1' THEN
        pDesErr :=     'procedura CALCOLA_EFFLUENTI_M3 '||pDesErr;
        RAISE EXC_ERR;
    END IF;

    nTotAzoto:=    nAzotoProdottoTmp1    +    nAzotoProdottoTmp2;         --BM003
    nTotaleAzotoAziendale    := nAzotoProdottoAzTmp1 +  nAzotoProdottoAzTmp2;

    -- sommo l'azoto iniziale e l'azoto post dichiarato della comunicazione
    -- che ora e' gia' popolato dall'applicativo
    -- e finisco il calcolo del totale azoto
    SELECT NVL(SUM(AZOTO_POST_DICHIARATO),0)
      INTO nTotAzotoPostDichiarato
      FROM DB_EFFLUENTE_10R EF10R
     WHERE EF10R.ID_COMUNICAZIONE_10R = nNewIdCom
       AND EF10R.ID_TRATTAMENTO IS NOT NULL;

    -- azoto iniziale aziendale
    SELECT NVL(SUM(AZOTO_INIZIALE),0)
      INTO nTotAzotoIniziale
      FROM (
    SELECT EF10R.ID_EFFLUENTE_ORIGINE,
           MAX(EF10R.AZOTO_INIZIALE) AS AZOTO_INIZIALE
      FROM DB_EFFLUENTE_10R EF10R
     WHERE EF10R.ID_COMUNICAZIONE_10R = nNewIdCom
       AND EF10R.ID_TRATTAMENTO IS NOT NULL
  GROUP BY EF10R.ID_EFFLUENTE_ORIGINE);


    nTotAzoto := nTotAzoto - nTotAzotoIniziale + nTotAzotoPostDichiarato;
    nTotaleAzotoAziendale := nTotaleAzotoAziendale - nTotAzotoIniziale + nTotAzotoPostDichiarato;

    -- seleziono il totale di azoto
    -- acquisito e ceduto dalla comunicazione 10R
    SELECT NVL(SUM(DECODE(ID_CAUSALE_EFFLUENTE,1,QUANTITA_AZOTO_DICHIARATO,0)),0),
           NVL(SUM(DECODE(ID_CAUSALE_EFFLUENTE,2,QUANTITA_AZOTO_DICHIARATO,0)),0)
      INTO nTotAzotoCeduto,
           nTotAzotoAcquisito
      FROM DB_EFFLUENTE_CES_ACQ_10R EF
     WHERE EF.ID_COMUNICAZIONE_10R = nNewIdCom;

    -- sottraggo al totale di azoto quello che ho ceduto
    nTotAzoto := nTotAzoto - nTotAzotoCeduto;

    -- sommo al totale di azoto quello che ho acquisito
    nTotAzoto := nTotAzoto + nTotAzotoAcquisito;



    CALCOLA_CES_ACQUISIZIONE     ( nNewIdCom,'S',1,NULL,nStockAcqAzTmp,nStockAcqAzStoTmp,pCodErr,pDesErr);
    IF pCodErr = '1' THEN
        pDesErr :=     'procedura CALCOLA_CES_ACQUISIZIONE '||pDesErr;
        RAISE EXC_ERR;
    END IF;

--    nStocNettoPalabile        := nVolumeProdottoTmp1 - nStockAcqAzTmp;
    nStocNettoPalabile        := nVolumeProdottoTmp1 - nStockAcqAzStoTmp;

    CALCOLA_CES_ACQUISIZIONE     ( nNewIdCom,'S',2,NULL,nStockAcqAzTmp,nStockAcqAzStoTmp,pCodErr,pDesErr);
    IF pCodErr = '1' THEN
        pDesErr :=     'procedura CALCOLA_CES_ACQUISIZIONE '||pDesErr;
        RAISE EXC_ERR;
    END IF;

    nStocNettoPalabile        := nStocNettoPalabile + nStockAcqAzStoTmp;

    CALCOLA_VOLUME_PIOGGIE_M3 (     pIdUte,nSuperficeScopertaTmp,pCodErr,pDesErr);
    IF pCodErr = '1' THEN
        pDesErr :=     'procedura CALCOLA_VOLUME_PIOGGIE_M3 '||pDesErr;
        RAISE EXC_ERR;
    END IF;

    CALCOLA_ACQUE_MUNGITURA (    pIdUte,nTotMungituraTmp,pCodErr,pDesErr);
    IF pCodErr = '1' THEN
        pDesErr :=     'procedura CALCOLA_ACQUE_MUNGITURA '||pDesErr;
        RAISE EXC_ERR;
    END IF;

    CALCOLA_CES_ACQUISIZIONE     (    nNewIdCom,'N',1,NULL,nStockAcqAzTmp,nStockAcqAzStoTmp,pCodErr,pDesErr);
    IF pCodErr = '1' THEN
        pDesErr :=     'procedura CALCOLA_CES_ACQUISIZIONE '||pDesErr;
        RAISE EXC_ERR;
    END IF;

    BEGIN
        SELECT NVL(SUM(NVL(ACQ.VOLUME_REFLUO,0)),0)
        INTO nVolumeRefluoExtra
        FROM DB_COMUNICAZIONE_10R  COM,
              DB_ACQUA_EXTRA_10R        ACQ
        WHERE COM.ID_COMUNICAZIONE_10R     =    RecComunicazione10r.ID_COMUNICAZIONE_10R
        AND    ACQ.ID_COMUNICAZIONE_10R    =    COM.ID_COMUNICAZIONE_10R;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            nVolumeRefluoExtra := 0;
    END;

--    nStocNettoNonpalabile    := nVolumeProdottoTmp2 + nSuperficeScopertaTmp + nTotMungituraTmp + NVL(RecComunicazione10r.VOLUME_REFLUO_AZIENDA,0) + NVL(nVolumeRefluoExtra,0) - nStockAcqAzTmp;
    nStocNettoNonpalabile    := nVolumeProdottoTmp2 + nSuperficeScopertaTmp + nTotMungituraTmp + NVL(RecComunicazione10r.VOLUME_REFLUO_AZIENDA,0) + NVL(nVolumeRefluoExtra,0) - nStockAcqAzStoTmp;

    CALCOLA_CES_ACQUISIZIONE     (    nNewIdCom,'N',2,NULL,nStockAcqAzTmp,nStockAcqAzStoTmp,pCodErr,pDesErr);
    IF pCodErr = '1' THEN
        pDesErr :=     'procedura CALCOLA_CES_ACQUISIZIONE '||pDesErr;
        RAISE EXC_ERR;
    END IF;

    nStocNettoNonpalabile := nStocNettoNonpalabile + nStockAcqAzStoTmp;

    CALCOLA_UTILE_FAB_STOCCAGGIO (     pIdUte,'S',nUtileFabStockTmp,pCodErr,pDesErr);
    IF pCodErr = '1' THEN
        pDesErr :=     'procedura CALCOLA_UTILE_FAB_STOCCAGGIO '||pDesErr;
        RAISE EXC_ERR;
    END IF;

     CALCOLA_LETTIERA_PERM_ALLEVAM (     pIdUte,nTotLettieraTmp,pCodErr,pDesErr);
    IF pCodErr = '1' THEN
        pDesErr :=     'procedura CALCOLA_LETTIERA_PERM_ALLEVAM '||pDesErr;
        RAISE EXC_ERR;
    END IF;

    CALCOLA_STOCCAGGIO_EXTRA_AZ (     nNewIdCom,'S',nStockExtraAzTmp,pCodErr,pDesErr);
    IF pCodErr = '1' THEN
        pDesErr :=     'procedura CALCOLA_STOCCAGGIO_EXTRA_AZ '||pDesErr;
        RAISE EXC_ERR;
    END IF;

    nStocDispPalabileVol := nUtileFabStockTmp + nTotLettieraTmp + nStockExtraAzTmp;

    CALCOLA_UTILE_FAB_STOCCAGGIO (     pIdUte,'N',nUtileFabStockTmp,pCodErr,pDesErr);
    IF pCodErr = '1' THEN
        pDesErr :=     'procedura CALCOLA_UTILE_FAB_STOCCAGGIO '||pDesErr;
        RAISE EXC_ERR;
    END IF;

    CALCOLA_STOCCAGGIO_EXTRA_AZ (     nNewIdCom,'N',nStockExtraAzTmp,pCodErr,pDesErr);
    IF pCodErr = '1' THEN
        pDesErr :=     'procedura CALCOLA_STOCCAGGIO_EXTRA_AZ '||pDesErr;
        RAISE EXC_ERR;
    END IF;

    nStocDispNonpalabileVol := nUtileFabStockTmp + NVL(RecComunicazione10r.VOLUME_SOTTOGRIGLIATO,0) + nStockExtraAzTmp;

    CALCOLA_SUPERF_SAU_BIS (NVL(RecComunicazione10r.ID_UTE,pIdUte),nTotSupSauPiemonte,pCodErr,pDesErr);

    IF pCodErr = '1' THEN
        pDesErr :=     'procedura CALCOLA_SUPERF_SAU_BIS - ID_UTE = ' || recComunicazione10r.ID_UTE  || ' - ' || pDesErr;
        RAISE EXC_ERR;
    END IF;

    CALCOLA_SUPERF_ZVN_SAU_BIS (NVL(RecComunicazione10r.ID_UTE,pIdUte),nTotSupSauPiemonteZvn,pCodErr,pDesErr);
    IF pCodErr = '1' THEN
        pDesErr :=     'procedura CALCOLA_SUPERF_ZVN_SAU_BIS - ID_UTE = ' || recComunicazione10r.ID_UTE  || ' - ' || pDesErr;
        RAISE EXC_ERR;
    END IF;


    UPDATE DB_COMUNICAZIONE_10R
    SET     SUPERFICIE_CONDUZIONE_ZVN          = nSuperficieConduzioneZvn,
            SUPERFICIE_ASSERVIMENTO_ZVN       = nSuperficieAsservimentoZvn,
            SUPERFICIE_CONDUZIONE_NO_ZVN      = nSuperficieConduzioneNoZvn,
            SUPERFICIE_ASSERVIMENTO_NO_ZVN    = nSuperficieAsservimentoNoZvn,
            AZOTO_CONDUZIONE_ZVN              = nAzotoConduzioneZvn,
            AZOTO_CONDUZIONE_NO_ZVN           = nAzotoConduzioneNoZvn,
            AZOTO_ASSERVIMENTO_ZVN            = nAzotoAsservimentoZvn,
            AZOTO_ASSERVIMENTO_NO_ZVN         = nAzotoAsservimentoNoZvn,
            TOTALE_AZOTO_AZIENDALE            = nTotaleAzotoAziendale,
            STOC_NETTO_PALABILE               = nStocNettoPalabile,
            STOC_NETTO_NONPALABILE            = nStocNettoNonpalabile,
            STOC_DISP_PALABILE_VOL            = nStocDispPalabileVol,
            STOC_DISP_NONPALABILE_VOL         = nStocDispNonpalabileVol,
            VOLUME_PIOGGE                      =    nSuperficeScopertaTmp,
            ACQUE_LAVAGGIO                      = nTotMungituraTmp,
            TOTALE_AZOTO                      =    nTotAzoto,    
            SUPERFICIE_SAU_PIEMONTE           = nTotSupSauPiemonte, 
            SUPERFICIE_SAU_PIEMONTE_ZVN       = nTotSupSauPiemonteZvn 
    WHERE  ID_COMUNICAZIONE_10R = nNewIdCom;
---------------------------------------------------


/*
    BEGIN
        SELECT MIN(ID_EFFLUENTE_10R), MAX(ID_EFFLUENTE_10R)
        INTO     nMinIdEffluente10R,nMaxIdEffluente10R
        FROM DB_EFFLUENTE_10R
        WHERE ID_COMUNICAZIONE_10R = RecComunicazione10r.ID_COMUNICAZIONE_10R;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
                nMinIdEffluente10R      := 0;
                nMaxIdEffluente10R      := 0;
    END;
*/

    vStrSql := NULL;
    FOR REC_EFFLUENTE IN CUR_EFFLU (nNewIdCom) LOOP
        -- bTuttoTrattato := FALSE;
        vStrSql := vStrSql || REC_EFFLUENTE.ID_EFFLUENTE || ',';


        /*
        IF REC_EFFLUENTE.TRATTAMENTO = 'N' THEN
            SELECT COUNT(*) INTO nContaDichiarato
            FROM DB_EFFLUENTE_10R
            WHERE   ID_COMUNICAZIONE_10R = RecComunicazione10r.ID_COMUNICAZIONE_10R
                    AND    ID_EFFLUENTE = REC_EFFLUENTE.ID_EFFLUENTE
                    AND VOLUME_POST_DICHIARATO IS NOT NULL;

            nVolumePostDichiarato:=NULL;

            IF nContaDichiarato>0 THEN
                SELECT  SUM(NVL(VOLUME_POST_DICHIARATO,0))
                INTO     nVolumePostDichiarato
                FROM DB_EFFLUENTE_10R
                WHERE   ID_COMUNICAZIONE_10R = RecComunicazione10r.ID_COMUNICAZIONE_10R
                        AND    ID_EFFLUENTE = REC_EFFLUENTE.ID_EFFLUENTE;
            END IF;

            SELECT COUNT(*)
            INTO nContaDichiarato
            FROM DB_EFFLUENTE_10R
            WHERE   ID_COMUNICAZIONE_10R = RecComunicazione10r.ID_COMUNICAZIONE_10R
                    AND    ID_EFFLUENTE = REC_EFFLUENTE.ID_EFFLUENTE
                    AND AZOTO_POST_DICHIARATO IS NOT NULL;

            nAzotoPostDichiarato:=NULL;

            IF nContaDichiarato > 0 THEN
                SELECT  NVL(SUM(NVL(AZOTO_POST_DICHIARATO,0)),0)
                INTO     nAzotoPostDichiarato
                FROM DB_EFFLUENTE_10R
                WHERE ID_COMUNICAZIONE_10R = RecComunicazione10r.ID_COMUNICAZIONE_10R
                AND    ID_EFFLUENTE = REC_EFFLUENTE.ID_EFFLUENTE;
            END IF;
        END IF;
        */

        CALCOLA_EFFLUENTI_M3 (    pIdUte,NULL,'N',REC_EFFLUENTE.ID_EFFLUENTE,nVolumeProdottoTmp1,nVolumeProdottoAzTmp1,nAzotoProdottoTmp1,nAzotoProdottoAzTmp1,pCodErr,pDesErr);
        IF pCodErr = '1' THEN
            pDesErr :=     'procedura CALCOLA_EFFLUENTI_M3 '||pDesErr;
            RAISE EXC_ERR;
        END IF;

        nVolumeIniziale                := nVolumeProdottoTmp1;
        nVolumeInizialeCon            := nVolumeProdottoAzTmp1;        --BM003

        nAzotoIniziale                    := nAzotoProdottoAzTmp1;
        nAzotoInizialeDec                := nAzotoProdottoTmp1;            --BM003


        IF REC_EFFLUENTE.TRATTAMENTO = 'S' THEN
            -- sostituita CALCOLA_EFFLUENTI_M3  con select di cui sotto
            SELECT NVL(SUM(VOLUME_POST_DICHIARATO),0),
                   NVL(SUM(AZOTO_POST_DICHIARATO),0),
                   NVL(SUM(VOLUME_POST_TRATTAMENTO),0), --TM 14/10/2004
                   NVL(SUM(AZOTO_POST_TRATTAMENTO),0) -- TM 14/10/2004
              INTO nVolumeProdottoTmp2 ,
                   nAzotoProdottoTmp2,
                   nVolumePostTrattamento, 
                   nAzotoPostTrattamento 
              FROM DB_EFFLUENTE_10R EF10R
             WHERE EF10R.ID_COMUNICAZIONE_10R = nNewIdCom
               AND EF10R.ID_TRATTAMENTO IS NOT NULL
               AND EF10R.ID_EFFLUENTE = REC_EFFLUENTE.ID_EFFLUENTE;

            nVolumeProdottoAzTmp2 := nVolumeProdottoTmp2;
            nAzotoProdottoAzTmp2 := nAzotoProdottoTmp2;

            IF nVolumePostTrattamento = 0 THEN -- TM14/10/2014
                nVolumePostTrattamento        := nVolumeProdottoTmp2;
            END IF;
            nVolumePostTrattamentoCon    := nVolumeProdottoAzTmp2;        --BM003

            IF nAzotoPostTrattamento = 0 THEN -- TM14/10/2014
                nAzotoPostTrattamento        :=    nAzotoProdottoAzTmp2;
            END IF;
            nAzotoPostTrattamentoDec    :=    nAzotoProdottoTmp2;            --BM003


        ELSE
           -- se non trattamento
           -- resta il vecchio metodo
           /*
            CALCOLA_EFFLUENTI_M3 (    pIdUte,NULL,'S',REC_EFFLUENTE.ID_EFFLUENTE,nVolumeProdottoTmp2,nVolumeProdottoAzTmp2,nAzotoProdottoTmp2,nAzotoProdottoAzTmp2,pCodErr,pDesErr);
            IF pCodErr = '1' THEN
                pDesErr :=     'procedura CALCOLA_EFFLUENTI_M3 '||pDesErr;
                RAISE EXC_ERR;
            END IF;
            */

            -- dal sommare VOLUME / AZOTO post trattamento al POST dichiarato
            -- ed ora passiamo a prendere il massimo VOLUME / AZOTO iniziale
            SELECT NVL(MAX(VOLUME_INIZIALE),0),
                   NVL(MAX(AZOTO_INIZIALE),0),
                   COUNT(ID_EFFLUENTE_10R)
              INTO nVolumeDaTrattareInsUtente,
                   nAzotoDaTrattareInsUtente,
                   nNumEfflGenTrattamento
              FROM DB_EFFLUENTE_10R
             WHERE ID_TRATTAMENTO IS NOT NULL
               AND ID_COMUNICAZIONE_10R = nNewIdCom
               AND ID_EFFLUENTE_ORIGINE = REC_EFFLUENTE.ID_EFFLUENTE;

            SELECT NVL(SUM(QUANTITA),0),
                   NVL(SUM(QUANTITA_AZOTO_DICHIARATO),0)
              INTO nVolumeAcqEffluente,
                   nAzotoAcqEffluente
              FROM DB_EFFLUENTE_CES_ACQ_10R EF
             WHERE EF.ID_COMUNICAZIONE_10R  = nNewIdCom
               AND EF.ID_CAUSALE_EFFLUENTE = 2
               AND EF.ID_EFFLUENTE = REC_EFFLUENTE.ID_EFFLUENTE;


            IF nNumEfflGenTrattamento > 0 THEN


                nVolumePostDichiarato := (REC_EFFLUENTE.TOT_VOLUME + nVolumeAcqEffluente) - nVolumeDaTrattareInsUtente;
                nAzotoPostDichiarato := (REC_EFFLUENTE.TOT_AZOTO + nAzotoAcqEffluente)  - nAzotoDaTrattareInsUtente;
/* TM 14/10/2014
              IF nVolumePostDichiarato = 0 AND nAzotoPostDichiarato = 0 THEN
                bTuttoTrattato := TRUE;
             END IF;
*/

            ELSE
                nVolumePostDichiarato := REC_EFFLUENTE.TOT_VOLUME + nVolumeAcqEffluente;
                nAzotoPostDichiarato := REC_EFFLUENTE.TOT_AZOTO + nAzotoAcqEffluente;
            END IF;


            nVolumePostTrattamento        := nVolumePostDichiarato;
            nVolumePostTrattamentoCon    := nVolumePostDichiarato;

            nAzotoPostTrattamento        :=    nAzotoPostDichiarato;
            nAzotoPostTrattamentoDec    :=    nAzotoPostDichiarato;

        END IF;


        CALCOLA_CES_ACQUISIZIONE     ( nNewIdCom,NULL,1,REC_EFFLUENTE.ID_EFFLUENTE,nStockAcqAzTmp,nStockAcqAzStoTmp,pCodErr,pDesErr);
        IF pCodErr = '1' THEN
            pDesErr :=     'procedura CALCOLA_CES_ACQUISIZIONE '||pDesErr;
            RAISE EXC_ERR;
        END IF;

        nVolumeCessione                := nStockAcqAzTmp;
        nVolumeCessioneStok            := nStockAcqAzStoTmp;
        TROVA_AZOTO_CES_ACQ_10R (     nNewIdCom,NULL,1,REC_EFFLUENTE.ID_EFFLUENTE,nQuantitaAzotoTmp,pCodErr,pDesErr);
        IF pCodErr = '1' THEN
            pDesErr :=     'procedura TROVA_AZOTO_CES_ACQ_10R '||pDesErr;
            RAISE EXC_ERR;
        END IF;


        nAzotoCessione                    :=    nQuantitaAzotoTmp;
--        nAzotoCessione                    :=    0;

        CALCOLA_CES_ACQUISIZIONE     ( nNewIdCom,NULL,2,REC_EFFLUENTE.ID_EFFLUENTE,nStockAcqAzTmp,nStockAcqAzStoTmp,pCodErr,pDesErr);
        IF pCodErr = '1' THEN
            pDesErr :=     'procedura CALCOLA_CES_ACQUISIZIONE '||pDesErr;
            RAISE EXC_ERR;
        END IF;

        nVolumeAcquisizione            := nStockAcqAzTmp;
        nVolumeAcquisizioneStok        := nStockAcqAzStoTmp;

        TROVA_AZOTO_CES_ACQ_10R (     nNewIdCom,NULL,2,REC_EFFLUENTE.ID_EFFLUENTE,nQuantitaAzotoTmp,pCodErr,pDesErr);
        IF pCodErr = '1' THEN
            pDesErr :=     'procedura TROVA_AZOTO_CES_ACQ_10R '||pDesErr;
            RAISE EXC_ERR;
        END IF;

        nAzotoAcquisizione            := nQuantitaAzotoTmp;

        BEGIN

         IF nVolumePostTrattamento <>0 THEN
                IF REC_EFFLUENTE.FLAG_PALABILE = 'S' THEN
                    nGgStocDisponibile :=     (365 * nStocDispPalabileVol)        /    (nVolumePostTrattamento - nVolumeCessioneStok + nVolumeAcquisizioneStok);
                ELSE
                    nGgStocDisponibile :=    (365 * nStocDispNonpalabileVol) /    (nVolumePostTrattamento - nVolumeCessioneStok + nVolumeAcquisizioneStok);
                END IF;
            ELSE
                nGgStocDisponibile :=0;
            END IF;

            nGgStocDisponibile := ROUND(nGgStocDisponibile);
        EXCEPTION
            WHEN OTHERS THEN
                nGgStocDisponibile := 0;
        END;

        CALCOLA_GIORNI_STOC_NECESSARI (    pIdUte,REC_EFFLUENTE.ID_EFFLUENTE,nLimiteMinAzoto,nTotGgNec,pCodErr,pDesErr);
        IF pCodErr = '1' THEN
            pDesErr :=     'procedura CALCOLA_GIORNI_STOC_NECESSARI '||pDesErr;
            RAISE EXC_ERR;
        END IF;


--        nStocNecessarioVol :=  (nVolumePostTrattamento  - nVolumeCessione) * nTotGgNec / 365;
        nStocNecessarioVol :=  (nVolumePostTrattamento  - nVolumeCessioneStok + nVolumeAcquisizioneStok) * nTotGgNec / 365;

        IF bAggiornamento THEN
            DELETE DB_EFFLUENTE_10R
             WHERE ID_COMUNICAZIONE_10R = RecComunicazione10r.ID_COMUNICAZIONE_10R
               AND ID_EFFLUENTE = REC_EFFLUENTE.ID_EFFLUENTE
               AND ID_TRATTAMENTO IS NULL;

        END IF;

        -- posso fare sempre update perche' l'effluente legato alla vecchia
        -- comunicazione e' stato ribaltato sulla nuova
        IF REC_EFFLUENTE.TRATTAMENTO = 'S' THEN
            UPDATE DB_EFFLUENTE_10R
               SET VOLUME_POST_TRATTAMENTO = nVolumePostTrattamento,
                   AZOTO_POST_TRATTAMENTO = nAzotoPostTrattamento,
                   VOLUME_CESSIONE = nVolumeCessione,
                   AZOTO_CESSIONE = nAzotoCessione,
                   VOLUME_ACQUISIZIONE = nVolumeAcquisizione,
                   AZOTO_ACQUISIZIONE = nAzotoAcquisizione,
                   STOC_DISPONIBILE_GG = nGgStocDisponibile,
                   STOC_NECESSARIO_VOL = nStocNecessarioVol,
                   STOC_NECESSARIO_GG = nTotGgNec,
                   VOLUME_CESSIONE_STOCCATO = nVolumeCessioneStok,
                   VOLUME_ACQUISIZIONE_STOCCATO = nVolumeAcquisizioneStok,
                   VOLUME_INIZIALE_CON = nVolumeInizialeCon,
                   AZOTO_INIZIALE_DEC = nAzotoInizialeDec,
                   VOLUME_POST_TRATTAMENTO_CON =nVolumePostTrattamentoCon,
                   AZOTO_POST_TRATTAMENTO_DEC = nAzotoPostTrattamentoDec
             WHERE ID_COMUNICAZIONE_10R = nNewIdCom
               AND ID_EFFLUENTE = REC_EFFLUENTE.ID_EFFLUENTE
               AND ID_TRATTAMENTO IS NOT NULL;
           --AND ID_TRATTAMENTO =  REC_EFFLUENTE.ID_TRATTAMENTO;

        ELSIF REC_EFFLUENTE.TRATTAMENTO = 'N' /*AND NOT bTuttoTrattato MS 16/10/2014 lo tolgo non serve più*/THEN
            INSERT INTO DB_EFFLUENTE_10R (    ID_EFFLUENTE_10R,             ID_COMUNICAZIONE_10R,     ID_EFFLUENTE,                         VOLUME_INIZIALE,     AZOTO_INIZIALE,     VOLUME_POST_TRATTAMENTO,     AZOTO_POST_TRATTAMENTO, VOLUME_CESSIONE,     AZOTO_CESSIONE, VOLUME_ACQUISIZIONE,     AZOTO_ACQUISIZIONE,     VOLUME_POST_DICHIARATO, AZOTO_POST_DICHIARATO,     STOC_DISPONIBILE_GG, STOC_NECESSARIO_VOL, STOC_NECESSARIO_GG,    VOLUME_CESSIONE_STOCCATO,         VOLUME_ACQUISIZIONE_STOCCATO, VOLUME_INIZIALE_CON,    AZOTO_INIZIALE_DEC,    VOLUME_POST_TRATTAMENTO_CON,    AZOTO_POST_TRATTAMENTO_DEC    )
            VALUES (    SEQ_EFFLUENTE_10R.NEXTVAL,    nNewIdCom,                    REC_EFFLUENTE.ID_EFFLUENTE,    nVolumeIniziale,    nAzotoIniziale,    nVolumePostTrattamento,        nAzotoPostTrattamento,    nVolumeCessione,    nAzotoCessione, nVolumeAcquisizione,    nAzotoAcquisizione,    nVolumePostDichiarato,    nAzotoPostDichiarato,    nGgStocDisponibile,    nStocNecessarioVol,    nTotGgNec,                nVolumeCessioneStok,                nVolumeAcquisizioneStok,        nVolumeInizialeCon,    nAzotoInizialeDec,    nVolumePostTrattamentoCon,        nAzotoPostTrattamentoDec    );
        END IF;

    END LOOP;

    /*
    IF bAggiornamento THEN
        DELETE FROM DB_EFFLUENTE_10R
        WHERE ID_COMUNICAZIONE_10R = RecComunicazione10r.ID_COMUNICAZIONE_10R
          AND ID_TRATTAMENTO IS NULL; 
    END IF;
    */

    --- Ricalcolo azoto ceduto sulla tavola db_effluente_ces_acq_10R
--     FOR REC_AZOTO_ACQ IN C_RICALCOLO_AZOTO(nNewIdCom) LOOP

--        TROVA_CES_ACQ_10R (    pIdUte, nNewIdCom,1,REC_AZOTO_ACQ.ID_EFFLUENTE, REC_AZOTO_ACQ.QUANTITA,nQuaOut,pCodErr,pDesErr);
--        IF pCodErr = '1' THEN
--            pDesErr :=     'procedura TROVA_CES_ACQ_10R '||pDesErr;
--            RAISE EXC_ERR;
--        END IF;

--        UPDATE DB_EFFLUENTE_CES_ACQ_10R
--        SET     QUANTITA_AZOTO                 =  nQuaOut,
--                QUANTITA_AZOTO_DICHIARATO     =  nQuaOut        -- BM001
--        WHERE ID_EFFLUENTE_CES_ACQ_10R = REC_AZOTO_ACQ.ID_EFFLUENTE_CES_ACQ_10R;
--    END LOOP;


    --- Aggiornamento azoto ceduto sulla tavola db_effluente_10r
    FOR REC_AGG_AZ IN C_AGGIORNAMENTO_AZOTO(nNewIdCom) LOOP

        TROVA_AZOTO_CES_ACQ_10R (    nNewIdCom,NULL,1,REC_AGG_AZ.ID_EFFLUENTE, nQuaOut,pCodErr,pDesErr);
        IF pCodErr = '1' THEN
            pDesErr :=     'procedura TROVA_AZOTO_CES_ACQ_10R '||pDesErr;
            RAISE EXC_ERR;
        END IF;

        UPDATE DB_EFFLUENTE_10R
        SET AZOTO_CESSIONE = nQuaOut
        WHERE ID_EFFLUENTE_10R = REC_AGG_AZ.ID_EFFLUENTE_10R;

    END LOOP;



 ---  DB_COMUNICAZIONE_10R ---
    SELECT NVL(SUM(NVL(VOLUME_REFLUO,0)),0) INTO nTotAcqEx FROM DB_ACQUA_EXTRA_10R
    WHERE ID_COMUNICAZIONE_10R = nNewIdCom;

    CALCOLA_CES_ACQUISIZIONE     (         nNewIdCom,NULL,1,19,nStockAcqAzTmp,nStockAcqAzStoTmp,pCodErr,pDesErr);
    IF pCodErr = '1' THEN
        pDesErr :=     'procedura CALCOLA_CES_ACQUISIZIONE '||pDesErr;
        RAISE EXC_ERR;
    END IF;

    nStocAcqueNettoCessione        := NVL(RecComunicazione10r.VOLUME_REFLUO_AZIENDA,0)  + nSuperficeScopertaTmp + nTotMungituraTmp + nTotAcqEx - nStockAcqAzStoTmp;

    CALCOLA_CES_ACQUISIZIONE     (         nNewIdCom,NULL,2,19,nStockAcqAzTmp,nStockAcqAzStoTmp,pCodErr,pDesErr);
    IF pCodErr = '1' THEN
        pDesErr :=     'procedura CALCOLA_CES_ACQUISIZIONE '||pDesErr;
        RAISE EXC_ERR;
    END IF;

    nStocAcqueNettoCessione := nStocAcqueNettoCessione  + nStockAcqAzStoTmp;

    SELECT NVL(MAX(stoc_necessario_gg),365)
    INTO  nStocAcqueNecGg
    FROM     DB_EFFLUENTE_10R  EFF,
            DB_TIPO_EFFLUENTE TIP
    WHERE TIP.ID_EFFLUENTE         = EFF.ID_EFFLUENTE
    AND    FLAG_PALABILE            = 'N'
    AND    ID_COMUNICAZIONE_10R = nNewIdCom;


     nStocAcqueNecVol                := nStocAcqueNettoCessione * nStocAcqueNecGg / 365;

    UPDATE DB_COMUNICAZIONE_10R
    SET     STOC_ACQUE_NETTO_CESSIONE             = nStocAcqueNettoCessione,
            STOC_ACQUE_NEC_GG                         =    nStocAcqueNecGg,
            STOC_ACQUE_NEC_VOL                     = nStocAcqueNecVol
    WHERE  ID_COMUNICAZIONE_10R = nNewIdCom;
 ---  DB_COMUNICAZIONE_10R ---


    /*  Verifico se tra le acquisizioni dichiarate sono presenti effluente non prodotti dall'azienda
        quindi li aggiungo all'elenco effluenti
    */

    vStrSql := SUBSTR(vStrSql,1,LENGTH(vStrSql) -1);

    FOR REC_ACQUISITI IN C_EFF_ACQUISITI(nNewIdCom,
                                         vStrSql) LOOP

        -- se per qualche strano motivo l'effluente acquisito
        -- e' gia' presente su DB_EFFLUENTE_10R lo cancello
        -- e lo ricalcolo
        DELETE
          FROM DB_EFFLUENTE_10R
         WHERE ID_COMUNICAZIONE_10R = nNewIdCom
           AND ID_EFFLUENTE = REC_ACQUISITI.ID_EFFLUENTE;

        CALCOLA_GIORNI_STOC_NECESSARI (    pIdUte,REC_ACQUISITI.ID_EFFLUENTE,nLimiteMinAzoto,nTotGgNec,pCodErr,pDesErr);
        IF pCodErr = '1' THEN
            pDesErr :=     'procedura CALCOLA_GIORNI_STOC_NECESSARI '||pDesErr;
            RAISE EXC_ERR;
        END IF;

        -- passo a valorizzare anche volume cessione
        CALCOLA_CES_ACQUISIZIONE     ( nNewIdCom,NULL,1,REC_ACQUISITI.ID_EFFLUENTE,nStockAcqAzTmp,nStockAcqAzStoTmp,pCodErr,pDesErr);
        IF pCodErr = '1' THEN
            pDesErr :=     'procedura CALCOLA_CES_ACQUISIZIONE '||pDesErr;
            RAISE EXC_ERR;
        END IF;

        -- ed azoto cessione che prima non erano valorizzati
        TROVA_AZOTO_CES_ACQ_10R (     nNewIdCom,NULL,1,REC_ACQUISITI.ID_EFFLUENTE,nQuantitaAzotoTmp,pCodErr,pDesErr);
        IF pCodErr = '1' THEN
            pDesErr :=     'procedura TROVA_AZOTO_CES_ACQ_10R '||pDesErr;
            RAISE EXC_ERR;
        END IF;

        -- sono praticamente nel caso in cui un'azienda agricola prima acquisisce un effluente
        -- e poi cede parzialmente o totalemnte lo stesso
        INSERT INTO DB_EFFLUENTE_10R     (    ID_EFFLUENTE_10R,             ID_COMUNICAZIONE_10R,    ID_EFFLUENTE,                    VOLUME_INIZIALE,     AZOTO_INIZIALE,     VOLUME_POST_TRATTAMENTO,     AZOTO_POST_TRATTAMENTO, VOLUME_CESSIONE,     AZOTO_CESSIONE,     VOLUME_ACQUISIZIONE,     AZOTO_ACQUISIZIONE,                                                 VOLUME_POST_DICHIARATO, AZOTO_POST_DICHIARATO,     STOC_DISPONIBILE_GG, STOC_NECESSARIO_VOL,                                                 STOC_NECESSARIO_GG,    VOLUME_CESSIONE_STOCCATO,     VOLUME_ACQUISIZIONE_STOCCATO,    VOLUME_INIZIALE_CON,    AZOTO_INIZIALE_DEC,    VOLUME_POST_TRATTAMENTO_CON,    AZOTO_POST_TRATTAMENTO_DEC        )
        VALUES                                  (    SEQ_EFFLUENTE_10R.NEXTVAL,    nNewIdCom,                     REC_ACQUISITI.ID_EFFLUENTE,    0,                     0,                     0,                                 0,                             nStockAcqAzTmp,                        nQuantitaAzotoTmp,                     REC_ACQUISITI.QUANTITA,    REC_ACQUISITI.QUANTITA_AZOTO_DICHIARATO,    /*BM001*/    0,                                0,                                0,                            ROUND((REC_ACQUISITI.QUANTITA_STOC * nTotGgNec /365),1),    nTotGgNec,                0,                                    REC_ACQUISITI.QUANTITA_STOC,    0,                            0,                            0,                                        0                                        );

    END LOOP;

    -- effettuo il calcolo dell'azoto escreto al pascolo
    AZOTO_ESCRETO_PASCOLO (NVL(RecComunicazione10r.ID_UTE,pIdUte), nTotAzotoEscreto, pCodErr,pDesErr);

    IF pCodErr = '1' THEN
       pDesErr :=     'procedura AZOTO_ESCRETO_PASCOLO - ID_UTE = ' || RecComunicazione10r.ID_UTE || ' - ' || pDesErr;
       RAISE EXC_ERR;
    END IF;

    UPDATE DB_COMUNICAZIONE_10R
       SET AZOTO_ESCRETO_PASCOLO = nTotAzotoEscreto
     WHERE ID_COMUNICAZIONE_10R = nNewIdCom;

    pOutIdComunicazione := nNewIdCom;
EXCEPTION
    WHEN EXC_ERR THEN
        pCodErr        := '1';
    WHEN EXC_PARAMETRO_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRO INPUT NULL';
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);
END RICALCOLA ;

   /*********************************************************************
   Dato un id_azienda mi dice se l'azienda risulta cessata su DB_ANAGRAFICA_AZIENDA
   Tipo:    funzione
   input:  pIDAzienda
   output: nessuno
   ritorno: TRUE / FALSE
   *********************************************************************/
   FUNCTION IsAziendaCessata (pIdAzienda IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE)RETURN BOOLEAN IS
      nIdAnagraficaAzienda DB_ANAGRAFICA_AZIENDA.ID_ANAGRAFICA_AZIENDA%TYPE;
   BEGIN
      SELECT id_anagrafica_azienda
        INTO nIdAnagraficaAzienda
        FROM db_anagrafica_azienda
       WHERE id_azienda = pIdAzienda
         AND data_fine_validita IS NULL
         AND data_cessazione IS NOT NULL;

      RETURN TRUE;
   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RETURN FALSE;
   END IsAziendaCessata;


PROCEDURE RICALCOLA_AZIENDA (    pIdAzienda                 IN NUMBER,
                                        pIdUtente                IN NUMBER,
                                          pCodErr                    OUT VARCHAR2,
                                          pDesErr                    OUT VARCHAR2) IS

CURSOR CUR_UTE IS
SELECT ID_UTE
  FROM DB_UTE
 WHERE ID_AZIENDA = pIdAzienda
   AND DATA_FINE_ATTIVITA IS NULL;


EXC_PARAMETRO_NULL         EXCEPTION;
EXC_ERR                 EXCEPTION;

nOutIdComunicazione        NUMBER;

BEGIN

    IF pIdAzienda IS NULL OR pIdUtente IS NULL THEN
        RAISE EXC_PARAMETRO_NULL;
    END IF;

    FOR Rec_Ute IN CUR_UTE LOOP
        RICALCOLA (    Rec_Ute.ID_UTE,pIdUtente,nOutIdComunicazione,pCodErr,pDesErr);
        DBMS_OUTPUT.PUT_LINE('nuova id comunicazione '||nOutIdComunicazione);
        IF pCodErr = '1' THEN
            RAISE EXC_ERR;
        END IF;
    END LOOP;

EXCEPTION
    WHEN EXC_ERR THEN
        pCodErr        := '1';
    WHEN EXC_PARAMETRO_NULL THEN
        pCodErr        := '1';
        pDesErr        := 'PARAMETRO INPUT NULL';
    WHEN OTHERS THEN
        pCodErr        := '1';
        pDesErr        := SUBSTR(SQLERRM,1,100);
END RICALCOLA_AZIENDA;

/*********************************************************************
Calcola la quantità di effluente ceduta od acquisita dall'azienda corrente
rispetto all'azienda cedente od acquirente per la tipologia di effluente
ed il tipo causale dati in input
Tipo: procedure
input: pIdAziendaCorrente, pIdAziendaCesAcq, pIdEffluente, pIdCausaleEffluente
output: pTotEffluenteCedAcq, pCodErr, pMessErr
ritorno: nessuno
*********************************************************************/
PROCEDURE M3_EFFLUENTE_CEDUTO_ACQUISITO (pIdAziendaCorrente     IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                         pIdAziendaCesAcq       IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                         pIdEffluente           IN DB_TIPO_EFFLUENTE.ID_EFFLUENTE%TYPE,
                                         pIdCausaleEffluente    IN DB_TIPO_CAUSALE_EFFLUENTE.ID_CAUSALE_EFFLUENTE%TYPE,
                                         pTotEffluenteCedAcq   OUT DB_EFFLUENTE_CES_ACQ_10R.QUANTITA%TYPE,
                                         pCodErr               OUT VARCHAR2,
                                         pMessErr              OUT VARCHAR2
                                         ) IS
    recDichCons10R  DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE;
BEGIN
--    pCodErr := '0';
    pTotEffluenteCedAcq := 0;

    recDichCons10R := SelLastDichConsByIdAziendaEMot (pIdAziendaCesAcq,knIdTipoMotDichComu10R);

    IF recDichCons10R.ID_DICHIARAZIONE_CONSISTENZA IS NOT NULL THEN

       SELECT NVL(SUM(EFCA.QUANTITA),0)
         INTO pTotEffluenteCedAcq
         FROM DB_UTE U,
              DB_COMUNICAZIONE_10R C,
              DB_EFFLUENTE_CES_ACQ_10R EFCA
        WHERE U.ID_AZIENDA = pIdAziendaCesAcq
          AND recDichCons10R.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN U.DATA_INIZIO_ATTIVITA AND NVL(U.DATA_FINE_ATTIVITA,SYSDATE)
          AND U.ID_UTE = C.ID_UTE
          AND recDichCons10R.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN C.DATA_INIZIO_VALIDITA AND NVL(C.DATA_FINE_VALIDITA,SYSDATE)
          AND C.ID_COMUNICAZIONE_10R = EFCA.ID_COMUNICAZIONE_10R
          AND EFCA.ID_AZIENDA = pIdAziendaCorrente
          AND EFCA.ID_EFFLUENTE = pIdEffluente
          AND EFCA.ID_CAUSALE_EFFLUENTE = pIdCausaleEffluente;

    END IF;

EXCEPTION
    WHEN OTHERS THEN
       pCodErr := '1';
       pMessErr := 'Errore durante il calcolo dell''effluente ceduto / acquisito : ' || SUBSTR(SQLERRM,1,150);
END M3_EFFLUENTE_CEDUTO_ACQUISITO;

END Pack_Comunicazione_10r;

/
--------------------------------------------------------
--  DDL for Package Body PACK_CONTROLLI
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PACK_CONTROLLI" IS

consonanti CONSTANT VARCHAR2(21) := 'BCDFGHJKLMNPQRSTVWXYZ';
vocali     CONSTANT VARCHAR2(21) := 'AEIOU';
filler     CONSTANT VARCHAR2(3)  := 'XXX';
clenPIVA   CONSTANT INTEGER      := 11;
clenCF     CONSTANT INTEGER      := 16;
result              INTEGER      := 0;
result2             INTEGER      := 0;
err_num             VARCHAR2(15);
err_msg             VARCHAR2(85);

    FUNCTION SelTAziendaAaepByCuaa (pCuaa IN DB_AZIENDA_AAEP.CUAA%TYPE)
    RETURN DB_AZIENDA_AAEP%ROWTYPE IS
        recTAziendaAAEP DB_AZIENDA_AAEP%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTAziendaAAEP
          FROM DB_AZIENDA_AAEP
         WHERE CUAA = pCuaa
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recTAziendaAAEP;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTAziendaAaepByCuaa;

    /*********************************************************************
    Accoda al messaggio dato in input / output la stringa data in input se
    essa non provoca un supero della dimensione massima
    Tipo:    procedure
    Input:   pMessaggio, vStringa
    Output:  pMessaggio
    Return:  nessuno
    ********************************************************************/
    PROCEDURE AccodaMessaggio (pMessaggio IN OUT VARCHAR2,
                               vStringa   IN VARCHAR2) IS

        nLengthMsg  INTEGER:=0; -- conterra la lunghezza del messaggio attuale
        nLengthStr  INTEGER:=0; -- contiene la lunghezza della stringa da aggiungere

    BEGIN

        IF NVL(gnMaxLenghtMessaggio,0) = 0 THEN
            BEGIN
                -- mi cerco la lunghezza
                -- massima per la colonna messaggio_esteso
                SELECT DATA_LENGTH
                  INTO gnMaxLenghtMessaggio
                  FROM USER_TAB_COLUMNS
                 WHERE TABLE_NAME = 'DB_DICHIARAZIONE_SEGNALAZIONE'
                   AND COLUMN_NAME = 'DESCRIZIONE';
            EXCEPTION
                WHEN OTHERS THEN
                     gnMaxLenghtMessaggio := 2000;
            END;

        END IF;

        -- setto la lunghezza del messaggio attuale
        nLengthMsg := NVL(LENGTH(pMessaggio),0);
        -- setto la lunghezza della stringa da aggiungere al messaggio attuale
        nLengthStr := NVL(LENGTH(vStringa),0);
        -- se la somma della lunghezza del messagio attuale + la stringa da aggiungere
        -- e minore della lunghezza massima disponibile
        IF nLengthMsg + nLengthStr <= gnMaxLenghtMessaggio THEN
           -- accoda la stringa nel messaggio
           pMessaggio := pMessaggio || vStringa;
        ELSE
           IF nLengthMsg = 0 THEN
              -- e se e maggiore di zero accodo solamente un pezzo della stringa
              pMessaggio := substr(vStringa,1,gnMaxLenghtMessaggio);
           END IF;
        END IF;

    END AccodaMessaggio;

/*********************************************************************
Inserisce un record di tipo DB_ISTRUTTORIA_POLIZZA_COLTURA sull'omonima
tabella
Tipo: procedure
input : pRecTIstrPolColtura
output: nessuno
ritorno: nessuno
*********************************************************************/
PROCEDURE InsertTIstrPolizzaColtura (pRecTIstrPolColtura IN DB_ISTRUTTORIA_POLIZZA_COLTURA%ROWTYPE) IS
BEGIN

    INSERT INTO DB_ISTRUTTORIA_POLIZZA_COLTURA
        (
        ID_ISTRUTTORIA_POLIZZA_COLTURA,
        ESITO_ISTRUTTORIA,
        COEFFICIENTE_RIDUZIONE,
        RESA_MEDIA_REGIONALE,
        RESA_MEDIA_ASSICURATA,
        RESA_MEDIA_TRIENNALE,
        ID_DETTAGLIO_POLIZZA_COLTURA
        )
    VALUES
        (
        pRecTIstrPolColtura.ID_ISTRUTTORIA_POLIZZA_COLTURA,
        pRecTIstrPolColtura.ESITO_ISTRUTTORIA,
        pRecTIstrPolColtura.COEFFICIENTE_RIDUZIONE,
        pRecTIstrPolColtura.RESA_MEDIA_REGIONALE,
        pRecTIstrPolColtura.RESA_MEDIA_ASSICURATA,
        pRecTIstrPolColtura.RESA_MEDIA_TRIENNALE,
        pRecTIstrPolColtura.ID_DETTAGLIO_POLIZZA_COLTURA
        );
END InsertTIstrPolizzaColtura;


/*********************************************************************
Verifica se l'azienda e' dell'opr Piemonte
Tipo: function
input : pIdAzienda
output: nessuno
ritorno: TRUE / FALSE
*********************************************************************/
FUNCTION IsAziendaInOprPiemonte (pIdAzienda IN DB_AZIENDA.ID_AZIENDA%TYPE) RETURN BOOLEAN IS
    bRet BOOLEAN:=FALSE;
    nRec INTEGER:=0;
BEGIN

    SELECT COUNT(AZ.ID_AZIENDA)
      INTO nRec
      FROM DB_AZIENDA AZ,
           DB_SIAN_TIPO_OPR STO
     WHERE AZ.ID_AZIENDA = pIdAzienda
       AND AZ.ID_OPR = STO.ID_OPR (+)
       AND NVL(STO.FLAG_PRINCIPALE,'S') = 'S';


    IF nRec > 0 THEN
       bRet := TRUE;
    END IF;

    RETURN bRet;

END IsAziendaInOprPiemonte;


/*********************************************************************
Ricerca il valore del parametro con codice dato in input nella tavola
DB_TIPO_CONTROLLO_PARAMETRO per l'id_controllo dato in input e ne
ritorna il ROWTYPE
Tipo: function
input: pIdControllo , pCodice
output: nessuno
ritorno: DB_TIPO_CONTROLLO_PARAMETRO%ROWTYPE
*********************************************************************/
FUNCTION SelValoreParametroCtrlByCodice (pIdControllo IN DB_TIPO_CONTROLLO_PARAMETRO.ID_CONTROLLO%TYPE,
                                         pCodice      IN DB_TIPO_CONTROLLO_PARAMETRO.CODICE%TYPE
                                         ) RETURN DB_TIPO_CONTROLLO_PARAMETRO%ROWTYPE IS

    recTipoControlloParametro DB_TIPO_CONTROLLO_PARAMETRO%ROWTYPE;
BEGIN
    SELECT *
      INTO recTipoControlloParametro
      FROM DB_TIPO_CONTROLLO_PARAMETRO
     WHERE ID_CONTROLLO = pIdControllo
       AND CODICE = pCodice
       AND DATA_FINE_VALIDITA IS NULL;

    RETURN recTipoControlloParametro;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
         recTipoControlloParametro := NULL;
         RETURN recTipoControlloParametro;
END SelValoreParametroCtrlByCodice;

/*********************************************************************
Ricerca il valore del parametro con codice dato in input nella tavola
DB_TIPO_CONTROLLO_PARAMETRO per l'id_controllo dato in input e ne
ritorna il ROWTYPE
Tipo: function
input: pIdAzienda
output: nessuno
ritorno: DB_COMPENSAZIONE_AZIENDA%ROWTYPE
*********************************************************************/
FUNCTION SelTCompAziendaByIdAzienda (pIdAzienda IN DB_COMPENSAZIONE_AZIENDA.ID_AZIENDA%TYPE)
RETURN DB_COMPENSAZIONE_AZIENDA%ROWTYPE IS
    recTCompensazioneAzienda DB_COMPENSAZIONE_AZIENDA%ROWTYPE;
BEGIN

    SELECT *
      INTO recTCompensazioneAzienda
      FROM DB_COMPENSAZIONE_AZIENDA
     WHERE ID_AZIENDA = pIdAzienda
       AND DATA_FINE_VALIDITA IS NULL;

    RETURN recTCompensazioneAzienda;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
         RETURN NULL;
END SelTCompAziendaByIdAzienda;

/*********************************************************************
Ricerca l'ultima dichiarazione di consistenza per l'azienda con motivo compatibile
con il procedimento dato in input per l'anno campagna dato in input ed effettuata
entro la dataoffset data in input
Tipo: function
input: pIdAzienda, pIdProcedimento, pAnnoCampagna, pDataOffset
output: nessuno
ritorno: nIdDichConsistenza
*********************************************************************/
FUNCTION SelDichConsForAzProcAnnoData (pIdAzienda      IN DB_PROCEDIMENTO_AZIENDA.ID_AZIENDA%TYPE,
                                       pIdProcedimento IN DB_PROCEDIMENTO_AZIENDA.ID_PROCEDIMENTO%TYPE,
                                       pAnnoCampagna   IN DB_PROCEDIMENTO_AZIENDA.ANNO_CAMPAGNA%TYPE,
                                       pDataOffset     IN DB_DICHIARAZIONE_CONSISTENZA.DATA%TYPE
                                        )
RETURN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE IS
    nIdDichConsistenza DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE;
BEGIN

    SELECT ID_DICHIARAZIONE_CONSISTENZA
      INTO nIdDichConsistenza
      FROM DB_DICHIARAZIONE_CONSISTENZA
     WHERE ID_AZIENDA = pIdAzienda
       AND ANNO = pAnnoCampagna
       AND DATA = (SELECT MAX (DATA)
                     FROM DB_DICHIARAZIONE_CONSISTENZA DC
                    WHERE ID_AZIENDA = pIdAzienda
                      AND ANNO = pAnnoCampagna
                      AND DATA_PROTOCOLLO IS NOT NULL
                      AND NUMERO_PROTOCOLLO IS NOT NULL
                      AND DATA BETWEEN TO_DATE('01/01/' || pAnnoCampagna,'DD/MM/YYYY') AND pDataOffset
                      AND ID_MOTIVO_DICHIARAZIONE NOT IN
                         (SELECT ID_MOTIVO_DICHIARAZIONE
                            FROM DB_MOTIVO_ESCLUSO_PROCEDIMENTO
                           WHERE ID_PROCEDIMENTO = pIdProcedimento));

    RETURN nIdDichConsistenza;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
         RETURN NULL;
END SelDichConsForAzProcAnnoData;

/*********************************************************************
Ricerca la dichiarazione di consistenza di una determinata pratica di
un procedimento se è in stato 'C = Conclusa' od 'I = In Corso' ma in
quest'ultimo caso solamente se è in istruttoria
Tipo: function
input: pIdAzienda, pIdProcedimento, pAnnoCampagna
output: nessuno
ritorno: nIdDichConsistenza
*********************************************************************/
FUNCTION SelDichConsForAziendaProcAnno (pIdAzienda      IN DB_PROCEDIMENTO_AZIENDA.ID_AZIENDA%TYPE,
                                        pIdProcedimento IN DB_PROCEDIMENTO_AZIENDA.ID_PROCEDIMENTO%TYPE,
                                        pAnnoCampagna   IN DB_PROCEDIMENTO_AZIENDA.ANNO_CAMPAGNA%TYPE
                                        )
RETURN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE IS
    nIdDichConsistenza DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE;
BEGIN

    SELECT MAX(ID_DICHIARAZIONE_CONSISTENZA)
      INTO nIdDichConsistenza
      FROM DB_PROCEDIMENTO_AZIENDA
     WHERE ID_AZIENDA = pIdAzienda
       AND ID_PROCEDIMENTO = pIdProcedimento
       AND ANNO_CAMPAGNA = pAnnoCampagna
       AND (STATO = kvStatoPraticaConclusa OR
           (STATO = kvStatoPraticaInCorso AND
            DESCRIZIONE_STATO = 'In istruttoria'));

    RETURN nIdDichConsistenza;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
         RETURN NULL;
END SelDichConsForAziendaProcAnno;


/*********************************************************************
Inserisce un record di tipo DB_ANOMALIA_POLIZZA nell'omonima tabella
Tipo: procedure
input: pRecTAnomaliaPolizza
output: nessuno
ritorno: nessuno
*********************************************************************/
PROCEDURE InsertTAnomaliaPolizza (pRecTAnomaliaPolizza IN DB_ANOMALIA_POLIZZA%ROWTYPE) IS
BEGIN

    INSERT INTO DB_ANOMALIA_POLIZZA
        (
        ID_ANOMALIA_POLIZZA,
        ID_POLIZZA_ASSICURATIVA,
        ID_DETTAGLIO_POLIZZA,
        ID_DETTAGLIO_POLIZZA_COLTURA,
        ID_DETTAGLIO_POLIZZA_STRUTTURA,
        ID_DETTAGLIO_POLIZZA_ZOOTECNIA,
        ID_FONTE,
        ID_CONTROLLO,
        DESCRIZIONE,
        DATA_ESECUZIONE
        )
    VALUES
        (
        pRecTAnomaliaPolizza.ID_ANOMALIA_POLIZZA,
        pRecTAnomaliaPolizza.ID_POLIZZA_ASSICURATIVA,
        pRecTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA,
        pRecTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA_COLTURA,
        pRecTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA_STRUTTURA,
        pRecTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA_ZOOTECNIA,
        pRecTAnomaliaPolizza.ID_FONTE,
        pRecTAnomaliaPolizza.ID_CONTROLLO,
        pRecTAnomaliaPolizza.DESCRIZIONE,
        pRecTAnomaliaPolizza.DATA_ESECUZIONE
        );
END InsertTAnomaliaPolizza;

/*********************************************************************
Inserisce un record di tipo DB_ESITO_DETTAGLIO_POLIZZA nell'omonima tabella
Tipo: procedure
input: pRecTEsitoDettPolizza
output: nessuno
ritorno: nessuno
*********************************************************************/
PROCEDURE InsertTEsitoDettaglioPolizza (pRecTEsitoDettPolizza IN DB_ESITO_DETTAGLIO_POLIZZA%ROWTYPE) IS
BEGIN

    INSERT INTO DB_ESITO_DETTAGLIO_POLIZZA
        (
        ID_ESITO_DETTAGLIO_POLIZZA,
        ID_DETTAGLIO_POLIZZA,
        ID_DICHIARAZIONE_CONSISTENZA,
        TIPO_CRITERIO,
        ID_GRUPPO_MACRO_USO,
        ISTAT_COMUNE,
        TOTALE_SUP_DICHIARATA,
        TOTALE_SUP_ASSICURATA,
        COEFFICIENTE,
        IMPORTO_PROPOSTO,
        DATA_CALCOLO,
        ID_MACRO_USO,
        IMPORTO_PROPOSTO_OP,
        IMPORTO_PAGATO
        )
    VALUES
        (
        pRecTEsitoDettPolizza.ID_ESITO_DETTAGLIO_POLIZZA,
        pRecTEsitoDettPolizza.ID_DETTAGLIO_POLIZZA,
        pRecTEsitoDettPolizza.ID_DICHIARAZIONE_CONSISTENZA,
        pRecTEsitoDettPolizza.TIPO_CRITERIO,
        pRecTEsitoDettPolizza.ID_GRUPPO_MACRO_USO,
        pRecTEsitoDettPolizza.ISTAT_COMUNE,
        pRecTEsitoDettPolizza.TOTALE_SUP_DICHIARATA,
        pRecTEsitoDettPolizza.TOTALE_SUP_ASSICURATA,
        pRecTEsitoDettPolizza.COEFFICIENTE,
        pRecTEsitoDettPolizza.IMPORTO_PROPOSTO,
        pRecTEsitoDettPolizza.DATA_CALCOLO,
        pRecTEsitoDettPolizza.ID_MACRO_USO,
        pRecTEsitoDettPolizza.IMPORTO_PROPOSTO_OP,
        pRecTEsitoDettPolizza.IMPORTO_PAGATO
        );
END InsertTEsitoDettaglioPolizza;

/*********************************************************************
Dato un identificativo unità arborea selezione il corrispettivo record
su DB_UNITA_ARBOREA_DICHIARATA
Tipo: funzione
input: pIdUnitaArboreaDich
output: nessuno
ritorno: DB_UNITA_ARBOREA_DICHIARATA
*********************************************************************/
FUNCTION SelTUnitaArboreaDichById (pIdUnitaArboreaDich IN DB_UNITA_ARBOREA_DICHIARATA.ID_UNITA_ARBOREA_DICHIARATA%TYPE)
RETURN DB_UNITA_ARBOREA_DICHIARATA%ROWTYPE IS
    recTUnitaArboreaDich DB_UNITA_ARBOREA_DICHIARATA%ROWTYPE;
BEGIN

    SELECT *
      INTO recTUnitaArboreaDich
      FROM DB_UNITA_ARBOREA_DICHIARATA
     WHERE ID_UNITA_ARBOREA_DICHIARATA = pIdUnitaArboreaDich;

    RETURN recTUnitaArboreaDich;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
         RETURN NULL;
END SelTUnitaArboreaDichById;

/*********************************************************************
Dati un codice controllo ed un codice parametro controllo ritorna
il corrispettivo record su DB_TIPO_CONTROLLO_PARAMETRO se presente
oppure NULL
Tipo: funzione
input: pCodControllo , pCodParametro, pDataConf
output: nessuno
ritorno: DB_TIPO_CONTROLLO_PARAMETRO%ROWTYPE
*********************************************************************/
FUNCTION SelValParByCodCtrlAndCodParEDt (pCodControllo IN DB_TIPO_CONTROLLO.CODICE_CONTROLLO%TYPE,
                                         pCodParametro IN DB_TIPO_CONTROLLO_PARAMETRO.CODICE%TYPE,
                                         pDataConf     IN DATE
                                         ) RETURN DB_TIPO_CONTROLLO_PARAMETRO%ROWTYPE IS
    recTcParametro DB_TIPO_CONTROLLO_PARAMETRO%ROWTYPE;
BEGIN

    SELECT TCP.*
      INTO recTcParametro
      FROM DB_TIPO_CONTROLLO TC,
           DB_TIPO_CONTROLLO_PARAMETRO TCP
     WHERE TC.CODICE_CONTROLLO = pCodControllo
       AND TC.ID_CONTROLLO = TCP.ID_CONTROLLO
       AND TCP.CODICE = pCodParametro
       AND pDataConf BETWEEN TCP.DATA_INIZIO_VALIDITA AND NVL(TCP.DATA_FINE_VALIDITA,pDataConf);

    RETURN recTcParametro;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
         RETURN NULL;
END SelValParByCodCtrlAndCodParEDt;

/*********************************************************************
Dato un id_dichiarazione_consistenza seleziona il record dall'omonima tabella
Tipo:    funzione
input:    pIDDichCons
output: nessuno
ritorno: DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE
*********************************************************************/
FUNCTION SelDichConsistenzaById (pIDDichCons IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE)
RETURN DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE IS
    recDichConsist DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE;
BEGIN
   SELECT *
     INTO recDichConsist
     FROM DB_DICHIARAZIONE_CONSISTENZA
    WHERE ID_DICHIARAZIONE_CONSISTENZA =  pIDDichCons;

   RETURN recDichConsist;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
         RETURN NULL;
END SelDichConsistenzaById;

/*********************************************************************
Dati un id_attestazione ed un codice fotografia terreni
controllo se la coppia esiste su DB_ATTESTAZIONE_DICHIARATA
Tipo:    funzione
input:    pIdAttestazione, pCodFotoTerreni
output: nessuno
ritorno: TRUE / FALSE
*********************************************************************/
FUNCTION EsisteAttestazione (pIdAttestazione IN DB_ATTESTAZIONE_DICHIARATA.ID_ATTESTAZIONE%TYPE,
                             pCodFotoTerreni IN DB_ATTESTAZIONE_DICHIARATA.CODICE_FOTOGRAFIA_TERRENI%TYPE)
RETURN BOOLEAN IS
    nRec INTEGER:=0;
    bRet BOOLEAN:=FALSE;
BEGIN

    SELECT COUNT(ID_ATTESTAZIONE_DICHIARATA)
      INTO nRec
      FROM DB_ATTESTAZIONE_DICHIARATA
     WHERE ID_ATTESTAZIONE = pIdAttestazione
       AND CODICE_FOTOGRAFIA_TERRENI = pCodFotoTerreni
       AND DATA_FINE_VALIDITA IS NULL; 

    IF nRec > 0 THEN
       bRet := TRUE;
    END IF;

    RETURN bRet;
END EsisteAttestazione;


/********************************************************
*** FUNZIONE PER IL CONFRONTO DI DUE STRINGHE
*** INPUT: Stringa, Stringa, tipo di confronto (attualmente 0)
*** OUTPUT: Percentuale di provabilita'
*** NOTA: Se si confrontano denominazioni occorre separare
*** cognome e nome con uno spazio
********************************************************/
FUNCTION confrontaStringhe(var1 VARCHAR2, var2 VARCHAR2, tipo NUMBER)
  RETURN NUMBER IS
 TYPE char_typ IS TABLE OF VARCHAR2(100) INDEX BY BINARY_INTEGER;
 TYPE numb_typ IS TABLE OF NUMBER INDEX BY BINARY_INTEGER;

 a  VARCHAR2(32767);  possibile
 b  VARCHAR2(32767); possibile
 x  VARCHAR2(150);
 l  NUMBER;
 s  numb_typ;
 s1 numb_typ;
 s2 numb_typ;
 t1 char_typ;
 t2 char_typ;
 i  BINARY_INTEGER:=0;
 j  BINARY_INTEGER:=0;
 k  BINARY_INTEGER:=0;
 k1 BINARY_INTEGER;
 k2 BINARY_INTEGER;
 e1 INTEGER;
 e2 INTEGER;
 c1 INTEGER;
 c2 INTEGER;
 c11 INTEGER;
 c21 INTEGER;
 ass INTEGER;
 mf NUMBER:=0;
 mp NUMBER:=0;
 lm NUMBER:=0;
 mfp NUMBER:=0;
 mpp NUMBER:=0;
 lmp NUMBER:=0;
 percentuale1 NUMBER(6,2);
 percentuale2 NUMBER(6,2);

BEGIN

-- se una delle due stringhe passate come parametro per il confronto e' null ritorno 0 come percentuale di comparazione
IF ( var1 IS NULL OR var2 IS NULL ) THEN

    percentuale1 := 0;
    percentuale2 := 0;

ELSE -- altrimenti effettua il confronto

 a:=RTRIM(LTRIM(UPPER(var1)))||' ';
 k:=1;
 s(k):=INSTR(a,'.',1);
 IF s(k)>0 THEN
  LOOP
   k:=k+1;
   s(k):=INSTR(a,'.',s(k-1)+1);
   IF s(k)-s(k-1)=2 THEN
    a:=SUBSTR(a,1,s(k-1)-1)||'@'||SUBSTR(a,s(k-1)+1);
   ELSE
    a:=SUBSTR(a,1,s(k-1)-1)||' '||SUBSTR(a,s(k-1)+1);
   END IF;
   EXIT WHEN s(k)=0;
  END LOOP;
 END IF;
 a:=REPLACE(a,'@','');
-- if a like '%._.%' then
--  a:=replace(a,'.','');
-- else
--  a:=replace(a,'.',' ');
-- end if;
 a:=REPLACE(a,'&','E');
 a:=REPLACE(a,' E ','   ');
 a:=REPLACE(a,' ED ','    ');
 a:=REPLACE(a,'''',' ');
 a:=REPLACE(a,'-',' ');
 a:=REPLACE(a,'"',' ');
 a:=REPLACE(a,',',' ');
 a:=REPLACE(a,'_',' ');
 a:=REPLACE(a,'*',' ');
 a:=REPLACE(a,')',' ');
 a:=REPLACE(a,'(',' ');
 a:=REPLACE(a,'      ',' ');
 a:=REPLACE(a,'     ',' ');
 a:=REPLACE(a,'    ',' ');
 a:=REPLACE(a,'   ',' ');
 a:=REPLACE(a,'  ',' ');
 a:=LTRIM(RTRIM(a));

 b:=RTRIM(LTRIM(UPPER(var2)))||' ';
 k:=1;
 s(k):=INSTR(b,'.',1);
 IF s(k)>0 THEN
  LOOP
   k:=k+1;
   s(k):=INSTR(b,'.',s(k-1)+1);
   IF s(k)-s(k-1)=2 THEN
    b:=SUBSTR(b,1,s(k-1)-1)||'@'||SUBSTR(b,s(k-1)+1);
   ELSE
    b:=SUBSTR(b,1,s(k-1)-1)||' '||SUBSTR(b,s(k-1)+1);
   END IF;
   EXIT WHEN s(k)=0;
  END LOOP;
 END IF;
 b:=REPLACE(b,'@','');
-- if b like '%._.%' then
--  b:=replace(b,'.','');
-- else
--  b:=replace(b,'.',' ');
-- end if;
 b:=REPLACE(b,'&','E');
 b:=REPLACE(b,' E ','   ');
 b:=REPLACE(b,' ED ','    ');
 b:=REPLACE(b,'''',' ');
 b:=REPLACE(b,'-',' ');
 b:=REPLACE(b,'"',' ');
 b:=REPLACE(b,',',' ');
 b:=REPLACE(b,'_',' ');
 b:=REPLACE(b,'*',' ');
 b:=REPLACE(b,')',' ');
 b:=REPLACE(b,'(',' ');
 b:=REPLACE(b,'      ',' ');
 b:=REPLACE(b,'     ',' ');
 b:=REPLACE(b,'    ',' ');
 b:=REPLACE(b,'   ',' ');
 b:=REPLACE(b,'  ',' ');
 b:=LTRIM(RTRIM(b));


-- se una delle due stringhe passate come parametro per il confronto
-- dopo le replace e' null ritorno 0 come percentuale di comparazione
IF ( a IS NULL OR b IS NULL ) THEN
    percentuale1 := 0;
    percentuale2 := 0;
ELSE -- altrimenti fa il resto




 l:=GREATEST(LENGTH(REPLACE(a,' ',NULL)),LENGTH(REPLACE(b,' ',NULL)));
 s1(0):=0;
 s2(0):=0;
 LOOP
  i:=i+1;
  s1(i):=INSTR(a,' ',s1(i-1)+1);
  EXIT WHEN s1(i)=0;
  t1(i):=SUBSTR(a,s1(i-1)+1,s1(i)-s1(i-1)-1);
 END LOOP;
 t1(i):=SUBSTR(a,s1(i-1)+1);
 LOOP
  j:=j+1;
  s2(j):=INSTR(b,' ',s2(j-1)+1);
  EXIT WHEN s2(j)=0;
  t2(j):=SUBSTR(b,s2(j-1)+1,s2(j)-s2(j-1)-1);
 END LOOP;
 t2(j):=SUBSTR(b,s2(j-1)+1);
 FOR k1 IN 1..i-1 LOOP
  FOR k2 IN k1+1..i LOOP
   IF LENGTH(t1(k1))<LENGTH(t1(k2)) THEN
    x:=t1(k1);
    t1(k1):=t1(k2);
    t1(k2):=x;
   END IF;
  END LOOP;
 END LOOP;
 FOR k1 IN 1..j-1 LOOP
  FOR k2 IN k1+1..j LOOP
   IF LENGTH(t2(k1))<LENGTH(t2(k2)) THEN
    x:=t2(k1);
    t2(k1):=t2(k2);
    t2(k2):=x;
   END IF;
  END LOOP;
 END LOOP;
 IF i > j OR (i = j AND LENGTH(a) >= LENGTH(b)) THEN
  FOR k1 IN 1..i LOOP
   mfp := 0;
   mpp := 0;
   lmp := 0;
   e1:=0;
   e2:=0;
   c11:=0;
   c21:=0;
   FOR k2 IN 1..j LOOP
    IF t1(k1)=t2(k2) THEN
     mfp:=1;
     mpp:=0;
     lmp:=LENGTH(t1(k1));
     e1:=k1;
     e2:=k2;
     ass:=0;
    ELSIF INSTR(t2(k2),t1(k1),1)>0 AND LENGTH(t1(k1))>lmp THEN
     lmp:=LENGTH(t1(k1));
     mpp:=lmp/(LENGTH(t2(k2))+0.5);
     e1:=k1;
     e2:=k2;
     ass:=1;
    ELSIF INSTR(t1(k1),t2(k2),1)>0 AND LENGTH(t2(k2))>lmp THEN
     lmp:=LENGTH(t2(k2));
     mpp:=lmp/(LENGTH(t1(k1))+0.5);
     e1:=k1;
     e2:=k2;
     ass:=0;
    ELSIF SOUNDEX(t1(k1))=SOUNDEX(t2(k2)) AND
          LEAST(LENGTH(t1(k1)),LENGTH(t2(k2)))>lmp THEN
     lmp:=LEAST(LENGTH(t1(k1)),LENGTH(t2(k2)));
     mpp:=lmp/GREATEST(LENGTH(t1(k1)),LENGTH(t2(k2)));
     e1:=k1;
     e2:=k2;
     ass:=0;
    ELSE
     c1:=0;
     LOOP
      EXIT WHEN (SUBSTR(t1(k1),1,c1+1)!=SUBSTR(t2(k2),1,c1+1) OR
                 c1=LEAST(LENGTH(t1(k1)),LENGTH(t2(k2))));
      c1:=c1+1;
     END LOOP;
     c2:=0;
     LOOP
      EXIT WHEN (SUBSTR(t1(k1),-c2-1,c2+1)!=SUBSTR(t2(k2),-c2-1,c2+1) OR
                 c2=LEAST(LENGTH(t1(k1)),LENGTH(t2(k2))));
      c2:=c2+1;
     END LOOP;
     IF c1+c2>lmp                                                      AND
        ((c1+c2>=GREATEST(LENGTH(t1(k1)),LENGTH(t2(k2))) / 2 AND c1+c2>1) OR
         c1+c2>3)                                                      THEN
      lmp:=LEAST(c1+c2,LENGTH(t1(k1)),LENGTH(t2(k2)));
      mpp:=lmp/(GREATEST(LENGTH(t1(k1)),LENGTH(t2(k2)))+1);
      e1:=k1;
      e2:=k2;
      ass:=2;
      c11:=c1;
      c21:=c2;
     END IF;
    END IF;
   END LOOP;
   IF e1>0 AND e2>0 AND ass=1 THEN
    t2(e2):=REPLACE(t2(e2),t1(e1),LPAD(' ',LENGTH(t1(e1)),' '));
    t2(e2):=NVL(LTRIM(RTRIM(t2(e2))),LPAD(' ',LENGTH(t2(e2)),' '));
   ELSIF e1>0 AND e2>0 AND ass=0 THEN
    t2(e2):=LPAD(' ',LENGTH(t2(e2)),' ');
   ELSIF e1>0 AND e2>0 AND ass=2 THEN
    IF c11>0 THEN
     t2(e2):=LPAD(' ',c11,' ')||SUBSTR(t2(e2),c11+1);
    END IF;
    IF c21>0 THEN
     t2(e2):=SUBSTR(t2(e2),1,LENGTH(t2(e2))-c21)||LPAD(' ',c21,' ');
    END IF;
    t2(e2):=NVL(LTRIM(RTRIM(t2(e2))),LPAD(' ',LENGTH(t2(e2)),' '));
   END IF;
   mf:=mf+mfp;
   mp:=mp+mpp;
   lm:=lm+lmp;
  END LOOP;
 ELSE
  FOR k2 IN 1..j LOOP
   mfp := 0;
   mpp := 0;
   lmp := 0;
   e1:=0;
   e2:=0;
   c11:=0;
   c21:=0;
   FOR k1 IN 1..i LOOP
    IF t1(k1)=t2(k2) THEN
     mfp:=1;
     mpp:=0;
     lmp:=LENGTH(t1(k1));
     e1:=k1;
     e2:=k2;
     ass:=0;
    ELSIF INSTR(t1(k1),t2(k2),1)>0 AND LENGTH(t2(k2))>lmp THEN
     lmp:=LENGTH(t2(k2));
     mpp:=lmp/(LENGTH(t1(k1))+0.5);
     e1:=k1;
     e2:=k2;
     ass:=1;
    ELSIF INSTR(t2(k2),t1(k1),1)>0 AND LENGTH(t1(k1))>lmp THEN
     lmp:=LENGTH(t1(k1));
     mpp:=lmp/(LENGTH(t2(k2))+0.5);
     e1:=k1;
     e2:=k2;
     ass:=0;
    ELSIF SOUNDEX(t1(k1))=SOUNDEX(t2(k2)) AND
          LEAST(LENGTH(t1(k1)),LENGTH(t2(k2)))>lmp THEN
     lmp:=LEAST(LENGTH(t1(k1)),LENGTH(t2(k2)));
     mpp:=lmp/GREATEST(LENGTH(t1(k1)),LENGTH(t2(k2)));
     e1:=k1;
     e2:=k2;
     ass:=0;
    ELSE
     c1:=0;
     LOOP
      EXIT WHEN (SUBSTR(t1(k1),1,c1+1)!=SUBSTR(t2(k2),1,c1+1) OR
                 c1=LEAST(LENGTH(t1(k1)),LENGTH(t2(k2))));
      c1:=c1+1;
     END LOOP;
     c2:=0;
     LOOP
      EXIT WHEN (SUBSTR(t1(k1),-c2-1,c2+1)!=SUBSTR(t2(k2),-c2-1,c2+1) OR
                 c2=LEAST(LENGTH(t1(k1)),LENGTH(t2(k2))));
      c2:=c2+1;
     END LOOP;
     IF c1+c2>lmp                                                      AND
        ((c1+c2>=GREATEST(LENGTH(t1(k1)),LENGTH(t2(k2))) / 2 AND c1+c2>1) OR
         c1+c2>3)                                                      THEN
      lmp:=LEAST(c1+c2,LENGTH(t1(k1)),LENGTH(t2(k2)));
      mpp:=lmp/(GREATEST(LENGTH(t1(k1)),LENGTH(t2(k2)))+1);
      e1:=k1;
      e2:=k2;
      ass:=2;
      c11:=c1;
      c21:=c2;
     END IF;
    END IF;
   END LOOP;
   IF e1>0 AND e2>0 AND ass=1 THEN
    t1(e1):=REPLACE(t1(e1),t2(e2),LPAD(' ',LENGTH(t2(e2)),' '));
    t1(e1):=NVL(LTRIM(RTRIM(t1(e1))),LPAD(' ',LENGTH(t1(e1)),' '));
   ELSIF e1>0 AND e2>0 AND ass=0 THEN
    t1(e1):=LPAD(' ',LENGTH(t1(e1)),' ');
   ELSIF e1>0 AND e2>0 AND ass=2 THEN
    IF c11>0 THEN
     t1(e1):=LPAD(' ',c11,' ')||SUBSTR(t1(e1),c11+1);
    END IF;
    IF c21>0 THEN
     t1(e1):=SUBSTR(t1(e1),1,LENGTH(t1(e1))-c21)||LPAD(' ',c21,' ');
    END IF;
    t1(e1):=NVL(LTRIM(RTRIM(t1(e1))),LPAD(' ',LENGTH(t1(e1)),' '));
   END IF;
   mf:=mf+mfp;
   mp:=mp+mpp;
   lm:=lm+lmp;
  END LOOP;
 END IF;
 IF mf=LEAST(i,j) THEN
  percentuale1:=100;
 ELSE
  percentuale1:=(mf+mp)/GREATEST(i,j)*100;
 END IF;
 percentuale2:=lm/l*100;
END IF; -- fine controllo se a o b sono null

END IF; -- fine controllo se var1 o var2 sono null

 RETURN GREATEST(percentuale1,percentuale2);

END confrontaStringhe;

   /*********************************************************************
    Dato un ID_AZIENDA, un ID_PROCEDIMENTO, ed il flag protocollata (TRUE/FALSE)
    ricerco l'ultima dichiarazione dell'azienda per motivi non da escludere
    per il procedimento in input, filtrando per protocollata o meno
    a seconda della booleana
    Tipo:   function
    input:  pIdAzienda, pIdProcedimento, bProtocollata
    output: nessuno
    ritorno: DB_DICHIARAZIONE_CONSISTENZA
    *********************************************************************/
    FUNCTION SelectLastDichConsistenza (pIdAzienda      IN DB_DICHIARAZIONE_CONSISTENZA.ID_AZIENDA%TYPE,
                                        pIdProcedimento IN DB_PROCEDIMENTO_AZIENDA.ID_PROCEDIMENTO%TYPE,
                                        bProtocollata   IN BOOLEAN )
    RETURN DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE IS

        recTDichConsistenza DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE;

    BEGIN

        IF bProtocollata THEN

            SELECT *
              INTO recTDichConsistenza
              FROM DB_DICHIARAZIONE_CONSISTENZA
             WHERE id_azienda = pIdAzienda
               AND DATA = (SELECT MAX (DATA)
                             FROM DB_DICHIARAZIONE_CONSISTENZA DC
                            WHERE ID_AZIENDA = pIdAzienda
                              AND DATA_PROTOCOLLO IS NOT NULL
                              AND NUMERO_PROTOCOLLO IS NOT NULL
                              AND ID_MOTIVO_DICHIARAZIONE NOT IN
                             (SELECT ID_MOTIVO_DICHIARAZIONE
                                FROM DB_MOTIVO_ESCLUSO_PROCEDIMENTO
                               WHERE ID_PROCEDIMENTO = pIdProcedimento));

        ELSE

            SELECT *
              INTO recTDichConsistenza
              FROM DB_DICHIARAZIONE_CONSISTENZA
             WHERE id_azienda = pIdAzienda
               AND DATA = (SELECT MAX (DATA)
                             FROM DB_DICHIARAZIONE_CONSISTENZA DC
                            WHERE ID_AZIENDA = pIdAzienda
                              AND ID_MOTIVO_DICHIARAZIONE NOT IN
                             (SELECT ID_MOTIVO_DICHIARAZIONE
                                FROM DB_MOTIVO_ESCLUSO_PROCEDIMENTO
                               WHERE ID_PROCEDIMENTO = pIdProcedimento));

        END IF;

        RETURN recTDichConsistenza;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelectLastDichConsistenza;

FUNCTION IS_NUMERIC (P_NUMERO       IN  VARCHAR2,
                   P_NUMERICO      OUT NUMBER) RETURN BOOLEAN IS

BEGIN

  P_NUMERICO         := TO_NUMBER(P_NUMERO);

  RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
 RETURN (FALSE);

END IS_NUMERIC;

FUNCTION fncEstraiConsonanti( parString IN     VARCHAR2,
                               P_CODERR       OUT VARCHAR2,
                              P_MSGERR       OUT VARCHAR2 ) RETURN VARCHAR2 IS
j          INTEGER      := 1;
tmp        DB_PERSONA_FISICA.cognome%TYPE := '';
BEGIN
    -- Conta le consonanti
    WHILE j <= ( LENGTH(parString) )  LOOP
      IF INSTR(consonanti, SUBSTR(parString,j,1) ) != 0 THEN
        tmp := tmp || SUBSTR(parString,j,1);
      END IF;
      j := j + 1;
    END LOOP;
    RETURN tmp;
EXCEPTION
  WHEN OTHERS THEN
      -- Error on Function
      P_CODERR := TO_CHAR(SQLCODE);
      P_MSGERR := SQLERRM;
END fncEstraiConsonanti;

FUNCTION fncEstraiVocali( parString IN     VARCHAR2,
                           P_CODERR       OUT VARCHAR2,
                          P_MSGERR       OUT VARCHAR2 ) RETURN VARCHAR2 IS
j      INTEGER      := 1;
tmp    DB_PERSONA_FISICA.cognome%TYPE := '';
BEGIN
    -- Conta le vocali
    WHILE j <= ( LENGTH(parString) )  LOOP
      IF INSTR(vocali, SUBSTR(parString,j,1) ) != 0 THEN
        tmp := tmp || SUBSTR(parString,j,1);
      END IF;
      j := j + 1;
    END LOOP;
    RETURN tmp;
EXCEPTION
  WHEN OTHERS THEN
      -- Error on Function
      P_CODERR := TO_CHAR(SQLCODE);
      P_MSGERR := SQLERRM;
END fncEstraiVocali;


----------------------------------------------------------------------
-- Function Controlla Codice Provincia
----------------------------------------------------------------------
FUNCTION fncControllaProvincia( parProvincia VARCHAR2 ) RETURN BOOLEAN IS
  wCodiceProvincia VARCHAR2(3) := '';
  rc               BOOLEAN     := FALSE;
BEGIN

  IF parProvincia IS NULL THEN
     rc := FALSE;
  ELSE
     wCodiceProvincia := trim( parProvincia );

     BEGIN
        SELECT p.istat_provincia
        INTO   wCodiceProvincia
        FROM   PROVINCIA p
        WHERE  p.sigla_provincia = wCodiceProvincia;
        rc := TRUE;
     EXCEPTION
        WHEN OTHERS THEN
          rc := FALSE;
     END;
      rc := TRUE;
  END IF;

  RETURN rc;
EXCEPTION
  WHEN OTHERS THEN
    -- Error on Function
    err_num := TO_CHAR(SQLCODE);
    err_msg := SUBSTR(SQLERRM, 1, 100);
    DBMS_OUTPUT.PUT_LINE('Errore su fncControllaProvincia: (' || err_num || ') ' || err_msg );
END fncControllaProvincia;


----------------------------------------------------------------------
-- Function Controlla Codice Comune: verifica l'esistenza del cod. ISTAT comune
----------------------------------------------------------------------
FUNCTION fncControllaComune( parComune VARCHAR2 ) RETURN BOOLEAN IS
  wCodiceComune    VARCHAR2(6) := '';
  rc               BOOLEAN     := FALSE;
  PAR_NULL           EXCEPTION;
BEGIN

   IF parComune IS NULL THEN
      RAISE PAR_NULL;
   END IF;

   wCodiceComune := trim( parComune );

   BEGIN
     SELECT c.istat_comune
     INTO   wCodiceComune
     FROM   COMUNE c
     WHERE  c.istat_comune = wCodiceComune;
     rc := TRUE;
   EXCEPTION
     WHEN OTHERS THEN
       rc := FALSE;
   END;

RETURN rc;

EXCEPTION
  WHEN PAR_NULL THEN
    RETURN FALSE;

  WHEN OTHERS THEN
    -- Error on Function
    err_num := TO_CHAR(SQLCODE);
    err_msg := SUBSTR(SQLERRM, 1, 100);
    DBMS_OUTPUT.PUT_LINE('Errore su fncControllaProvincia: (' || err_num || ') ' || err_msg );
    RETURN FALSE;
END fncControllaComune;



FUNCTION fncCheckDigit( parCUAA DB_ANAGRAFICA_AZIENDA.cuaa%TYPE DEFAULT NULL ) RETURN BOOLEAN IS
  set1    VARCHAR2(36) := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  set2    VARCHAR2(36) := 'ABCDEFGHIJABCDEFGHIJKLMNOPQRSTUVWXYZ';
  setpari VARCHAR2(26) := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
  setdisp VARCHAR2(26) := 'BAKPLCQDREVOSFTGUHMINJWZYX';
  j       INTEGER      := 0;
  tmp     INTEGER      := 0;
  rc      BOOLEAN      := FALSE;
BEGIN

  result  := 0;
  result2 := 0;

  IF LENGTH( parCUAA ) = clenPIVA THEN
    -- Case A) It's Partita IVA
    j := 1;
    WHILE j <= (clenPIVA - 1) LOOP
      result := result + ( ASCII( SUBSTR(parCUAA,j,1) ) - ASCII('0') );
      j := j + 2;
    END LOOP;

    j := 2;
    WHILE j <= (clenPIVA - 1) LOOP
      result2 := 2 * ( ASCII( SUBSTR(parCUAA,j,1) ) - ASCII('0') );
      IF result2 > 9 THEN
        result2 := result2 - 9;
      END IF;
      result := result + result2;
      j := j + 2;
    END LOOP;
    IF MOD(10 - MOD(result,10),10) != ( ASCII( SUBSTR(parCUAA,clenPIVA,1) ) - ASCII('0') ) THEN
      rc := FALSE; -- It's incorrect
    ELSE
      rc := TRUE; -- It's correct
    END IF;

  ELSIF LENGTH( parCUAA ) = clenCF THEN
    -- Case B) It's Codice Fiscale
    j := 2;
    WHILE j <= (clenCF -1) LOOP
      tmp   := INSTR(setpari , SUBSTR(set2, INSTR(set1, SUBSTR(parCUAA,j,1) ),1) ) -1;
      result := result + tmp;
      j := j + 2;
    END LOOP;

    j := 1;
    WHILE j <= (clenCF - 1)  LOOP
      tmp   := INSTR(setdisp , SUBSTR(set2, INSTR(set1, SUBSTR(parCUAA,j,1) ),1) ) -1;
      result := result + tmp;
      j := j + 2;
    END LOOP;

    IF MOD(result,26) = ( ASCII( SUBSTR(parCUAA,16,1) ) - ASCII('A') ) THEN
      rc := TRUE; -- It's correct
    ELSE
      -- It's incorrect
      rc := FALSE;
    END IF;
  ELSE
    -- Case C) What's this?!?
    rc := FALSE;
  END IF;

  RETURN rc;
EXCEPTION
  WHEN OTHERS THEN
    -- Error on Function
    err_num := TO_CHAR(SQLCODE);
    err_msg := SUBSTR(SQLERRM, 1, 100);
    DBMS_OUTPUT.PUT_LINE('Errore su fncCtrlCUAAChkDgt: (' || err_num || ') ' || err_msg );
END fncCheckDigit;


----------------------------------------------------------------------
-- Function Check Codice Fiscale
----------------------------------------------------------------------
FUNCTION fncCodiceFiscale(
   tmp_codice_fiscale DB_PERSONA_FISICA.codice_fiscale%TYPE
  ,tmp_cognome        IN OUT DB_PERSONA_FISICA.cognome%TYPE
  ,tmp_nome           DB_PERSONA_FISICA.nome%TYPE
  ,tmp_nascita_comune DB_PERSONA_FISICA.nascita_comune%TYPE
  ,tmp_nascita_data   DB_PERSONA_FISICA.nascita_data%TYPE
  ,tmp_sesso          DB_PERSONA_FISICA.sesso%TYPE
) RETURN BOOLEAN IS

  tmp                VARCHAR2(16) := '';
  cf_cognome         VARCHAR2(50) := '';
  cf_nome            VARCHAR2(50) := '';
  cf_anno            VARCHAR2(2)  := '';
  cf_mese            VARCHAR2(2)  := '';
  cf_giornoU         VARCHAR2(2)  := '';
  cf_giornoD         VARCHAR2(2)  := '';
  cf_comune          VARCHAR2(4)  := '';
  rc                 BOOLEAN      := FALSE;
  n_NUMERO              NUMBER(3);

  vCodErr VARCHAR2(1000);
  vCodMsg VARCHAR2(1000);

BEGIN

tmp        := '';

-- Determina il Cognome
tmp_cognome := REPLACE(tmp_cognome,'''','');
cf_cognome := SUBSTR(fncEstraiconsonanti(tmp_cognome, vCodErr, vCodMsg),1,3);
IF LENGTH(cf_cognome) > 2 THEN
  -- Case A) Il cognome presenta tre o più consonanti: in tal caso i primi tre caratteri
  -- del codice fiscale saranno le prime tre consonanti del cognome, prese nell'ordine.
  -- Ad esempio PALUMBO diviene PLM, COVINO diciene CVN etc.
  tmp := SUBSTR(cf_cognome,1,3);
ELSIF LENGTH(cf_cognome) = 2 AND LENGTH(tmp_cognome) > 2 THEN
  -- Case B) Il cognome presenta solo due consonanti ed è composto da almeno tre lettere:
  -- in tal caso si considereranno, nell'ordine, le due consonanti e la prima vocale del
  -- cognome. Ad esempio GORI diviene GRO, LIETO diviene LTI, etc.
  tmp := cf_cognome || SUBSTR( fncEstraiVocali(tmp_cognome, vCodErr, vCodMsg),1,1) ;
ELSIF LENGTH(cf_cognome) = 1 AND LENGTH(tmp_cognome) > 2 THEN
  -- Case C) Il cognome presenta una sola consonante ed è composto da almeno tre lettere:
  -- in tal caso si considereranno, nell'ordine, l'unica consonante e le prime due vocali
  -- del cognome. Ad esempio, ALEA diviene LAE, MAIO diviene MAI, etc.
  tmp := cf_cognome || SUBSTR( fncEstraiVocali(tmp_cognome, vCodErr, vCodMsg),1,2);
  --    elsif length(cf_cognome) = 0 then
ELSIF cf_cognome IS NULL THEN
  -- Case D) Il cognome non contiene consonanti: in tal caso si considerano, nell'ordine,
  -- le prime tre vocali del cognome e, qualora queste fossero meno di tre, si completa con
  -- tante X quante ne mancano (ovviamente, a meno di cognomi di una sola lettera - ipotesi
  -- abbastanza scartabile - di X ne occorrerà una sola). Ad esempio AIUOA diviene AIU, AO
  -- diviene AOX, etc.
  tmp := SUBSTR( fncEstraiVocali(tmp_cognome, vCodErr, vCodMsg) || filler ,1,3);
ELSIF LENGTH(tmp_cognome) < 3 THEN
  -- Case E) Il cognome è composto da meno di tre lettere: in tal caso si considereranno,
  -- nell'ordine, le eventuali consonanti, le eventuali vocali e tante X quante ne occorrono
  -- per avere tre caratteri (ovviamente, a meno di cognomi d'una sola lettera - ipotesi
  -- abbastanza scartabile - di X ne occorrerà una sola). Ad esempio, RE diviene REX, IH
  -- diviene HIX, etc.
  tmp := SUBSTR( cf_cognome || fncEstraiVocali(tmp_cognome, vCodErr, vCodMsg) || FILLER ,1, 3);
ELSE
  -- Case F) What's this?!?
  tmp := filler;
END IF;

cf_cognome := tmp;

-- Determina il Nome
cf_nome := fncEstraiconsonanti(tmp_nome, vCodErr, vCodMsg);
IF LENGTH(cf_nome) > 3 THEN
  -- Case A) Il nome presenta almeno quattro consonanti: in tal caso si considerano,
  -- nell'ordine, la prima, la terza e la quarta consonante.
  -- Ad esempio BARBARA diviene BBR.
  tmp := SUBSTR(cf_nome,1,1) || SUBSTR(cf_nome,3,1) || SUBSTR(cf_nome,4,1);
ELSIF LENGTH(cf_nome) = 3 THEN
  -- Case B) Il nome presenta tre consonanti: in tal caso si considerano le tre consonanti
  -- ordinatamente. Ad esempio SERGIO diviene SRG.
  tmp := SUBSTR(cf_nome,1,3);
ELSIF LENGTH(cf_nome) = 2 AND LENGTH(tmp_nome) > 2 THEN
  -- Case C) Il nome presenta due consonanti ed è composto da almeno tre lettere:
  -- in tal caso si considerano le due consonanti ordinatamente e poi la prima vocale.
  tmp := cf_nome || SUBSTR( fncEstraiVocali(tmp_nome, vCodErr, vCodMsg) ,1,1) ;
ELSIF LENGTH(cf_nome) = 1 AND LENGTH(tmp_nome) > 2 THEN
  -- Case D) Il nome presenta una consonante ed è composto da almeno tre lettere:
  -- in tal caso si considera l'unica consonante seguita dalle prime due vocali.
  tmp := cf_nome || SUBSTR( fncEstraiVocali(tmp_nome, vCodErr, vCodMsg) ,1,2) ;
--    elsif length(cf_nome) = 0 then
ELSIF cf_nome IS NULL THEN
  -- Case E) Il nome non contiene consonanti: in tal caso si considerano, nell'ordine,
  -- le prime tre vocali del nome e, qualora queste fossero meno di tre, si
  -- completa con tante X quante ne mancano (ovviamente, a meno di cognomi di
  -- una sola lettera - ipotesi abbastanza scartabile - di X ne occorrerà una sola).
  tmp := SUBSTR( fncEstraiVocali(tmp_nome, vCodErr, vCodMsg) || filler,1,3);
ELSIF LENGTH(tmp_nome) < 3 THEN
  -- Case F) Il nome è composto da meno di tre lettere: in tal caso si considereranno,
  -- nell'ordine, le eventuali consonanti, le eventuali vocali e tante X quante
  -- ne occorrono per avere tre caratteri (ovviamente, a meno di nomi d'una sola
  -- lettera - ipotesi abbastanza scartabile - di X ne occorrerà una sola).
  tmp := SUBSTR( cf_nome || fncEstraiVocali(tmp_nome, vCodErr, vCodMsg) || filler ,1,3);
ELSE
  -- Case G) What's this?!?
  tmp := filler;
END IF;

cf_nome := tmp;

-- Determina Anno
cf_anno := TO_CHAR(tmp_nascita_data,'YY');

-- Determina Mese
SELECT DECODE( TO_CHAR(tmp_nascita_data,'MM') , '01','A','02','B','03','C','04','D','05','E','06','H','07','L','08','M','09','P','10','R','11','S','12','T')
INTO   cf_mese
FROM   dual;

-- Determina Giorno
cf_giornoU := TO_CHAR(tmp_nascita_data,'DD');

-- Determina Giorno Donna
cf_giornoD := TO_CHAR( TO_NUMBER(TO_CHAR(tmp_nascita_data,'DD')) + 40 );

-- Determina Comune
BEGIN
  SELECT c.codfisc
  INTO   cf_comune
  FROM COMUNE c
  WHERE c.istat_comune = tmp_nascita_comune;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    cf_comune := filler;
  WHEN OTHERS THEN
    err_num := TO_CHAR(SQLCODE);
    err_msg := SUBSTR(SQLERRM, 1, 100);
    DBMS_OUTPUT.PUT_LINE('Errore su fncCodiceFiscale COMUNE: (' || err_num || ') ' || err_msg );
END;

--- il codice fiscale deve essere controllato a pezzi in quanto in caso di doppioni
--- al posto dei numeri vengono messe delle lettere. 23/01/2004

IF SUBSTR(tmp_codice_fiscale,1,3) <> cf_cognome THEN
   RETURN (FALSE);
END IF;

IF SUBSTR(tmp_codice_fiscale,4,3) <> cf_nome THEN
  RETURN (FALSE);
END IF;

IF IS_NUMERIC (SUBSTR(tmp_codice_fiscale,7,2), n_NUMERO) THEN
   IF n_numero <> cf_anno THEN
     RETURN (FALSE);
   END IF;
END IF;

IF SUBSTR(tmp_codice_fiscale,9,1) <> cf_mese THEN
  RETURN (FALSE);
END IF;

IF IS_NUMERIC (SUBSTR(tmp_codice_fiscale,10,2), n_NUMERO) THEN
 IF n_numero > 40 THEN --- donna
    IF n_numero <> cf_giornoD THEN
         RETURN (FALSE);
    END IF;
         ELSE -- uomo
    IF n_numero <> cf_giornoU THEN
         RETURN (FALSE);
    END IF;
 END IF;
END IF;

IF SUBSTR(tmp_codice_fiscale,12,1) <> SUBSTR(cf_comune,1,1) THEN  --prima lettere del codice belfiore
   RETURN (FALSE);
END IF;

IF IS_NUMERIC (SUBSTR(tmp_codice_fiscale,13,3), n_NUMERO) THEN
   IF n_numero <> SUBSTR(cf_comune,2,3) THEN
     RETURN (FALSE);
   END IF;
END IF;

RETURN (TRUE);


EXCEPTION
  WHEN OTHERS THEN
    -- Error on Function
    err_num := TO_CHAR(SQLCODE);
    err_msg := SUBSTR(SQLERRM, 1, 100);
    DBMS_OUTPUT.PUT_LINE('Errore su fncCodiceFiscale: (' || err_num || ') ' || err_msg );
END fncCodiceFiscale;



FUNCTION fncMessaggioErrore(p_id_err INTEGER) RETURN VARCHAR2 IS
  vErrMsg DB_MESSAGGIO_ERRORE.descrizione%TYPE;

BEGIN
   -- Preleva la descrizione dell'errore dalla tabella db_messaggio_errore
   --
   SELECT descrizione INTO vErrMsg
   FROM DB_MESSAGGIO_ERRORE
   WHERE id_messaggio_errore = p_id_err;

   RETURN vErrMsg;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
     RETURN 'Errore non classificato su db_messaggio_errore ' || TO_CHAR(p_id_err) ;

  WHEN TOO_MANY_ROWS THEN
     RETURN 'Più di un record su db_messaggio_errore corrisponde a id: ' || TO_CHAR(p_id_err) ;

  WHEN OTHERS THEN
     RETURN 'Si è verificato un errore in fncMessaggioErrore; id: ' || TO_CHAR(p_id_err) ;

END fncMessaggioErrore;



FUNCTION PER01(p_cognome          IN  DB_PERSONA_FISICA.cognome%TYPE,
                   p_nome              IN  DB_PERSONA_FISICA.nome%TYPE,
                 p_nascita_data   IN  DB_PERSONA_FISICA.nascita_data%TYPE,
                 p_nascita_comune IN  DB_PERSONA_FISICA.nascita_comune%TYPE,
                 p_codice_fiscale IN  DB_PERSONA_FISICA.codice_fiscale%TYPE,
                 p_result          IN  OUT VARCHAR2,
                 p_msg            IN  OUT VARCHAR2,
                 p_id_err         OUT NUMBER)

RETURN BOOLEAN IS

tmp                VARCHAR2(16) := '';
cf_cognome         VARCHAR2(50) := '';
cf_nome            VARCHAR2(50) := '';
cf_anno            VARCHAR2(2)  := '';
cf_mese            VARCHAR2(2)  := '';
cf_giornoU         VARCHAR2(2)  := '';
cf_giornoD         VARCHAR2(2)  := '';
cf_comune          VARCHAR2(4)  := '';
rc                 BOOLEAN      := FALSE;
n_NUMERO           NUMBER(3);

ERR_DATI EXCEPTION;

BEGIN
    tmp        := '';

    -- Determina il Cognome
    cf_cognome := SUBSTR(fncEstraiconsonanti(P_COGNOME,p_result, p_msg),1,3);
    IF LENGTH(cf_cognome) > 2 THEN
      -- Case A) Il cognome presenta tre o più consonanti: in tal caso i primi tre caratteri
      -- del codice fiscale saranno le prime tre consonanti del cognome, prese nell'ordine.
      -- Ad esempio PALUMBO diviene PLM, COVINO diciene CVN etc.
      tmp := SUBSTR(cf_cognome,1,3);
    ELSIF LENGTH(cf_cognome) = 2 AND LENGTH(P_COGNOME) > 2 THEN
      -- Case B) Il cognome presenta solo due consonanti ed è composto da almeno tre lettere:
      -- in tal caso si considereranno, nell'ordine, le due consonanti e la prima vocale del
      -- cognome. Ad esempio GORI diviene GRO, LIETO diviene LTI, etc.
      tmp := cf_cognome || SUBSTR( fncEstraiVocali(P_COGNOME,p_result, p_msg),1,1) ;
    ELSIF LENGTH(cf_cognome) = 1 AND LENGTH(P_cognome) > 2 THEN
      -- Case C) Il cognome presenta una sola consonante ed è composto da almeno tre lettere:
      -- in tal caso si considereranno, nell'ordine, l'unica consonante e le prime due vocali
      -- del cognome. Ad esempio, ALEA diviene LAE, MAIO diviene MAI, etc.
      tmp := cf_cognome || SUBSTR( fncEstraiVocali(P_cognome,p_result, p_msg),1,2);
--    elsif length(cf_cognome) = 0 then
    ELSIF cf_cognome IS NULL THEN
      -- Case D) Il cognome non contiene consonanti: in tal caso si considerano, nell'ordine,
      -- le prime tre vocali del cognome e, qualora queste fossero meno di tre, si completa con
      -- tante X quante ne mancano (ovviamente, a meno di cognomi di una sola lettera - ipotesi
      -- abbastanza scartabile - di X ne occorrerà una sola). Ad esempio AIUOA diviene AIU, AO
      -- diviene AOX, etc.
      tmp := SUBSTR( fncEstraiVocali(P_cognome,p_result, p_msg) || filler ,1,3);
    ELSIF LENGTH(P_cognome) < 3 THEN
      -- Case E) Il cognome è composto da meno di tre lettere: in tal caso si considereranno,
      -- nell'ordine, le eventuali consonanti, le eventuali vocali e tante X quante ne occorrono
      -- per avere tre caratteri (ovviamente, a meno di cognomi d'una sola lettera - ipotesi
      -- abbastanza scartabile - di X ne occorrerà una sola). Ad esempio, RE diviene REX, IH
      -- diviene HIX, etc.
      tmp := SUBSTR( cf_cognome || fncEstraiVocali(P_cognome,p_result, p_msg) || FILLER ,1, 3);
    ELSE
      -- Case F) What's this?!?
      tmp := filler;
    END IF;

    cf_cognome := tmp;

    -- Determina il Nome
    cf_nome := fncEstraiconsonanti(P_nome,p_result, p_msg);
    IF LENGTH(cf_nome) > 3 THEN
      -- Case A) Il nome presenta almeno quattro consonanti: in tal caso si considerano,
      -- nell'ordine, la prima, la terza e la quarta consonante.
      -- Ad esempio BARBARA diviene BBR.
      tmp := SUBSTR(cf_nome,1,1) || SUBSTR(cf_nome,3,1) || SUBSTR(cf_nome,4,1);
    ELSIF LENGTH(cf_nome) = 3 THEN
      -- Case B) Il nome presenta tre consonanti: in tal caso si considerano le tre consonanti
      -- ordinatamente. Ad esempio SERGIO diviene SRG.
      tmp := SUBSTR(cf_nome,1,3);
    ELSIF LENGTH(cf_nome) = 2 AND LENGTH(P_nome) > 2 THEN
      -- Case C) Il nome presenta due consonanti ed è composto da almeno tre lettere:
      -- in tal caso si considerano le due consonanti ordinatamente e poi la prima vocale.
      tmp := cf_nome || SUBSTR( fncEstraiVocali(P_nome,p_result, p_msg) ,1,1) ;
    ELSIF LENGTH(cf_nome) = 1 AND LENGTH(P_nome) > 2 THEN
      -- Case D) Il nome presenta una consonante ed è composto da almeno tre lettere:
      -- in tal caso si considera l'unica consonante seguita dalle prime due vocali.
      tmp := cf_nome || SUBSTR( fncEstraiVocali(P_nome,p_result, p_msg) ,1,2) ;
--    elsif length(cf_nome) = 0 then
    ELSIF cf_nome IS NULL THEN
      -- Case E) Il nome non contiene consonanti: in tal caso si considerano, nell'ordine,
      -- le prime tre vocali del nome e, qualora queste fossero meno di tre, si
      -- completa con tante X quante ne mancano (ovviamente, a meno di cognomi di
      -- una sola lettera - ipotesi abbastanza scartabile - di X ne occorrerà una sola).
      tmp := SUBSTR( fncEstraiVocali(P_nome,p_result, p_msg) || filler,1,3);
    ELSIF LENGTH(P_nome) < 3 THEN
      -- Case F) Il nome è composto da meno di tre lettere: in tal caso si considereranno,
      -- nell'ordine, le eventuali consonanti, le eventuali vocali e tante X quante
      -- ne occorrono per avere tre caratteri (ovviamente, a meno di nomi d'una sola
      -- lettera - ipotesi abbastanza scartabile - di X ne occorrerà una sola).
      tmp := SUBSTR( cf_nome || fncEstraiVocali(P_nome,p_result, p_msg) || filler ,1,3);
    ELSE
      -- Case G) What's this?!?
      tmp := filler;
    END IF;

    cf_nome := tmp;

    -- Determina Anno
    cf_anno := TO_CHAR(P_nascita_data,'YY');

    -- Determina Mese
    SELECT DECODE( TO_CHAR(P_nascita_data,'MM') , '01','A','02','B','03','C','04','D','05','E','06','H','07','L','08','M','09','P','10','R','11','S','12','T')
    INTO   cf_mese
    FROM   dual;

    -- Determina Giorno
    cf_giornoU := TO_CHAR(P_nascita_data,'DD');

    -- Determina Giorno Donna
    cf_giornoD := TO_CHAR( TO_NUMBER(TO_CHAR(P_nascita_data,'DD')) + 40 );

    -- Determina Comune
    BEGIN
      SELECT c.codfisc
      INTO   cf_comune
      FROM COMUNE c
      WHERE c.istat_comune = P_nascita_comune;
    EXCEPTION
      WHEN NO_DATA_FOUND THEN
        cf_comune := filler;
      WHEN OTHERS THEN
        RAISE ERR_DATI;
--        P_CODERR := to_char(sqlcode);
--        P_MSGERR := sqlerrm;
--         p_id_err := 1;
--        dbms_output.put_line('Errore su fncCodiceFiscale COMUNE: (' || err_num || ') ' || err_msg );
    END;

    --- il codice fiscale deve essere controllato a pezzi in quanto in caso di doppioni
    --- al posto dei numeri vengono messe delle lettere. 23/01/2004

     IF SUBSTR(P_codice_fiscale,1,3) <> cf_cognome THEN
         RETURN (FALSE);
     END IF;

      IF SUBSTR(P_codice_fiscale,4,3) <> cf_nome THEN
         RETURN (FALSE);
     END IF;

     IF IS_NUMERIC (SUBSTR(P_codice_fiscale,7,2), n_NUMERO) THEN
         IF n_numero <> cf_anno THEN
             RETURN (FALSE);
        END IF;
     END IF;

     IF SUBSTR(P_codice_fiscale,9,1) <> cf_mese THEN
         RETURN (FALSE);
     END IF;

     IF IS_NUMERIC (SUBSTR(P_codice_fiscale,10,2), n_NUMERO) THEN
         IF n_numero > 40 THEN --- donna
            IF n_numero <> cf_giornoD THEN
                 RETURN (FALSE);
            END IF;
           ELSE -- uomo
            IF n_numero <> cf_giornoU THEN
                 RETURN (FALSE);
            END IF;
         END IF;
     END IF;

     IF SUBSTR(P_codice_fiscale,12,1) <> SUBSTR(cf_comune,1,1) THEN  --prima lettere del codice belfiore
         RETURN (FALSE);
     END IF;

     IF IS_NUMERIC (SUBSTR(P_codice_fiscale,13,3), n_NUMERO) THEN
         IF n_numero <> SUBSTR(cf_comune,2,3) THEN
             RETURN (FALSE);
        END IF;
     END IF;

     RETURN (TRUE);
EXCEPTION
    WHEN ERR_DATI THEN
      p_result  := RET_ERR_PROC;
      p_msg     := fncMessaggioErrore(9);
      p_id_err  := 9;

    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [PER01] ' || SQLERRM;
      p_id_err  := 1;

END PER01;


PROCEDURE ANA01(p_id_azienda DB_AZIENDA.ID_AZIENDA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- Controllo valorizzazione CUAA:
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------

     vCUAA VARCHAR2(16);

     CUAA_NON_VALORIZZATO EXCEPTION;

  BEGIN

   --
   -- Legge il CUAA dell'azienda in esame
   --
   BEGIN
      SELECT CUAA
      INTO vCUAA
      FROM DB_ANAGRAFICA_AZIENDA
      WHERE id_azienda = p_id_azienda
      AND data_fine_validita IS NULL;

      IF ( vCUAA IS NULL ) THEN

         RAISE CUAA_NON_VALORIZZATO;

      END IF;

   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       RAISE CUAA_NON_VALORIZZATO;

     WHEN TOO_MANY_ROWS THEN
       RAISE;
   END;

   p_result := RET_OK;
   p_msg    := 'CUAA valorizzato';
   p_id_err := NULL;

  EXCEPTION
    WHEN CUAA_NON_VALORIZZATO THEN
      p_result  :=  RET_ERR_CNTL;
      p_msg     :=  fncMessaggioErrore(10);
      p_id_err  :=  10;

    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [ANA01] ' || SQLERRM;
      p_id_err  := 1;

-- insert into DB_MESSAGGIO_ERRORE(ID_MESSAGGIO_ERRORE, ID_TIPO_ERRORE, DESCRIZIONE) values(10, 1, '[ANA01] CUAA o forma giuridica non valorizzata' );
--
END ANA01;



PROCEDURE ANA02(p_id_azienda    IN DB_AZIENDA.ID_AZIENDA%TYPE,
                p_result       OUT VARCHAR2,
                p_msg          OUT VARCHAR2,
                p_id_err       OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- Controllo CUAA:
  -- congruenza in base alla forma giuridica
  --    (codice fiscale per ditte individuali [ id_forma_giuridica = 1 ]
  --    e persona fisica che non esercita attività di impresa, [ id_forma_giuridica = 52 ]
  --    partita IVA negli altri casi.
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------
     vCUAA VARCHAR2(16);
     v_forma_giuridica NUMBER(4);

     CUAA_NON_VALORIZZATO EXCEPTION;
     ERR_CUAA_FORMA_GIURIDICA EXCEPTION;

  BEGIN

   --
   -- Legge la forma giuridica ed il CUAA dell'azienda in esame
   --
   BEGIN
      SELECT ID_FORMA_GIURIDICA, CUAA
      INTO v_forma_giuridica, vCUAA
      FROM DB_ANAGRAFICA_AZIENDA
      WHERE id_azienda = p_id_azienda
      AND data_fine_validita IS NULL;

      IF ( v_forma_giuridica IS NULL ) OR ( vCUAA IS NULL ) THEN

         RAISE CUAA_NON_VALORIZZATO;

      END IF;

   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       RAISE CUAA_NON_VALORIZZATO;

     WHEN TOO_MANY_ROWS THEN
       RAISE;
   END;

   --
   -- Verifica la corrispondenza del tipo di CUAA in base alla forma giuridica
   --  1 e 52 => codice fiscale, altrimenti partita IVA
   --
   IF ( v_forma_giuridica IN (1, 52) ) THEN

      IF ( LENGTH(trim(vCUAA)) <> clenCF ) THEN

         RAISE ERR_CUAA_FORMA_GIURIDICA;

      END IF;

   ELSE

      IF ( LENGTH(trim(vCUAA)) <> clenPIVA ) THEN

         RAISE ERR_CUAA_FORMA_GIURIDICA;

      END IF;

   END IF;

   p_result := RET_OK;
   p_msg    := 'CUAA congruente in base alla forma giuridica';
   p_id_err := NULL;

  EXCEPTION
    WHEN CUAA_NON_VALORIZZATO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(20);
      p_id_err := 20;

    WHEN ERR_CUAA_FORMA_GIURIDICA THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(21);
      p_id_err := 21;

    WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [ANA02] ' || SQLERRM;
      p_id_err := 1;

-- insert into DB_MESSAGGIO_ERRORE(ID_MESSAGGIO_ERRORE, ID_TIPO_ERRORE, DESCRIZIONE) values(20, 1, '[ANA02] CUAA o forma giuridica non valorizzata');
-- insert into DB_MESSAGGIO_ERRORE(ID_MESSAGGIO_ERRORE, ID_TIPO_ERRORE, DESCRIZIONE) values(21, 1, ''[ANA02] CUAA non congruente in base alla forma giuridica');
--

END ANA02;



PROCEDURE ANA03(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- Controllo CUAA:
  -- 1) congruenza in base alla forma giuridica
  --    (codice fiscale per ditte individuali [ id_forma_giuridica = 1 ]
  --    e persona fisica che non esercita attività di impresa, [ id_forma_giuridica = 52 ]
  --    partita IVA negli altri casi.
  -- 2) Correttezza del check digit del CUAA
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------

     vCUAA VARCHAR2(16);
     v_forma_giuridica NUMBER(4);

     CUAA_NON_VALORIZZATO EXCEPTION;
     ERR_CUAA_FORMA_GIURIDICA EXCEPTION;
     ERR_CUAA_CHECK_DIGIT EXCEPTION;

  BEGIN

   --
   -- Legge la forma giuridica ed il CUAA dell'azienda in esame
   --
   BEGIN
      SELECT ID_FORMA_GIURIDICA, CUAA
      INTO v_forma_giuridica, vCUAA
      FROM DB_ANAGRAFICA_AZIENDA
      WHERE id_azienda = p_id_azienda
      AND data_fine_validita IS NULL;

      IF ( v_forma_giuridica IS NULL ) OR ( vCUAA IS NULL ) THEN

         RAISE CUAA_NON_VALORIZZATO;

      END IF;

   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       RAISE CUAA_NON_VALORIZZATO;

     WHEN TOO_MANY_ROWS THEN
       RAISE;
   END;

   --
   -- Verifica la corrispondenza del tipo di CUAA in base alla forma giuridica
   --  1 e 52 => codice fiscale, altrimenti partita IVA
   --
   IF ( v_forma_giuridica IN (1, 52) ) THEN

      IF ( LENGTH(trim(vCUAA)) <> clenCF ) THEN

         RAISE ERR_CUAA_FORMA_GIURIDICA;

      END IF;

   ELSE

      IF ( LENGTH(trim(vCUAA)) <> clenPIVA ) THEN

         RAISE ERR_CUAA_FORMA_GIURIDICA;

      END IF;

   END IF;

   --
   -- Controllo del check digit
   --
   IF NOT ( fncCheckDigit( vCUAA ) ) THEN

      RAISE ERR_CUAA_CHECK_DIGIT;

   END IF;

   p_result := RET_OK;
   p_msg    := 'Controllo CUAA positivo';
   p_id_err := NULL;

  EXCEPTION
    WHEN CUAA_NON_VALORIZZATO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(30);
      p_id_err := 30;

    WHEN ERR_CUAA_FORMA_GIURIDICA THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(31);
      p_id_err := 31;

    WHEN ERR_CUAA_CHECK_DIGIT THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(32);
      p_id_err := 32;

    WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [ANA03] ' || SQLERRM;
      p_id_err := 1;

-- insert into DB_MESSAGGIO_ERRORE(ID_MESSAGGIO_ERRORE, ID_TIPO_ERRORE, DESCRIZIONE) values(30, 1, '[ANA03] CUAA o forma giuridica non valorizzata');
-- insert into DB_MESSAGGIO_ERRORE(ID_MESSAGGIO_ERRORE, ID_TIPO_ERRORE, DESCRIZIONE) values(31, 1, '[ANA03] CUAA non congruente in base alla forma giuridica');
-- insert into DB_MESSAGGIO_ERRORE(ID_MESSAGGIO_ERRORE, ID_TIPO_ERRORE, DESCRIZIONE) values(32, 1, '[ANA03] CUAA non congruente in base a controllo check-digit');



END ANA03;


PROCEDURE ANA04(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS


  ----------------------------------------------------------------------
  -- Purpose :
  -- Verifica la valorizzazione della partita IVA in base alla forma
  -- giuridica dell'azienda
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------

     vPIVA VARCHAR2(11);
     vFLAG DB_TIPO_FORMA_GIURIDICA.FLAG_PARTITA_IVA%TYPE;

     PIVA_NON_VALORIZZATA EXCEPTION;

  BEGIN

     --
     -- Legge la forma giuridica ed il CUAA dell'azienda in esame
     --
     BEGIN
      SELECT a.PARTITA_IVA, b.FLAG_PARTITA_IVA
      INTO vPIVA, vFLAG
      FROM DB_ANAGRAFICA_AZIENDA a, DB_TIPO_FORMA_GIURIDICA b
      WHERE a.id_azienda = p_id_azienda
      AND a.data_fine_validita IS NULL
      AND a.ID_FORMA_GIURIDICA = b.ID_FORMA_GIURIDICA
      ;

        IF ( vFLAG = 'S' ) AND  ( vPIVA IS NULL ) THEN

           RAISE PIVA_NON_VALORIZZATA;

        END IF;

     EXCEPTION
       WHEN NO_DATA_FOUND THEN
         RAISE PIVA_NON_VALORIZZATA;

       WHEN TOO_MANY_ROWS THEN
         RAISE;
     END;

   p_result := RET_OK;
   p_msg    := 'La Partita IVA è valorizzata';
   p_id_err := NULL;

   EXCEPTION
    WHEN PIVA_NON_VALORIZZATA THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(40);
      p_id_err := 40;

    WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [ANA04] ' || SQLERRM;
      p_id_err := 1;

-- insert into DB_MESSAGGIO_ERRORE(ID_MESSAGGIO_ERRORE, ID_TIPO_ERRORE, DESCRIZIONE) values(40, 1, '[ANA04] Partita IVA non valorizzata');
--

END ANA04;



PROCEDURE ANA05(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- Verifica la correttezza del check-digit della partita IVA
  -- Se la partita IVA è valorizzata, viene controllata la correttezza
  -- del check-digit
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------
     vPIVA VARCHAR2(11);
     vFLAG DB_TIPO_FORMA_GIURIDICA.FLAG_PARTITA_IVA%TYPE;

     PIVA_NON_VALORIZZATA EXCEPTION;
     ERR_PIVA_CHECK_DIGIT EXCEPTION;

  BEGIN

   --
   -- Legge la forma giuridica ed il CUAA dell'azienda in esame
   --
   BEGIN

      SELECT a.PARTITA_IVA, b.FLAG_PARTITA_IVA
      INTO vPIVA, vFLAG
      FROM DB_ANAGRAFICA_AZIENDA a, DB_TIPO_FORMA_GIURIDICA b
      WHERE a.id_azienda = p_id_azienda
      AND a.data_fine_validita IS NULL
      AND a.ID_FORMA_GIURIDICA = b.ID_FORMA_GIURIDICA
      ;

      IF ( vFLAG = 'S' ) AND  ( vPIVA IS NULL ) THEN

         RAISE PIVA_NON_VALORIZZATA;

      END IF;

   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       RAISE PIVA_NON_VALORIZZATA;

     WHEN TOO_MANY_ROWS THEN
       RAISE;
   END;

   --
   -- Controllo del check digit
   --
   IF vPIVA IS NOT NULL THEN
       IF NOT ( fncCheckDigit( vPIVA ) ) THEN

          RAISE ERR_PIVA_CHECK_DIGIT;

       END IF;
   END IF;

   p_result := RET_OK;
   p_msg    := 'Controllo check-digit Partita IVA positivo';
   p_id_err := NULL;

  EXCEPTION
    WHEN PIVA_NON_VALORIZZATA THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(50);
      p_id_err := 50;

    WHEN ERR_PIVA_CHECK_DIGIT THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(51);
      p_id_err := 51;

    WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [ANA05] ' || SQLERRM;
      p_id_err := 1;

-- insert into DB_MESSAGGIO_ERRORE(ID_MESSAGGIO_ERRORE, ID_TIPO_ERRORE, DESCRIZIONE) values(50, 1, '[ANA05] Partita IVA non valorizzata');
-- insert into DB_MESSAGGIO_ERRORE(ID_MESSAGGIO_ERRORE, ID_TIPO_ERRORE, DESCRIZIONE) values(51, 1, '[ANA05] Partita IVA non congruente in base a controllo check-digit ');

END ANA05;



PROCEDURE ANA07(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- Controlla che l'indirizzo della sede legale sia completo e corretto,
  -- tenendo conto anche della possibilità di residenza all'estero.
  -- Viene controllata la visualizzazione dei seguenti campi:
  -- SEDELEG_COMUNE, SEDELEG_INDIRIZZO, SEDELEG_CAP
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------

 vComune       DB_ANAGRAFICA_AZIENDA.SEDELEG_COMUNE%TYPE;
 vIndirizzo    DB_ANAGRAFICA_AZIENDA.SEDELEG_INDIRIZZO%TYPE;
 vCAP          DB_ANAGRAFICA_AZIENDA.SEDELEG_CAP%TYPE;
 vCittaEstero  DB_ANAGRAFICA_AZIENDA.SEDELEG_CITTA_ESTERO%TYPE;

 bFlagEstero         COMUNE.FLAG_ESTERO%TYPE;
 bFlagEstinto        COMUNE.FLAG_ESTINTO%TYPE;

 INDIRIZZO_SEDE_NON_VALORIZZATO EXCEPTION;
 ERR_CAP             EXCEPTION;
 ERR_CITTA_ESTERO    EXCEPTION;
 ERR_DATI             EXCEPTION;
 ERR_COMUNE_ESTINTO     EXCEPTION;
 ERR_STATO_ESTINTO     EXCEPTION;

BEGIN

    BEGIN

      SELECT SEDELEG_COMUNE, SEDELEG_INDIRIZZO, SEDELEG_CAP, SEDELEG_CITTA_ESTERO
      INTO vComune, vIndirizzo, vCAP, vCittaEstero
      FROM DB_ANAGRAFICA_AZIENDA
      WHERE id_azienda = p_id_azienda
      AND data_fine_validita IS NULL;

    EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RAISE INDIRIZZO_SEDE_NON_VALORIZZATO;

      WHEN TOO_MANY_ROWS THEN
         RAISE;

    END;

    IF vComune IS NULL    OR
       vIndirizzo IS NULL THEN
       RAISE INDIRIZZO_SEDE_NON_VALORIZZATO;
    END IF;


  -- Verifica se si tratta di uno stato estero
  BEGIN
     SELECT flag_estero, flag_estinto
     INTO bFlagEstero, bFlagEstinto
     FROM COMUNE WHERE istat_comune = vComune;
  EXCEPTION
     WHEN OTHERS THEN
        RAISE ERR_DATI;
  END;

  -- Nel caso di residenza all'estero, controlla la validazione della città
  --
  IF bFlagEstero = 'S' THEN

     IF trim(vCittaEstero) IS NULL THEN
        RAISE ERR_CITTA_ESTERO;
     END IF;

     IF bFlagEstinto='S' THEN
         RAISE ERR_STATO_ESTINTO;
     END IF;

  ELSE
  -- Nel caso di residenza in Italia, controlla la validazione del CAP
  --
     IF trim(vCAP) IS NULL THEN
        RAISE ERR_CAP;
     END IF;

     IF bFlagEstinto='S' THEN
         RAISE ERR_COMUNE_ESTINTO;
     END IF;


  END IF;






   p_result := RET_OK;
   p_msg    := 'Controllo indirizzo sede legale positivo';
   p_id_err := NULL;

EXCEPTION
   WHEN INDIRIZZO_SEDE_NON_VALORIZZATO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(70);
      p_id_err := 70;

   WHEN ERR_CAP THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(71);
      p_id_err := 71;

   WHEN ERR_CITTA_ESTERO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(72);
      p_id_err := 72;

   WHEN ERR_COMUNE_ESTINTO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(74); -- [ANA07] Comune della sede legale estinto
      p_id_err := 74;

   WHEN ERR_STATO_ESTINTO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(75); -- [ANA07] Stato estero della sede legale estinto
      p_id_err := 75;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(73);
      p_id_err := 73;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [ANA07] ' || SQLERRM;
      p_id_err := 1;

-- insert into DB_MESSAGGIO_ERRORE(ID_MESSAGGIO_ERRORE, ID_TIPO_ERRORE, DESCRIZIONE) values(70, 1, '[ANA07] Indirizzo sede legale non valorizzato' );

END ANA07;



PROCEDURE ANA08(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS


  ----------------------------------------------------------------------
  -- Purpose :
  -- Controlla lo stato di cessazione dell'azienda
  --
  --
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------
   vDataCessazione DATE;

   ERR_AZIENDA_CESSATA EXCEPTION;
   ERR_DATI            EXCEPTION;
BEGIN

   BEGIN

       SELECT DATA_CESSAZIONE INTO vDataCessazione
       FROM DB_ANAGRAFICA_AZIENDA
       WHERE id_azienda = p_id_azienda
       AND data_fine_validita IS NULL;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RAISE ERR_DATI;

      WHEN TOO_MANY_ROWS THEN
         RAISE;

   END;

   -- Se il campo DATA_CESSAZIONE è valorizzato, significa che l'azienda è cessata
   --
   IF vDataCessazione IS NOT NULL THEN
      RAISE ERR_AZIENDA_CESSATA;
   END IF;

   p_result := RET_OK;
   p_msg    := 'Controllo cessazione azienda positivo';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_AZIENDA_CESSATA THEN
   p_result := RET_ERR_CNTL;
   p_msg    := fncMessaggioErrore(80);
   p_id_err := 80;

   WHEN ERR_DATI THEN
   p_result := RET_ERR_PROC;
   p_msg    := fncMessaggioErrore(81);
   p_id_err := 81;

   WHEN OTHERS THEN
   p_result := RET_ERR;
   p_msg    := fncMessaggioErrore(1) || ' [ANA08] ' || SQLERRM;
   p_id_err := 1;

-- insert into DB_MESSAGGIO_ERRORE(ID_MESSAGGIO_ERRORE, ID_TIPO_ERRORE, DESCRIZIONE) values(80, 1, ' [ANA08] Azienda cessata');
-- insert into DB_MESSAGGIO_ERRORE(ID_MESSAGGIO_ERRORE, ID_TIPO_ERRORE, DESCRIZIONE) values(81, 1, ' [ANA08] Nessuna azienda corrisponde all''identificativo');

END ANA08;



PROCEDURE ANA10(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS


  ----------------------------------------------------------------------
  -- Purpose :
  -- Controlla la corretta valorizzazione dei dati di Provincia REA, Anno iscrizione,
  -- Numero REA.
  --
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------

  ERR_CCIAA_PROVINCIA  EXCEPTION;
  ERR_CCIAA_ANNO       EXCEPTION;
  ERR_CCIAA_NUMERO     EXCEPTION;
  ERR_DATI               EXCEPTION;

  vProvincia       DB_ANAGRAFICA_AZIENDA.CCIAA_PROVINCIA_REA%TYPE;
  vAnno            DB_ANAGRAFICA_AZIENDA.CCIAA_ANNO_ISCRIZIONE%TYPE;
  vNumero           DB_ANAGRAFICA_AZIENDA.CCIAA_NUMERO_REA%TYPE;

  nAnno NUMBER(4);

BEGIN

   BEGIN
      SELECT CCIAA_PROVINCIA_REA, CCIAA_ANNO_ISCRIZIONE, CCIAA_NUMERO_REA
      INTO vProvincia, vAnno, vNumero
      FROM DB_ANAGRAFICA_AZIENDA
      WHERE id_azienda = p_id_azienda
      AND data_fine_validita IS NULL;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RAISE ERR_DATI;

      WHEN TOO_MANY_ROWS THEN
         RAISE;
   END;

   IF vProvincia IS NULL THEN
     RAISE ERR_CCIAA_PROVINCIA;
   END IF;

   IF vAnno IS NULL THEN
      RAISE ERR_CCIAA_ANNO;
   END IF;

   IF vNumero IS NULL THEN
      RAISE ERR_CCIAA_NUMERO;
   END IF;

   -- Controllo congruenza sigla provincia
   --
   IF NOT fncControllaProvincia( vProvincia ) THEN
         RAISE ERR_CCIAA_PROVINCIA;
   END IF;

   -- Controllo congruenza anno iscrizione
   --
   BEGIN
     nAnno:= TO_NUMBER(vAnno);

     IF nAnno < 1900 THEN
       RAISE ERR_CCIAA_ANNO;
     END IF;

   EXCEPTION
     WHEN OTHERS THEN
        RAISE ERR_CCIAA_ANNO;

   END;

   p_result := RET_OK;
   p_msg    := 'Controllo dati iscrizione CCIAA positivo';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_CCIAA_PROVINCIA THEN
   p_result := RET_ERR_CNTL;
   p_msg    := fncMessaggioErrore(100);
   p_id_err := 100;

   WHEN ERR_CCIAA_ANNO THEN
   p_result := RET_ERR_CNTL;
   p_msg    := fncMessaggioErrore(101);
   p_id_err := 101;

   WHEN ERR_CCIAA_NUMERO THEN
   p_result := RET_ERR_CNTL;
   p_msg    := fncMessaggioErrore(102);
   p_id_err := 102;

   WHEN ERR_DATI THEN
   p_result := RET_ERR_PROC;
   p_msg    := fncMessaggioErrore(103);
   p_id_err := 103;

   WHEN OTHERS THEN
   p_result := RET_ERR;
   p_msg    := fncMessaggioErrore(1) || ' [ANA10] ' || SQLERRM;
   p_id_err := 1;


END ANA10;



PROCEDURE ANA11(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- In base alla forma giuridica, controlla la corretta valorizzazione dei dati di
  -- Provincia REA, Anno iscrizione,Numero REA
  --
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------

  vProvincia        DB_ANAGRAFICA_AZIENDA.CCIAA_PROVINCIA_REA%TYPE;
  vAnno             DB_ANAGRAFICA_AZIENDA.CCIAA_ANNO_ISCRIZIONE%TYPE;
  vNumero            DB_ANAGRAFICA_AZIENDA.CCIAA_NUMERO_REA%TYPE;
  nIdFormaGiuridica DB_ANAGRAFICA_AZIENDA.ID_FORMA_GIURIDICA%TYPE;

  nAnno NUMBER(4);

  ERR_CCIAA_PROVINCIA  EXCEPTION;
  ERR_CCIAA_ANNO       EXCEPTION;
  ERR_CCIAA_NUMERO     EXCEPTION;
  ERR_DATI               EXCEPTION;

BEGIN

   -- Preleva la forma giuridica dell'azienda
   --
   BEGIN

     SELECT CCIAA_PROVINCIA_REA, CCIAA_ANNO_ISCRIZIONE, CCIAA_NUMERO_REA, ID_FORMA_GIURIDICA
     INTO vProvincia, vAnno, vNumero, nIdFormaGiuridica
     FROM DB_ANAGRAFICA_AZIENDA
     WHERE id_azienda = p_id_azienda
     AND data_fine_validita IS NULL;


   EXCEPTION
      WHEN OTHERS THEN
         RAISE ERR_DATI;

   END;

   -- Verifica che la forma giuridica dell'azienda in esame renda obbligatoria la valorizzazione
   -- dei campi provincia REA, anno iscrizione, numero REA
   --
   IF nIdFormaGiuridica NOT IN
      ('26','27','29','30','31','40','41','42','43','44','45','48','49','50','65','66','67','68',
       '69','70','71','72','78','79','80','81','82','83','84','85','86','87') THEN
      IF vProvincia IS NULL THEN
         RAISE ERR_CCIAA_PROVINCIA;
      END IF;

      IF vAnno IS NULL THEN
         RAISE ERR_CCIAA_ANNO;
      END IF;

      IF vNumero IS NULL THEN
         RAISE ERR_CCIAA_NUMERO;
      END IF;

      -- Controllo congruenza Provincia
      --
      IF NOT fncControllaProvincia( vProvincia ) THEN
               RAISE ERR_CCIAA_PROVINCIA;
      END IF;

      -- Controllo congruenza anno iscrizione
      --
      BEGIN
         nAnno:= TO_NUMBER(vAnno);

         IF nAnno < 1900 THEN
            RAISE ERR_CCIAA_ANNO;
         END IF;

      EXCEPTION
         WHEN OTHERS THEN
            RAISE ERR_CCIAA_ANNO;
      END;

   END IF;

   p_result := RET_OK;
   p_msg    := 'Controllo dati iscrizione CCIAA positivo';
   p_id_err := NULL;

   EXCEPTION

   WHEN ERR_CCIAA_PROVINCIA THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(110);
      p_id_err := 110;

   WHEN ERR_CCIAA_ANNO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(111);
      p_id_err := 111;

   WHEN ERR_CCIAA_NUMERO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(112);
      p_id_err := 112;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(113);
      p_id_err := 113;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [ANA11] ' || SQLERRM;
      p_id_err := 1;


END ANA11;



PROCEDURE ANA12(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS


  ----------------------------------------------------------------------
  -- Purpose :
  -- Controlla la corretta valorizzazione dei dati di Provincia REA, Anno iscrizione,
  -- numero iscrizione al registro imprese
  --
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------
  ERR_CCIAA_PROVINCIA  EXCEPTION;
  ERR_CCIAA_ANNO       EXCEPTION;
  ERR_CCIAA_NUMERO     EXCEPTION;
  ERR_DATI               EXCEPTION;

  vProvincia              DB_ANAGRAFICA_AZIENDA.CCIAA_PROVINCIA_REA%TYPE;
  vAnno                   DB_ANAGRAFICA_AZIENDA.CCIAA_ANNO_ISCRIZIONE%TYPE;
  vNumero                  DB_ANAGRAFICA_AZIENDA.CCIAA_NUMERO_REGISTRO_IMPRESE%TYPE;

  nAnno NUMBER(4);

BEGIN

   BEGIN
      SELECT CCIAA_PROVINCIA_REA, CCIAA_ANNO_ISCRIZIONE, CCIAA_NUMERO_REGISTRO_IMPRESE
      INTO vProvincia, vAnno, vNumero
      FROM DB_ANAGRAFICA_AZIENDA
      WHERE id_azienda = p_id_azienda
      AND data_fine_validita IS NULL;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RAISE ERR_DATI;

      WHEN TOO_MANY_ROWS THEN
         RAISE;
   END;

   IF vProvincia IS NULL THEN
     RAISE ERR_CCIAA_PROVINCIA;
   END IF;

   IF vAnno IS NULL THEN
      RAISE ERR_CCIAA_ANNO;
   END IF;

   IF trim(vNumero) IS NULL THEN
      RAISE ERR_CCIAA_NUMERO;
   END IF;

   -- Controllo congruenza sigla provincia
   --
   IF NOT fncControllaProvincia( vProvincia ) THEN
         RAISE ERR_CCIAA_PROVINCIA;
   END IF;

   -- Controllo congruenza anno iscrizione
   --
   BEGIN
     nAnno:= TO_NUMBER(vAnno);

     IF nAnno < 1900 THEN
       RAISE ERR_CCIAA_ANNO;
     END IF;

   EXCEPTION
     WHEN OTHERS THEN
        RAISE ERR_CCIAA_ANNO;

   END;

   p_result := RET_OK;
   p_msg    := 'Controllo dati iscrizione CCIAA positivo';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_CCIAA_PROVINCIA THEN
   p_result := RET_ERR_CNTL;
   p_msg    := fncMessaggioErrore(120);
   p_id_err := 120;

   WHEN ERR_CCIAA_ANNO THEN
   p_result := RET_ERR_CNTL;
   p_msg    := fncMessaggioErrore(121);
   p_id_err := 121;

   WHEN ERR_CCIAA_NUMERO THEN
   p_result := RET_ERR_CNTL;
   p_msg    := fncMessaggioErrore(122);
   p_id_err := 122;

   WHEN ERR_DATI THEN
   p_result := RET_ERR_PROC;
   p_msg    := fncMessaggioErrore(123);
   p_id_err := 123;

   WHEN OTHERS THEN
   p_result := RET_ERR;
   p_msg    := fncMessaggioErrore(1) || ' [ANA12] ' || SQLERRM;
   p_id_err := 1;


END ANA12;


PROCEDURE ANA13(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- In base alla forma giuridica, controlla la corretta valorizzazione dei dati di
  -- Provincia REA, Anno iscrizione,Numero iscrizione registro imprese
  --
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------

  vProvincia        DB_ANAGRAFICA_AZIENDA.CCIAA_PROVINCIA_REA%TYPE;
  vAnno             DB_ANAGRAFICA_AZIENDA.CCIAA_ANNO_ISCRIZIONE%TYPE;
  vNumero            DB_ANAGRAFICA_AZIENDA.CCIAA_NUMERO_REGISTRO_IMPRESE%TYPE;
  nIdFormaGiuridica DB_ANAGRAFICA_AZIENDA.ID_FORMA_GIURIDICA%TYPE;

  nAnno NUMBER(4);

  ERR_CCIAA_PROVINCIA  EXCEPTION;
  ERR_CCIAA_ANNO       EXCEPTION;
  ERR_CCIAA_NUMERO     EXCEPTION;
  ERR_DATI                  EXCEPTION;

BEGIN

   -- Preleva la forma giuridica dell'azienda
   --
   BEGIN

     SELECT CCIAA_PROVINCIA_REA, CCIAA_ANNO_ISCRIZIONE, CCIAA_NUMERO_REGISTRO_IMPRESE, ID_FORMA_GIURIDICA
     INTO vProvincia, vAnno, vNumero, nIdFormaGiuridica
     FROM DB_ANAGRAFICA_AZIENDA
     WHERE id_azienda = p_id_azienda
     AND data_fine_validita IS NULL;


   EXCEPTION
      WHEN OTHERS THEN
         RAISE ERR_DATI;

   END;

   -- Verifica che la forma giuridica dell'azienda in esame renda obbligatoria la valorizzazione
   -- dei campi provincia REA, anno iscrizione, numero REA
   --
   IF nIdFormaGiuridica NOT IN
      ('26','27','29','30','31','40','41','42','43','44','45','48','49','50','65','66','67','68',
       '69','70','71','72','78','79','80','81','82','83','84','85','86','87') THEN
      IF vProvincia IS NULL THEN
         RAISE ERR_CCIAA_PROVINCIA;
      END IF;

      IF vAnno IS NULL THEN
         RAISE ERR_CCIAA_ANNO;
      END IF;

      IF vNumero IS NULL THEN
         RAISE ERR_CCIAA_NUMERO;
      END IF;

      -- Controllo congruenza Provincia
      --
      IF NOT fncControllaProvincia( vProvincia ) THEN
               RAISE ERR_CCIAA_PROVINCIA;
      END IF;

      -- Controllo congruenza anno iscrizione
      --
      BEGIN
         nAnno:= TO_NUMBER(vAnno);

         IF nAnno < 1900 THEN
            RAISE ERR_CCIAA_ANNO;
         END IF;

      EXCEPTION
         WHEN OTHERS THEN
            RAISE ERR_CCIAA_ANNO;
      END;

   END IF;

   p_result := RET_OK;
   p_msg    := 'Controllo dati iscrizione CCIAA positivo';
   p_id_err := NULL;

   EXCEPTION

   WHEN ERR_CCIAA_PROVINCIA THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(130);
      p_id_err := 130;

   WHEN ERR_CCIAA_ANNO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(131);
      p_id_err := 131;

   WHEN ERR_CCIAA_NUMERO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(132);
      p_id_err := 132;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(133);
      p_id_err := 133;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [ANA13] ' || SQLERRM;
      p_id_err := 1;

-- insert into DB_MESSAGGIO_ERRORE(ID_MESSAGGIO_ERRORE, ID_TIPO_ERRORE, DESCRIZIONE) values(130, 1, '[ANA13] Provincia REA non valorizzata o non valida');
-- insert into DB_MESSAGGIO_ERRORE(ID_MESSAGGIO_ERRORE, ID_TIPO_ERRORE, DESCRIZIONE) values(131, 1, '[ANA13] Anno iscrizione non valorizzato o non valido');
-- insert into DB_MESSAGGIO_ERRORE(ID_MESSAGGIO_ERRORE, ID_TIPO_ERRORE, DESCRIZIONE) values(132, 1, '[ANA13] Numero iscrizione non valorizzato o non valido');
-- insert into DB_MESSAGGIO_ERRORE(ID_MESSAGGIO_ERRORE, ID_TIPO_ERRORE, DESCRIZIONE) values(133, 1, '[ANA13] Nessuna azienda corrisponde all''identificativo');

END ANA13;


PROCEDURE ANA14(p_id_azienda DB_AZIENDA.ID_AZIENDA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS
  ----------------------------------------------------------------------
  ----------------------------------------------------------------------
  -- Purpose :
  -- Controllo se l'azienda è bloccata
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------

     AZIENDA_BLOCCATA EXCEPTION;

     nRec               NUMBER;

  BEGIN

    /* Se esiste almeno un record aperto con le specifiche fissate
      (id procedimento destinatario = 7 ; id tipologia notifica = 10), l'azienda risulta bloccata */

    -- resta fisso l'ID_PROCEDIMENTO = 7
    -- non si va più fissi su una tipologia notifica
    -- va si usa il flag BLOCCO_AZIENDA della categoria della notifica
    SELECT COUNT(1)
      INTO nRec
      FROM DB_NOTIFICA A,
           DB_TIPO_CATEGORIA_NOTIFICA TCN
     WHERE A.ID_AZIENDA = p_id_azienda
       AND A.ID_PROCEDIMENTO_DESTINATARIO = 7
       AND A.ID_CATEGORIA_NOTIFICA = TCN.ID_CATEGORIA_NOTIFICA
       AND TCN.BLOCCO_AZIENDA = 'S'
       AND A.DATA_CHIUSURA IS NULL;

    IF nRec > 0 THEN
       RAISE AZIENDA_BLOCCATA;
    END IF;

    p_result := RET_OK;
    p_msg    := 'Azienda non bloccata';
    p_id_err := NULL;

  EXCEPTION
    WHEN AZIENDA_BLOCCATA THEN
      p_result  :=  RET_ERR_CNTL;
      p_msg     :=  fncMessaggioErrore(134);
      p_id_err  :=  134;

    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [ANA14] ' || SQLERRM;
      p_id_err  := 1;

END ANA14;

PROCEDURE ANA15(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- Verifica se la forma giuridica dell'azienda è attiva o meno
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------
     vDataFineFormaGiuridica DB_TIPO_FORMA_GIURIDICA.DATA_FINE_FORMA_GIURIDICA%TYPE;

     FORMA_GIURIDICA_SCADUTA EXCEPTION;
BEGIN
   BEGIN
      SELECT b.DATA_FINE_FORMA_GIURIDICA
      INTO vDataFineFormaGiuridica
      FROM DB_ANAGRAFICA_AZIENDA a, DB_TIPO_FORMA_GIURIDICA b
      WHERE a.id_azienda = p_id_azienda
      AND a.data_fine_validita IS NULL
      AND a.ID_FORMA_GIURIDICA = b.ID_FORMA_GIURIDICA;
   EXCEPTION
     WHEN NO_DATA_FOUND THEN
       RAISE FORMA_GIURIDICA_SCADUTA;
     WHEN TOO_MANY_ROWS THEN
       RAISE;
   END;

   IF vDataFineFormaGiuridica IS NOT NULL THEN
      RAISE FORMA_GIURIDICA_SCADUTA;
   END IF;


   p_result := RET_OK;
   p_msg    := 'Controllo Forma Giuridica attiva positivo';
   p_id_err := NULL;

EXCEPTION
  WHEN FORMA_GIURIDICA_SCADUTA THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(1020);
      p_id_err := 1020;
  WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [ANA15] ' || SQLERRM;
      p_id_err := 1;
END ANA15;

-- ANA17 e' su GNPS

PROCEDURE ANA18(    p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                        p_result        OUT VARCHAR2,
                        p_msg             OUT VARCHAR2,
                        p_id_err        OUT NUMBER        ) IS


  ----------------------------------------------------------------------
  -- Purpose :
  -- Verifica la valorizzazione della partita IVA
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------

vPIVA VARCHAR2(11);

PIVA_VALORIZZATA EXCEPTION;

BEGIN


    SELECT a.PARTITA_IVA
    INTO vPIVA
    FROM DB_ANAGRAFICA_AZIENDA a
    WHERE a.id_azienda = p_id_azienda
    AND a.data_fine_validita IS NULL;

    IF  vPIVA IS NOT NULL  THEN

        RAISE PIVA_VALORIZZATA;

    END IF;


   p_result := RET_OK;
   p_msg    := 'La Partita IVA non è valorizzata';
   p_id_err := NULL;

EXCEPTION
    WHEN PIVA_VALORIZZATA THEN
           p_result := RET_ERR_CNTL;
        p_msg    := fncMessaggioErrore(2505);
           p_id_err := 2505;
    WHEN OTHERS THEN
        p_result := RET_ERR;
        p_msg    := fncMessaggioErrore(1) || ' [ANA18] ' || SQLERRM;
           p_id_err := 1;

END ANA18;

-- verifica che almeno un recapito
-- dell'azienda sia valorizzato
PROCEDURE ANA19(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS
    nRec INTEGER:=0;
BEGIN

    SELECT COUNT(*)
      INTO nRec
      FROM DB_ANAGRAFICA_AZIENDA
     WHERE ID_AZIENDA = P_ID_AZIENDA
       AND DATA_FINE_VALIDITA IS NULL
       AND (-- TELEFONO IS NOT NULL OR 
            MAIL IS NOT NULL OR
            PEC IS NOT NULL);

    IF nRec = 0 THEN
       p_result := RET_ERR_CNTL;
       --p_msg    := fncMessaggioErrore(3478);
       p_msg    := fncMessaggioErrore(3608);
       --p_id_err := 3478;
       p_id_err := 3608;
    ELSE
       p_result := RET_OK;
       p_msg    := NULL;
       p_id_err := NULL;
    END IF;

EXCEPTION
  WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [ANA19] ' || SQLERRM;
      p_id_err := 1;
END ANA19;

-- verifica che la PEC sia valorizzata
PROCEDURE ANA20(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS
    nRec        INTEGER:=0;
    nRecFmOK    INTEGER:=0;
    nRecAAEPOK  INTEGER:=0;
BEGIN

    SELECT COUNT(DECODE(AZ.PEC,NULL,NULL,AZ.ID_ANAGRAFICA_AZIENDA)),
           COUNT(DECODE(AZ.ID_FORMA_GIURIDICA,52,NULL,AZ.ID_ANAGRAFICA_AZIENDA)),
           COUNT(DECODE(AA.FLAG_PRESENTE_IN_AAEP, 'S', AZ.ID_ANAGRAFICA_AZIENDA, NULL))
      INTO nRec,
           nRecFmOK,
           nRecAAEPOK
      FROM DB_ANAGRAFICA_AZIENDA AZ,
           DB_AZIENDA_AAEP AA
     WHERE AZ.ID_AZIENDA = P_ID_AZIENDA
       AND AZ.DATA_FINE_VALIDITA IS NULL
       -- AND AZ.PEC IS NOT NULL
       AND AZ.CUAA = AA.CUAA (+);

    -- se l'azienda ha la forma giuridica diversa da 52 (nRecFmOk > 0 )
    -- ed e' in AAEP (nRecAAEPOK > 0)
    IF nRecFmOk > 0 AND nRecAAEPOk > 0 THEN
       -- posso controllo se non ha la pec
       IF nRec = 0 THEN
           -- e dare apposito errore
           p_result := RET_ERR_CNTL;
           p_msg    := fncMessaggioErrore(3526);
           p_id_err := 3526;
       ELSE
           p_result := RET_OK;
           p_msg    := NULL;
           p_id_err := NULL;
       END IF;
    ELSE
        p_result := RET_OK;
        p_msg    := NULL;
        p_id_err := NULL;
    END IF;
EXCEPTION
  WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [ANA20] ' || SQLERRM;
      p_id_err := 1;
END ANA20;

-- verifica che l'azienda abbia consolidato le UV
PROCEDURE ANA21(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

    nRec            INTEGER:=0;
    dDataOffSet     DATE;
    recTpCtrlParam  DB_TIPO_CONTROLLO_PARAMETRO%ROWTYPE;
BEGIN

    -- cerco su DB_TIPO_CONTROLLO_PARAMETRO il parametro del controllo contenente la data fino alla quale
    -- eseguire il controllo
    recTpCtrlParam := SelValoreParametroCtrlByCodice (knIdControlloANA21, kvCodParControlloANA21);

    IF recTpCtrlParam.ID_CONTROLLO_PARAMETRO IS NOT NULL THEN
       BEGIN
           dDataOffSet := NVL(TO_DATE(recTpCtrlParam.VALORE_STRINGA,'DD/MM/YYYY'), TO_DATE('31/01/2014','DD/MM/YYYY'));
       EXCEPTION
           WHEN OTHERS THEN
                dDataOffSet := TO_DATE('31/01/2014','DD/MM/YYYY');
       END;
    ELSE
       dDataOffSet := TO_DATE('31/01/2014','DD/MM/YYYY');
    END IF;

    SELECT COUNT(ID_ANAGRAFICA_AZIENDA)
      INTO nRec
      FROM DB_ANAGRAFICA_AZIENDA
     WHERE ID_AZIENDA = p_id_azienda
       AND DATA_INIZIO_VALIDITA < dDataOffSet
       AND ROWNUM < 2;
    -- se si eseguo il controllo vero e proprio
    IF nRec > 0 THEN
        -- controllo se l'azienda ha almeno un UV
        SELECT COUNT(ID_STORICO_UNITA_ARBOREA)
          INTO nRec
          FROM DB_STORICO_UNITA_ARBOREA
         WHERE ID_AZIENDA = p_id_azienda
           AND DATA_FINE_VALIDITA IS NULL
           AND ROWNUM < 2;
        -- se si
        IF nRec > 0 THEN
            -- controllo se ha fatto il consolidamento del GIS
            SELECT COUNT(ID_COMPENSAZIONE_AZIENDA)
              INTO nRec
              FROM DB_COMPENSAZIONE_AZIENDA
             WHERE ID_AZIENDA IN (SELECT ID_AZIENDA
                                    FROM DB_AZIENDA
                              START WITH ID_AZIENDA = p_id_azienda
                              CONNECT BY ID_AZIENDA = PRIOR ID_AZIENDA_PROVENIENZA) 
               AND DATA_FINE_VALIDITA IS NULL
               AND DATA_CONSOLIDAMENTO_GIS IS NOT NULL;
            -- se no do anomalia
            IF nRec = 0 THEN
               p_result := RET_ERR_CNTL;
               p_msg    := fncMessaggioErrore(3529);
               p_id_err := 3529;
            ELSE
               p_result := RET_OK;
               p_msg    := NULL;
               p_id_err := NULL;
            END IF;
        ELSE
            p_result := RET_OK;
            p_msg    := NULL;
            p_id_err := NULL;
        END IF;
    ELSE
        p_result := RET_OK;
        p_msg    := NULL;
        p_id_err := NULL;
    END IF;
EXCEPTION
  WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [ANA21] ' || SQLERRM;
      p_id_err := 1;
END ANA21;

-- controlla che almeno uno tra il telefono
-- dell'azienda ed i telefono del titolare / rappresentante
-- legale siano valorizzati
PROCEDURE ANA22(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER
                ) IS
    nRec INTEGER:=0;
BEGIN

    SELECT COUNT(*)
      INTO nRec
      FROM (
    SELECT AZ.ID_ANAGRAFICA_AZIENDA
      FROM DB_ANAGRAFICA_AZIENDA AZ
     WHERE AZ.ID_AZIENDA = P_ID_AZIENDA
       AND AZ.DATA_FINE_VALIDITA IS NULL
       AND AZ.TELEFONO IS NOT NULL

    UNION ALL

    SELECT PF.ID_PERSONA_FISICA
      FROM DB_PERSONA_FISICA PF,
           DB_CONTITOLARE CT
     WHERE CT.ID_AZIENDA = p_id_azienda
       AND CT.DATA_FINE_RUOLO IS NULL
       AND CT.ID_RUOLO = knIdRuoloTitRPLeg
       AND CT.ID_SOGGETTO = PF.ID_SOGGETTO
       AND (PF.RES_TELEFONO IS NOT NULL OR PF.NUMERO_CELLULARE IS NOT NULL));


    IF nRec = 0 THEN
       p_result := RET_ERR_CNTL;
       p_msg    := fncMessaggioErrore(3610);
       p_id_err := 3610;
    ELSE
       p_result := RET_OK;
       p_msg    := NULL;
       p_id_err := NULL;
    END IF;

EXCEPTION
  WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [ANA22] ' || SQLERRM;
      p_id_err := 1;
END ANA22;

-- nuovo controllo
-- verifica che non siano indicati i dati relativi
-- all'iscrizione in camera di commercio sul fascicolo se l¿azienda in oggetto
-- non risulta iscritta in CCIAA (fonte Infocamere)
--verifica che non siano valorizzati all'iscrizione in camera di commercio
--se fuori regione pero' non verifica che siano valorizzati
PROCEDURE ANA23(p_id_azienda    IN DB_AZIENDA.ID_AZIENDA%TYPE,
                p_cuaa          IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER
                ) IS
    vFlagPresenzaAAEP   DB_AZIENDA_AAEP.FLAG_PRESENTE_IN_AAEP%TYPE;
    nRec                INTEGER:=0;
    vProvRea            DB_ANAGRAFICA_AZIENDA.CCIAA_PROVINCIA_REA%TYPE;
    nNumRea             DB_ANAGRAFICA_AZIENDA.CCIAA_NUMERO_REA%TYPE;
    vAnnoIscr           DB_ANAGRAFICA_AZIENDA.CCIAA_ANNO_ISCRIZIONE%TYPE;
    vNumRegImp          DB_ANAGRAFICA_AZIENDA.CCIAA_NUMERO_REGISTRO_IMPRESE%TYPE;
    vProvPiemontese     CHAR(1);
    dDataIscrRi         DATE;
    dDataIscrRea        DATE;
    dDataCessRea        DATE;
    dDataCessRi         DATE;



BEGIN
    -- cerco se il soggetto e' presente in AAEP
    BEGIN

        SELECT FLAG_PRESENTE_IN_AAEP
          INTO vFlagPresenzaAAEP
          FROM DB_AZIENDA_AAEP
         WHERE CUAA = p_cuaa
           AND DATA_CESSAZIONE IS NULL; 
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             
             vFlagPresenzaAAEP := 'N';
    END;

    SELECT CCIAA_PROVINCIA_REA,
           CCIAA_NUMERO_REA,
           CCIAA_ANNO_ISCRIZIONE,
           CCIAA_NUMERO_REGISTRO_IMPRESE,
           DATA_ISCRIZIONE_REA, 
           DATA_CESSAZIONE_REA,
           DATA_ISCRIZIONE_RI,
           DATA_CESSAZIONE_RI,
          DECODE(
          (SELECT COUNT(ISTAT_PROVINCIA)
             FROM PROVINCIA
            WHERE SIGLA_PROVINCIA = CCIAA_PROVINCIA_REA
              AND ID_REGIONE = '01'),0,'N','S') AS PROVINCIA_PIEMONTESE
      INTO vProvRea,
           nNumRea,
           vAnnoIscr,
           vNumRegImp,
           dDataIscrRea, 
           dDataCessRea,
           dDataIscrRi,
           dDataCessRi,
           vProvPiemontese
      FROM DB_ANAGRAFICA_AZIENDA
     WHERE ID_AZIENDA = p_id_azienda
       AND DATA_FINE_VALIDITA IS NULL;

    -- se non lo e'
    IF vFlagPresenzaAAEP = 'N' THEN
       -- controllo se anche solo un dato CCIAA e' valorizzato
       IF (vProvRea IS NOT NULL OR
           nNumRea IS NOT NULL OR
           vAnnoIscr IS NOT NULL OR
           vNumRegImp IS NOT NULL OR
           dDataIscrRea IS NOT NULL OR  
           dDataCessRea IS NOT NULL OR  
           dDataIscrRi  IS NOT NULL OR  
           dDataCessRi  IS NOT NULL    
           ) AND vProvPiemontese = 'S' THEN 

          p_result := RET_ERR_CNTL;
          p_msg    := fncMessaggioErrore(3719);
          p_id_err := 3719;

       ELSE
          -- tutto ok
          p_result := RET_OK;
          p_msg    := NULL;
          p_id_err := NULL;
       END IF;
    ELSE
       -- se il soggetto e' presente in AAEP
       -- allora devono essere tutti valorizzati
       IF vProvRea IS NULL OR
          nNumRea IS NULL OR
          vAnnoIscr IS NULL OR
          vNumRegImp IS NULL THEN

          p_result := RET_ERR_CNTL;
          p_msg    := fncMessaggioErrore(3720);
          p_id_err := 3720;

       ELSE
          p_result := RET_OK;
          p_msg    := NULL;
          p_id_err := NULL;
       END IF;
    END IF;

EXCEPTION
    /* MS 15/10/2014
    WHEN NO_DATA_FOUND THEN
         -- se non ho records per il cuaa su DB_AZIENDA_AAEP
         -- do stesso messaggio di AEP01
         p_result := RET_ERR_CNTL;
         p_msg    := fncMessaggioErrore(990);
         p_id_err := 990; */
    WHEN OTHERS THEN
         p_result := RET_ERR;
         p_msg    := fncMessaggioErrore(1) || ' [ANA23] ' || SQLERRM;
         p_id_err := 1;
END ANA23;

PROCEDURE ANA24(pIdAzienda      DB_AZIENDA.ID_AZIENDA%TYPE,
                pResult     OUT VARCHAR2,
                pMsg        OUT VARCHAR2,
                pIdErr      OUT NUMBER) IS

  nCont  SIMPLE_INTEGER := 0;
BEGIN
  pResult := RET_OK;
  pMsg    := NULL;
  pIdErr  := NULL;

  SELECT COUNT(*)
  INTO   nCont
  FROM   DB_ANAGRAFICA_AZIENDA AA,DB_MANODOPERA M
  WHERE  AA.ID_AZIENDA             = pIdAzienda
  AND    AA.DATA_FINE_VALIDITA     IS NULL
  AND    AA.FLAG_IAP               = 'S'
  AND    M.ID_AZIENDA(+)           = AA.ID_AZIENDA
  AND    M.DATA_FINE_VALIDITA      IS NULL
  AND    M.ID_TIPO_ISCRIZIONE_INPS IS NULL;

  IF nCont >= 1 THEN
    pResult := RET_ERR_CNTL;
    pMsg    := fncMessaggioErrore(3876);
    pIdErr  := 3876;
  END IF;
EXCEPTION
   WHEN OTHERS THEN
      pResult := RET_ERR;
      pMsg    := fncMessaggioErrore(1) || ' [ANA24] ' || SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
      pIdErr  := 1;
END ANA24;

PROCEDURE ADE01(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- Controlla la corretta valorizzazione del codice ATECO
  --
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------
  vAteco    DB_ANAGRAFICA_AZIENDA.ID_ATTIVITA_ATECO%TYPE;

  ERR_DATI       EXCEPTION;
  ERR_COD_ATECO  EXCEPTION;

BEGIN

   BEGIN
     SELECT ID_ATTIVITA_ATECO INTO vAteco
     FROM DB_ANAGRAFICA_AZIENDA
     WHERE id_azienda = p_id_azienda
     AND data_fine_validita IS NULL
     AND data_cessazione IS NULL;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RAISE ERR_DATI;

      WHEN TOO_MANY_ROWS THEN
         RAISE;
   END;

   IF vAteco IS NULL THEN
      RAISE ERR_COD_ATECO;
   END IF;

   p_result := RET_OK;
   p_msg    := 'Controllo codice ATECO positivo';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_COD_ATECO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(140);
      p_id_err := 140;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(141);
      p_id_err := 141;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [ADE01] ' || SQLERRM;
      p_id_err := 1;


END ADE01;


PROCEDURE ADE02(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- Controlla la corretta valorizzazione del codice ATECO
  --
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------
  vOte      DB_ANAGRAFICA_AZIENDA.ID_ATTIVITA_OTE%TYPE;

  ERR_DATI       EXCEPTION;
  ERR_COD_OTE    EXCEPTION;

BEGIN

   BEGIN
     SELECT ID_ATTIVITA_OTE INTO vOte
     FROM DB_ANAGRAFICA_AZIENDA
     WHERE id_azienda = p_id_azienda
     AND data_fine_validita IS NULL
     AND data_cessazione IS NULL;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RAISE ERR_DATI;

      WHEN TOO_MANY_ROWS THEN
         RAISE;
   END;

   IF vOte IS NULL THEN
      RAISE ERR_COD_OTE;
   END IF;

   p_result := RET_OK;
   p_msg    := 'Controllo codice OTE positivo';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_COD_OTE THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(150);
      p_id_err := 150;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(151);
      p_id_err := 151;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [ADE02] ' || SQLERRM;
      p_id_err := 1;


END ADE02;

PROCEDURE ADE03(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- Controlla che la forma giuridica dell'azienda sia una cooperativa,
  -- uno dei seguenti valori è ammesso:
  -- 6    COOPERATIVE ISCRITTE REGISTRI
  -- 7    ALTRE COOPERATIVE
  -- 14    SOCIETA' COOPERATIVA
  -- 36    CONSORZIO DI COOPERATIVE
  -- 73    COOPERATIVA
  -- 74    COOPERATIVA A RESPONSABILITA LIMITATA IN LIQUIDAZIONE
  -- 75    COOPERATIVA SOCIALE
  -- 76    PICCOLA SOCIETA COOPERATIVA
  -- 77    PICCOLA SOCIETA COOP. A RESPONSABILITA LIMITATA
  -- 95    SOC. COOP. A RESPONSABILITA LIMITATA PER AZIONI
  -- 103    SOCIETA CONSORTILE COOP. A RESPONSABILITA LIMITATA
  -- 107    SOCIETA COOPERATIVA A RESPONSABILITA ILLIMITATA
  -- 108    SOCIETA COOPERATIVA A RESPONSABILITA LIMITATA
  -- 109    SOCIETA COOPERATIVA CONSORTILE
  -- 110    SOCIETA COOPERATIVA IN LIQUIDAZIONE
  -- 111    SOCIETA COOPERATIVE E LORO CONSORZI
  ----------------------------------------------------------------------
  vFormaGiuridica      DB_ANAGRAFICA_AZIENDA.ID_FORMA_GIURIDICA%TYPE;

  ERR_DATI        EXCEPTION;
  ERR_FG_NULL     EXCEPTION;
  ERR_FG_NOCOOP     EXCEPTION;

BEGIN

   BEGIN
     SELECT ID_FORMA_GIURIDICA INTO vFormaGiuridica
     FROM DB_ANAGRAFICA_AZIENDA
     WHERE id_azienda = p_id_azienda
     AND data_fine_validita IS NULL
     AND data_cessazione IS NULL;

   EXCEPTION
     WHEN NO_DATA_FOUND THEN
         RAISE ERR_DATI;

     WHEN TOO_MANY_ROWS THEN
        RAISE;

     WHEN OTHERS THEN
         RAISE;
   END;

   IF vFormaGiuridica IS NULL THEN
      RAISE ERR_FG_NULL;
   END IF;

   IF vFormaGiuridica NOT IN (6,7,14,36,73,74,75,76,77,95,103,107,108,109,110,111) THEN
      RAISE ERR_FG_NOCOOP;
   END IF;

   p_result := RET_OK;
   p_msg    := 'Controllo Forma Giuridica positivo';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_FG_NULL THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(153);
      p_id_err := 153;

   WHEN ERR_FG_NOCOOP THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(154);
      p_id_err := 154;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(152);
      p_id_err := 152;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [ADE03] ' || SQLERRM;
      p_id_err := 1;


END ADE03;

PROCEDURE ADE04(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- Controlla che la forma giuridica dell'azienda NON sia una cooperativa,
  -- Tutti i seguenti valori NON sono ammessi:
  -- 6    COOPERATIVE ISCRITTE REGISTRI
  -- 7    ALTRE COOPERATIVE
  -- 14    SOCIETA' COOPERATIVA
  -- 36    CONSORZIO DI COOPERATIVE
  -- 73    COOPERATIVA
  -- 74    COOPERATIVA A RESPONSABILITA LIMITATA IN LIQUIDAZIONE
  -- 75    COOPERATIVA SOCIALE
  -- 76    PICCOLA SOCIETA COOPERATIVA
  -- 77    PICCOLA SOCIETA COOP. A RESPONSABILITA LIMITATA
  -- 95    SOC. COOP. A RESPONSABILITA LIMITATA PER AZIONI
  -- 103    SOCIETA CONSORTILE COOP. A RESPONSABILITA LIMITATA
  -- 107    SOCIETA COOPERATIVA A RESPONSABILITA ILLIMITATA
  -- 108    SOCIETA COOPERATIVA A RESPONSABILITA LIMITATA
  -- 109    SOCIETA COOPERATIVA CONSORTILE
  -- 110    SOCIETA COOPERATIVA IN LIQUIDAZIONE
  -- 111    SOCIETA COOPERATIVE E LORO CONSORZI
  ----------------------------------------------------------------------
  vFormaGiuridica      DB_ANAGRAFICA_AZIENDA.ID_FORMA_GIURIDICA%TYPE;

  ERR_DATI        EXCEPTION;
  ERR_FG_NULL     EXCEPTION;
  ERR_FG_NOCOOP     EXCEPTION;

BEGIN

   BEGIN
     SELECT ID_FORMA_GIURIDICA INTO vFormaGiuridica
     FROM DB_ANAGRAFICA_AZIENDA
     WHERE id_azienda = p_id_azienda
     AND data_fine_validita IS NULL
     AND data_cessazione IS NULL;

   EXCEPTION
     WHEN NO_DATA_FOUND THEN
         RAISE ERR_DATI;

     WHEN TOO_MANY_ROWS THEN
        RAISE;

     WHEN OTHERS THEN
         RAISE;
   END;

   IF vFormaGiuridica IS NULL THEN
      RAISE ERR_FG_NULL;
   END IF;

   IF vFormaGiuridica IN (6,7,14,36,73,74,75,76,77,95,103,107,108,109,110,111) THEN
      RAISE ERR_FG_NOCOOP;
   END IF;

   p_result := RET_OK;
   p_msg    := 'Controllo Forma Giuridica positivo';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_FG_NULL THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(156);
      p_id_err := 156;

   WHEN ERR_FG_NOCOOP THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(157);
      p_id_err := 157;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(155);
      p_id_err := 155;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [ADE04] ' || SQLERRM;
      p_id_err := 1;


END ADE04;

 ----------------------------------------------------------------------
  -- Author  : Ernesto Ferrando
  -- Created : 07/07/2005
  -- This software is under GPL2 licence - read COPYING for details
  ----------------------------------------------------------------------
  -- ADE05
  -- Controllo che esista una dichiarazione di consistenza in anagrafe
  --
  --
  -- Parametri:
  -- p_id_azienda: identificativo della azienda
  -- p_result:     codice di ritorno
  -- p_msg:        messaggio di ritorno
  -- p_id_err:     identificativo del codice di errore.
  --
  ----------------------------------------------------------------------
PROCEDURE ADE05(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS

nRec           INTEGER;
ERR_DATI       EXCEPTION;
IdDichiarazioneConsistenza NUMBER;

BEGIN

      SELECT ID_DICHIARAZIONE_CONSISTENZA
        INTO IdDichiarazioneConsistenza
        FROM SMRGAA.DB_DICHIARAZIONE_CONSISTENZA
        WHERE ID_AZIENDA = p_id_azienda
        AND DATA =
      (SELECT MAX(DATA) FROM SMRGAA.DB_DICHIARAZIONE_CONSISTENZA
       WHERE ID_AZIENDA = p_id_azienda);

     p_result := RET_OK;
     p_msg    := '';
     p_id_err := NULL;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(937);
      p_id_err := 937;

  WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(936);
      p_id_err := 936;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [ADE05] ' || SQLERRM;
      p_id_err := 1;

END ADE05;

PROCEDURE ADE06(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- Controlla che la forma giuridica dell'azienda NON sia:
  -- PERSONA FISICA CHE NON ESERCITA ATTIVITA' D'IMPRESA (52)
  ----------------------------------------------------------------------
  vFormaGiuridica      DB_ANAGRAFICA_AZIENDA.ID_FORMA_GIURIDICA%TYPE;

  ERR_DATI                 EXCEPTION;
  ERR_FG_NULL              EXCEPTION;
  ERR_FG_NOPERSONAFISICA EXCEPTION;

BEGIN

   BEGIN
     SELECT ID_FORMA_GIURIDICA INTO vFormaGiuridica
     FROM DB_ANAGRAFICA_AZIENDA
     WHERE id_azienda = p_id_azienda
     AND data_fine_validita IS NULL
     AND data_cessazione IS NULL;

   EXCEPTION
     WHEN NO_DATA_FOUND THEN
         RAISE ERR_DATI;

     WHEN TOO_MANY_ROWS THEN
        RAISE;

     WHEN OTHERS THEN
         RAISE;
   END;

   IF vFormaGiuridica IS NULL THEN
      RAISE ERR_FG_NULL;
   END IF;

   IF vFormaGiuridica = 52 THEN
      RAISE ERR_FG_NOPERSONAFISICA;
   END IF;

   p_result := RET_OK;
   p_msg    := 'Controllo Forma Giuridica positivo';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_FG_NULL THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(1023);
      p_id_err := 1023;

   WHEN ERR_FG_NOPERSONAFISICA THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(1021);
      p_id_err := 1021;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(1022);
      p_id_err := 1022;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [ADE06] ' || SQLERRM;
      p_id_err := 1;
END ADE06;

-- Controlla che per ogni polizza dell'azienda
-- per l'anno della campagna passato in input e l'intervento
-- la data di stipula non sia maggiore della data di inizio copertura
PROCEDURE ASS01(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                pResult            OUT VARCHAR2,
                pMsg               OUT VARCHAR2) IS

    CURSOR curPolizzaNonCoperta IS
    SELECT PA.DATA_POLIZZA,
           PA.ID_POLIZZA_ASSICURATIVA,
           DPC.*
      FROM DB_POLIZZA_ASSICURATIVA PA,
           DB_DETTAGLIO_POLIZZA DP,
           DB_DETTAGLIO_POLIZZA_COLTURA DPC
     WHERE PA.ID_AZIENDA = pIdAzienda
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND ((pIdTipoIntervento IS NOT NULL AND PA.ID_TIPO_INTERVENTO = pIdTipoIntervento) OR pIdTipoIntervento IS NULL)
       AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
       AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
       AND TRUNC(PA.DATA_POLIZZA) > TRUNC(DPC.DATA_INIZIO_COPERTURA);

    recTAnomaliaPolizza DB_ANOMALIA_POLIZZA%ROWTYPE;
    knIdControlloASS01  CONSTANT DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE:=1100;
    bAnomalia           BOOLEAN:=FALSE;

BEGIN

    FOR recPolizzaNonCoperta IN curPolizzaNonCoperta LOOP
        SELECT SEQ_DB_ANOMALIA_POLIZZA.nextval
          INTO recTAnomaliaPolizza.ID_ANOMALIA_POLIZZA
          FROM DUAL;

        recTAnomaliaPolizza.ID_POLIZZA_ASSICURATIVA := recPolizzaNonCoperta.ID_POLIZZA_ASSICURATIVA;
        recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA := recPolizzaNonCoperta.ID_DETTAGLIO_POLIZZA;
        recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA_COLTURA := recPolizzaNonCoperta.ID_DETTAGLIO_POLIZZA_COLTURA;
        recTAnomaliaPolizza.ID_FONTE := knIdTipoFonteSiap;
        recTAnomaliaPolizza.ID_CONTROLLO := knIdControlloASS01;
        recTAnomaliaPolizza.DESCRIZIONE := 'La data di inizio copertura della polizza (' || TO_CHAR(recPolizzaNonCoperta.DATA_INIZIO_COPERTURA,'DD/MM/YYYY') ||
                                           ') è precedente alla data di stipula (' || TO_CHAR(recPolizzaNonCoperta.DATA_POLIZZA,'DD/MM/YYYY') || ')';
        recTAnomaliaPolizza.DATA_ESECUZIONE := SYSDATE;

        InsertTAnomaliaPolizza (recTAnomaliaPolizza);

        bAnomalia := TRUE;

    END LOOP;

    IF bAnomalia THEN
       pResult := RET_ERR_PROC;
       pMsg := 'Riscontrata presenza di polizze con data inizio copertura precedente alla data di stipula';
    ELSE
       pResult := RET_OK;
    END IF;
EXCEPTION
   WHEN OTHERS THEN
        pResult := RET_ERR;
        pMsg    := fncMessaggioErrore(1) || ' [ASS01] ' || SQLERRM;
END ASS01;

-- Controlla che per ogni polizza dell'azienda
-- per l'anno della campagna passato in input e l'intervento
-- la data di inizio copertura non sia precedente alla data di inizio campagna
PROCEDURE ASS02(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                pResult            OUT VARCHAR2,
                pMsg               OUT VARCHAR2) IS

    CURSOR curPolizzaCopertaPrecAnnoCp IS
    SELECT DPC.*,
           TO_DATE(DECODE(TP.CODICE_PERIODO, 'AP', '16/10/' || TO_CHAR(pAnnoCampagna -1),'01/01/' || TO_CHAR(pAnnoCampagna), 'DD/MM/YYYY')) AS DATA_CONFRONTO,
           TP.DESCRIZIONE,
           PA.ID_POLIZZA_ASSICURATIVA
      FROM DB_POLIZZA_ASSICURATIVA PA,
           DB_DETTAGLIO_POLIZZA DP,
           DB_DETTAGLIO_POLIZZA_COLTURA DPC,
           DB_TIPO_PERIODO TP
     WHERE PA.ID_AZIENDA = pIdAzienda
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND ((pIdTipoIntervento IS NOT NULL AND PA.ID_TIPO_INTERVENTO = pIdTipoIntervento) OR pIdTipoIntervento IS NULL)
       AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
       AND PA.ID_TIPO_PERIODO  = TP.ID_TIPO_PERIODO
       AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
       AND DPC.DATA_INIZIO_COPERTURA < TO_DATE(DECODE(TP.CODICE_PERIODO, 'AP', '16/10/' || TO_CHAR(pAnnoCampagna -1),'01/01/' || TO_CHAR(pAnnoCampagna)), 'DD/MM/YYYY');

    recTAnomaliaPolizza DB_ANOMALIA_POLIZZA%ROWTYPE;
    knIdControlloASS02  CONSTANT DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE:=1101;
    bAnomalia           BOOLEAN:=FALSE;

BEGIN

    FOR recPolizzaCopertaPrecAnnoCp IN curPolizzaCopertaPrecAnnoCp LOOP
        SELECT SEQ_DB_ANOMALIA_POLIZZA.nextval
          INTO recTAnomaliaPolizza.ID_ANOMALIA_POLIZZA
          FROM DUAL;

        recTAnomaliaPolizza.ID_POLIZZA_ASSICURATIVA := recPolizzaCopertaPrecAnnoCp.ID_POLIZZA_ASSICURATIVA;
        recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA := recPolizzaCopertaPrecAnnoCp.ID_DETTAGLIO_POLIZZA;
        recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA_COLTURA := recPolizzaCopertaPrecAnnoCp.ID_DETTAGLIO_POLIZZA_COLTURA;
        recTAnomaliaPolizza.ID_FONTE := knIdTipoFonteSiap;
        recTAnomaliaPolizza.ID_CONTROLLO := knIdControlloASS02;
        recTAnomaliaPolizza.DESCRIZIONE := 'La data di inizio copertura della polizza (' || TO_CHAR(recPolizzaCopertaPrecAnnoCp.DATA_INIZIO_COPERTURA,'DD/MM/YYYY') ||
                                           ') è precedente alla data di inizio del periodo di riferimento (' || recPolizzaCopertaPrecAnnoCp.DESCRIZIONE || ')specificato nella polizza (' || TO_CHAR(recPolizzaCopertaPrecAnnoCp.DATA_CONFRONTO, 'DD/MM/YYYY') || ')';
        recTAnomaliaPolizza.DATA_ESECUZIONE := SYSDATE;

        InsertTAnomaliaPolizza (recTAnomaliaPolizza);

        bAnomalia := TRUE;

    END LOOP;

    IF bAnomalia THEN
       pResult := RET_ERR_PROC;
       pMsg := 'Riscontrata presenza di polizze con data inizio copertura precedente alla data di inizio anno campagna';
    ELSE
       pResult := RET_OK;
    END IF;
EXCEPTION
   WHEN OTHERS THEN
        pResult := RET_ERR;
        pMsg    := fncMessaggioErrore(1) || ' [ASS02] ' || SQLERRM;
END ASS02;

-- Controlla che per ogni polizza dell'azienda
-- per l'anno della campagna passato in input e l'intervento
-- la data di fine copertura non sia successiva alla data di fine campagna
PROCEDURE ASS03(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                pResult            OUT VARCHAR2,
                pMsg               OUT VARCHAR2) IS

    CURSOR curPolizzaCopertaPostAnnoCp IS
    SELECT DPC.*,
           PA.ID_POLIZZA_ASSICURATIVA
      FROM DB_POLIZZA_ASSICURATIVA PA,
           DB_DETTAGLIO_POLIZZA DP,
           DB_DETTAGLIO_POLIZZA_COLTURA DPC
     WHERE PA.ID_AZIENDA = pIdAzienda
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND ((pIdTipoIntervento IS NOT NULL AND PA.ID_TIPO_INTERVENTO = pIdTipoIntervento) OR pIdTipoIntervento IS NULL)
       AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
       AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
       AND TRUNC(DPC.DATA_FINE_COPERTURA) > TO_DATE('31/12/' || pAnnoCampagna, 'DD/MM/YYYY');

    recTAnomaliaPolizza DB_ANOMALIA_POLIZZA%ROWTYPE;
    knIdControlloASS03  CONSTANT DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE:=1102;
    bAnomalia           BOOLEAN:=FALSE;

BEGIN

    FOR recPolizzaCopertaPostAnnoCp IN curPolizzaCopertaPostAnnoCp LOOP
        SELECT SEQ_DB_ANOMALIA_POLIZZA.nextval
          INTO recTAnomaliaPolizza.ID_ANOMALIA_POLIZZA
          FROM DUAL;

        recTAnomaliaPolizza.ID_POLIZZA_ASSICURATIVA := recPolizzaCopertaPostAnnoCp.ID_POLIZZA_ASSICURATIVA;
        recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA := recPolizzaCopertaPostAnnoCp.ID_DETTAGLIO_POLIZZA;
        recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA_COLTURA := recPolizzaCopertaPostAnnoCp.ID_DETTAGLIO_POLIZZA_COLTURA;
        recTAnomaliaPolizza.ID_FONTE := knIdTipoFonteSiap;
        recTAnomaliaPolizza.ID_CONTROLLO := knIdControlloASS03;
        recTAnomaliaPolizza.DESCRIZIONE := 'La data di fine copertura della polizza (' || TO_CHAR(recPolizzaCopertaPostAnnoCp.DATA_INIZIO_COPERTURA,'DD/MM/YYYY') ||
                                           ') è successiva alla data di fine anno campagna (' || TO_DATE('31/12/' || pAnnoCampagna, 'DD/MM/YYYY') || ')';
        recTAnomaliaPolizza.DATA_ESECUZIONE := SYSDATE;

        InsertTAnomaliaPolizza (recTAnomaliaPolizza);

        bAnomalia := TRUE;

    END LOOP;

    IF bAnomalia THEN
       pResult := RET_ERR_PROC;
       pMsg := 'Riscontrata presenza di polizze con data fine copertura successiva alla data di fine anno campagna';
    ELSE
       pResult := RET_OK;
    END IF;
EXCEPTION
   WHEN OTHERS THEN
        pResult := RET_ERR;
        pMsg    := fncMessaggioErrore(1) || ' [ASS03] ' || SQLERRM;
END ASS03;

-- Controlla che per ogni polizza dell'azienda
-- per l'anno della campagna passato in input e l'intervento
-- la data di quietanza sia stata valorizzata
PROCEDURE ASS04(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                pResult            OUT VARCHAR2,
                pMsg               OUT VARCHAR2) IS

    CURSOR curPolizzaCopertaPostAnnoCp IS
    SELECT DPC.*,
           PA.ID_POLIZZA_ASSICURATIVA
      FROM DB_POLIZZA_ASSICURATIVA PA,
           DB_DETTAGLIO_POLIZZA DP,
           DB_DETTAGLIO_POLIZZA_COLTURA DPC
     WHERE PA.ID_AZIENDA = pIdAzienda
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND ((pIdTipoIntervento IS NOT NULL AND PA.ID_TIPO_INTERVENTO = pIdTipoIntervento) OR pIdTipoIntervento IS NULL)
       AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
       AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
       AND PA.DATA_QUIETANZA IS NULL;

    recTAnomaliaPolizza DB_ANOMALIA_POLIZZA%ROWTYPE;
    knIdControlloASS04  CONSTANT DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE:=1103;
    bAnomalia           BOOLEAN:=FALSE;

BEGIN

    FOR recPolizzaCopertaPostAnnoCp IN curPolizzaCopertaPostAnnoCp LOOP
        SELECT SEQ_DB_ANOMALIA_POLIZZA.nextval
          INTO recTAnomaliaPolizza.ID_ANOMALIA_POLIZZA
          FROM DUAL;

        recTAnomaliaPolizza.ID_POLIZZA_ASSICURATIVA := recPolizzaCopertaPostAnnoCp.ID_POLIZZA_ASSICURATIVA;
        recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA := recPolizzaCopertaPostAnnoCp.ID_DETTAGLIO_POLIZZA;
        recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA_COLTURA := recPolizzaCopertaPostAnnoCp.ID_DETTAGLIO_POLIZZA_COLTURA;
        recTAnomaliaPolizza.ID_FONTE := knIdTipoFonteSiap;
        recTAnomaliaPolizza.ID_CONTROLLO := knIdControlloASS04;
        recTAnomaliaPolizza.DESCRIZIONE := 'La data di quietanza della polizza non è stata valorizzata';
        recTAnomaliaPolizza.DATA_ESECUZIONE := SYSDATE;

        InsertTAnomaliaPolizza (recTAnomaliaPolizza);

        bAnomalia := TRUE;

    END LOOP;

    IF bAnomalia THEN
       pResult := RET_ERR_PROC;
       pMsg := 'Riscontrata presenza di polizze con data quitenza non valorizzata';
    ELSE
       pResult := RET_OK;
    END IF;
EXCEPTION
   WHEN OTHERS THEN
        pResult := RET_ERR;
        pMsg    := fncMessaggioErrore(1) || ' [ASS04] ' || SQLERRM;
END ASS04;

-- Controlla per ogni polizza dell'azienda
-- per l'anno della campagna passato in input , l'intervento
-- e la dichiarazione di consistenza passate in input
-- che la superficie assicurata per comune e gruppo macrouso non
-- superi la superficie effettivamente dichiarata in fascicolo
PROCEDURE ASS05(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                pIdProcedimento     IN DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE,
                pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                pResult            OUT VARCHAR2,
                pMsg               OUT VARCHAR2) IS


    -- cursore che estrae il totale della superficie assicurata per l'azienda,
    -- la titopologia di intervento , il comune ed il macro uso
    CURSOR curSupAssPerComuneEGrMacroUso IS
    SELECT PA.ID_AZIENDA,
           PA.ID_TIPO_INTERVENTO,
           DPC.ISTAT_COMUNE,
           GMU.ID_GRUPPO_MACRO_USO,
           GMU.DESCRIZIONE,
           DPC.PROGR_RACCOLTO, 
           MIN(DPC.DATA_INIZIO_COPERTURA) AS MIN_DATA_INIZIO_COPERTURA,
           MAX (DPC.DATA_INIZIO_COPERTURA) AS MAX_DATA_INIZIO_COPERTURA,
           SUM(DPC.SUPERFICIE_ASSICURATA) AS TOT_ASSICURATA,
           SUM(DPC.IMPORTO_PREMIO) AS TOT_PREMIO
      FROM DB_POLIZZA_ASSICURATIVA PA,
           DB_DETTAGLIO_POLIZZA DP,
           DB_DETTAGLIO_POLIZZA_COLTURA DPC,
           DB_TIPO_MACRO_USO TMU,
           DB_GRUPPO_MACRO_USO GMU
     WHERE PA.ID_AZIENDA = pIdAzienda
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
       AND PA.ID_TIPO_INTERVENTO = pIdTipoIntervento
       AND DP.TIPO_DETTAGLIO = 'C'
       AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
       AND DPC.ID_MACRO_USO = TMU.ID_MACRO_USO
       AND TMU.ID_GRUPPO_MACRO_USO = GMU.ID_GRUPPO_MACRO_USO
       AND NOT EXISTS (SELECT AP.ID_ANOMALIA_POLIZZA
                         FROM DB_ANOMALIA_POLIZZA AP,
                              DB_TIPO_CONTROLLO_FASE TCF
                        WHERE AP.ID_DETTAGLIO_POLIZZA = DP.ID_DETTAGLIO_POLIZZA
                          AND AP.ID_FONTE = knIdTipoFonteSiap
                          AND AP.ID_CONTROLLO = TCF.ID_CONTROLLO
                          AND TCF.BLOCCANTE = 'S') 
       AND NOT EXISTS (SELECT AP.ID_ANOMALIA_POLIZZA
                         FROM DB_ANOMALIA_POLIZZA AP,
                              DB_TIPO_CONTROLLO_FASE TCF
                        WHERE AP.ID_POLIZZA_ASSICURATIVA = PA.ID_POLIZZA_ASSICURATIVA
                          AND AP.ID_FONTE = knIdTipoFonteSiap
                          AND AP.ID_CONTROLLO = TCF.ID_CONTROLLO
                          AND TCF.BLOCCANTE = 'S') 
  GROUP BY PA.ID_AZIENDA, PA.ID_TIPO_INTERVENTO, DPC.ISTAT_COMUNE, GMU.ID_GRUPPO_MACRO_USO , GMU.DESCRIZIONE, DPC.PROGR_RACCOLTO; 
    -- cursore che estrae il totale della superficie utilizzata
    -- per azienda , comune e macro uso e per tre identificativi dichiarazione consistenza
    -- dati in input (quello del procedimento , quello a alla minima data inizio copertura e quella alla
    -- massima data inzio copertura)
    CURSOR curTotUtilPerDichComuEMacroUso (pIdGruppoMacroUso            IN DB_TIPO_MACRO_USO.ID_GRUPPO_MACRO_USO%TYPE,
                                           pIstatComune                 IN DB_STORICO_PARTICELLA.COMUNE%TYPE,
                                           pIdDichConsistProc           IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                           pIdDichConsistDtInizCopMin   IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                           pIdDichConsistDtInizCopMax   IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE
                                           )IS
    SELECT DC.ID_DICHIARAZIONE_CONSISTENZA,
           NVL(SUM(UD.SUPERFICIE_UTILIZZATA),0) AS TOT_UTILIZZATA,
           DECODE(DC.ID_DICHIARAZIONE_CONSISTENZA,pIdDichConsistProc,'P',NULL) AS CRITERO_P,
           DECODE(DC.ID_DICHIARAZIONE_CONSISTENZA,pIdDichConsistDtInizCopMin,'F',NULL) AS CRITERO_F,
           DECODE(DC.ID_DICHIARAZIONE_CONSISTENZA,pIdDichConsistDtInizCopMax,'L',NULL) AS CRITERO_L
      FROM DB_DICHIARAZIONE_CONSISTENZA DC,
           DB_CONDUZIONE_DICHIARATA CD,
           DB_UTILIZZO_DICHIARATO UD,
           DB_STORICO_PARTICELLA SP,
           DB_TIPO_MACRO_USO_VARIETA TMV,
           DB_TIPO_MACRO_USO TMU,
           DB_TIT_POSSESSO_PROCEDIMENTO TPP
     WHERE DC.ID_DICHIARAZIONE_CONSISTENZA IN (pIdDichConsistProc,
                                               pIdDichConsistDtInizCopMin,
                                               pIdDichConsistDtInizCopMax)
       AND DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
       AND CD.ID_CONDUZIONE_DICHIARATA = UD.ID_CONDUZIONE_DICHIARATA
       AND CD.ID_STORICO_PARTICELLA = SP.ID_STORICO_PARTICELLA
       AND CD.ID_TITOLO_POSSESSO = TPP.ID_TITOLO_POSSESSO
       AND TPP.ID_PROCEDIMENTO = pIdProcedimento
       AND TPP.IMPORTA_TERRENI = 'S'
       AND TPP.DATA_FINE_VALIDITA IS NULL
       AND SP.COMUNE IN (SELECT ISTAT_COMUNE
                           FROM COMUNE
                          WHERE ISTAT_COMUNE = pIstatComune
                             OR COMUNE_NEW = pIstatComune) 
       AND UD.ID_CATALOGO_MATRICE = TMV.ID_CATALOGO_MATRICE 
       AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN TMV.DATA_INIZIO_VALIDITA
                                                 AND NVL(TMV.DATA_FINE_VALIDITA,DC.DATA_INSERIMENTO_DICHIARAZIONE)
       AND TMV.ID_MACRO_USO = TMU.ID_MACRO_USO
       AND TMU.ID_GRUPPO_MACRO_USO = pIdGruppoMacroUso
  GROUP BY DC.ID_DICHIARAZIONE_CONSISTENZA;

    -- cursore che estrae il dettaglio polizza coltura per
    -- l'azienda , l'anno campagna , l'intervento , il codice istat comune ed il macro uso dato in input
    CURSOR curDettaglioPolizzaXEsito (pIdAzienda        IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                                      pAnnoCampagna     IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                                      pIdTipoIntervento IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                                      pIstatComune      IN DB_DETTAGLIO_POLIZZA_COLTURA.ISTAT_COMUNE%TYPE,
                                      pIdGruppoMacroUso IN DB_TIPO_MACRO_USO.ID_GRUPPO_MACRO_USO%TYPE,
                                      pProgrRaccolto    IN DB_DETTAGLIO_POLIZZA_COLTURA.PROGR_RACCOLTO%TYPE
                                      ) IS
    SELECT DPC.*,
           PA.ID_POLIZZA_ASSICURATIVA
      FROM DB_POLIZZA_ASSICURATIVA PA,
           DB_DETTAGLIO_POLIZZA DP,
           DB_DETTAGLIO_POLIZZA_COLTURA DPC,
           DB_TIPO_MACRO_USO TMU
     WHERE PA.ID_AZIENDA = pIdAzienda
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
       AND PA.ID_TIPO_INTERVENTO = pIdTipoIntervento
       AND DP.TIPO_DETTAGLIO = 'C'
       AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
       AND DPC.ISTAT_COMUNE = pIstatComune
       AND NVL(DPC.PROGR_RACCOLTO, -1) = NVL(pProgrRaccolto, -1) 
       AND DPC.ID_MACRO_USO = TMU.ID_MACRO_USO
       AND TMU.ID_GRUPPO_MACRO_USO = pIdGruppoMacroUso;

    knIdControlloASS05          CONSTANT DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE:=1104;
    bAnomalia                   BOOLEAN:=FALSE;
    nTotUtilizzaComuEMacroUso   NUMBER;
    recTAnomaliaPolizza         DB_ANOMALIA_POLIZZA%ROWTYPE;
    recTEsitoDettPolizza        DB_ESITO_DETTAGLIO_POLIZZA%ROWTYPE;
    nIdDichConsistProc          DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE;
    nIdDichConsistDtInizCopMin  DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE;
    nIdDichConsistDtInizCopMax  DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE;
    nNumRec                     INTEGER:=0;
BEGIN

    -- prendo la dichiarazione di consistenza della pratica del procedimento in istruttoria per l'anno campagna
    nIdDichConsistProc := SelDichConsForAziendaProcAnno (pIdAzienda,
                                                         pIdProcedimento,
                                                         pAnnoCampagna);
    -- scirro il cursore della superficie assicurata totale per comune e macro uso
    FOR recSupAssPerComuneEGrMacroUso IN curSupAssPerComuneEGrMacroUso LOOP

        -- prendo l'ultima dichiarazione di consistenza per l'anno campagna compatibile col procedimento
        -- e con data inferiore alla data minima di inizio copertura
        nIdDichConsistDtInizCopMin := SelDichConsForAzProcAnnoData (pIdAzienda,
                                                                    pIdProcedimento,
                                                                    pAnnoCampagna,
                                                                    recSupAssPerComuneEGrMacroUso.MIN_DATA_INIZIO_COPERTURA
                                                                    );
        -- prendo l'ultima dichiarazione di consistenza per l'anno campagna compatibile col procedimento
        -- e con data inferiore alla data massima di inizio copertura
        nIdDichConsistDtInizCopMax := SelDichConsForAzProcAnnoData (pIdAzienda,
                                                                    pIdProcedimento,
                                                                    pAnnoCampagna,
                                                                    recSupAssPerComuneEGrMacroUso.MAX_DATA_INIZIO_COPERTURA
                                                                    );
        nNumRec := 0;
        -- scorro il cursore della superficie utilizzata totale per comune , macro uso e le tre dichiarazioni di consistenza
        FOR recTotUtilPerDichComuEMacroUso IN curTotUtilPerDichComuEMacroUso (recSupAssPerComuneEGrMacroUso.ID_GRUPPO_MACRO_USO,
                                                                              recSupAssPerComuneEGrMacroUso.ISTAT_COMUNE,
                                                                              nIdDichConsistProc,
                                                                              nIdDichConsistDtInizCopMin,
                                                                              nIdDichConsistDtInizCopMax) LOOP
            nNumRec := nNumRec + 1;
            -- trasformo la superficie utilizzata in metri quadrati
            nTotUtilizzaComuEMacroUso := recTotUtilPerDichComuEMacroUso.TOT_UTILIZZATA * 10000;
            -- controllo se è essa è maggiore od uguale alla superficie assicurata
            IF nTotUtilizzaComuEMacroUso >= recSupAssPerComuneEGrMacroUso.TOT_ASSICURATA THEN
               -- se lo è il coefficiente di riproporzionamento è ad 1
               recTEsitoDettPolizza.COEFFICIENTE := 1;
            ELSE
               -- altrimenti lo calcolo
               recTEsitoDettPolizza.COEFFICIENTE := nTotUtilizzaComuEMacroUso / recSupAssPerComuneEGrMacroUso.TOT_ASSICURATA;
            END IF;
            -- scorro il cursore dei dettaglio polizza coltura per l'azienda il comune ed il macro uso
            FOR recDettaglioPolizzaXEsito IN curDettaglioPolizzaXEsito (recSupAssPerComuneEGrMacroUso.ID_AZIENDA,
                                                                        pAnnoCampagna,
                                                                        recSupAssPerComuneEGrMacroUso.ID_TIPO_INTERVENTO,
                                                                        recSupAssPerComuneEGrMacroUso.ISTAT_COMUNE,
                                                                        recSupAssPerComuneEGrMacroUso.ID_GRUPPO_MACRO_USO,
                                                                        recSupAssPerComuneEGrMacroUso.PROGR_RACCOLTO 
                                                                        ) LOOP

               -- applicando il coefficiente calcolato sopra all'importo premio
               recTEsitoDettPolizza.ID_DETTAGLIO_POLIZZA := recDettaglioPolizzaXEsito.ID_DETTAGLIO_POLIZZA;
               recTEsitoDettPolizza.ID_DICHIARAZIONE_CONSISTENZA := recTotUtilPerDichComuEMacroUso.ID_DICHIARAZIONE_CONSISTENZA;
               recTEsitoDettPolizza.ID_GRUPPO_MACRO_USO := recSupAssPerComuneEGrMacroUso.ID_GRUPPO_MACRO_USO;
               recTEsitoDettPolizza.ISTAT_COMUNE := recDettaglioPolizzaXEsito.ISTAT_COMUNE;
               recTEsitoDettPolizza.TOTALE_SUP_DICHIARATA := nTotUtilizzaComuEMacroUso;
               recTEsitoDettPolizza.TOTALE_SUP_ASSICURATA := recSupAssPerComuneEGrMacroUso.TOT_ASSICURATA;
               recTEsitoDettPolizza.IMPORTO_PROPOSTO := recDettaglioPolizzaXEsito.IMPORTO_PREMIO * recTEsitoDettPolizza.COEFFICIENTE;
               recTEsitoDettPolizza.DATA_CALCOLO := SYSDATE;
               IF recTotUtilPerDichComuEMacroUso.CRITERO_P IS NOT NULL THEN
                  SELECT SEQ_DB_ESITO_DETTAGLIO_POLIZZA.nextval
                    INTO recTEsitoDettPolizza.ID_ESITO_DETTAGLIO_POLIZZA
                    FROM DUAL;
                  recTEsitoDettPolizza.TIPO_CRITERIO := recTotUtilPerDichComuEMacroUso.CRITERO_P;
                  InsertTEsitoDettaglioPolizza (recTEsitoDettPolizza);
               END IF;

               IF recTotUtilPerDichComuEMacroUso.CRITERO_F IS NOT NULL THEN
                  SELECT SEQ_DB_ESITO_DETTAGLIO_POLIZZA.nextval
                    INTO recTEsitoDettPolizza.ID_ESITO_DETTAGLIO_POLIZZA
                    FROM DUAL;
                  recTEsitoDettPolizza.TIPO_CRITERIO := recTotUtilPerDichComuEMacroUso.CRITERO_F;
                  InsertTEsitoDettaglioPolizza (recTEsitoDettPolizza);
               END IF;

               IF recTotUtilPerDichComuEMacroUso.CRITERO_L IS NOT NULL THEN
                  SELECT SEQ_DB_ESITO_DETTAGLIO_POLIZZA.nextval
                    INTO recTEsitoDettPolizza.ID_ESITO_DETTAGLIO_POLIZZA
                    FROM DUAL;
                  recTEsitoDettPolizza.TIPO_CRITERIO := recTotUtilPerDichComuEMacroUso.CRITERO_L;
                  InsertTEsitoDettaglioPolizza (recTEsitoDettPolizza);
               END IF;

               -- se il totale della superficie assicurata per comune e macro uso superava il totale della superficie
               -- utilizzata
               IF recSupAssPerComuneEGrMacroUso.TOT_ASSICURATA > nTotUtilizzaComuEMacroUso THEN
                  -- segnalo anche apposita anomalia
                  bAnomalia := TRUE;

                  SELECT SEQ_DB_ANOMALIA_POLIZZA.nextval
                    INTO recTAnomaliaPolizza.ID_ANOMALIA_POLIZZA
                    FROM DUAL;

                  recTAnomaliaPolizza.ID_POLIZZA_ASSICURATIVA := recDettaglioPolizzaXEsito.ID_POLIZZA_ASSICURATIVA;
                  recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA := recDettaglioPolizzaXEsito.ID_DETTAGLIO_POLIZZA;
                  recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA_COLTURA := recDettaglioPolizzaXEsito.ID_DETTAGLIO_POLIZZA_COLTURA;
                  recTAnomaliaPolizza.ID_FONTE := knIdTipoFonteSiap;
                  recTAnomaliaPolizza.ID_CONTROLLO := knIdControlloASS05;
                  recTAnomaliaPolizza.DESCRIZIONE := 'La superficie assicurata (' || recSupAssPerComuneEGrMacroUso.TOT_ASSICURATA || ') per il gruppo macro uso : ' ||
                                                                                     recSupAssPerComuneEGrMacroUso.DESCRIZIONE || ' nel comune : ' ||
                                                                                     recSupAssPerComuneEGrMacroUso.ISTAT_COMUNE || ' risulta maggiore di quanto dichiarato in fascicolo (' ||
                                                                                     nTotUtilizzaComuEMacroUso || ')';
                  recTAnomaliaPolizza.DATA_ESECUZIONE := SYSDATE;
                  InsertTAnomaliaPolizza (recTAnomaliaPolizza);
               END IF;

           END LOOP;
        END LOOP;

        IF nNumRec = 0 THEN
            -- scorro il cursore dei dettaglio polizza coltura per l'azienda il comune ed il macro uso
            FOR recDettaglioPolizzaXEsito IN curDettaglioPolizzaXEsito (recSupAssPerComuneEGrMacroUso.ID_AZIENDA,
                                                                        pAnnoCampagna,
                                                                        recSupAssPerComuneEGrMacroUso.ID_TIPO_INTERVENTO,
                                                                        recSupAssPerComuneEGrMacroUso.ISTAT_COMUNE,
                                                                        recSupAssPerComuneEGrMacroUso.ID_GRUPPO_MACRO_USO,
                                                                        recSupAssPerComuneEGrMacroUso.PROGR_RACCOLTO 
                                                                        ) LOOP

                -- applicando il coefficiente calcolato sopra all'importo premio
                recTEsitoDettPolizza.ID_DETTAGLIO_POLIZZA := recDettaglioPolizzaXEsito.ID_DETTAGLIO_POLIZZA;
                recTEsitoDettPolizza.ID_GRUPPO_MACRO_USO := recSupAssPerComuneEGrMacroUso.ID_GRUPPO_MACRO_USO;
                recTEsitoDettPolizza.ISTAT_COMUNE := recDettaglioPolizzaXEsito.ISTAT_COMUNE;
                recTEsitoDettPolizza.COEFFICIENTE := 0;
                recTEsitoDettPolizza.TOTALE_SUP_DICHIARATA := 0;
                recTEsitoDettPolizza.TOTALE_SUP_ASSICURATA := recSupAssPerComuneEGrMacroUso.TOT_ASSICURATA;
                recTEsitoDettPolizza.IMPORTO_PROPOSTO := 0;
                recTEsitoDettPolizza.DATA_CALCOLO := SYSDATE;

                IF nIdDichConsistProc IS NOT NULL THEN
                   recTEsitoDettPolizza.ID_DICHIARAZIONE_CONSISTENZA := nIdDichConsistProc;
                   SELECT SEQ_DB_ESITO_DETTAGLIO_POLIZZA.nextval
                     INTO recTEsitoDettPolizza.ID_ESITO_DETTAGLIO_POLIZZA
                     FROM DUAL;
                   recTEsitoDettPolizza.TIPO_CRITERIO := 'P';
                   InsertTEsitoDettaglioPolizza (recTEsitoDettPolizza);
                END IF;

                IF nIdDichConsistDtInizCopMin IS NOT NULL THEN
                   recTEsitoDettPolizza.ID_DICHIARAZIONE_CONSISTENZA := nIdDichConsistDtInizCopMin;
                   SELECT SEQ_DB_ESITO_DETTAGLIO_POLIZZA.nextval
                     INTO recTEsitoDettPolizza.ID_ESITO_DETTAGLIO_POLIZZA
                     FROM DUAL;
                   recTEsitoDettPolizza.TIPO_CRITERIO := 'F';
                   InsertTEsitoDettaglioPolizza (recTEsitoDettPolizza);
                END IF;

                IF nIdDichConsistDtInizCopMax IS NOT NULL THEN
                   recTEsitoDettPolizza.ID_DICHIARAZIONE_CONSISTENZA := nIdDichConsistDtInizCopMax;
                   SELECT SEQ_DB_ESITO_DETTAGLIO_POLIZZA.nextval
                     INTO recTEsitoDettPolizza.ID_ESITO_DETTAGLIO_POLIZZA
                     FROM DUAL;
                   recTEsitoDettPolizza.TIPO_CRITERIO := 'L';
                   InsertTEsitoDettaglioPolizza (recTEsitoDettPolizza);
                END IF;

                -- se il totale della superficie assicurata per comune e macro uso superava il totale della superficie
                -- utilizzata
                IF recSupAssPerComuneEGrMacroUso.TOT_ASSICURATA > recTEsitoDettPolizza.TOTALE_SUP_DICHIARATA THEN
                   -- segnalo anche apposita anomalia
                   bAnomalia := TRUE;

                   SELECT SEQ_DB_ANOMALIA_POLIZZA.nextval
                     INTO recTAnomaliaPolizza.ID_ANOMALIA_POLIZZA
                     FROM DUAL;

                   recTAnomaliaPolizza.ID_POLIZZA_ASSICURATIVA := recDettaglioPolizzaXEsito.ID_POLIZZA_ASSICURATIVA;
                   recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA := recDettaglioPolizzaXEsito.ID_DETTAGLIO_POLIZZA;
                   recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA_COLTURA := recDettaglioPolizzaXEsito.ID_DETTAGLIO_POLIZZA_COLTURA;
                   recTAnomaliaPolizza.ID_FONTE := knIdTipoFonteSiap;
                   recTAnomaliaPolizza.ID_CONTROLLO := knIdControlloASS05;
                   recTAnomaliaPolizza.DESCRIZIONE := 'La superficie assicurata (' || recSupAssPerComuneEGrMacroUso.TOT_ASSICURATA || ') per il gruppo macro uso : ' ||
                                                                                      recSupAssPerComuneEGrMacroUso.DESCRIZIONE || ' nel comune : ' ||
                                                                                      recSupAssPerComuneEGrMacroUso.ISTAT_COMUNE || ' risulta maggiore di quanto dichiarato in fascicolo (' ||
                                                                                      recTEsitoDettPolizza.TOTALE_SUP_DICHIARATA || ')';
                   recTAnomaliaPolizza.DATA_ESECUZIONE := SYSDATE;
                   InsertTAnomaliaPolizza (recTAnomaliaPolizza);
                END IF;

            END LOOP;
        END IF;

    END LOOP;

    IF bAnomalia THEN
       pResult := RET_ERR_PROC;
       pMsg := 'Riscontrata presenza di polizze con superficie assicurata maggiore della superficie utilizzata presente in fascicolo';
    ELSE
       pResult := RET_OK;
    END IF;

EXCEPTION
   WHEN OTHERS THEN
        pResult := RET_ERR;
        pMsg    := fncMessaggioErrore(1) || ' [ASS05] ' || SQLERRM;
END ASS05;


-- Controlla per ogni polizza dell'azienda
-- per l'anno della campagna passato in input , l'intervento
-- e la dichiarazione di consistenza passate in input
-- che la superficie assicurata per comune e macrouso non
-- superi la superficie effettivamente dichiarata in fascicolo
PROCEDURE ASS06(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                pIdProcedimento     IN DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE,
                pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                pResult            OUT VARCHAR2,
                pMsg               OUT VARCHAR2) IS


    -- cursore che estrae il totale della superficie assicurata per l'azienda,
    -- la titopologia di intervento , il comune ed il macro uso
    CURSOR curSupAssPerComuneEMacroUso IS
    SELECT PA.ID_AZIENDA,
           PA.ID_TIPO_INTERVENTO,
           DPC.ISTAT_COMUNE,
           DPC.ID_MACRO_USO,
           TMU.DESCRIZIONE,
           DPC.PROGR_RACCOLTO, 
           MIN(DPC.DATA_INIZIO_COPERTURA) AS MIN_DATA_INIZIO_COPERTURA,
           MAX (DPC.DATA_INIZIO_COPERTURA) AS MAX_DATA_INIZIO_COPERTURA,
           SUM(DPC.SUPERFICIE_ASSICURATA) AS TOT_ASSICURATA,
           SUM(DPC.IMPORTO_PREMIO) AS TOT_PREMIO
      FROM DB_POLIZZA_ASSICURATIVA PA,
           DB_DETTAGLIO_POLIZZA DP,
           DB_DETTAGLIO_POLIZZA_COLTURA DPC,
           DB_TIPO_MACRO_USO TMU
     WHERE PA.ID_AZIENDA = pIdAzienda
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
       AND PA.ID_TIPO_INTERVENTO = pIdTipoIntervento
       AND DP.TIPO_DETTAGLIO = 'C'
       AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
       AND DPC.ID_MACRO_USO = TMU.ID_MACRO_USO (+)
       AND NOT EXISTS (SELECT AP.ID_ANOMALIA_POLIZZA
                         FROM DB_ANOMALIA_POLIZZA AP,
                              DB_TIPO_CONTROLLO_FASE TCF
                        WHERE AP.ID_DETTAGLIO_POLIZZA = DP.ID_DETTAGLIO_POLIZZA
                          AND AP.ID_FONTE = knIdTipoFonteSiap
                          AND AP.ID_CONTROLLO = TCF.ID_CONTROLLO
                          AND TCF.BLOCCANTE = 'S') 
       AND NOT EXISTS (SELECT AP.ID_ANOMALIA_POLIZZA
                         FROM DB_ANOMALIA_POLIZZA AP,
                              DB_TIPO_CONTROLLO_FASE TCF
                        WHERE AP.ID_POLIZZA_ASSICURATIVA = PA.ID_POLIZZA_ASSICURATIVA
                          AND AP.ID_FONTE = knIdTipoFonteSiap
                          AND AP.ID_CONTROLLO = TCF.ID_CONTROLLO
                          AND TCF.BLOCCANTE = 'S') 
  GROUP BY PA.ID_AZIENDA, PA.ID_TIPO_INTERVENTO,DPC.ISTAT_COMUNE, DPC.ID_MACRO_USO, TMU.DESCRIZIONE, DPC.PROGR_RACCOLTO; 

    -- cursore che estrae il totale della superficie utilizzata
    -- per azienda , comune e macro uso e per tre identificativi dichiarazione consistenza
    -- dati in input (quello del procedimento , quello a alla minima data inizio copertura e quella alla
    -- massima data inzio copertura)
    CURSOR curTotUtilPerDichComuEMacroUso (pIdMacroUso                  IN DB_TIPO_MACRO_USO_VARIETA.ID_MACRO_USO%TYPE,
                                           pIstatComune                 IN DB_STORICO_PARTICELLA.COMUNE%TYPE,
                                           pIdDichConsistProc           IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                           pIdDichConsistDtInizCopMin   IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                           pIdDichConsistDtInizCopMax   IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE
                                           )IS
    SELECT DC.ID_DICHIARAZIONE_CONSISTENZA,
           NVL(SUM(UD.SUPERFICIE_UTILIZZATA),0) AS TOT_UTILIZZATA,
           DECODE(DC.ID_DICHIARAZIONE_CONSISTENZA,pIdDichConsistProc,'P',NULL) AS CRITERO_P,
           DECODE(DC.ID_DICHIARAZIONE_CONSISTENZA,pIdDichConsistDtInizCopMin,'F',NULL) AS CRITERO_F,
           DECODE(DC.ID_DICHIARAZIONE_CONSISTENZA,pIdDichConsistDtInizCopMax,'L',NULL) AS CRITERO_L
      FROM DB_DICHIARAZIONE_CONSISTENZA DC,
           DB_CONDUZIONE_DICHIARATA CD,
           DB_UTILIZZO_DICHIARATO UD,
           DB_STORICO_PARTICELLA SP,
           DB_TIPO_MACRO_USO_VARIETA TMV,
           DB_TIT_POSSESSO_PROCEDIMENTO TPP
     WHERE DC.ID_DICHIARAZIONE_CONSISTENZA IN (pIdDichConsistProc,
                                               pIdDichConsistDtInizCopMin,
                                               pIdDichConsistDtInizCopMax)
       AND DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
       AND CD.ID_CONDUZIONE_DICHIARATA = UD.ID_CONDUZIONE_DICHIARATA
       AND CD.ID_STORICO_PARTICELLA = SP.ID_STORICO_PARTICELLA
       AND CD.ID_TITOLO_POSSESSO = TPP.ID_TITOLO_POSSESSO
       AND TPP.ID_PROCEDIMENTO = pIdProcedimento
       AND TPP.IMPORTA_TERRENI = 'S'
       AND TPP.DATA_FINE_VALIDITA IS NULL
       AND SP.COMUNE IN (SELECT ISTAT_COMUNE
                           FROM COMUNE
                          WHERE ISTAT_COMUNE = pIstatComune
                             OR COMUNE_NEW = pIstatComune) 
       AND UD.ID_CATALOGO_MATRICE = TMV.ID_CATALOGO_MATRICE 
       AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN TMV.DATA_INIZIO_VALIDITA
                                                 AND NVL(TMV.DATA_FINE_VALIDITA,DC.DATA_INSERIMENTO_DICHIARAZIONE)
       AND TMV.ID_MACRO_USO = pIdMacroUso
    GROUP BY DC.ID_DICHIARAZIONE_CONSISTENZA;

    -- cursore che estrae il dettaglio polizza coltura per
    -- l'azienda , l'anno campagna , l'intervento , il codice istat comune ed il macro uso dato in input
    CURSOR curDettaglioPolizzaXEsito (pIdAzienda        IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                                      pAnnoCampagna     IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                                      pIdTipoIntervento IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                                      pIstatComune      IN DB_DETTAGLIO_POLIZZA_COLTURA.ISTAT_COMUNE%TYPE,
                                      pIdMacroUso       IN DB_DETTAGLIO_POLIZZA_COLTURA.ID_MACRO_USO%TYPE,
                                      pProgrRaccolto    IN DB_DETTAGLIO_POLIZZA_COLTURA.PROGR_RACCOLTO%TYPE
                                      ) IS
    SELECT DPC.*,
           PA.ID_POLIZZA_ASSICURATIVA
      FROM DB_POLIZZA_ASSICURATIVA PA,
           DB_DETTAGLIO_POLIZZA DP,
           DB_DETTAGLIO_POLIZZA_COLTURA DPC
     WHERE PA.ID_AZIENDA = pIdAzienda
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
       AND PA.ID_TIPO_INTERVENTO = pIdTipoIntervento
       AND DP.TIPO_DETTAGLIO = 'C'
       AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
       AND DPC.ISTAT_COMUNE = pIstatComune
       AND NVL(DPC.PROGR_RACCOLTO, -1) = NVL(pProgrRaccolto, -1) 
       AND DPC.ID_MACRO_USO = pIdMacroUso;

    knIdControlloASS06          CONSTANT DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE:=1105;
    bAnomalia                   BOOLEAN:=FALSE;
    nTotUtilizzaComuEMacroUso   NUMBER;
    recTAnomaliaPolizza         DB_ANOMALIA_POLIZZA%ROWTYPE;
    recTEsitoDettPolizza        DB_ESITO_DETTAGLIO_POLIZZA%ROWTYPE;
    nIdDichConsistProc          DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE;
    nIdDichConsistDtInizCopMin  DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE;
    nIdDichConsistDtInizCopMax  DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE;
    nNumRec                     INTEGER:=0;
BEGIN

    -- prendo la dichiarazione di consistenza della pratica del procedimento in istruttoria per l'anno campagna
    nIdDichConsistProc := SelDichConsForAziendaProcAnno (pIdAzienda,
                                                         pIdProcedimento,
                                                         pAnnoCampagna);
    -- scirro il cursore della superficie assicurata totale per comune e macro uso
    FOR recSupAssPerComuneEMacroUso IN curSupAssPerComuneEMacroUso LOOP

        -- prendo l'ultima dichiarazione di consistenza per l'anno campagna compatibile col procedimento
        -- e con data inferiore alla data minima di inizio copertura
        nIdDichConsistDtInizCopMin := SelDichConsForAzProcAnnoData (pIdAzienda,
                                                                    pIdProcedimento,
                                                                    pAnnoCampagna,
                                                                    recSupAssPerComuneEMacroUso.MIN_DATA_INIZIO_COPERTURA
                                                                    );
        -- prendo l'ultima dichiarazione di consistenza per l'anno campagna compatibile col procedimento
        -- e con data inferiore alla data massima di inizio copertura
        nIdDichConsistDtInizCopMax := SelDichConsForAzProcAnnoData (pIdAzienda,
                                                                    pIdProcedimento,
                                                                    pAnnoCampagna,
                                                                    recSupAssPerComuneEMacroUso.MAX_DATA_INIZIO_COPERTURA
                                                                    );
        nNumRec := 0;
        -- scorro il cursore della superficie utilizzata totale per comune , macro uso e le tre dichiarazioni di consistenza
        FOR recTotUtilPerDichComuEMacroUso IN curTotUtilPerDichComuEMacroUso (recSupAssPerComuneEMacroUso.ID_MACRO_USO,
                                                                              recSupAssPerComuneEMacroUso.ISTAT_COMUNE,
                                                                              nIdDichConsistProc,
                                                                              nIdDichConsistDtInizCopMin,
                                                                              nIdDichConsistDtInizCopMax) LOOP
            nNumRec := nNumRec + 1;
            -- trasformo la superficie utilizzata in metri quadrati
            nTotUtilizzaComuEMacroUso := recTotUtilPerDichComuEMacroUso.TOT_UTILIZZATA * 10000;
            -- controllo se è essa è maggiore od uguale alla superficie assicurata
            IF nTotUtilizzaComuEMacroUso >= recSupAssPerComuneEMacroUso.TOT_ASSICURATA THEN
               -- se lo è il coefficiente di riproporzionamento è ad 1
               recTEsitoDettPolizza.COEFFICIENTE := 1;
            ELSE
               -- altrimenti lo calcolo
               recTEsitoDettPolizza.COEFFICIENTE := nTotUtilizzaComuEMacroUso / recSupAssPerComuneEMacroUso.TOT_ASSICURATA;
            END IF;
            -- scorro il cursore dei dettaglio polizza coltura per l'azienda il comune ed il macro uso
            FOR recDettaglioPolizzaXEsito IN curDettaglioPolizzaXEsito (recSupAssPerComuneEMacroUso.ID_AZIENDA,
                                                                        pAnnoCampagna,
                                                                        recSupAssPerComuneEMacroUso.ID_TIPO_INTERVENTO,
                                                                        recSupAssPerComuneEMacroUso.ISTAT_COMUNE,
                                                                        recSupAssPerComuneEMacroUso.ID_MACRO_USO,
                                                                        recSupAssPerComuneEMacroUso.PROGR_RACCOLTO 
                                                                        ) LOOP

               -- applicando il coefficiente calcolato sopra all'importo premio
               recTEsitoDettPolizza.ID_DETTAGLIO_POLIZZA := recDettaglioPolizzaXEsito.ID_DETTAGLIO_POLIZZA;
               recTEsitoDettPolizza.ID_DICHIARAZIONE_CONSISTENZA := recTotUtilPerDichComuEMacroUso.ID_DICHIARAZIONE_CONSISTENZA;
               recTEsitoDettPolizza.ID_MACRO_USO := recDettaglioPolizzaXEsito.ID_MACRO_USO;
               recTEsitoDettPolizza.ISTAT_COMUNE := recDettaglioPolizzaXEsito.ISTAT_COMUNE;
               recTEsitoDettPolizza.TOTALE_SUP_DICHIARATA := nTotUtilizzaComuEMacroUso;
               recTEsitoDettPolizza.TOTALE_SUP_ASSICURATA := recSupAssPerComuneEMacroUso.TOT_ASSICURATA;
               recTEsitoDettPolizza.IMPORTO_PROPOSTO := recDettaglioPolizzaXEsito.IMPORTO_PREMIO * recTEsitoDettPolizza.COEFFICIENTE;
               recTEsitoDettPolizza.DATA_CALCOLO := SYSDATE;
               IF recTotUtilPerDichComuEMacroUso.CRITERO_P IS NOT NULL THEN
                  SELECT SEQ_DB_ESITO_DETTAGLIO_POLIZZA.nextval
                    INTO recTEsitoDettPolizza.ID_ESITO_DETTAGLIO_POLIZZA
                    FROM DUAL;
                  recTEsitoDettPolizza.TIPO_CRITERIO := recTotUtilPerDichComuEMacroUso.CRITERO_P;
                  InsertTEsitoDettaglioPolizza (recTEsitoDettPolizza);
               END IF;

               IF recTotUtilPerDichComuEMacroUso.CRITERO_F IS NOT NULL THEN
                  SELECT SEQ_DB_ESITO_DETTAGLIO_POLIZZA.nextval
                    INTO recTEsitoDettPolizza.ID_ESITO_DETTAGLIO_POLIZZA
                    FROM DUAL;
                  recTEsitoDettPolizza.TIPO_CRITERIO := recTotUtilPerDichComuEMacroUso.CRITERO_F;
                  InsertTEsitoDettaglioPolizza (recTEsitoDettPolizza);
               END IF;

               IF recTotUtilPerDichComuEMacroUso.CRITERO_L IS NOT NULL THEN
                  SELECT SEQ_DB_ESITO_DETTAGLIO_POLIZZA.nextval
                    INTO recTEsitoDettPolizza.ID_ESITO_DETTAGLIO_POLIZZA
                    FROM DUAL;
                  recTEsitoDettPolizza.TIPO_CRITERIO := recTotUtilPerDichComuEMacroUso.CRITERO_L;
                  InsertTEsitoDettaglioPolizza (recTEsitoDettPolizza);
               END IF;

               -- se il totale della superficie assicurata per comune e macro uso superava il totale della superficie
               -- utilizzata
               IF recSupAssPerComuneEMacroUso.TOT_ASSICURATA > nTotUtilizzaComuEMacroUso THEN
                  -- segnalo anche apposita anomalia
                  bAnomalia := TRUE;

                  SELECT SEQ_DB_ANOMALIA_POLIZZA.nextval
                    INTO recTAnomaliaPolizza.ID_ANOMALIA_POLIZZA
                    FROM DUAL;

                  recTAnomaliaPolizza.ID_POLIZZA_ASSICURATIVA :=  recDettaglioPolizzaXEsito.ID_POLIZZA_ASSICURATIVA;
                  recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA := recDettaglioPolizzaXEsito.ID_DETTAGLIO_POLIZZA;
                  recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA_COLTURA := recDettaglioPolizzaXEsito.ID_DETTAGLIO_POLIZZA_COLTURA;
                  recTAnomaliaPolizza.ID_FONTE := knIdTipoFonteSiap;
                  recTAnomaliaPolizza.ID_CONTROLLO := knIdControlloASS06;
                  recTAnomaliaPolizza.DESCRIZIONE := 'La superficie assicurata (' || recSupAssPerComuneEMacroUso.TOT_ASSICURATA || ') per il macro uso : ' ||
                                                                                     recSupAssPerComuneEMacroUso.DESCRIZIONE || ' nel comune : ' ||
                                                                                     recSupAssPerComuneEMacroUso.ISTAT_COMUNE || ' risulta maggiore di quanto dichiarato in fascicolo (' ||
                                                                                     nTotUtilizzaComuEMacroUso || ')';
                  recTAnomaliaPolizza.DATA_ESECUZIONE := SYSDATE;
                  InsertTAnomaliaPolizza (recTAnomaliaPolizza);
               END IF;

           END LOOP;
        END LOOP;

        -- di consistenza non è stato trovato nulla su SMRGAA
        IF nNumRec = 0 THEN
            -- scorro il cursore dei dettaglio polizza coltura per l'azienda il comune ed il macro uso
            FOR recDettaglioPolizzaXEsito IN curDettaglioPolizzaXEsito (recSupAssPerComuneEMacroUso.ID_AZIENDA,
                                                                        pAnnoCampagna,
                                                                        recSupAssPerComuneEMacroUso.ID_TIPO_INTERVENTO,
                                                                        recSupAssPerComuneEMacroUso.ISTAT_COMUNE,
                                                                        recSupAssPerComuneEMacroUso.ID_MACRO_USO,
                                                                        recSupAssPerComuneEMacroUso.PROGR_RACCOLTO 
                                                                        ) LOOP

                -- applicando il coefficiente calcolato sopra all'importo premio
                recTEsitoDettPolizza.ID_DETTAGLIO_POLIZZA := recDettaglioPolizzaXEsito.ID_DETTAGLIO_POLIZZA;
                recTEsitoDettPolizza.ID_MACRO_USO := recDettaglioPolizzaXEsito.ID_MACRO_USO;
                recTEsitoDettPolizza.ISTAT_COMUNE := recDettaglioPolizzaXEsito.ISTAT_COMUNE;
                recTEsitoDettPolizza.COEFFICIENTE := 0;
                recTEsitoDettPolizza.TOTALE_SUP_DICHIARATA := 0;
                recTEsitoDettPolizza.TOTALE_SUP_ASSICURATA := recSupAssPerComuneEMacroUso.TOT_ASSICURATA;
                recTEsitoDettPolizza.IMPORTO_PROPOSTO := 0;
                recTEsitoDettPolizza.DATA_CALCOLO := SYSDATE;

                IF nIdDichConsistProc IS NOT NULL THEN
                   recTEsitoDettPolizza.ID_DICHIARAZIONE_CONSISTENZA := nIdDichConsistProc;
                   SELECT SEQ_DB_ESITO_DETTAGLIO_POLIZZA.nextval
                     INTO recTEsitoDettPolizza.ID_ESITO_DETTAGLIO_POLIZZA
                     FROM DUAL;
                   recTEsitoDettPolizza.TIPO_CRITERIO := 'P';
                   InsertTEsitoDettaglioPolizza (recTEsitoDettPolizza);
                END IF;

                IF nIdDichConsistDtInizCopMin IS NOT NULL THEN
                   recTEsitoDettPolizza.ID_DICHIARAZIONE_CONSISTENZA := nIdDichConsistDtInizCopMin;
                   SELECT SEQ_DB_ESITO_DETTAGLIO_POLIZZA.nextval
                     INTO recTEsitoDettPolizza.ID_ESITO_DETTAGLIO_POLIZZA
                     FROM DUAL;
                   recTEsitoDettPolizza.TIPO_CRITERIO := 'F';
                   InsertTEsitoDettaglioPolizza (recTEsitoDettPolizza);
                END IF;

                IF nIdDichConsistDtInizCopMax IS NOT NULL THEN
                   recTEsitoDettPolizza.ID_DICHIARAZIONE_CONSISTENZA := nIdDichConsistDtInizCopMax;
                   SELECT SEQ_DB_ESITO_DETTAGLIO_POLIZZA.nextval
                     INTO recTEsitoDettPolizza.ID_ESITO_DETTAGLIO_POLIZZA
                     FROM DUAL;
                   recTEsitoDettPolizza.TIPO_CRITERIO := 'L';
                   InsertTEsitoDettaglioPolizza (recTEsitoDettPolizza);
                END IF;

                -- se il totale della superficie assicurata per comune e macro uso superava il totale della superficie
                -- utilizzata
                IF recSupAssPerComuneEMacroUso.TOT_ASSICURATA > recTEsitoDettPolizza.TOTALE_SUP_DICHIARATA THEN
                   -- segnalo anche apposita anomalia
                   bAnomalia := TRUE;

                   SELECT SEQ_DB_ANOMALIA_POLIZZA.nextval
                     INTO recTAnomaliaPolizza.ID_ANOMALIA_POLIZZA
                     FROM DUAL;

                   recTAnomaliaPolizza.ID_POLIZZA_ASSICURATIVA :=  recDettaglioPolizzaXEsito.ID_POLIZZA_ASSICURATIVA;
                   recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA := recDettaglioPolizzaXEsito.ID_DETTAGLIO_POLIZZA;
                   recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA_COLTURA := recDettaglioPolizzaXEsito.ID_DETTAGLIO_POLIZZA_COLTURA;
                   recTAnomaliaPolizza.ID_FONTE := knIdTipoFonteSiap;
                   recTAnomaliaPolizza.ID_CONTROLLO := knIdControlloASS06;
                   recTAnomaliaPolizza.DESCRIZIONE := 'La superficie assicurata (' || recSupAssPerComuneEMacroUso.TOT_ASSICURATA || ') per il macro uso : ' ||
                                                                                      recSupAssPerComuneEMacroUso.DESCRIZIONE || ' nel comune : ' ||
                                                                                      recSupAssPerComuneEMacroUso.ISTAT_COMUNE || ' risulta maggiore di quanto dichiarato in fascicolo (' ||
                                                                                      recTEsitoDettPolizza.TOTALE_SUP_DICHIARATA || ')';
                   recTAnomaliaPolizza.DATA_ESECUZIONE := SYSDATE;
                   InsertTAnomaliaPolizza (recTAnomaliaPolizza);
                END IF;

            END LOOP;
        END IF;

    END LOOP;

    IF bAnomalia THEN
       pResult := RET_ERR_PROC;
       pMsg := 'Riscontrata presenza di polizze con superficie assicurata maggiore della superficie utilizzata presente in fascicolo';
    ELSE
       pResult := RET_OK;
    END IF;

EXCEPTION
   WHEN OTHERS THEN
        pResult := RET_ERR;
        pMsg    := fncMessaggioErrore(1) || ' [ASS06] ' || SQLERRM;
END ASS06;

-- Controlla che per l'azienda , l'anno campagna ed gli interventi
-- forniti in input siano stipulate polizze con solamente un consorzio
-- per regione (salto ASS07 e ASS08 perchè qualcuno si è inventato dei controlli fittizi)
PROCEDURE ASS09(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                pVetTipoIntervento  IN VARCHAR2,
                pResult            OUT VARCHAR2,
                pMsg               OUT VARCHAR2) IS

    CURSOR curRegioneCnPolizzePiuConsorzi IS
    WITH INTERVENTI_CONCATENATI AS
       ( SELECT pVetTipoIntervento AS InterventiConc,
                LEVEL AS pos,
                SUBSTR(pVetTipoIntervento,ROWNUM,1) AS CH,
                COUNT(CASE WHEN SUBSTR(pVetTipoIntervento,ROWNUM,1) = ',' THEN '#' END)
                OVER (ORDER BY LEVEL) AS section
           FROM dual
     CONNECT BY LEVEL <= LENGTH(pVetTipoIntervento)),
         INTERVENTI AS
       ( SELECT SUBSTR(InterventiConc,MIN(pos), 1 + MAX(pos) - MIN(pos)) AS INTERVENTO
           FROM INTERVENTI_CONCATENATI
          WHERE CH <> ','
       GROUP BY InterventiConc,section )
    SELECT R.ID_REGIONE,
           R.DESCRIZIONE,
           COUNT(DISTINCT(CD.CODICE_CONSORZIO)) AS QUANTI
      FROM DB_POLIZZA_ASSICURATIVA PA,
           DB_CONSORZIO_DIFESA CD,
           REGIONE R,
           INTERVENTI I
     WHERE PA.ID_CONSORZIO_DIFESA = CD.ID_CONSORZIO_DIFESA
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND PA.ID_AZIENDA = pIdAzienda
       AND PA.ID_TIPO_INTERVENTO = I.INTERVENTO
       AND SUBSTR(CD.CODICE_CONSORZIO,1,2) = R.ID_REGIONE
  GROUP BY R.ID_REGIONE, R.DESCRIZIONE
  HAVING COUNT(DISTINCT(CD.CODICE_CONSORZIO)) > 1;

    CURSOR curDettaglioPolizza (pIdRegione IN REGIONE.ID_REGIONE%TYPE) IS
    WITH INTERVENTI_CONCATENATI AS
       ( SELECT pVetTipoIntervento AS InterventiConc,
                LEVEL AS pos,
                SUBSTR(pVetTipoIntervento,ROWNUM,1) AS CH,
                COUNT(CASE WHEN SUBSTR(pVetTipoIntervento,ROWNUM,1) = ',' THEN '#' END)
                OVER (ORDER BY LEVEL) AS section
           FROM dual
     CONNECT BY LEVEL <= LENGTH(pVetTipoIntervento)),
         INTERVENTI AS
       ( SELECT SUBSTR(InterventiConc,MIN(pos), 1 + MAX(pos) - MIN(pos)) AS INTERVENTO
           FROM INTERVENTI_CONCATENATI
          WHERE CH <> ','
       GROUP BY InterventiConc,section )
    SELECT DP.*
      FROM DB_POLIZZA_ASSICURATIVA PA,
           DB_DETTAGLIO_POLIZZA DP,
           DB_CONSORZIO_DIFESA CD,
           INTERVENTI I
     WHERE PA.ID_AZIENDA = pIdAzienda
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND PA.ID_TIPO_INTERVENTO = I.INTERVENTO
       AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
       AND PA.ID_CONSORZIO_DIFESA = CD.ID_CONSORZIO_DIFESA
       AND SUBSTR(CD.CODICE_CONSORZIO,1,2) = pIdRegione;


    recTAnomaliaPolizza DB_ANOMALIA_POLIZZA%ROWTYPE;
    knIdControlloASS09  CONSTANT DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE:=1107;
    bAnomalia           BOOLEAN:=FALSE;

BEGIN

    FOR recRegioneCnPolizzePiuConsorzi IN curRegioneCnPolizzePiuConsorzi LOOP
        recTAnomaliaPolizza.DESCRIZIONE := 'Verificata presenza di polizze associate a ' || recRegioneCnPolizzePiuConsorzi.QUANTI || ' organismi di controllo della stessa regione : ' || recRegioneCnPolizzePiuConsorzi.DESCRIZIONE;
        FOR recDettaglioPolizza iN curDettaglioPolizza (recRegioneCnPolizzePiuConsorzi.ID_REGIONE) LOOP
            SELECT SEQ_DB_ANOMALIA_POLIZZA.nextval
              INTO recTAnomaliaPolizza.ID_ANOMALIA_POLIZZA
              FROM DUAL;
            recTAnomaliaPolizza.ID_POLIZZA_ASSICURATIVA := recDettaglioPolizza.ID_POLIZZA_ASSICURATIVA;
            recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA := recDettaglioPolizza.ID_DETTAGLIO_POLIZZA;
            recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA_COLTURA := NULL;
            recTAnomaliaPolizza.ID_FONTE := knIdTipoFonteSiap;
            recTAnomaliaPolizza.ID_CONTROLLO := knIdControlloASS09;
            recTAnomaliaPolizza.DATA_ESECUZIONE := SYSDATE;
            InsertTAnomaliaPolizza (recTAnomaliaPolizza);
        END LOOP;
        bAnomalia := TRUE;
    END LOOP;

    IF bAnomalia THEN
       pResult := RET_ERR_PROC;
       pMsg := 'Riscontrata presenza di polizze associate a più organismi di controllo della stessa regione';
    ELSE
       pResult := RET_OK;
    END IF;
EXCEPTION
   WHEN OTHERS THEN
        pResult := RET_ERR;
        pMsg    := fncMessaggioErrore(1) || ' [ASS09] ' || SQLERRM;
END ASS09;

/*********************************************************************
Controllo se per le polizze dell'azienda data in input per l'intervento
e la campagna dati in input risultano prodotti con rese superiori a
quanto previsto dalle tabelle regionali
Tipo: procedure
input: pIdAzienda, pAnnoCampagna, pIdTipoIntervento
output: nessuno
ritorno: nessuno
*********************************************************************/
PROCEDURE ASS11(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                pResult            OUT VARCHAR2,
                pMsg               OUT VARCHAR2) IS

    knIdControlloASS11  CONSTANT DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE:=1109;
    bAnomalia           BOOLEAN:=FALSE;
    recTAnomaliaPolizza DB_ANOMALIA_POLIZZA%ROWTYPE;

    CURSOR curResaPerComuneEProdotto IS
    WITH RESA_PRODOTTO_COMUNE AS
    (
    SELECT SUM(DPC.SUPERFICIE_ASSICURATA) / 10000 AS TOT_SUPERFICIE_ASSICURATA,
           SUM(DPC.QUANTITA_ASSICURATA) AS TOT_QUANTITA_ASSICURATA,
           DPC.ID_TIPO_PRODOTTO,
           TP.DESCRIZIONE AS DESC_TIPO_PRODOTTO,
           DPC.ISTAT_COMUNE,
           C.DESCOM AS DESC_COMUNE,
           NVL(
           NVL(
           NVL(
           (SELECT RRP.RESA
              FROM DB_RESA_PRODOTTO_LUOGO RRP
             WHERE RRP.ISTAT_COMUNE = DPC.ISTAT_COMUNE
               AND RRP.ID_TIPO_PRODOTTO = DPC.ID_TIPO_PRODOTTO
               AND pAnnoCampagna BETWEEN RRP.ANNO_INIZIO_VALIDITA AND NVL(RRP.ANNO_FINE_VALIDITA, 9999)),
           (SELECT RRP.RESA
              FROM DB_RESA_PRODOTTO_LUOGO RRP,
                   COMUNE C
             WHERE RRP.ISTAT_PROVINCIA = C.ISTAT_PROVINCIA
               AND DPC.ISTAT_COMUNE = C.ISTAT_COMUNE
               AND RRP.ID_TIPO_PRODOTTO = DPC.ID_TIPO_PRODOTTO
               AND pAnnoCampagna BETWEEN RRP.ANNO_INIZIO_VALIDITA AND NVL(RRP.ANNO_FINE_VALIDITA, 9999))),
           (SELECT RRP.RESA
              FROM DB_RESA_PRODOTTO_LUOGO RRP,
                   COMUNE C,
                   PROVINCIA P
             WHERE RRP.ID_REGIONE = P.ID_REGIONE
               AND C.ISTAT_PROVINCIA = P.ISTAT_PROVINCIA
               AND DPC.ISTAT_COMUNE = C.ISTAT_COMUNE
               AND RRP.ID_TIPO_PRODOTTO = DPC.ID_TIPO_PRODOTTO
               AND pAnnoCampagna BETWEEN RRP.ANNO_INIZIO_VALIDITA AND NVL(RRP.ANNO_FINE_VALIDITA, 9999))),0) AS RESA_PREVISTA
      FROM DB_POLIZZA_ASSICURATIVA PA,
           DB_DETTAGLIO_POLIZZA DP,
           DB_DETTAGLIO_POLIZZA_COLTURA DPC,
           COMUNE C,
           DB_TIPO_PRODOTTO TP
     WHERE PA.ID_AZIENDA = pIdAzienda
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
       AND PA.ID_TIPO_INTERVENTO = pIdTipoIntervento
       AND DP.TIPO_DETTAGLIO = 'C'
       AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
       AND DPC.ISTAT_COMUNE = C.ISTAT_COMUNE
       AND DPC.ID_TIPO_PRODOTTO = TP.ID_TIPO_PRODOTTO
 GROUP BY DPC.ISTAT_COMUNE, C.DESCOM, DPC.ID_TIPO_PRODOTTO , TP.DESCRIZIONE)
    SELECT RPR.*,
           ROUND(RPR.TOT_QUANTITA_ASSICURATA / RPR.TOT_SUPERFICIE_ASSICURATA,2) AS RESA_CALCOLATA
      FROM RESA_PRODOTTO_COMUNE RPR
     WHERE ROUND(RPR.TOT_QUANTITA_ASSICURATA / RPR.TOT_SUPERFICIE_ASSICURATA,2) > RPR.RESA_PREVISTA;

    CURSOR curDettaglioPolizza (pIstatComune  IN COMUNE.ISTAT_COMUNE%TYPE,
                                pIdTipoProd   IN DB_TIPO_PRODOTTO.ID_TIPO_PRODOTTO%TYPE
                                ) IS
    SELECT DPC.*,
           PA.ID_POLIZZA_ASSICURATIVA
      FROM DB_POLIZZA_ASSICURATIVA PA,
           DB_DETTAGLIO_POLIZZA DP,
           DB_DETTAGLIO_POLIZZA_COLTURA DPC
     WHERE PA.ID_AZIENDA = pIdAzienda
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
       AND PA.ID_TIPO_INTERVENTO = pIdTipoIntervento
       AND DP.TIPO_DETTAGLIO = 'C'
       AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
       AND DPC.ISTAT_COMUNE = pIstatComune
       AND DPC.ID_TIPO_PRODOTTO = pIdTipoProd
       AND (NVL(DPC.EXTRA_RESA, 'N') = 'N' OR (
            NVL(DPC.EXTRA_RESA, 'N') = 'S' AND PA.ESTRATTA_CAMPIONE = 'S')); 

       /*
       AND EXISTS (SELECT DPC2.ID_DETTAGLIO_POLIZZA_COLTURA
                     FROM DB_DETTAGLIO_POLIZZA DP2,
                          DB_DETTAGLIO_POLIZZA_COLTURA DPC2
                    WHERE DP2.ID_POLIZZA_ASSICURATIVA = PA.ID_POLIZZA_ASSICURATIVA
                      AND DP2.TIPO_DETTAGLIO = 'C'
                      AND DP2.ID_DETTAGLIO_POLIZZA = DPC2.ID_DETTAGLIO_POLIZZA
                      AND DPC2.ISTAT_COMUNE = pIstatComune
                      AND DPC2.ID_TIPO_PRODOTTO = pIdTipoProd
                      AND NVL(DPC2.EXTRA_RESA,'N') = 'N');*/ 


    nCoefRiduzioneResa NUMBER;
    vBloccante         DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE;

BEGIN

    BEGIN

        SELECT BLOCCANTE
          INTO vBloccante
          FROM DB_TIPO_CONTROLLO_FASE
         WHERE ID_CONTROLLO = knIdControlloASS11
           AND ID_FASE = knIdFaseControlliPolizza;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             vBloccante := 'N';
    END;


    FOR recResaPerComuneEProdotto IN curResaPerComuneEProdotto LOOP

        IF vBloccante = 'N' THEN
           IF recResaPerComuneEProdotto.RESA_PREVISTA = 0 THEN
              nCoefRiduzioneResa := 0;
           ELSE
              nCoefRiduzioneResa := ROUND(1 - ((recResaPerComuneEProdotto.RESA_CALCOLATA - recResaPerComuneEProdotto.RESA_PREVISTA) / recResaPerComuneEProdotto.RESA_PREVISTA),4);
              IF nCoefRiduzioneResa < 0 THEN
                 nCoefRiduzioneResa := 0;
              END IF;
           END IF;
        ELSE
           nCoefRiduzioneResa := NULL;
        END IF;


        FOR recDettaglioPolizza IN curDettaglioPolizza (recResaPerComuneEProdotto.ISTAT_COMUNE,
                                                        recResaPerComuneEProdotto.ID_TIPO_PRODOTTO) LOOP

            SELECT SEQ_DB_ANOMALIA_POLIZZA.nextval
              INTO recTAnomaliaPolizza.ID_ANOMALIA_POLIZZA
              FROM DUAL;
            recTAnomaliaPolizza.ID_POLIZZA_ASSICURATIVA := recDettaglioPolizza.ID_POLIZZA_ASSICURATIVA;
            recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA := recDettaglioPolizza.ID_DETTAGLIO_POLIZZA;
            recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA_COLTURA := recDettaglioPolizza.ID_DETTAGLIO_POLIZZA_COLTURA;
            recTAnomaliaPolizza.ID_FONTE := knIdTipoFonteSiap;
            recTAnomaliaPolizza.ID_CONTROLLO := knIdControlloASS11;
            recTAnomaliaPolizza.DESCRIZIONE := 'Resa polizza (' || TRIM(TO_CHAR(recResaPerComuneEProdotto.RESA_CALCOLATA,'999G990D99')) || ') maggiore della resa massima (' || TRIM(TO_CHAR(recResaPerComuneEProdotto.RESA_PREVISTA,'999G990D99')) || ') per la coltura : ' || recResaPerComuneEProdotto.DESC_TIPO_PRODOTTO || ' comune : ' || recResaPerComuneEProdotto.DESC_COMUNE;
            recTAnomaliaPolizza.DATA_ESECUZIONE := SYSDATE;
            InsertTAnomaliaPolizza (recTAnomaliaPolizza);

            UPDATE DB_DETTAGLIO_POLIZZA_COLTURA
               SET COEFFICIENTE_RIDUZIONE_RESA = nCoefRiduzioneResa,
                   RESA_MEDIA_PRODOTTO_COMUNE =  recResaPerComuneEProdotto.RESA_CALCOLATA
             WHERE ID_DETTAGLIO_POLIZZA_COLTURA = recDettaglioPolizza.ID_DETTAGLIO_POLIZZA_COLTURA;

        END LOOP;
        bAnomalia:=TRUE;
    END LOOP;

    IF bAnomalia THEN
       pResult := RET_ERR_PROC;
       pMsg := 'Riscontrata presenza di polizze con resa media per la coltura maggiore di quella regionale prevista';
    ELSE
       pResult := RET_OK;
    END IF;
EXCEPTION
   WHEN OTHERS THEN
        pResult := RET_ERR;
        pMsg    := fncMessaggioErrore(1) || ' [ASS11] ' || SQLERRM;
END ASS11;


/*********************************************************************
Ccontrolla se la polizza e' stata presentata piu' di un tot di giorni dal termine previsto
Tipo: procedure
input: pIdAzienda, pAnnoCampagna, pIdTipoIntervento
output: nessuno
ritorno: nessuno
*********************************************************************/
PROCEDURE ASS12(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                pResult            OUT VARCHAR2,
                pMsg               OUT VARCHAR2) IS


    recTAnomaliaPolizza DB_ANOMALIA_POLIZZA%ROWTYPE;
    knIdControlloASS12  CONSTANT DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE:=1110;
    bAnomalia           BOOLEAN:=FALSE;

    CURSOR curPolizzaFuoriTermine IS
    SELECT PA.ID_POLIZZA_ASSICURATIVA,
           PA.GIORNI_FUORI_TERMINE,
           TCP.VALORE_NUMERICO
      FROM DB_POLIZZA_ASSICURATIVA PA,
           DB_TIPO_CONTROLLO_PARAMETRO TCP
     WHERE PA.ID_AZIENDA = pIdAzienda
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND ((pIdTipoIntervento IS NOT NULL AND PA.ID_TIPO_INTERVENTO = pIdTipoIntervento) OR pIdTipoIntervento IS NULL)
       AND PA.GIORNI_FUORI_TERMINE > TCP.VALORE_NUMERICO
       AND TCP.CODICE = 'GGFUORITERMINE'
       AND TCP.ID_CONTROLLO = knIdControlloASS12
       AND TO_DATE('31/12/' || pAnnoCampagna, 'DD/MM/YYYY') BETWEEN TCP.DATA_INIZIO_VALIDITA AND NVL(TCP.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','DD/MM/YYYY'));

BEGIN

    FOR recPolizzaFuoriTermine IN curPolizzaFuoriTermine LOOP
        SELECT SEQ_DB_ANOMALIA_POLIZZA.nextval
          INTO recTAnomaliaPolizza.ID_ANOMALIA_POLIZZA
          FROM DUAL;

        recTAnomaliaPolizza.ID_POLIZZA_ASSICURATIVA := recPolizzaFuoriTermine.ID_POLIZZA_ASSICURATIVA;
        recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA := NULL;
        recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA_COLTURA := NULL;
        recTAnomaliaPolizza.ID_FONTE := knIdTipoFonteSiap;
        recTAnomaliaPolizza.ID_CONTROLLO := knIdControlloASS12;
        recTAnomaliaPolizza.DESCRIZIONE := 'Polizza presenta piu'' di ' || recPolizzaFuoriTermine.VALORE_NUMERICO || ' giorni fuori termine (' || recPolizzaFuoriTermine.GIORNI_FUORI_TERMINE || ')';
        recTAnomaliaPolizza.DATA_ESECUZIONE := SYSDATE;

        InsertTAnomaliaPolizza (recTAnomaliaPolizza);

        bAnomalia := TRUE;

    END LOOP;

    IF bAnomalia THEN
       pResult := RET_ERR_PROC;
       pMsg := 'Polizza presentata fuori termine !!';
    ELSE
       pResult := RET_OK;
    END IF;
EXCEPTION
   WHEN OTHERS THEN
        pResult := RET_ERR;
        pMsg    := fncMessaggioErrore(1) || ' [ASS12] ' || SQLERRM;
END ASS12;

/*********************************************************************
Verifica l'esistenza di una anomalia SIAN P01 sulla polizza
Tipo: procedure
input: pIdAzienda, pAnnoCampagna, pIdTipoIntervento
output: nessuno
ritorno: nessuno
*********************************************************************/
PROCEDURE ASS13(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                pResult            OUT VARCHAR2,
                pMsg               OUT VARCHAR2) IS


    recTAnomaliaPolizza DB_ANOMALIA_POLIZZA%ROWTYPE;
    knIdControlloASS13  CONSTANT DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE:=1111;
    bAnomalia           BOOLEAN:=FALSE;

    CURSOR curPolizzaCoesistente IS
    SELECT PA.ID_POLIZZA_ASSICURATIVA
      FROM DB_POLIZZA_ASSICURATIVA PA,
           DB_ANOMALIA_POLIZZA AP
     WHERE PA.ID_AZIENDA = pIdAzienda
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND ((pIdTipoIntervento IS NOT NULL AND PA.ID_TIPO_INTERVENTO = pIdTipoIntervento) OR pIdTipoIntervento IS NULL)
       AND AP.ID_POLIZZA_ASSICURATIVA = PA.ID_POLIZZA_ASSICURATIVA
       AND AP.DESCRIZIONE LIKE 'P01%';

BEGIN

    FOR recPolizzaCoesistente IN curPolizzaCoesistente LOOP
        SELECT SEQ_DB_ANOMALIA_POLIZZA.nextval
          INTO recTAnomaliaPolizza.ID_ANOMALIA_POLIZZA
          FROM DUAL;

        recTAnomaliaPolizza.ID_POLIZZA_ASSICURATIVA := recPolizzaCoesistente.ID_POLIZZA_ASSICURATIVA;
        recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA := NULL;
        recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA_COLTURA := NULL;
        recTAnomaliaPolizza.ID_FONTE := knIdTipoFonteSiap;
        recTAnomaliaPolizza.ID_CONTROLLO := knIdControlloASS13;
        recTAnomaliaPolizza.DESCRIZIONE := 'Coesistenza Polizze Individuali e Collettive nella stessa Regione';
        recTAnomaliaPolizza.DATA_ESECUZIONE := SYSDATE;

        InsertTAnomaliaPolizza (recTAnomaliaPolizza);

        bAnomalia := TRUE;

    END LOOP;

    IF bAnomalia THEN
       pResult := RET_ERR_PROC;
       pMsg := 'Coesistenza Polizze Individuali e Collettive nella stessa Regione';
    ELSE
       pResult := RET_OK;
    END IF;
EXCEPTION
   WHEN OTHERS THEN
        pResult := RET_ERR;
        pMsg    := fncMessaggioErrore(1) || ' [ASS13] ' || SQLERRM;
END ASS13;

/*********************************************************************
Verifica l'esistenza di una anomalia SIAN P01 sulla polizza
Tipo: procedure
input: pIdAzienda, pAnnoCampagna, pIdTipoIntervento
output: nessuno
ritorno: nessuno
*********************************************************************/
PROCEDURE ASS15(pIdAzienda          IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                pAnnoCampagna       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                pIdTipoIntervento   IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                pResult            OUT VARCHAR2,
                pMsg               OUT VARCHAR2) IS


    recTAnomaliaPolizza DB_ANOMALIA_POLIZZA%ROWTYPE;
    knIdControlloASS15  CONSTANT DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE:=1112;
    knIdControlloASS14  CONSTANT DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE:=1113;


    recTIstrPolizzaColt DB_ISTRUTTORIA_POLIZZA_COLTURA%ROWTYPE;

    bAnomalia           BOOLEAN:=FALSE;
    nNumPolEstratteER   INTEGER:=0; -- numero di polizze estratte a campione per l'azienda in extra resa
    nResaApp            NUMBER(10,4);



    CURSOR curProdottoAnomalo IS
    WITH PRODOTTI_OBBLIGATORI AS
    (
    SELECT DISTINCT TP.CODICE_PRODOTTO , TP.DESCRIZIONE, PA.ANNO_CAMPAGNA AS CAMPAGNA_ATTUALE
      FROM DB_DETTAGLIO_POLIZZA DP,
           DB_DETTAGLIO_POLIZZA_COLTURA DPC,
           DB_POLIZZA_ASSICURATIVA PA,
           DB_TIPO_PRODOTTO TP
     WHERE DP.ID_POLIZZA_ASSICURATIVA = PA.ID_POLIZZA_ASSICURATIVA
       AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
       AND PA.ID_TIPO_INTERVENTO = pIdTipoIntervento
       AND DP.TIPO_DETTAGLIO = 'C'
       AND PA.ESTRATTA_CAMPIONE = 'S'
       AND DPC.EXTRA_RESA = 'S'
       AND DPC.COEFFICIENTE_RIDUZIONE_RESA < 1 
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND PA.ID_AZIENDA = pIdAzienda
       AND DPC.ID_TIPO_PRODOTTO = TP.ID_TIPO_PRODOTTO
    )
    SELECT PO.CODICE_PRODOTTO, PO.DESCRIZIONE, PO.CAMPAGNA_ATTUALE, COUNT(DISTINCT(RAP.ANNO_CAMPAGNA)) AS QUANTI
      FROM PRODOTTI_OBBLIGATORI PO,
           DB_TIPO_PRODOTTO TP,
           DB_RIEPILOGO_ANNUALE_PRODOTTO RAP
     WHERE PO.CODICE_PRODOTTO = TP.CODICE_PRODOTTO
       AND TP.ID_TIPO_PRODOTTO = RAP.ID_TIPO_PRODOTTO (+)
       AND RAP.ID_AZIENDA (+) = pIdAzienda
       AND RAP.ANNO_CAMPAGNA (+)>= pAnnoCampagna - 5
       AND RAP.ANNO_CAMPAGNA (+)<= pAnnoCampagna - 1
       AND RAP.DATA_ANNULLAMENTO (+) IS NULL
  GROUP BY PO.CODICE_PRODOTTO, PO.DESCRIZIONE, PO.CAMPAGNA_ATTUALE
 HAVING COUNT(DISTINCT(ANNO_CAMPAGNA)) NOT IN (3,5) AND
        COUNT(DECODE(RAP.AZIENDA_NEOCOSTITUITA,'S',RAP.ID_RIEPILOGO_ANNUALE_PRODOTTO)) = 0; 


    CURSOR curProdottoOk IS
    WITH PRODOTTI_OBBLIGATORI AS
    (
    SELECT DISTINCT TP.ID_TIPO_PRODOTTO , TP.CODICE_PRODOTTO , TP.DESCRIZIONE, PA.ANNO_CAMPAGNA AS CAMPAGNA_ATTUALE
      FROM DB_DETTAGLIO_POLIZZA DP,
           DB_DETTAGLIO_POLIZZA_COLTURA DPC,
           DB_POLIZZA_ASSICURATIVA PA,
           DB_TIPO_PRODOTTO TP
     WHERE DP.ID_POLIZZA_ASSICURATIVA = PA.ID_POLIZZA_ASSICURATIVA
       AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
       AND PA.ID_TIPO_INTERVENTO = pIdTipoIntervento
       AND DP.TIPO_DETTAGLIO = 'C'
       AND PA.ESTRATTA_CAMPIONE = 'S'
       AND DPC.EXTRA_RESA = 'S'
       AND DPC.COEFFICIENTE_RIDUZIONE_RESA < 1 
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND PA.ID_AZIENDA = pIdAzienda
       AND DPC.ID_TIPO_PRODOTTO = TP.ID_TIPO_PRODOTTO
    )
    SELECT PO.ID_TIPO_PRODOTTO,
           PO.CODICE_PRODOTTO,
           PO.DESCRIZIONE,
           PO.CAMPAGNA_ATTUALE,
           COUNT(DISTINCT(RAP.ANNO_CAMPAGNA)) AS QUANTI,
           AVG(RAP.RESA_CALCOLATA) AS RESA_MEDIA,
           (SUM(RAP.RESA_CALCOLATA) - (MIN(RAP.RESA_CALCOLATA) + MAX(RAP.RESA_CALCOLATA))) / 3 AS ALTRA_RESA,
           COUNT(DECODE(RAP.AZIENDA_NEOCOSTITUITA,'S',RAP.ID_RIEPILOGO_ANNUALE_PRODOTTO)) AS NUM_NEO   
      FROM PRODOTTI_OBBLIGATORI PO,
           DB_TIPO_PRODOTTO TP,
           DB_RIEPILOGO_ANNUALE_PRODOTTO RAP
     WHERE PO.CODICE_PRODOTTO = TP.CODICE_PRODOTTO
       AND TP.ID_TIPO_PRODOTTO = RAP.ID_TIPO_PRODOTTO (+)
       AND RAP.ID_AZIENDA = pIdAzienda
       AND RAP.ANNO_CAMPAGNA >= pAnnoCampagna - 5
       AND RAP.ANNO_CAMPAGNA <= pAnnoCampagna - 1
       AND RAP.DATA_ANNULLAMENTO IS NULL
  GROUP BY PO.ID_TIPO_PRODOTTO, PO.CODICE_PRODOTTO, PO.DESCRIZIONE, PO.CAMPAGNA_ATTUALE
 HAVING COUNT(DISTINCT(ANNO_CAMPAGNA)) IN (3,5) OR
        COUNT(DECODE(RAP.AZIENDA_NEOCOSTITUITA,'S',RAP.ID_RIEPILOGO_ANNUALE_PRODOTTO)) > 0; 

    CURSOR curResaPerLuogoEProdotto (pIdTipoProdotto IN DB_TIPO_PRODOTTO.ID_TIPO_PRODOTTO%TYPE)IS
    WITH RESA_PRODOTTO_COMUNE AS
    (
    SELECT SUM(DPC.SUPERFICIE_ASSICURATA) / 10000 AS TOT_SUPERFICIE_ASSICURATA,
           SUM(DPC.QUANTITA_ASSICURATA) AS TOT_QUANTITA_ASSICURATA,
           DPC.ID_TIPO_PRODOTTO,
           TP.DESCRIZIONE AS DESC_TIPO_PRODOTTO,
           DPC.ISTAT_COMUNE,
           C.DESCOM AS DESC_COMUNE,
           NVL(
           NVL(
           NVL(
           (SELECT RRP.RESA
              FROM DB_RESA_PRODOTTO_LUOGO RRP
             WHERE RRP.ISTAT_COMUNE = DPC.ISTAT_COMUNE
               AND RRP.ID_TIPO_PRODOTTO = DPC.ID_TIPO_PRODOTTO
               AND pAnnoCampagna BETWEEN RRP.ANNO_INIZIO_VALIDITA AND NVL(RRP.ANNO_FINE_VALIDITA, 9999)),
           (SELECT RRP.RESA
              FROM DB_RESA_PRODOTTO_LUOGO RRP,
                   COMUNE C
             WHERE RRP.ISTAT_PROVINCIA = C.ISTAT_PROVINCIA
               AND DPC.ISTAT_COMUNE = C.ISTAT_COMUNE
               AND RRP.ID_TIPO_PRODOTTO = DPC.ID_TIPO_PRODOTTO
               AND pAnnoCampagna BETWEEN RRP.ANNO_INIZIO_VALIDITA AND NVL(RRP.ANNO_FINE_VALIDITA, 9999))),
           (SELECT RRP.RESA
              FROM DB_RESA_PRODOTTO_LUOGO RRP,
                   COMUNE C,
                   PROVINCIA P
             WHERE RRP.ID_REGIONE = P.ID_REGIONE
               AND C.ISTAT_PROVINCIA = P.ISTAT_PROVINCIA
               AND DPC.ISTAT_COMUNE = C.ISTAT_COMUNE
               AND RRP.ID_TIPO_PRODOTTO = DPC.ID_TIPO_PRODOTTO
               AND pAnnoCampagna BETWEEN RRP.ANNO_INIZIO_VALIDITA AND NVL(RRP.ANNO_FINE_VALIDITA, 9999))),0) AS RESA_PREVISTA
      FROM DB_POLIZZA_ASSICURATIVA PA,
           DB_DETTAGLIO_POLIZZA DP,
           DB_DETTAGLIO_POLIZZA_COLTURA DPC,
           COMUNE C,
           DB_TIPO_PRODOTTO TP
     WHERE PA.ID_AZIENDA = pIdAzienda
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
       AND PA.ESTRATTA_CAMPIONE = 'S'
       AND PA.ID_TIPO_INTERVENTO = pIdTipoIntervento
       AND DP.TIPO_DETTAGLIO = 'C'
       AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
       AND DPC.ISTAT_COMUNE = C.ISTAT_COMUNE
       AND DPC.ID_TIPO_PRODOTTO = TP.ID_TIPO_PRODOTTO
       AND DPC.ID_TIPO_PRODOTTO = pIdTipoProdotto
       /*
       AND EXISTS (SELECT ID_DETTAGLIO_POLIZZA_COLTURA
                     FROM DB_DETTAGLIO_POLIZZA_COLTURA
                    WHERE ID_POLIZZA_ASSICURATIVA = PA.ID_POLIZZA_ASSICURATIVA
                      AND EXTRA_RESA = 'S')*/ -- N.B. Capire se la resa calcolata polizza deve essere aziendale o solo sulle extra resa
  GROUP BY DPC.ISTAT_COMUNE, C.DESCOM, DPC.ID_TIPO_PRODOTTO , TP.DESCRIZIONE)
    SELECT RPR.RESA_PREVISTA,
           RPR.ID_TIPO_PRODOTTO,
           RPR.DESC_TIPO_PRODOTTO,
           ROUND(SUM(RPR.TOT_QUANTITA_ASSICURATA) / SUM(RPR.TOT_SUPERFICIE_ASSICURATA),2) AS RESA_CALCOLATA
      FROM RESA_PRODOTTO_COMUNE RPR
  GROUP BY RPR.RESA_PREVISTA, RPR.ID_TIPO_PRODOTTO, RPR.DESC_TIPO_PRODOTTO;

    CURSOR curDettaglioPolizza (pIdTipoProd   IN DB_TIPO_PRODOTTO.ID_TIPO_PRODOTTO%TYPE,
                                pResaPrev     IN DB_RESA_PRODOTTO_LUOGO.RESA%TYPE
                                ) IS
    WITH DETTAGLIO_CON_RESA AS (
    SELECT DPC.*,
           PA.ID_POLIZZA_ASSICURATIVA,
           NVL(
           NVL(
           NVL(
           (SELECT RRP.RESA
              FROM DB_RESA_PRODOTTO_LUOGO RRP
             WHERE RRP.ISTAT_COMUNE = DPC.ISTAT_COMUNE
               AND RRP.ID_TIPO_PRODOTTO = DPC.ID_TIPO_PRODOTTO
               AND pAnnoCampagna BETWEEN RRP.ANNO_INIZIO_VALIDITA AND NVL(RRP.ANNO_FINE_VALIDITA, 9999)),
           (SELECT RRP.RESA
              FROM DB_RESA_PRODOTTO_LUOGO RRP,
                   COMUNE C
             WHERE RRP.ISTAT_PROVINCIA = C.ISTAT_PROVINCIA
               AND DPC.ISTAT_COMUNE = C.ISTAT_COMUNE
               AND RRP.ID_TIPO_PRODOTTO = DPC.ID_TIPO_PRODOTTO
               AND pAnnoCampagna BETWEEN RRP.ANNO_INIZIO_VALIDITA AND NVL(RRP.ANNO_FINE_VALIDITA, 9999))),
           (SELECT RRP.RESA
              FROM DB_RESA_PRODOTTO_LUOGO RRP,
                   COMUNE C,
                   PROVINCIA P
             WHERE RRP.ID_REGIONE = P.ID_REGIONE
               AND C.ISTAT_PROVINCIA = P.ISTAT_PROVINCIA
               AND DPC.ISTAT_COMUNE = C.ISTAT_COMUNE
               AND RRP.ID_TIPO_PRODOTTO = DPC.ID_TIPO_PRODOTTO
               AND pAnnoCampagna BETWEEN RRP.ANNO_INIZIO_VALIDITA AND NVL(RRP.ANNO_FINE_VALIDITA, 9999))),0) AS RESA_PREVISTA
      FROM DB_POLIZZA_ASSICURATIVA PA,
           DB_DETTAGLIO_POLIZZA DP,
           DB_DETTAGLIO_POLIZZA_COLTURA DPC
     WHERE PA.ID_AZIENDA = pIdAzienda
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
       AND PA.ID_TIPO_INTERVENTO = pIdTipoIntervento
       AND DP.TIPO_DETTAGLIO = 'C'
       AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
       AND DPC.ID_TIPO_PRODOTTO = pIdTipoProd
       AND DPC.EXTRA_RESA = 'S') 
       SELECT *
         FROM DETTAGLIO_CON_RESA DRE
        WHERE DRE.RESA_PREVISTA = pResaPrev;
       /*
       AND EXISTS (SELECT DPC2.ID_DETTAGLIO_POLIZZA_COLTURA
                     FROM DB_DETTAGLIO_POLIZZA DP2,
                          DB_DETTAGLIO_POLIZZA_COLTURA DPC2
                    WHERE DP2.ID_POLIZZA_ASSICURATIVA = PA.ID_POLIZZA_ASSICURATIVA
                      AND DP2.TIPO_DETTAGLIO = 'C'
                      AND DP2.ID_DETTAGLIO_POLIZZA = DPC2.ID_DETTAGLIO_POLIZZA
                      AND DPC2.ISTAT_COMUNE = pIstatComune
                      AND DPC2.ID_TIPO_PRODOTTO = pIdTipoProd
                      AND NVL(DPC2.EXTRA_RESA,'N') = 'S')*/


    CURSOR curPolizzaAzienda (pCodiceProdotto IN DB_TIPO_PRODOTTO.CODICE_PRODOTTO%TYPE) IS
    SELECT PA.ID_POLIZZA_ASSICURATIVA,
           DP.ID_DETTAGLIO_POLIZZA,
           DPC.ID_DETTAGLIO_POLIZZA_COLTURA
      FROM DB_POLIZZA_ASSICURATIVA PA ,
           DB_DETTAGLIO_POLIZZA DP,
           DB_DETTAGLIO_POLIZZA_COLTURA DPC,
           DB_TIPO_PRODOTTO TP
     WHERE PA.ID_AZIENDA = pIdAzienda
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND ((pIdTipoIntervento IS NOT NULL AND PA.ID_TIPO_INTERVENTO = pIdTipoIntervento) OR pIdTipoIntervento IS NULL)
       AND PA.ESTRATTA_CAMPIONE = 'S'
       AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
       AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
       AND DPC.ID_TIPO_PRODOTTO = TP.ID_TIPO_PRODOTTO
       AND TP.CODICE_PRODOTTO = pCodiceProdotto
       AND DPC.EXTRA_RESA = 'S'
       AND DPC.COEFFICIENTE_RIDUZIONE_RESA < 1;


    nCoefRiduzioneResa  DB_DETTAGLIO_POLIZZA_COLTURA.COEFFICIENTE_RIDUZIONE_RESA%TYPE;

BEGIN

    --DBMS_OUTPUT.PUT_LINE ('Inizio esecuzione');

    SELECT COUNT(PA.ID_POLIZZA_ASSICURATIVA)
      INTO nNumPolEstratteER
      FROM DB_POLIZZA_ASSICURATIVA PA
     WHERE PA.ID_AZIENDA = pIdAzienda
       AND PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND ((pIdTipoIntervento IS NOT NULL AND PA.ID_TIPO_INTERVENTO = pIdTipoIntervento) OR pIdTipoIntervento IS NULL)
       AND PA.ESTRATTA_CAMPIONE = 'S'
       AND EXISTS (SELECT DPC.ID_DETTAGLIO_POLIZZA_COLTURA
                     FROM DB_DETTAGLIO_POLIZZA DP,
                          DB_DETTAGLIO_POLIZZA_COLTURA DPC
                    WHERE DP.ID_POLIZZA_ASSICURATIVA = PA.ID_POLIZZA_ASSICURATIVA
                      AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
                      AND DPC.EXTRA_RESA = 'S');

    IF nNumPolEstratteER > 0 THEN

       --DBMS_OUTPUT.PUT_LINE ('Azienda con ID : ' || pIdAzienda || ' esistono polizze a campione in extra resa');

       -- guardo se ci sono prodotti in extra resa che non presentano
       -- i dati annuali per 3 o 5 anni e li segnalo
       FOR recProdottoAnomalo IN  curProdottoAnomalo LOOP

           IF recTAnomaliaPolizza.DESCRIZIONE IS NULL THEN
              recTAnomaliaPolizza.DESCRIZIONE := 'Verificata presenza di prodotti in extra resa mancanti della fornitura delle rese calcolate per 3 o 5 anni precedenti : ';
              recTAnomaliaPolizza.DESCRIZIONE := recTAnomaliaPolizza.DESCRIZIONE || ' Prodotto : ' || recProdottoAnomalo.CODICE_PRODOTTO || ' - ' || recProdottoAnomalo.DESCRIZIONE || ' presenti : ' || TO_CHAR(recProdottoAnomalo.QUANTI) || ' anni precedenti';
           ELSE
              recTAnomaliaPolizza.DESCRIZIONE := recTAnomaliaPolizza.DESCRIZIONE || ', Prodotto : ' || recProdottoAnomalo.CODICE_PRODOTTO || ' - ' || recProdottoAnomalo.DESCRIZIONE || ' presenti : ' || TO_CHAR(recProdottoAnomalo.QUANTI) || ' anni precedenti';
           END IF;


           FOR recPolizzaAzienda IN curPolizzaAzienda (recProdottoAnomalo.CODICE_PRODOTTO) LOOP
              -- capire dove mettere l'anomalia
              -- se mettere ASS15 sul dettaglio polizza coltura degli extra resa o cosa
              SELECT SEQ_DB_ANOMALIA_POLIZZA.nextval
                INTO recTAnomaliaPolizza.ID_ANOMALIA_POLIZZA
                FROM DUAL;
              recTAnomaliaPolizza.ID_POLIZZA_ASSICURATIVA := recPolizzaAzienda.ID_POLIZZA_ASSICURATIVA;
              recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA := recPolizzaAzienda.ID_DETTAGLIO_POLIZZA;
              recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA_COLTURA:= recPolizzaAzienda.ID_DETTAGLIO_POLIZZA_COLTURA;
              recTAnomaliaPolizza.ID_FONTE := knIdTipoFonteSiap;
              recTAnomaliaPolizza.ID_CONTROLLO := knIdControlloASS14;
              recTAnomaliaPolizza.DATA_ESECUZIONE := SYSDATE;
              InsertTAnomaliaPolizza (recTAnomaliaPolizza);
           END LOOP;
           bAnomalia := TRUE;
           --DBMS_OUTPUT.PUT_LINE ('Prodotto : ' || recProdottoAnomalo.CODICE_PRODOTTO || ' - ' || recProdottoAnomalo.DESCRIZIONE || ' presenti : ' || TO_CHAR(recProdottoAnomalo.QUANTI) || ' anni precedenti');

       END LOOP;

      -- scorro i prodotti che hanno i dati annuali per 3 o 5 anni
      -- che saranno tutti i prodotti dell'azienda della campagna
      FOR recProdottoOk IN curProdottoOk LOOP

          --DBMS_OUTPUT.PUT_LINE ('Prodotto : ' || recProdottoOk.CODICE_PRODOTTO || ' - ' || recProdottoOk.DESCRIZIONE || ' presenti : ' || TO_CHAR(recProdottoOk.QUANTI) || ' anni precedenti');

          -- a seconda del numero di anni
          IF recProdottoOk.QUANTI = 3 THEN
             -- se tre anni
             -- avro' la media aritmetica fatta con funzione AVG di oracle
             nResaApp := ROUND(recProdottoOk.RESA_MEDIA,2);
             --DBMS_OUTPUT.PUT_LINE ('Prodotto : ' || recProdottoOk.CODICE_PRODOTTO || ' - ' || recProdottoOk.DESCRIZIONE || ' resa media : ' || TO_CHAR(nResaApp,'999G990D99'));

          ELSIF recProdottoOk.QUANTI = 5 THEN
             -- se 5 anni la resa media sara' data
             -- dalla somma delle rese per i 5 anni
             -- meno la resa minima per i 5 anni
             -- meno la resa massima per i 5 anni
             -- diviso tre
             nResaApp := ROUND(recProdottoOk.ALTRA_RESA,2);
             --DBMS_OUTPUT.PUT_LINE ('Prodotto : ' || recProdottoOk.CODICE_PRODOTTO || ' - ' || recProdottoOk.DESCRIZIONE || ' resa media : ' || TO_CHAR(nResaApp,'999G990D99'));
          ELSE
             -- son nel caso in cui non ha ne 3 ne 5 anni
             -- ma e' un prodotto ok quindi vuol dire che
             -- e' un'azienda neocostituita
             nResaApp := ROUND(recProdottoOk.RESA_MEDIA,2);
          END IF;

          bAnomalia := FALSE;
          -- per il prodotto di cui sopra mi calcolo la resa
          -- dell'azienda /  anno campagna nella polizza per luogo (regione piemonte e/o comune in caso di fuori piemonte)
          FOR recResaPerLuogoEProdotto IN curResaPerLuogoEProdotto (recProdottoOk.ID_TIPO_PRODOTTO) LOOP


              --DBMS_OUTPUT.PUT_LINE ('Prodotto : ' || recProdottoOk.CODICE_PRODOTTO || ' - ' || recProdottoOk.DESCRIZIONE || ' comune : ' || recResaPerLuogoEProdotto.DESC_COMUNE || ' resa prevista (' || TRIM(TO_CHAR(recResaPerLuogoEProdotto.RESA_PREVISTA,'999G990D99') || '), resa calcolata polizze (' || TRIM(TO_CHAR(recResaPerLuogoEProdotto.RESA_CALCOLATA,'999G990D99')) || ')' ));
              nCoefRiduzioneResa := 1;
              bAnomalia := FALSE;
              -- se la resa prevista regionale, provinciale o comunale e' maggiore di zero
              -- controllo se la resa media triennale data dai dati annuali
              -- e' minore della resa prevista (regionale / provinciale / comunale)
              IF recResaPerLuogoEProdotto.RESA_PREVISTA > 0 THEN
                  IF nResaApp < recResaPerLuogoEProdotto.RESA_PREVISTA THEN
                     -- se si tutti i record di dettaglio polizza coltura del tipo prodotto
                     -- sono in anomalia ed il pagamento deve essere abbattuto a zero
                     bAnomalia := TRUE;
                     nCoefRiduzioneResa := 0; -- abbatto a zero
                     recTAnomaliaPolizza.DESCRIZIONE := 'Resa media dati annuali  (' || TRIM(TO_CHAR(nResaApp,'999G990D99')) || ') minore della resa (regionale / provinciale / comunale) prevista (' || TRIM(TO_CHAR(recResaPerLuogoEProdotto.RESA_PREVISTA,'999G990D99')) || ')  per la coltura : ' || recResaPerLuogoEProdotto.DESC_TIPO_PRODOTTO || ' esito completamente negativo' ;

                  ELSE
                     -- altrimenti controllo se la resa media triennale data dai dati annuali
                     -- e' minore della resa calcolata sulle polizze dell'azienda per il tipo prodotto
                     -- ed il comune
                     IF nResaApp < recResaPerLuogoEProdotto.RESA_CALCOLATA THEN
                        -- se non sono azienda neocostituta
                        IF recProdottoOk.NUM_NEO = 0 THEN
                            -- se si devo riproporziare il pagamento
                            -- calcolando un coefficiente di abbattimento come
                            -- 1 - [(RESA_CALCOLATA_POLIZZE_AZIENDA - RESA TRIENNALE DATI ANNUALI) / RESA TRIENNALE DATI ANNUALI]
                            nCoefRiduzioneResa := ROUND(1 - ((recResaPerLuogoEProdotto.RESA_CALCOLATA - nResaApp) / nResaApp),4);
                            IF nCoefRiduzioneResa < 0 THEN
                               nCoefRiduzioneResa := 0;
                            END IF;
                            recTAnomaliaPolizza.DESCRIZIONE := 'Resa media dati annuali  (' || TRIM(TO_CHAR(nResaApp,'999G990D99')) || ') minore della resa calcolata sulle polizze dell''azienda  (' || TRIM(TO_CHAR(recResaPerLuogoEProdotto.RESA_CALCOLATA,'999G990D99')) || ') per la coltura : ' || recResaPerLuogoEProdotto.DESC_TIPO_PRODOTTO;
                            --DBMS_OUTPUT.PUT_LINE ('Prodotto : ' || recProdottoOk.CODICE_PRODOTTO || ' - ' || recProdottoOk.DESCRIZIONE || ' comune : ' || recResaPerLuogoEProdotto.DESC_COMUNE || ' Resa media dati annuali  (' || TRIM(TO_CHAR(nResaApp,'999G990D99')) || ') minore della resa calcolata sulle polizze dell''azienda  (' || TRIM(TO_CHAR(recResaPerLuogoEProdotto.RESA_CALCOLATA,'999G990D99')) || ') per la coltura : ' || recResaPerLuogoEProdotto.DESC_TIPO_PRODOTTO || ' comune : ' || recResaPerLuogoEProdotto.DESC_COMUNE || ' coefficiente riduzione : ' || TO_CHAR(nCoefRiduzioneResa,'999G990D99'));
                        ELSE
                            -- se sono azienda neocostituita il coefficiente
                            -- e' calcolato diversamente
                            nCoefRiduzioneResa := ROUND(1 - ((recResaPerLuogoEProdotto.RESA_CALCOLATA - recResaPerLuogoEProdotto.RESA_PREVISTA) / recResaPerLuogoEProdotto.RESA_PREVISTA),4);
                            IF nCoefRiduzioneResa < 0 THEN
                               nCoefRiduzioneResa := 0;
                            END IF;
                            recTAnomaliaPolizza.DESCRIZIONE := 'Resa media dati annuali  (' || TRIM(TO_CHAR(nResaApp,'999G990D99')) || ') minore della resa calcolata sulle polizze dell''azienda  (' || TRIM(TO_CHAR(recResaPerLuogoEProdotto.RESA_CALCOLATA,'999G990D99')) || ') per la coltura : ' || recResaPerLuogoEProdotto.DESC_TIPO_PRODOTTO;
                            --DBMS_OUTPUT.PUT_LINE ('Prodotto : ' || recProdottoOk.CODICE_PRODOTTO || ' - ' || recProdottoOk.DESCRIZIONE || ' comune : ' || recResaPerLuogoEProdotto.DESC_COMUNE || ' Resa media dati annuali  (' || TRIM(TO_CHAR(nResaApp,'999G990D99')) || ') minore della resa calcolata sulle polizze dell''azienda  (' || TRIM(TO_CHAR(recResaPerLuogoEProdotto.RESA_CALCOLATA,'999G990D99')) || ') per la coltura : ' || recResaPerLuogoEProdotto.DESC_TIPO_PRODOTTO || ' comune : ' || recResaPerLuogoEProdotto.DESC_COMUNE || ' coefficiente riduzione : ' || TO_CHAR(nCoefRiduzioneResa,'999G990D99'));
                        END IF;

                        bAnomalia := TRUE;
                     END IF;
                  END IF;
              ELSE
                  -- se e' a zero vuol dire che probabilmente non la abbiamo
                  bAnomalia := TRUE;
                  nCoefRiduzioneResa := 0; -- abbatto a zero
                  recTAnomaliaPolizza.DESCRIZIONE := 'Resa (regionale / provinciale / comunale) prevista per la coltura : ' || recResaPerLuogoEProdotto.DESC_TIPO_PRODOTTO || ' non presente - esito completamente negativo' ;
              END IF;

              -- devo accendere l'anomalia su tutti i dettaglio polizza coltura
              FOR recDettaglioPolizza IN curDettaglioPolizza (recResaPerLuogoEProdotto.ID_TIPO_PRODOTTO,
                                                              recResaPerLuogoEProdotto.RESA_PREVISTA
                                                              ) LOOP
                  IF bAnomalia THEN

                     SELECT SEQ_DB_ANOMALIA_POLIZZA.nextval
                       INTO recTAnomaliaPolizza.ID_ANOMALIA_POLIZZA
                       FROM DUAL;
                     recTAnomaliaPolizza.ID_POLIZZA_ASSICURATIVA := recDettaglioPolizza.ID_POLIZZA_ASSICURATIVA;
                     recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA := recDettaglioPolizza.ID_DETTAGLIO_POLIZZA;
                     recTAnomaliaPolizza.ID_DETTAGLIO_POLIZZA_COLTURA := recDettaglioPolizza.ID_DETTAGLIO_POLIZZA_COLTURA;
                     recTAnomaliaPolizza.ID_FONTE := knIdTipoFonteSiap;
                     recTAnomaliaPolizza.ID_CONTROLLO := knIdControlloASS15;

                     recTAnomaliaPolizza.DATA_ESECUZIONE := SYSDATE;
                     InsertTAnomaliaPolizza (recTAnomaliaPolizza);

                     UPDATE DB_DETTAGLIO_POLIZZA_COLTURA
                        SET COEFFICIENTE_RIDUZIONE_RESA = nCoefRiduzioneResa,
                            RESA_MEDIA_PRODOTTO_COMUNE =  recResaPerLuogoEProdotto.RESA_CALCOLATA
                      WHERE ID_DETTAGLIO_POLIZZA_COLTURA = recDettaglioPolizza.ID_DETTAGLIO_POLIZZA_COLTURA;

                     IF nCoefRiduzioneResa > 0 THEN
                        recTIstrPolizzaColt.ESITO_ISTRUTTORIA := 'PARZIALMENTE POSITIVO';
                     ELSE
                        IF recResaPerLuogoEProdotto.RESA_PREVISTA = 0 THEN
                           recTIstrPolizzaColt.ESITO_ISTRUTTORIA := 'NEGATIVO - RESA REGIONALE NON PERVENUTA';
                        ELSE
                           recTIstrPolizzaColt.ESITO_ISTRUTTORIA := 'NEGATIVO';
                        END IF;
                     END IF;

                  ELSE
                     recTIstrPolizzaColt.ESITO_ISTRUTTORIA := 'POSITIVO';
                     -- devo annullarlo in quanto
                     -- potrebbe essere stato calcolato da ASS11
                     UPDATE DB_DETTAGLIO_POLIZZA_COLTURA
                        SET COEFFICIENTE_RIDUZIONE_RESA = NULL,
                            RESA_MEDIA_PRODOTTO_COMUNE =  NULL
                      WHERE ID_DETTAGLIO_POLIZZA_COLTURA = recDettaglioPolizza.ID_DETTAGLIO_POLIZZA_COLTURA;

                  END IF;

                  SELECT SEQ_DB_ISTRUT_POLIZZA_COLTURA.nextval
                    INTO recTIstrPolizzaColt.ID_ISTRUTTORIA_POLIZZA_COLTURA
                    FROM DUAL;

                  recTIstrPolizzaColt.COEFFICIENTE_RIDUZIONE := nCoefRiduzioneResa;
                  recTIstrPolizzaColt.RESA_MEDIA_REGIONALE := recResaPerLuogoEProdotto.RESA_PREVISTA;
                  recTIstrPolizzaColt.RESA_MEDIA_ASSICURATA := recResaPerLuogoEProdotto.RESA_CALCOLATA;
                  recTIstrPolizzaColt.RESA_MEDIA_TRIENNALE := nResaApp;
                  recTIstrPolizzaColt.ID_DETTAGLIO_POLIZZA_COLTURA := recDettaglioPolizza.ID_DETTAGLIO_POLIZZA_COLTURA;
                  InsertTIstrPolizzaColtura (recTIstrPolizzaColt);

                  INSERT INTO DB_ANNO_UTILIZZATO_ISTRUTTORIA
                    (
                    ID_ANNO_UTILIZZATO_ISTRUTTORIA,
                    ID_ISTRUTTORIA_POLIZZA_COLTURA,
                    ID_RIEPILOGO_ANNUALE_PRODOTTO
                    )
                  SELECT SEQ_DB_ANNO_UTILIZ_ISTRUTTORIA.nextval,
                         recTIstrPolizzaColt.ID_ISTRUTTORIA_POLIZZA_COLTURA,
                         RAP.ID_RIEPILOGO_ANNUALE_PRODOTTO
                    FROM DB_TIPO_PRODOTTO TP,
                         DB_RIEPILOGO_ANNUALE_PRODOTTO RAP
                   WHERE TP.CODICE_PRODOTTO =  recProdottoOk.CODICE_PRODOTTO
                     AND TP.ID_TIPO_PRODOTTO = RAP.ID_TIPO_PRODOTTO (+)
                     AND RAP.ID_AZIENDA = pIdAzienda
                     AND RAP.ANNO_CAMPAGNA >= pAnnoCampagna - 5
                     AND RAP.ANNO_CAMPAGNA <= pAnnoCampagna - 1
                     AND RAP.DATA_ANNULLAMENTO IS NULL;

                   IF SQL%ROWCOUNT = 5 THEN

                      DELETE
                        FROM DB_ANNO_UTILIZZATO_ISTRUTTORIA
                       WHERE ID_ISTRUTTORIA_POLIZZA_COLTURA = recTIstrPolizzaColt.ID_ISTRUTTORIA_POLIZZA_COLTURA
                         AND ID_RIEPILOGO_ANNUALE_PRODOTTO IN (SELECT RAP.ID_RIEPILOGO_ANNUALE_PRODOTTO
                                                                 FROM DB_ANNO_UTILIZZATO_ISTRUTTORIA AUI,
                                                                      DB_RIEPILOGO_ANNUALE_PRODOTTO RAP
                                                                WHERE AUI.ID_ISTRUTTORIA_POLIZZA_COLTURA = recTIstrPolizzaColt.ID_ISTRUTTORIA_POLIZZA_COLTURA
                                                                  AND AUI.ID_RIEPILOGO_ANNUALE_PRODOTTO = RAP.ID_RIEPILOGO_ANNUALE_PRODOTTO
                                                                  AND RAP.RESA_CALCOLATA IN (SELECT MIN(RAP2.RESA_CALCOLATA)
                                                                                               FROM DB_ANNO_UTILIZZATO_ISTRUTTORIA AUI2,
                                                                                                    DB_RIEPILOGO_ANNUALE_PRODOTTO RAP2
                                                                                              WHERE AUI2.ID_ISTRUTTORIA_POLIZZA_COLTURA = AUI.ID_ISTRUTTORIA_POLIZZA_COLTURA
                                                                                                AND AUI2.ID_RIEPILOGO_ANNUALE_PRODOTTO = RAP2.ID_RIEPILOGO_ANNUALE_PRODOTTO
                                                                                          UNION ALL
                                                                                             SELECT MAX(RAP2.RESA_CALCOLATA)
                                                                                               FROM DB_ANNO_UTILIZZATO_ISTRUTTORIA AUI2,
                                                                                                    DB_RIEPILOGO_ANNUALE_PRODOTTO RAP2
                                                                                              WHERE AUI2.ID_ISTRUTTORIA_POLIZZA_COLTURA = AUI.ID_ISTRUTTORIA_POLIZZA_COLTURA
                                                                                                AND AUI2.ID_RIEPILOGO_ANNUALE_PRODOTTO = RAP2.ID_RIEPILOGO_ANNUALE_PRODOTTO));


                   END IF;

              END LOOP;
          END LOOP;
      END LOOP;

    END IF;


    IF bAnomalia THEN
       pResult := RET_ERR_PROC;
       pMsg := 'Coesistenza Polizze Individuali e Collettive nella stessa Regione';
    ELSE
       pResult := RET_OK;
    END IF;

    --DBMS_OUTPUT.PUT_LINE ('Fine esecuzione');

EXCEPTION
   WHEN OTHERS THEN
        pResult := RET_ERR;
        pMsg    := fncMessaggioErrore(1) || ' [ASS15] ' || SQLERRM;
        --DBMS_OUTPUT.PUT_LINE ('Errore plsql : ' || SUBSTR(SQLERRM,1,150));
END ASS15;



-- implementato nuovo controllo ATT da esporre ai procedimenti fruitori
-- speculare al controllo "Dichiarazioni_Obbligatorie" presente nel PACK_DICHIARAZIONE_CONSISTENZA
PROCEDURE ATT01 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                 p_result                   OUT VARCHAR2,
                 p_msg                      OUT VARCHAR2,
                 p_id_err                   OUT NUMBER) IS

    kvCodControllo  CONSTANT DB_TIPO_CONTROLLO.CODICE_CONTROLLO%TYPE:= 'ATT01';
    nContAtt    INTEGER:=0;
    nContAllev  INTEGER:=0;
    nContTerr   INTEGER:=0;

BEGIN

    -- count stokey dei terreni alla validazione
    SELECT COUNT(CD.ID_CONDUZIONE_DICHIARATA)
      INTO nContTerr
      FROM DB_CONDUZIONE_DICHIARATA CD,
           DB_DICHIARAZIONE_CONSISTENZA DC
     WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
       AND DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
       AND ROWNUM < 2;

    -- count stokey degli allevamenti alla validazione
    SELECT COUNT(A.ID_ALLEVAMENTO)
      INTO nContAllev
      FROM DB_DICHIARAZIONE_CONSISTENZA DC,
           DB_UTE UT,
           DB_ALLEVAMENTO A
     WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
       AND UT.ID_AZIENDA = DC.ID_AZIENDA
       AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN UT.DATA_INIZIO_ATTIVITA AND NVL(UT.DATA_FINE_ATTIVITA,DC.DATA_INSERIMENTO_DICHIARAZIONE)
       AND UT.ID_UTE = A.ID_UTE
       AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN A.DATA_INIZIO AND NVL(A.DATA_FINE,DC.DATA_INSERIMENTO_DICHIARAZIONE)
       AND ROWNUM < 2;


    IF nContTerr > 0 OR nContAllev > 0 THEN
        -- count stopkey delle attestazioni alla validazione
        SELECT COUNT(AD.ID_ATTESTAZIONE_DICHIARATA)
          INTO nContAtt
          FROM DB_DICHIARAZIONE_CONSISTENZA DC,
               DB_ATTESTAZIONE_DICHIARATA AD,
               DB_TIPO_ATTESTAZIONE TA
         WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
           AND AD.CODICE_FOTOGRAFIA_TERRENI = DC.CODICE_FOTOGRAFIA_TERRENI 
           AND AD.DATA_FINE_VALIDITA IS NULL
           AND TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY') BETWEEN TRUNC(TA.DATA_INIZIO_VALIDITA) 
                                                                                  AND NVL(TRUNC(TA.DATA_FINE_VALIDITA),TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY'))
           AND AD.ID_ATTESTAZIONE = TA.ID_ATTESTAZIONE
           AND TA.CODICE_ATTESTAZIONE = 'COND'
           AND ROWNUM < 2;

        IF nContAtt > 0 THEN
           p_result := RET_OK;
           p_msg := '';
           p_id_err := NULL;
        ELSE
           p_result := RET_ERR_CNTL;
           p_msg    := fncMessaggioErrore(3427);
           p_id_err := 3427;
        END IF;

    ELSE
        p_result := RET_OK;
        p_msg := '';
        p_id_err := NULL;
    END IF;

EXCEPTION
   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [' || kvCodControllo || '] ' || SQLERRM;
      p_id_err := 1;
END ATT01;

-- implementato nuovo controllo ATT da esporre ai procedimenti fruitori
-- speculare al controllo "Condizionalita_Norme" presente nel PACK_DICHIARAZIONE_CONSISTENZA
PROCEDURE ATT03 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                 p_result                   OUT VARCHAR2,
                 p_msg                      OUT VARCHAR2,
                 p_id_err                   OUT NUMBER) IS

    kvCodControllo  CONSTANT DB_TIPO_CONTROLLO.CODICE_CONTROLLO%TYPE:= 'ATT03';

    -- allora in pratica il controllo ha dei parametri
    -- si è deciso di mettere in valore_numerico l'attestazione padre
    -- ed in valore_numerico1 le eventuali attestazioni figli
    -- per questo devo effettuare la distinct
    CURSOR curParametroControllo (pDataRif IN DATE) IS
    SELECT DISTINCT VALORE_NUMERICO AS ID_ATTESTAZIONE_PADRE
      FROM DB_TIPO_CONTROLLO_PARAMETRO
     WHERE ID_CONTROLLO = 702
       AND pDataRif BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,pDataRif)
       AND CODICE = 'COND';

    -- prendo le attestazioni valide
    -- presenti per la dichiarazione di consistenza e legate
    -- all'attestazione padre in elaborazione
    CURSOR curAttestazione (pIdDichConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                            pIdAttPadre        IN DB_TIPO_ATTESTAZIONE.ID_PADRE_CONTROLLO%TYPE)IS
    SELECT AD.ID_ATTESTAZIONE
      FROM DB_DICHIARAZIONE_CONSISTENZA DC,
           DB_ATTESTAZIONE_DICHIARATA AD,
           DB_TIPO_ATTESTAZIONE TA
     WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichConsistenza
       AND DC.CODICE_FOTOGRAFIA_TERRENI = AD.CODICE_FOTOGRAFIA_TERRENI
       AND AD.DATA_FINE_VALIDITA IS NULL
       AND AD.ID_ATTESTAZIONE = TA.ID_ATTESTAZIONE
       AND TA.ID_PADRE_CONTROLLO = pIdAttPadre;

    nCountAtt       INTEGER:=0;
    dDataDich       DATE;
    nCountAttSt     INTEGER:=0;
    nCountAttExtSt  INTEGER:=0;
    nCountTot       INTEGER:=0;
    bAnomalo        BOOLEAN:=FALSE;
BEGIN

    -- controllo se per la dichiarazione di consistenza
    -- c'è almeno un'attestazione e prendo la data della dichiarazione di consistenza
    SELECT COUNT(AD.ID_ATTESTAZIONE_DICHIARATA),
           -- MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
           MAX(TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY')) 
      INTO nCountAtt,
           dDataDich
      FROM DB_DICHIARAZIONE_CONSISTENZA DC,
           DB_ATTESTAZIONE_DICHIARATA AD,
           DB_TIPO_ATTESTAZIONE TA
     WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
       AND AD.CODICE_FOTOGRAFIA_TERRENI = AD.CODICE_FOTOGRAFIA_TERRENI
       AND AD.DATA_FINE_VALIDITA IS NULL
       AND AD.ID_ATTESTAZIONE = TA.ID_ATTESTAZIONE 
       AND TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY') BETWEEN TRUNC(TA.DATA_INIZIO_VALIDITA)
                                                                              AND NVL(TRUNC(TA.DATA_FINE_VALIDITA),TO_DATE('31/12' || NVL(DC.ANNO_CAMPAGNA,DC.ANNO),'DD/MM/YYYY'))
       AND TA.CODICE_ATTESTAZIONE = 'COND'
       AND ROWNUM < 2;

    -- se ho almeno un'attestazione
    IF nCountAtt > 0 THEN
        -- scorro le attestazioni padre da verificare per il controllo
        FOR recParametroControllo IN curParametroControllo (dDataDich)LOOP
            -- azzero i contatori
            nCountAttSt := 0;
            nCountAttExtSt := 0;
            nCountTot := 0;
            -- per ogni attestazione padre controllo le figlie selezionate
            FOR recAttestazione IN curAttestazione(pIdDichiarazioneConsistenza,
                                                   recParametroControllo.ID_ATTESTAZIONE_PADRE) LOOP

                -- controllo se l'attestazione figlia era effettivamente tra quelle
                -- possibili per la padre
                SELECT COUNT(*) + nCountAttSt INTO nCountAttSt
                  FROM DB_TIPO_CONTROLLO_PARAMETRO
                 WHERE ID_CONTROLLO = 702
                   AND CODICE = 'COND'
                   AND dDataDich BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,dDataDich) 
                   AND VALORE_NUMERICO = recParametroControllo.ID_ATTESTAZIONE_PADRE
                   AND VALORE_NUMERICO1 = recAttestazione.ID_ATTESTAZIONE;

                -- controllo se l'attestazione figlia era effettivamente tra quelle
                -- possibili (in alternativa) per la padre
                SELECT COUNT(*) + nCountAttExtSt INTO nCountAttExtSt
                  FROM DB_TIPO_CONTROLLO_PARAMETRO
                 WHERE ID_CONTROLLO = 702
                   AND dDataDich BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,dDataDich) 
                   AND CODICE = 'COND_EXT'
                   AND VALORE_NUMERICO = recParametroControllo.ID_ATTESTAZIONE_PADRE
                   AND VALORE_NUMERICO1 = recAttestazione.ID_ATTESTAZIONE;

                -- totalizzo le attestazione selezionate
                nCountTot :=  nCountTot + nCountAttSt + nCountAttExtSt;

            END LOOP;

            -- devo averne selezionata almeno una e deve essere o di tipo COND o di TIPO COND_EXT
            -- se ho attestazione di entrambi i tipi sono comunque in anomalia
            IF nCountTot = 0 OR (nCountAttSt > 0 AND  nCountAttExtSt > 0) THEN
               bAnomalo := TRUE;
            END IF;

        END LOOP;

    END IF;

    IF bAnomalo THEN
       p_result := RET_ERR_CNTL;
       p_msg    := fncMessaggioErrore(3428);
       p_id_err := 3428;
    ELSE
       p_result := RET_OK;
       p_msg := '';
       p_id_err := NULL;
    END IF;

EXCEPTION
   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [' || kvCodControllo || '] ' || SQLERRM;
      p_id_err := 1;
END ATT03;

-- Controllo ATT05 : verifica norme e varietà di utilizzo
PROCEDURE ATT05 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                 p_result                   OUT VARCHAR2,
                 p_msg                      OUT VARCHAR2,
                 p_id_err                   OUT NUMBER) IS

    kvCodControllo  CONSTANT DB_TIPO_CONTROLLO.CODICE_CONTROLLO%TYPE:= 'ATT05';

    CURSOR curAttestazione IS
    SELECT DISTINCT
           A.ID_PADRE_CONTROLLO,
           DC.CODICE_FOTOGRAFIA_TERRENI,
           DC.DATA_INSERIMENTO_DICHIARAZIONE
      FROM DB_DICHIARAZIONE_CONSISTENZA DC,
           DB_CONDUZIONE_DICHIARATA CD,
           DB_UTILIZZO_DICHIARATO UD,
           DB_TIPO_ATTESTAZIONE_VARIETA AV,
           DB_TIPO_ATTESTAZIONE A
     WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
       AND CD.CODICE_FOTOGRAFIA_TERRENI = DC.CODICE_FOTOGRAFIA_TERRENI
       AND UD.ID_CONDUZIONE_DICHIARATA = CD.ID_CONDUZIONE_DICHIARATA
       AND CD.ID_TITOLO_POSSESSO NOT IN (knIdTitoloPossessoAsservimento,
                                         knIdTitoloPossessoConferimento)
       AND UD.ID_VARIETA = AV.ID_VARIETA
       AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN AV.DATA_INIZIO_VALIDITA AND NVL(AV.DATA_FINE_VALIDITA,DC.DATA_INSERIMENTO_DICHIARAZIONE)
       AND AV.ID_ATTESTAZIONE = A.ID_ATTESTAZIONE
       AND A.ID_PADRE_CONTROLLO IN (SELECT TCP.VALORE_NUMERICO
                                      FROM DB_TIPO_CONTROLLO TC,
                                           DB_TIPO_CONTROLLO_PARAMETRO TCP
                                     WHERE TC.CODICE_CONTROLLO = kvCodControllo
                                       AND TC.ID_CONTROLLO = TCP.ID_CONTROLLO
                                       AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN TCP.DATA_INIZIO_VALIDITA AND NVL(TCP.DATA_FINE_VALIDITA,DC.DATA_INSERIMENTO_DICHIARAZIONE));

    -- cursore delle attestazioni figlie
    CURSOR curAttestazioniFiglie (pIdAttestazione IN DB_TIPO_ATTESTAZIONE_VARIETA.ID_ATTESTAZIONE%TYPE,
                                  pDataDich       IN DB_DICHIARAZIONE_CONSISTENZA.DATA_INSERIMENTO_DICHIARAZIONE%TYPE) IS
    SELECT ID_ATTESTAZIONE, CODICE_ATTESTAZIONE
      FROM DB_TIPO_ATTESTAZIONE
     WHERE ID_PADRE_CONTROLLO = pIdAttestazione
       AND pDataDich BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,pDataDich);

    -- mi dice se ho almeno un'attestazione figlia su DB_ATTESTAZIONE_DICHIARATA
    bNormaFigliaOk  BOOLEAN:=TRUE;
    ERR_DATI        EXCEPTION;

BEGIN

    IF pIdDichiarazioneConsistenza IS NULL THEN
       RAISE ERR_DATI;
    END IF;

    <<ATTESTAZIONE>>
    FOR recAttestazione IN curAttestazione LOOP
        bNormaFigliaOk := FALSE;
        -- per ognuna di queste scorre le attestazioni figlie
        <<ATTESTAZIONI_FIGLIE>>
        FOR recAttestazioniFiglie IN curAttestazioniFiglie (recAttestazione.ID_PADRE_CONTROLLO,
                                                            recAttestazione.DATA_INSERIMENTO_DICHIARAZIONE) LOOP
            -- e controllo se almeno una è presente su DB_ATTESTAZIONE_DICHIARATA
            -- per il codice fotografia terreni
            IF EsisteAttestazione (recAttestazioniFiglie.id_attestazione,
                                   recAttestazione.codice_fotografia_terreni) THEN
               -- se si sono a posto e posso proseguiro con l'attestazione padre
               -- successiva
               bNormaFigliaOk := TRUE;
               EXIT ATTESTAZIONI_FIGLIE;
            END IF;

        END LOOP ATTESTAZIONI_FIGLIE;

        -- altrimenti so già che c'è un'anomalia
        IF NOT bNormaFigliaOk THEN
           -- e la segnalo andando a prendermi il messaggio di errore
           p_result := RET_ERR_CNTL;
           p_msg    := fncMessaggioErrore(2888);
           p_id_err := 2888;
           EXIT ATTESTAZIONE;
        END IF;
    END LOOP ATTESTAZIONE;

    -- se tutte le attestazioni padri
    -- avevano almeno una figlia su DB_ATTESTAZIONE_DICHIARATA
    -- non ci sono anomalie
    IF bNormaFigliaOk THEN
        p_result := RET_OK;
        p_msg := '';
        p_id_err := NULL;
    END IF;

EXCEPTION
   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(2887);
      p_id_err := 2887;
   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [' || kvCodControllo || '] ' || SQLERRM;
      p_id_err := 1;
END ATT05;

-- ATT06 : Atto A1 - verifica congruenza terreni appartenenti a ZPS
PROCEDURE ATT06 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                 p_result                   OUT VARCHAR2,
                 p_msg                      OUT VARCHAR2,
                 p_id_err                   OUT NUMBER) IS

    kvCodControllo  CONSTANT DB_TIPO_CONTROLLO.CODICE_CONTROLLO%TYPE:= 'ATT06';
    bAttestazioneOK BOOLEAN:=FALSE;
    nCont           INTEGER:=0;
    vCodFoto        DB_DICHIARAZIONE_CONSISTENZA.CODICE_FOTOGRAFIA_TERRENI%TYPE;
    dDataDich       DB_DICHIARAZIONE_CONSISTENZA.DATA_INSERIMENTO_DICHIARAZIONE%TYPE;

    CURSOR curAttestazioneDaVerificare (pDataDich IN DATE) IS
    SELECT TCP.VALORE_NUMERICO AS ID_ATTESTAZIONE
     FROM DB_TIPO_CONTROLLO TC,
          DB_TIPO_CONTROLLO_PARAMETRO TCP
    WHERE TC.CODICE_CONTROLLO = kvCodControllo
      AND TC.ID_CONTROLLO = TCP.ID_CONTROLLO
      AND pDataDich BETWEEN TCP.DATA_INIZIO_VALIDITA AND NVL(TCP.DATA_FINE_VALIDITA,pDataDich);

BEGIN
    -- controllo se ci sono
    -- particelle con tipo_area C Natura 2000 Zone Protezione Speciale o ZPS + SIC
    SELECT COUNT(SP.ID_STORICO_PARTICELLA),
           MAX(CD.CODICE_FOTOGRAFIA_TERRENI),
           MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
      INTO nCont,
           vCodFoto,
           dDataDich
      FROM DB_DICHIARAZIONE_CONSISTENZA DC,
           DB_CONDUZIONE_DICHIARATA CD,
           DB_STORICO_PARTICELLA SP
     WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
       AND CD.CODICE_FOTOGRAFIA_TERRENI = DC.CODICE_FOTOGRAFIA_TERRENI
       AND CD.ID_TITOLO_POSSESSO NOT IN (knIdTitoloPossessoAsservimento,knIdTitoloPossessoConferimento)
       AND CD.ID_STORICO_PARTICELLA = SP.ID_STORICO_PARTICELLA
       AND SP.ID_AREA_C IN (2,4);-- Natura 2000 Zone Protezione Speciale,
                                 -- Natura 2000 ZPS + SIC
    -- se si
    IF nCont > 0 THEN
        -- seleziono il codice fotografia terreni relativo all'id_dichiarazione_consistenza
        FOR recAttestazioneDaVerificare IN curAttestazioneDaVerificare (dDataDich) LOOP
            IF EsisteAttestazione (recAttestazioneDaVerificare.ID_ATTESTAZIONE,
                                   vCodFoto) THEN
                bAttestazioneOK := TRUE;
                EXIT;
            END IF;
        END LOOP;
    ELSE
        bAttestazioneOK := TRUE;
    END IF;

  IF bAttestazioneOK THEN
     p_result := RET_OK;
     p_msg := '';
     p_id_err := NULL;
  ELSE
     p_result := RET_ERR_CNTL;
     p_msg    := fncMessaggioErrore(2889);
     p_id_err := 2889;
  END IF;

EXCEPTION
   WHEN OTHERS THEN
        p_result := RET_ERR;
        p_msg    := fncMessaggioErrore(1) || ' [' || kvCodControllo || '] ' || SQLERRM;
        p_id_err := 1;
END ATT06;

-- ATT07 : Atto A2 - Verifica congruenza dichiarazioni
PROCEDURE ATT07 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                 p_result                   OUT VARCHAR2,
                 p_msg                      OUT VARCHAR2,
                 p_id_err                   OUT NUMBER) IS

    kvCodControllo  CONSTANT DB_TIPO_CONTROLLO.CODICE_CONTROLLO%TYPE:= 'ATT07';
    bAttestazioneOK BOOLEAN:=FALSE;
    nCont           INTEGER:=0;
    recTDichConsist DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE;

    CURSOR curAttestazioneDaVerificare (pDataDich IN DATE) IS
    SELECT TCP.VALORE_NUMERICO AS ID_ATTESTAZIONE
     FROM DB_TIPO_CONTROLLO TC,
          DB_TIPO_CONTROLLO_PARAMETRO TCP
    WHERE TC.CODICE_CONTROLLO = kvCodControllo
      AND TC.ID_CONTROLLO = TCP.ID_CONTROLLO
      AND pDataDich BETWEEN TCP.DATA_INIZIO_VALIDITA AND NVL(TCP.DATA_FINE_VALIDITA,pDataDich);

    ERR_DATI        EXCEPTION;

BEGIN
     -- seleziono il codice fotografia terreni relativo all'id_dichiarazione_consistenza
     recTDichConsist := SelDichConsistenzaById (pIdDichiarazioneConsistenza);

     IF recTDichConsist.codice_fotografia_terreni IS NULL THEN
        RAISE ERR_DATI;
     END IF;

     FOR recAttestazioneDaVerificare IN curAttestazioneDaVerificare (recTDichConsist.DATA_INSERIMENTO_DICHIARAZIONE) LOOP
        IF EsisteAttestazione (recAttestazioneDaVerificare.ID_ATTESTAZIONE,
                               recTDichConsist.codice_fotografia_terreni) THEN
           bAttestazioneOK := TRUE;
           EXIT;
        END IF;
     END LOOP;

    IF bAttestazioneOK THEN
       p_result := RET_OK;
       p_msg := '';
       p_id_err := NULL;
    ELSE
       p_result := RET_ERR_CNTL;
       p_msg    := fncMessaggioErrore(2891);
       p_id_err := 2891;
    END IF;

EXCEPTION
   WHEN ERR_DATI THEN
        p_result := RET_ERR_PROC;
        p_msg    := fncMessaggioErrore(2890);
        p_id_err := 2890;
   WHEN OTHERS THEN
        p_result := RET_ERR;
        p_msg    := fncMessaggioErrore(1) || ' [' || kvCodControllo || '] ' || SQLERRM;
        p_id_err := 1;
END ATT07;

-- ATT08 : Atto A3 - Verifica congruenza dichiarazioni
PROCEDURE ATT08 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                 p_result                   OUT VARCHAR2,
                 p_msg                      OUT VARCHAR2,
                 p_id_err                   OUT NUMBER) IS

    kvCodControllo  CONSTANT DB_TIPO_CONTROLLO.CODICE_CONTROLLO%TYPE:= 'ATT08';
    bAttestazioneOK BOOLEAN:=FALSE;
    nCont           INTEGER:=0;
    recTDichConsist DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE;

    CURSOR curAttestazioneDaVerificare (pDataDich IN DATE) IS
    SELECT TCP.VALORE_NUMERICO AS ID_ATTESTAZIONE
      FROM DB_TIPO_CONTROLLO TC,
           DB_TIPO_CONTROLLO_PARAMETRO TCP
     WHERE TC.CODICE_CONTROLLO = kvCodControllo
       AND TC.ID_CONTROLLO = TCP.ID_CONTROLLO
       AND pDataDich BETWEEN TCP.DATA_INIZIO_VALIDITA AND NVL(TCP.DATA_FINE_VALIDITA,pDataDich);

    ERR_DATI        EXCEPTION;

BEGIN
     -- seleziono il codice fotografia terreni relativo all'id_dichiarazione_consistenza
     recTDichConsist := SelDichConsistenzaById (pIdDichiarazioneConsistenza);

     IF recTDichConsist.codice_fotografia_terreni IS NULL THEN
        RAISE ERR_DATI;
     END IF;

     FOR recAttestazioneDaVerificare IN curAttestazioneDaVerificare (recTDichConsist.DATA_INSERIMENTO_DICHIARAZIONE) LOOP
        IF EsisteAttestazione (recAttestazioneDaVerificare.ID_ATTESTAZIONE,
                               recTDichConsist.codice_fotografia_terreni) THEN
           bAttestazioneOK := TRUE;
           EXIT;
        END IF;
     END LOOP;

    IF bAttestazioneOK THEN
       p_result := RET_OK;
       p_msg := '';
       p_id_err := NULL;
    ELSE
       p_result := RET_ERR_CNTL;
       p_msg    := fncMessaggioErrore(2893);
       p_id_err := 2893; 
    END IF;

EXCEPTION
   WHEN ERR_DATI THEN
        p_result := RET_ERR_PROC;
        p_msg    := fncMessaggioErrore(2892);
        p_id_err := 2892;
   WHEN OTHERS THEN
        p_result := RET_ERR;
        p_msg    := fncMessaggioErrore(1) || ' [' || kvCodControllo || '] ' || SQLERRM;
        p_id_err := 1;
END ATT08;

-- ATT09 : Atto A4 - verifica congruenza dichiarazione
PROCEDURE ATT09 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                 p_result                   OUT VARCHAR2,
                 p_msg                      OUT VARCHAR2,
                 p_id_err                   OUT NUMBER) IS

    kvCodControllo          CONSTANT DB_TIPO_CONTROLLO.CODICE_CONTROLLO%TYPE:= 'ATT09';
    kvCodPercLim            CONSTANT DB_TIPO_CONTROLLO_PARAMETRO.CODICE%TYPE:='PERCLIMITEZVN';
    kvCodIdAttest           CONSTANT DB_TIPO_CONTROLLO_PARAMETRO.CODICE%TYPE:='IDATTESTATT09';
    bAttestazioneOK         BOOLEAN:=FALSE;
    recTParamPerc           DB_TIPO_CONTROLLO_PARAMETRO%ROWTYPE;
    recTParamAttest         DB_TIPO_CONTROLLO_PARAMETRO%ROWTYPE;
    vCodFoto                DB_DICHIARAZIONE_CONSISTENZA.CODICE_FOTOGRAFIA_TERRENI%TYPE;
    dDataDich               DB_DICHIARAZIONE_CONSISTENZA.DATA_INSERIMENTO_DICHIARAZIONE%TYPE;
    ERR_PARAMETRI           EXCEPTION;
    nSommaSupCondotta       DB_CONDUZIONE_DICHIARATA.SUPERFICIE_CONDOTTA%TYPE;
    nSommaSupCondottaZvn    DB_CONDUZIONE_DICHIARATA.SUPERFICIE_CONDOTTA%TYPE;
BEGIN

    -- prendo la superficie condotta per l'azienda
    SELECT NVL(SUM(CD.SUPERFICIE_CONDOTTA),0),
           MAX(DC.CODICE_FOTOGRAFIA_TERRENI),
           MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
      INTO nSommaSupCondotta,
           vCodFoto,
           dDataDich
      FROM DB_DICHIARAZIONE_CONSISTENZA DC,
           DB_CONDUZIONE_DICHIARATA CD
     WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
       AND DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
       AND CD.ID_TITOLO_POSSESSO NOT IN (knIdTitoloPossessoAsservimento,
                                         knIdTitoloPossessoConferimento); 

    IF nSommaSupCondotta > 0 THEN
       recTParamPerc := SelValParByCodCtrlAndCodParEDt (kvCodControllo,kvCodPercLim,dDataDich);

       IF recTParamPerc.ID_CONTROLLO_PARAMETRO IS  NULL THEN
          RAISE ERR_PARAMETRI;
       END IF;

       recTParamAttest  := SelValParByCodCtrlAndCodParEDt (kvCodControllo,kvCodIdAttest,dDataDich);
       IF recTParamAttest.ID_CONTROLLO_PARAMETRO IS  NULL THEN
          RAISE ERR_PARAMETRI;
       END IF;
       -- prendo la superficie condotta per l'azienda in ZVN
       SELECT NVL(SUM(CD.SUPERFICIE_CONDOTTA),0)
         INTO nSommaSupCondottaZvn
         FROM DB_DICHIARAZIONE_CONSISTENZA DC,
              DB_CONDUZIONE_DICHIARATA CD,
              DB_STORICO_PARTICELLA SP,
              DB_FOGLIO F,DB_R_PARTICELLA_AREA PA,DB_TIPO_VALORE_AREA TVA
        WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
          AND DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
          AND CD.ID_TITOLO_POSSESSO NOT IN (knIdTitoloPossessoAsservimento,
                                            knIdTitoloPossessoConferimento) 
          AND CD.ID_STORICO_PARTICELLA = SP.ID_STORICO_PARTICELLA
          AND SP.COMUNE = F.COMUNE (+)
          AND SP.FOGLIO = F.FOGLIO (+)
          AND NVL(SP.SEZIONE,'#') = NVL(F.SEZIONE (+),'#')
          AND SP.ID_PARTICELLA = PA.ID_PARTICELLA
          AND PA.DATA_FINE_VALIDITA IS NULL
          and PA.ID_TIPO_VALORE_AREA = TVA.ID_TIPO_VALORE_AREA
          AND (TVA.ID_TIPO_AREA = 14 OR (TVA.ID_TIPO_AREA = 6 AND TVA.VALORE = 2));
          /*AND (SP.ID_FASCIA_FLUVIALE IS NOT NULL OR
               F.ID_AREA_E = 2 );*/
       -- controllo se la parcentuale di superficie condotta in ZVN è superiore
       -- al limite (25%)
       IF (nSommaSupCondottaZvn / nSommaSupCondotta) * 100 > recTParamPerc.VALORE_NUMERICO THEN
         -- seleziono il codice fotografia terreni relativo all'id_dichiarazione_consistenza
         IF EsisteAttestazione (recTParamAttest.VALORE_NUMERICO,
                                vCodFoto) THEN
            bAttestazioneOK := TRUE;
         END IF;
      ELSE
         bAttestazioneOK := TRUE;
      END IF;
  ELSE
     -- altrimenti se la superficie condotta è a zero
     -- so già che non ci sono anomalie
     bAttestazioneOK := TRUE;
  END IF;

  IF bAttestazioneOK THEN
      p_result := RET_OK;
      p_msg := '';
      p_id_err := NULL;
  ELSE
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(2895);
      p_id_err := 2895;
  END IF;

EXCEPTION
   WHEN ERR_PARAMETRI THEN
        p_result := RET_ERR_PROC;
        p_msg    := fncMessaggioErrore(2894);
        p_id_err := 2894;
   WHEN OTHERS THEN
        p_result := RET_ERR;
        p_msg    := fncMessaggioErrore(1) || ' [' || kvCodControllo || '] ' || SQLERRM;
        p_id_err := 1;
END ATT09;

-- ATT10 : Atto A5 - verifica congruenza dichiarazione
PROCEDURE ATT10 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                 p_result                   OUT VARCHAR2,
                 p_msg                      OUT VARCHAR2,
                 p_id_err                   OUT NUMBER) IS

    kvCodControllo  CONSTANT DB_TIPO_CONTROLLO.CODICE_CONTROLLO%TYPE:= 'ATT10';
    bAttestazioneOK BOOLEAN:=FALSE;
    nCont           INTEGER:=0;
    vCodFoto        DB_DICHIARAZIONE_CONSISTENZA.CODICE_FOTOGRAFIA_TERRENI%TYPE;
    dDataFoto       DB_DICHIARAZIONE_CONSISTENZA.DATA_INSERIMENTO_DICHIARAZIONE%TYPE;

    CURSOR curAttestazioneDaVerificare (pDataDich IN DATE)
    IS
    SELECT TCP.VALORE_NUMERICO AS ID_ATTESTAZIONE
     FROM DB_TIPO_CONTROLLO TC,
          DB_TIPO_CONTROLLO_PARAMETRO TCP
    WHERE TC.CODICE_CONTROLLO = kvCodControllo
      AND TC.ID_CONTROLLO = TCP.ID_CONTROLLO
      AND pDataDich BETWEEN TCP.DATA_INIZIO_VALIDITA AND NVL(TCP.DATA_FINE_VALIDITA,pDataDich);

BEGIN
    -- controllo se ci sono
    -- particelle con tipo_area C Natura 2000 Zone Protezione Speciale o ZPS + SIC
    SELECT COUNT(SP.ID_STORICO_PARTICELLA),
           MAX(CD.CODICE_FOTOGRAFIA_TERRENI),
           MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
      INTO nCont,
           vCodFoto,
           dDataFoto
      FROM DB_DICHIARAZIONE_CONSISTENZA DC,
           DB_CONDUZIONE_DICHIARATA CD,
           DB_STORICO_PARTICELLA SP,DB_R_PARTICELLA_AREA PA,DB_TIPO_VALORE_AREA TVA
     WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
       AND CD.CODICE_FOTOGRAFIA_TERRENI = DC.CODICE_FOTOGRAFIA_TERRENI
       AND CD.ID_TITOLO_POSSESSO NOT IN (knIdTitoloPossessoAsservimento,knIdTitoloPossessoConferimento)
       AND CD.ID_STORICO_PARTICELLA = SP.ID_STORICO_PARTICELLA
       AND SP.ID_PARTICELLA = PA.ID_PARTICELLA
       and PA.ID_TIPO_VALORE_AREA = TVA.ID_TIPO_VALORE_AREA
       AND PA.DATA_FINE_VALIDITA IS NULL
       AND TVA.ID_TIPO_AREA = 4
       AND TVA.VALORE IN (3,4);
       --AND SP.ID_AREA_C IN (3,4);-- Natura 2000 Siti Interesse Comunitario
                                 -- Natura 2000 ZPS + SIC
    -- se si
    IF nCont > 0 THEN
        -- seleziono il codice fotografia terreni relativo all'id_dichiarazione_consistenza
        FOR recAttestazioneDaVerificare IN curAttestazioneDaVerificare (dDataFoto)LOOP
            IF EsisteAttestazione (recAttestazioneDaVerificare.ID_ATTESTAZIONE,
                                   vCodFoto) THEN
                bAttestazioneOK := TRUE;
                EXIT;
            END IF;
        END LOOP;
    ELSE
        bAttestazioneOK := TRUE;
    END IF;

  IF bAttestazioneOK THEN
     p_result := RET_OK;
     p_msg := '';
     p_id_err := NULL;
  ELSE
     p_result := RET_ERR_CNTL;
     p_msg    := fncMessaggioErrore(2896);
     p_id_err := 2896;
  END IF;

EXCEPTION
   WHEN OTHERS THEN
        p_result := RET_ERR;
        p_msg    := fncMessaggioErrore(1) || ' [' || kvCodControllo || '] ' || SQLERRM;
        p_id_err := 1;
END ATT10;

-- ATT11 : Matrice CGO - Verifica congruenza dichiarazioni
PROCEDURE ATT11 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                 p_result                   OUT VARCHAR2,
                 p_msg                      OUT VARCHAR2,
                 p_id_err                   OUT NUMBER) IS

    kvCodControllo      CONSTANT DB_TIPO_CONTROLLO.CODICE_CONTROLLO%TYPE:= 'ATT11';
    recTDichConsistenza DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE;
    bAttestazioneOK     BOOLEAN:=TRUE;
    ERR_DATI            EXCEPTION;

    -- cursore che mi restituisce le attestazioni
    -- relative alle specie animali presenti negli allevamenti
    -- dell'azienda alla data dalle dichiarazione di consistenza
    CURSOR curAttestazioniSpecieAnimali (pIdAzienda    IN DB_UTE.ID_AZIENDA%TYPE,
                                         pDataDichCons IN DB_DICHIARAZIONE_CONSISTENZA.DATA%TYPE) IS
    SELECT DISTINCT TSAA.ID_ATTESTAZIONE
      FROM DB_UTE UT,
           DB_ALLEVAMENTO A,
           DB_TIPO_SP_ANIM_ATTESTAZIONE TSAA
     WHERE UT.ID_AZIENDA = pIDAzienda
       AND pDataDichCons BETWEEN UT.DATA_INIZIO_ATTIVITA AND NVL(UT.DATA_FINE_ATTIVITA,pDataDichCons)
       AND UT.ID_UTE = A.ID_UTE
       AND pDataDichCons BETWEEN A.DATA_INIZIO AND NVL(A.DATA_FINE,pDataDichCons) 
       AND A.ID_SPECIE_ANIMALE = TSAA.ID_SPECIE_ANIMALE
       AND pDataDichCons BETWEEN TSAA.DATA_INIZIO_VALIDITA AND NVL(TSAA.DATA_FINE_VALIDITA,pDataDichCons);

BEGIN
    -- seleziono il codice fotografia terreni relativo all'id_dichiarazione_consistenza
    recTDichConsistenza := SelDichConsistenzaById (pIdDichiarazioneConsistenza);

    IF recTDichConsistenza.CODICE_FOTOGRAFIA_TERRENI IS NULL THEN
       RAISE ERR_DATI;
    END IF;
    -- scorro il cursore delle attestazioni richieste x le specie animali
    FOR recAttestazioniSpecieAnimali IN curAttestazioniSpecieAnimali (recTDichConsistenza.ID_AZIENDA,
                                                                      recTDichConsistenza.DATA_INSERIMENTO_DICHIARAZIONE ) LOOP            --recTDichConsistenza.DATA) LOOP
        -- quando non ne trovo una su DB_ATTESTAZIONE_DICHIARATA
        IF NOT EsisteAttestazione (recAttestazioniSpecieAnimali.id_attestazione,
                                   recTDichConsistenza.codice_fotografia_terreni) THEN
           -- setto la BOOLEANA a FALSE ed esco segnalando l'anomalia
           bAttestazioneOK := FALSE;
           EXIT;
        END IF;
    END LOOP;

    IF bAttestazioneOK THEN
       p_result := RET_OK;
       p_msg := '';
       p_id_err := NULL;
    ELSE
       p_result := RET_ERR_CNTL;
       p_msg    := fncMessaggioErrore(2898);
       p_id_err := 2898;
    END IF;

EXCEPTION
   WHEN ERR_DATI THEN
        p_result := RET_ERR_PROC;
        p_msg    := fncMessaggioErrore(2897);
        p_id_err := 2897;
   WHEN OTHERS THEN
        p_result := RET_ERR;
        p_msg    := fncMessaggioErrore(1) || ' [' || kvCodControllo || '] ' || SQLERRM;
        p_id_err := 1;
END ATT11;

-- ATT12 : Atto A4 addendum - verifica congruenza dichiarazioni terreni in ZO (Zootecnia ?)
PROCEDURE ATT12 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                 p_result                   OUT VARCHAR2,
                 p_msg                      OUT VARCHAR2,
                 p_id_err                   OUT NUMBER) IS

    kvCodControllo            CONSTANT DB_TIPO_CONTROLLO.CODICE_CONTROLLO%TYPE:= 'ATT12';
    nIdAttestazioneVar        DB_ATTESTAZIONE_DICHIARATA.ID_ATTESTAZIONE%TYPE;
    nIdAttestazioneDich       DB_ATTESTAZIONE_DICHIARATA.ID_ATTESTAZIONE%TYPE;
    nPercLimiteZvn            NUMBER(3);
    nSommaSupCondotta         DB_CONDUZIONE_DICHIARATA.SUPERFICIE_CONDOTTA%TYPE;
    nSommaSupCondottaZvn      DB_CONDUZIONE_DICHIARATA.SUPERFICIE_CONDOTTA%TYPE;
    bAttestazioneOK           BOOLEAN:=FALSE;
    nPercZvn                  NUMBER(5,2); 
    nPartVarieta              INTEGER:=0;
    kvCodParPercLim           CONSTANT DB_TIPO_CONTROLLO_PARAMETRO.CODICE%TYPE:='PERCZVNATT12';
    kvCodParIdAttXVarieta     CONSTANT DB_TIPO_CONTROLLO_PARAMETRO.CODICE%TYPE:='IDATTXVARATT12';
    kvCodParIdAttDich         CONSTANT DB_TIPO_CONTROLLO_PARAMETRO.CODICE%TYPE:='IDATTDAVERATT12';
    recTParamControllo        DB_TIPO_CONTROLLO_PARAMETRO%ROWTYPE;
    vCodFoto                  DB_DICHIARAZIONE_CONSISTENZA.CODICE_FOTOGRAFIA_TERRENI%TYPE;
    dDataDich                 DB_DICHIARAZIONE_CONSISTENZA.DATA_INSERIMENTO_DICHIARAZIONE%TYPE;
    ERR_PARAMETRI             EXCEPTION;
BEGIN

    -- prendo la superficie condotta per l'azienda
    SELECT NVL(SUM(CD.SUPERFICIE_CONDOTTA),0),
           MAX(CD.CODICE_FOTOGRAFIA_TERRENI),
           MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
      INTO nSommaSupCondotta,
           vCodFoto,
           dDataDich
      FROM DB_DICHIARAZIONE_CONSISTENZA DC,
           DB_CONDUZIONE_DICHIARATA CD
     WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
       AND DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
       AND CD.ID_TITOLO_POSSESSO NOT IN (knIdTitoloPossessoAsservimento,
                                         knIdTitoloPossessoConferimento); 

    IF nSommaSupCondotta > 0 THEN
        -- recupero la percentuale minima in ZVN
       recTParamControllo := SelValParByCodCtrlAndCodParEDt (kvCodControllo,kvCodParPercLim,dDataDich);

       IF recTParamControllo.ID_CONTROLLO_PARAMETRO IS  NULL THEN
           RAISE ERR_PARAMETRI;
       ELSE
           BEGIN
               nPercZvn := recTParamControllo.VALORE_NUMERICO;
           EXCEPTION
               WHEN OTHERS THEN
                    RAISE ERR_PARAMETRI;
           END;
       END IF;

        -- recupero l'id_attestazione da ricercare su DB_ATTESTAZIONE_DICHIARATA
       recTParamControllo := SelValParByCodCtrlAndCodParEDt (kvCodControllo,kvCodParIdAttDich,dDataDich);

       IF recTParamControllo.ID_CONTROLLO_PARAMETRO IS  NULL THEN
           RAISE ERR_PARAMETRI;
       ELSE
           BEGIN
               nIdAttestazioneDich := recTParamControllo.VALORE_NUMERICO;
           EXCEPTION
               WHEN OTHERS THEN
                    RAISE ERR_PARAMETRI;
           END;
       END IF;

       -- recupero l'id_attestazione per cui ricercare le varietà
       recTParamControllo := SelValParByCodCtrlAndCodParEDt (kvCodControllo,kvCodParIdAttXVarieta,dDataDich);

       IF recTParamControllo.ID_CONTROLLO_PARAMETRO IS  NULL THEN
           RAISE ERR_PARAMETRI;
       ELSE
           BEGIN
               nIdAttestazioneVar := recTParamControllo.VALORE_NUMERICO;
           EXCEPTION
               WHEN OTHERS THEN
                    RAISE ERR_PARAMETRI;
           END;
       END IF;

       -- prendo la superficie condotta per l'azienda in ZVN
       SELECT NVL(SUM(CD.SUPERFICIE_CONDOTTA),0)
         INTO nSommaSupCondottaZvn
         FROM DB_DICHIARAZIONE_CONSISTENZA DC,
              DB_CONDUZIONE_DICHIARATA CD,
              DB_STORICO_PARTICELLA SP,
              DB_FOGLIO F,DB_R_PARTICELLA_AREA PA,DB_TIPO_VALORE_AREA TVA
        WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
          AND DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
          AND CD.ID_TITOLO_POSSESSO NOT IN (knIdTitoloPossessoAsservimento,
                                            knIdTitoloPossessoConferimento) 
          AND CD.ID_STORICO_PARTICELLA = SP.ID_STORICO_PARTICELLA
          AND SP.COMUNE = F.COMUNE (+)
          AND SP.FOGLIO = F.FOGLIO (+)
          AND NVL(SP.SEZIONE,'#') = NVL(F.SEZIONE (+),'#')
          AND SP.ID_PARTICELLA = PA.ID_PARTICELLA
          AND PA.DATA_FINE_VALIDITA IS NULL
          and PA.ID_TIPO_VALORE_AREA = TVA.ID_TIPO_VALORE_AREA
          AND (TVA.ID_TIPO_AREA = 14 OR (TVA.ID_TIPO_AREA = 6 AND TVA.VALORE = 2));
          --AND (SP.ID_FASCIA_FLUVIALE IS NOT NULL OR F.ID_AREA_E = 2 );

       -- calcolo la parcentuale di superficie condotta in ZVN
       nPercZvn := (nSommaSupCondottaZvn / nSommaSupCondotta) * 100;
       -- controllo se è compresa tra lo zero ed il parametro limite (25%)
       IF nPercZvn >= 0 AND nPercZvn <= nPercLimiteZvn THEN
          -- conto il numero di particella con
          -- varietà dell'attestazione data come parametro
          SELECT COUNT(UD.ID_UTILIZZO_DICHIARATO)
            INTO nPartVarieta
            FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                 DB_CONDUZIONE_DICHIARATA CD,
                 DB_UTILIZZO_DICHIARATO UD,
                 DB_TIPO_ATTESTAZIONE_VARIETA AV
           WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
             AND DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
             AND CD.ID_TITOLO_POSSESSO NOT IN (knIdTitoloPossessoAsservimento,
                                               knIdTitoloPossessoConferimento) 
             AND CD.ID_CONDUZIONE_DICHIARATA = UD.ID_CONDUZIONE_DICHIARATA
             AND UD.ID_VARIETA = AV.ID_VARIETA
             AND AV.ID_ATTESTAZIONE = nIdAttestazioneVar
             AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN AV.DATA_INIZIO_VALIDITA AND NVL(AV.DATA_FINE_VALIDITA,DC.DATA_INSERIMENTO_DICHIARAZIONE);
         -- se ce n'è almeno una
         IF nPartVarieta > 0 THEN
            -- controllo se è stata selezionata l'apposita attestazione
            IF EsisteAttestazione (nIdAttestazioneDich,
                                   vCodFoto
                                   ) THEN
               bAttestazioneOK := TRUE;
            END IF;
         ELSE
            bAttestazioneOK := TRUE;
         END IF;
      ELSE
         bAttestazioneOK := TRUE;
      END IF;
  ELSE
     -- altrimenti se la superficie condotta è a zero so già
     -- che non ci sono anomalie
     bAttestazioneOK := TRUE;
  END IF;

  IF bAttestazioneOK THEN
     p_result := RET_OK;
     p_msg := '';
     p_id_err := NULL;
  ELSE
     p_result := RET_ERR_CNTL;
     p_msg    := fncMessaggioErrore(2900);
     p_id_err := 2900;
  END IF;

EXCEPTION
  WHEN ERR_PARAMETRI THEN
       p_result := RET_ERR_PROC;
       p_msg    := fncMessaggioErrore(2899);
       p_id_err := 2899;
  WHEN OTHERS THEN
       p_result := RET_ERR;
       p_msg    := fncMessaggioErrore(1) || ' [' || kvCodControllo || '] ' || SQLERRM;
       p_id_err := 1;
END ATT12;

-- ATT13 : Verifica congruenza prodotti/varietà - attestazioni sottoscritte per B9-B11 addendum
PROCEDURE ATT13 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                 p_result                   OUT VARCHAR2,
                 p_msg                      OUT VARCHAR2,
                 p_id_err                   OUT NUMBER) IS

    kvCodControllo  CONSTANT DB_TIPO_CONTROLLO.CODICE_CONTROLLO%TYPE:= 'ATT13';

    CURSOR curAttestazione IS
    SELECT DISTINCT A.ID_PADRE_CONTROLLO AS ID_ATTESTAZIONE, DC.CODICE_FOTOGRAFIA_TERRENI
      FROM DB_DICHIARAZIONE_CONSISTENZA DC,
           DB_CONDUZIONE_DICHIARATA CD,
           DB_UTILIZZO_DICHIARATO UD,
           DB_TIPO_ATTESTAZIONE_VARIETA AV,
           DB_TIPO_ATTESTAZIONE A
     WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
       AND CD.CODICE_FOTOGRAFIA_TERRENI = DC.CODICE_FOTOGRAFIA_TERRENI
       AND UD.ID_CONDUZIONE_DICHIARATA = CD.ID_CONDUZIONE_DICHIARATA
       AND CD.ID_TITOLO_POSSESSO NOT IN (knIdTitoloPossessoAsservimento,
                                         knIdTitoloPossessoConferimento)
       AND UD.ID_VARIETA = AV.ID_VARIETA
       AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN AV.DATA_INIZIO_VALIDITA AND NVL(AV.DATA_FINE_VALIDITA,DC.DATA_INSERIMENTO_DICHIARAZIONE)
       AND AV.ID_ATTESTAZIONE = A.ID_ATTESTAZIONE
       AND A.ID_PADRE_CONTROLLO IN (SELECT TCP.VALORE_NUMERICO
                                      FROM DB_TIPO_CONTROLLO TC,
                                           DB_TIPO_CONTROLLO_PARAMETRO TCP
                                     WHERE TC.CODICE_CONTROLLO = kvCodControllo
                                       AND TC.ID_CONTROLLO = TCP.ID_CONTROLLO
                                       AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN TCP.DATA_INIZIO_VALIDITA
                                           AND NVL(TCP.DATA_FINE_VALIDITA,DC.DATA_INSERIMENTO_DICHIARAZIONE));

    -- inizializzata a TRUE alla prima attestazione mancante va a FALSE
    -- e segnala l'anomalia
    bAttestazioneOK  BOOLEAN:=TRUE;
    ERR_DATI         EXCEPTION;

BEGIN

    IF pIdDichiarazioneConsistenza IS NULL THEN
       RAISE ERR_DATI;
    END IF;

    FOR recAttestazione IN curAttestazione LOOP
            -- e controllo se almeno una è presente su DB_ATTESTAZIONE_DICHIARATA
            -- per il codice fotografia
          IF NOT EsisteAttestazione (recAttestazione.ID_ATTESTAZIONE,
                                     recAttestazione.codice_fotografia_terreni) THEN

             -- se si sono a posto e posso proseguiro con l'attestazione padre
             -- successiva
             bAttestazioneOK := FALSE;
             EXIT;
          END IF;

    END LOOP;

    -- se  ho trovato tutte le attestazioni su DB_ATTESTAZIONE_DICHIARATA
    IF bAttestazioneOK THEN
       p_result := RET_OK;
       p_msg := '';
       p_id_err := NULL;
    ELSE
       p_result := RET_ERR_CNTL;
       p_msg    := fncMessaggioErrore(2902);
       p_id_err := 2902;
    END IF;

EXCEPTION
   WHEN ERR_DATI THEN
        p_result := RET_ERR_PROC;
        p_msg    := fncMessaggioErrore(2901);
        p_id_err := 2901;
   WHEN OTHERS THEN
        p_result := RET_ERR;
        p_msg    := fncMessaggioErrore(1) || ' [' || kvCodControllo || '] ' || SQLERRM;
        p_id_err := 1;
END ATT13;

-- ATT14 : Verifica congruenza sottoscrizione atti B9/B11
PROCEDURE ATT14 (pIdDichiarazioneConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                 p_result                   OUT VARCHAR2,
                 p_msg                      OUT VARCHAR2,
                 p_id_err                   OUT NUMBER) IS

    kvCodControllo            CONSTANT DB_TIPO_CONTROLLO.CODICE_CONTROLLO%TYPE:= 'ATT14';
    kvCodParIdAttDich         CONSTANT DB_TIPO_CONTROLLO_PARAMETRO.CODICE%TYPE:='IDATTDAVERATT14';

    CURSOR curParametriControllo (pDataDich IN DATE) IS
    SELECT TCP.*
     FROM DB_TIPO_CONTROLLO TC,
          DB_TIPO_CONTROLLO_PARAMETRO TCP
    WHERE TC.CODICE_CONTROLLO = kvCodControllo
      AND TC.ID_CONTROLLO = TCP.ID_CONTROLLO
      AND TCP.CODICE <> kvCodParIdAttDich
      AND pDataDich BETWEEN TCP.DATA_INIZIO_VALIDITA AND NVL(TCP.DATA_FINE_VALIDITA,pDataDich);

    -- boleana che mi dice se ho trovato l'attestazione
    bAttestazioneOK           BOOLEAN:=TRUE;
    -- conterrà il numero di particella escluse quelle con determinati id_varietà
    nNumPart                  INTEGER := 0;
    -- conterrà l'ìd_attestazione padre
    nIdAttestazione           DB_TIPO_ATTESTAZIONE_VARIETA.ID_ATTESTAZIONE%TYPE;
    -- stringa di appoggio per select cursore dinamico delle attestazioni padri per id_varietà
    vStrSql                   VARCHAR2(2000);
    -- record di appoggio per reperimento parametro controllo
    recTParamControllo        DB_TIPO_CONTROLLO_PARAMETRO%ROWTYPE;
    ERR_PARAMETRI             EXCEPTION;
    ERR_DATI                  EXCEPTION;
    recTDichConsistenza       DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE;
BEGIN

    recTDichConsistenza := SelDichConsistenzaById (pIdDichiarazioneConsistenza);

    IF recTDichConsistenza.CODICE_FOTOGRAFIA_TERRENI IS NULL THEN
       RAISE ERR_DATI;
    END IF;

    -- preparo la stringa sql per l'estrazione del numero di particelle
    vStrSql := 'SELECT COUNT(UD.ID_UTILIZZO_DICHIARATO)
                  FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                       DB_CONDUZIONE_DICHIARATA CD,
                       DB_UTILIZZO_DICHIARATO UD
                 WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = :pIdDichiarazioneConsistenza
                   AND DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
                   AND CD.ID_TITOLO_POSSESSO NOT IN (:knIdTitoloPossessoAsservimento,
                                                     :knIdTitoloPossessoConferimento)
                   AND CD.ID_CONDUZIONE_DICHIARATA = UD.ID_CONDUZIONE_DICHIARATA
                   AND UD.ID_VARIETA NOT IN (
                    SELECT ID_VARIETA
                      FROM DB_TIPO_VARIETA TV,
                           DB_TIPO_UTILIZZO TU
                     WHERE TU.ID_UTILIZZO = TV.ID_UTILIZZO
                       AND TU.ANNO_FINE_VALIDITA IS NULL
                       AND TV.ANNO_FINE_VALIDITA IS NULL
                       AND (';

    FOR recParametriControllo IN curParametriControllo (recTDichConsistenza.DATA_INSERIMENTO_DICHIARAZIONE)LOOP
        vStrSql := vStrSql  || '(TU.CODICE = ''' || recParametriControllo.VALORE_STRINGA  || ''' AND ' ;
        vStrSql := vStrSql  || ' TV.CODICE_VARIETA = ''' || recParametriControllo.VALORE_STRINGA1 || ''') OR ';
    END LOOP;

    vStrSql := substr(vStrSql,1,LENGTH(vStrSql) - 3 );
    vStrSql := vStrSql || '))';

    -- eseguo la select count
    EXECUTE IMMEDIATE vStrSql
                 INTO nNumPart
                USING pIdDichiarazioneConsistenza,
                      knIdTitoloPossessoAsservimento,
                      knIdTitoloPossessoConferimento;
    -- se ci sono particelle
    IF nNumPart > 0 THEN

       -- recupero l'id_attestazione per cui ricercare le varietà
       recTParamControllo := SelValParByCodCtrlAndCodParEDt (kvCodControllo,kvCodParIdAttDich,recTDichConsistenza.DATA_INSERIMENTO_DICHIARAZIONE);

       IF recTParamControllo.ID_CONTROLLO_PARAMETRO IS NULL THEN
          RAISE ERR_PARAMETRI;
       ELSE
          BEGIN
              nIdAttestazione := recTParamControllo.VALORE_NUMERICO;
          EXCEPTION
              WHEN OTHERS THEN
                   RAISE ERR_PARAMETRI;
          END;
       END IF;


       -- controllo se esiste un record per l'attestazione dato come parametro
       -- ed il codice fotografia terreni su DB_ATTESTAZIONE_DICHIARATA
       IF NOT EsisteAttestazione (nIdAttestazione,
                                  recTDichConsistenza.CODICE_FOTOGRAFIA_TERRENI) THEN
          bAttestazioneOK := FALSE;
       END IF;

    END IF;

    IF bAttestazioneOK THEN
       p_result := RET_OK;
       p_msg := '';
       p_id_err := NULL;
    ELSE
       p_result := RET_ERR_CNTL;
       p_msg    := fncMessaggioErrore(2904);
       p_id_err := 2904;
    END IF;

EXCEPTION
  WHEN ERR_DATI THEN
       p_result := RET_ERR_PROC;
       p_msg    := fncMessaggioErrore(2905);
       p_id_err := 2905;
  WHEN ERR_PARAMETRI THEN
       p_result := RET_ERR_PROC;
       p_msg    := fncMessaggioErrore(2903);
       p_id_err := 2903;
  WHEN OTHERS THEN
       p_result := RET_ERR;
       p_msg    := fncMessaggioErrore(1) || ' [' || kvCodControllo || '] ' || SQLERRM;
       p_id_err := 1;
END ATT14;

/*********************************************************************
Verifica che il conto corrente identificato dal parametro di ingresso
pIdCC non sia Estinto, Cessato, Invalidato.
Tipo:   Procedure
input:  pIdCC
output: p_Result, p_Msg, p_Id_Err
ritorno: nessuno
*********************************************************************/
PROCEDURE CNC05(pIdCC           IN DB_CONTO_CORRENTE.ID_CONTO_CORRENTE%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS
    recTContoCorrente DB_CONTO_CORRENTE%ROWTYPE;
BEGIN

    SELECT *
      INTO recTContoCorrente
      FROM DB_CONTO_CORRENTE
     WHERE ID_CONTO_CORRENTE = pIdCC;

    IF recTContoCorrente.DATA_FINE_VALIDITA IS NOT NULL THEN
       p_result := RET_ERR_CNTL;
       p_msg    := fncMessaggioErrore(2882);
       p_id_err := 2882;
    ELSIF recTContoCorrente.DATA_ESTINZIONE IS NOT NULL THEN
       p_result := RET_ERR_CNTL;
       p_msg    := fncMessaggioErrore(2883);
       p_id_err := 2883;
    ELSIF recTContoCorrente.FLAG_VALIDATO = 'N' THEN
       p_result := RET_ERR_CNTL;
       p_msg    := fncMessaggioErrore(2884);
       p_id_err := 2884;
    ELSE
       p_result := RET_OK;
       p_msg    := 'Il conto corrente è valido';
       p_id_err := NULL;
    END IF;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        p_result := RET_ERR_CNTL;
        p_msg    := fncMessaggioErrore(2881);
        p_id_err := 2881;
    WHEN OTHERS THEN
        p_result := RET_ERR;
        p_msg    := fncMessaggioErrore(1) || ' [CNC05] ' || SQLERRM;
        p_id_err := 1;
END CNC05;

/*********************************************************************
Verifica che il conto corrente identificato dal parametro di ingresso
pIdCC non sia Estinto, Cessato, Invalidato ed in caso di aziende
con forma giuridica con il FLAG_CONTO_GF ad 'S' che il conto corrente
sia effettivamente un girofondo.
Tipo:   Procedure
input:  pIdCC
output: p_Result, p_Msg, p_Id_Err
ritorno: nessuno
*********************************************************************/
PROCEDURE CNC06(pIdCC           IN DB_CONTO_CORRENTE.ID_CONTO_CORRENTE%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

    vEsoneroGF        DB_ANAGRAFICA_AZIENDA.ESONERO_PAGAMENTO_GF%TYPE;
    vObbligoGF        DB_TIPO_FORMA_GIURIDICA.OBBLIGO_GF%TYPE;
    vSportelloGF      DB_TIPO_SPORTELLO.FLAG_SPORTELLO_GF%TYPE;

    CURSOR curTypCCConFlagSportello (pIdCC IN DB_CONTO_CORRENTE.ID_CONTO_CORRENTE%TYPE) IS
    SELECT CC.*,
           TS.FLAG_SPORTELLO_GF
      FROM DB_CONTO_CORRENTE CC,
           DB_TIPO_SPORTELLO TS
     WHERE CC.ID_CONTO_CORRENTE = pIdCC
       AND CC.ID_SPORTELLO = TS.ID_SPORTELLO;

    recTContoCorrente curTypCCConFlagSportello%ROWTYPE;

BEGIN

    BEGIN
        SELECT CC.*,
               TS.FLAG_SPORTELLO_GF
          INTO recTContoCorrente
          FROM DB_CONTO_CORRENTE CC,
               DB_TIPO_SPORTELLO TS
         WHERE CC.ID_CONTO_CORRENTE = pIdCC
           AND CC.ID_SPORTELLO = TS.ID_SPORTELLO;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             recTContoCorrente := NULL;
    END;
    -- se trovo il conto corrente
    IF recTContoCorrente.ID_CONTO_CORRENTE IS NOT NULL THEN
       -- cerco se l'azienda ha l'obbligo che sia un girofondo e
       -- non esente
       BEGIN
            -- capire se ID_FORMA_GIURIDICA è nullable per svista su
            -- DB_ANAGRAFICA_AZIENDA o se può essere effettivamente a null
            SELECT NVL(AZ.ESONERO_PAGAMENTO_GF,'N'),
                   FG.OBBLIGO_GF
              INTO vEsoneroGF,
                   vObbligoGf
              FROM DB_ANAGRAFICA_AZIENDA AZ,
                   DB_TIPO_FORMA_GIURIDICA FG
             WHERE AZ.ID_AZIENDA = recTContoCorrente.ID_AZIENDA
               AND AZ.ID_FORMA_GIURIDICA = FG.ID_FORMA_GIURIDICA
               AND AZ.DATA_FINE_VALIDITA IS NULL;
       EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 vEsoneroGF := NULL;
                 vObbligoGf := NULL;
       END;

       -- controllo se il conto corrente è attivo
       IF recTContoCorrente.DATA_FINE_VALIDITA IS NOT NULL THEN
          p_result := RET_ERR_CNTL;
          p_msg    := fncMessaggioErrore(3398);
          p_id_err := 3398;
       -- controllo se il conto corrente è estinto
       ELSIF recTContoCorrente.DATA_ESTINZIONE IS NOT NULL THEN
          p_result := RET_ERR_CNTL;
          p_msg    := fncMessaggioErrore(3399);
          p_id_err := 3399;
       -- controllo se il conto corrente è validato da SIGOP
       ELSIF recTContoCorrente.FLAG_VALIDATO = 'N' THEN
          p_result := RET_ERR_CNTL;
          p_msg    := fncMessaggioErrore(3400);
          p_id_err := 3400;
       -- se l'azienda ha l'obbligo del girofondo e non è esonerata
       -- controllo se il conto corrente è un girofondo
       -- (ed ultima novità se lo sportello è abilitato a fare i girofondo ...)
       ELSIF vObbligoGf = 'S' AND vEsoneroGF = 'N' THEN
          IF recTContoCorrente.FLAG_CONTO_GF = 'N' OR
             recTContoCorrente.FLAG_SPORTELLO_GF = 'N' THEN
             p_result := RET_ERR_CNTL;
             p_msg    := fncMessaggioErrore(3396);
             p_id_err := 3396;
          ELSE
             p_result := RET_OK;
             p_msg    := 'Il conto corrente è valido';
             p_id_err := NULL;
          END IF;
       -- se per qualche strano motivo non sono riuscito a recuperare
       -- il fatto che l'azienda necessiti di un conto girofondo
       -- do apposita anomalia
       ELSIF vObbligoGf IS NULL THEN
          p_result := RET_ERR_CNTL;
          p_msg    := fncMessaggioErrore(3401);
          p_id_err := 3401;
       ELSE
          p_result := RET_OK;
          p_msg    := 'Il conto corrente è valido';
          p_id_err := NULL;
       END IF;

    ELSE
       -- se non trovo il conto corrente tramite l'ID_CONTO_CORRENTE passato
       -- in input do apposito errore
       p_result := RET_ERR_CNTL;
       p_msg    := fncMessaggioErrore(3397);
       p_id_err := 3397;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        p_result := RET_ERR;
        p_msg    := fncMessaggioErrore(1) || ' [CNC06] ' || SQLERRM;
        p_id_err := 1;
END CNC06;

/*********************************************************************
Verifica che il conto corrente identificato coi parametri di ingresso
pIdAzienda e pIban non sia Estinto, Cessato, Invalidato ed in caso di aziende
con forma giuridica con il FLAG_CONTO_GF ad 'S' che il conto corrente
sia effettivamente un girofondo.
Tipo:   Procedure
input:  pIdAzienda, pIban
output: p_Result, p_Msg, p_Id_Err
ritorno: nessuno
*********************************************************************/
PROCEDURE CNC06(pIdAzienda        IN DB_CONTO_CORRENTE.ID_AZIENDA%TYPE,
                pIban             IN DB_CONTO_CORRENTE.IBAN%TYPE,
                p_result         OUT VARCHAR2,
                p_msg            OUT VARCHAR2,
                p_id_err         OUT NUMBER) IS
    vEsoneroGF        DB_ANAGRAFICA_AZIENDA.ESONERO_PAGAMENTO_GF%TYPE;
    vObbligoGf        DB_TIPO_FORMA_GIURIDICA.OBBLIGO_GF%TYPE;

    CURSOR curTypCCConFlagSportello (pIdCC IN DB_CONTO_CORRENTE.ID_CONTO_CORRENTE%TYPE) IS
    SELECT CC.*,
           TS.FLAG_SPORTELLO_GF
      FROM DB_CONTO_CORRENTE CC,
           DB_TIPO_SPORTELLO TS
     WHERE CC.ID_CONTO_CORRENTE = pIdCC
       AND CC.ID_SPORTELLO = TS.ID_SPORTELLO;

    recTContoCorrente curTypCCConFlagSportello%ROWTYPE;

BEGIN

    BEGIN
        -- cerco il massimo ID_CONTO_CORRENTE identificato
        -- con ID_AZIENDA ed IBAN, me ne frego se è cessato , estinto, etc
        SELECT CC.*,
               TS.FLAG_SPORTELLO_GF
          INTO recTContoCorrente
          FROM DB_CONTO_CORRENTE CC,
               DB_TIPO_SPORTELLO TS
         WHERE CC.ID_SPORTELLO = TS.ID_SPORTELLO
           AND CC.ID_CONTO_CORRENTE = (SELECT MAX(ID_CONTO_CORRENTE)
                                         FROM DB_CONTO_CORRENTE
                                        WHERE ID_AZIENDA = pIdAzienda
                                          AND IBAN = pIban);

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             recTContoCorrente := NULL;
    END;
    -- se trovo il conto corrente
    IF recTContoCorrente.ID_CONTO_CORRENTE IS NOT NULL THEN
       -- cerco se l'azienda ha l'obbligo che sia un girofondo e
       -- non esente
       BEGIN
            -- capire se ID_FORMA_GIURIDICA è nullable per svista su
            -- DB_ANAGRAFICA_AZIENDA o se può essere effettivamente a null
            SELECT NVL(AZ.ESONERO_PAGAMENTO_GF,'N'),
                   FG.OBBLIGO_GF
              INTO vEsoneroGF,
                   vObbligoGf
              FROM DB_ANAGRAFICA_AZIENDA AZ,
                   DB_TIPO_FORMA_GIURIDICA FG
             WHERE AZ.ID_AZIENDA = recTContoCorrente.ID_AZIENDA
               AND AZ.ID_FORMA_GIURIDICA = FG.ID_FORMA_GIURIDICA
               AND AZ.DATA_FINE_VALIDITA IS NULL;
       EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 vEsoneroGF := NULL;
                 vObbligoGf := NULL;
       END;

       -- controllo se il conto corrente è attivo
       IF recTContoCorrente.DATA_FINE_VALIDITA IS NOT NULL THEN
          p_result := RET_ERR_CNTL;
          p_msg    := fncMessaggioErrore(3398);
          p_id_err := 3398;
       -- controllo se il conto corrente è estinto
       ELSIF recTContoCorrente.DATA_ESTINZIONE IS NOT NULL THEN
          p_result := RET_ERR_CNTL;
          p_msg    := fncMessaggioErrore(3399);
          p_id_err := 3399;
       -- controllo se il conto corrente è validato da SIGOP
       ELSIF recTContoCorrente.FLAG_VALIDATO = 'N' THEN
          p_result := RET_ERR_CNTL;
          p_msg    := fncMessaggioErrore(3400);
          p_id_err := 3400;
       -- se l'azienda ha l'obbligo del girofondo e non è esonerata
       -- controllo se il conto corrente è un girofondo
       ELSIF vObbligoGf = 'S' AND vEsoneroGF = 'N' THEN
          IF recTContoCorrente.FLAG_CONTO_GF = 'N' OR
             recTContoCorrente.FLAG_SPORTELLO_GF = 'N' THEN
             p_result := RET_ERR_CNTL;
             p_msg    := fncMessaggioErrore(3396);
             p_id_err := 3396;
          ELSE
             p_result := RET_OK;
             p_msg    := 'Il conto corrente è valido';
             p_id_err := NULL;
          END IF;
       -- se per qualche strano motivo non sono riuscito a recuperare
       -- il fatto che l'azienda necessiti di un conto girofondo
       -- do apposita anomalia
       ELSIF vObbligoGf IS NULL THEN
          p_result := RET_ERR_CNTL;
          p_msg    := fncMessaggioErrore(3401);
          p_id_err := 3401;
       ELSE
          p_result := RET_OK;
          p_msg    := 'Il conto corrente è valido';
          p_id_err := NULL;
       END IF;

    ELSE
       -- se non trovo il conto corrente tramite l'ID_CONTO_CORRENTE passato
       -- in input do apposito errore
       p_result := RET_ERR_CNTL;
       p_msg    := fncMessaggioErrore(3397);
       p_id_err := 3397;
    END IF;
EXCEPTION
    WHEN OTHERS THEN
        p_result := RET_ERR;
        p_msg    := fncMessaggioErrore(1) || ' [CNC06] ' || SQLERRM;
        p_id_err := 1;
END CNC06;


/*********************************************************************
Dato l'id_azienda ed e l'id_Procedimento verifica che esiste
almeno una dichiarazione di consistenza effettuata per motivi
non da escludersi per il procedimento
Tipo:   Procedure
input:  pIdAzienda, pIdProcedimento
output: p_Result, p_Msg, p_Id_Err
ritorno: nessuno
*********************************************************************/
PROCEDURE DCC01(pIdAzienda      IN DB_AZIENDA.ID_AZIENDA%TYPE,
                pIdProcedimento IN DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

    recTDichConsistenza DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE;
BEGIN
     -- cerco la dichiarazione di consistenza per l'azienda ed il procedimento
     -- non protocollata
     recTDichConsistenza := SelectLastDichConsistenza (pIdAzienda,pIdProcedimento,FALSE);
     -- se la trovo
     IF recTDichConsistenza.ID_DICHIARAZIONE_CONSISTENZA IS NOT NULL THEN
        -- tutto ok
        p_result := RET_OK;
        p_msg    := '';
        p_id_err := NULL;
     ELSE
        -- altrimenti do apposita anomalia
        p_result := RET_ERR_PROC;
        p_msg    := fncMessaggioErrore(2715);
        p_id_err := 2715;
     END IF;

EXCEPTION
   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [DCC01] ' || SQLERRM;
      p_id_err := 1;
END DCC01;

/*********************************************************************
Dato l'id_azienda ed e l'id_Procedimento verifica che esiste
almeno una dichiarazione di consistenza effettuata per motivi
non da escludersi per il procedimento e che essa sia protocollata
Tipo:   Procedure
input:  pIdAzienda, pIdProcedimento
output: p_Result, p_Msg, p_Id_Err
ritorno: nessuno
*********************************************************************/
PROCEDURE DCC02(pIdAzienda      IN DB_AZIENDA.ID_AZIENDA%TYPE,
                pIdProcedimento IN DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

    recTDichConsistenza DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE;
    NO_DICHIARAZIONE    EXCEPTION;
    NO_PROTOCOLLO       EXCEPTION;
BEGIN
     -- cerco la dichiarazione di consistenza per l'azienda ed il procedimento
     recTDichConsistenza := SelectLastDichConsistenza (pIdAzienda,pIdProcedimento,TRUE);
     -- se non la trovo
     IF recTDichConsistenza.ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
        -- do apposita anomalia
        RAISE NO_DICHIARAZIONE;
     ELSE
        -- se la trovo controllo se è protocollata
        IF recTDichConsistenza.DATA_PROTOCOLLO IS NULL OR
           recTDichConsistenza.NUMERO_PROTOCOLLO IS NULL THEN
           -- altrimeti do apposita anomalia
           RAISE NO_PROTOCOLLO;
        END IF;
     END IF;

     p_result := RET_OK;
     p_msg    := '';
     p_id_err := NULL;

EXCEPTION
   WHEN NO_DICHIARAZIONE THEN
        p_result := RET_ERR_PROC;
        p_msg    := fncMessaggioErrore(2721);
        p_id_err := 2721;
   WHEN NO_PROTOCOLLO THEN
        p_result := RET_ERR_PROC;
        p_msg    := fncMessaggioErrore(2716);
        p_id_err := 2716;
   WHEN OTHERS THEN
        p_result := RET_ERR;
        p_msg    := fncMessaggioErrore(1) || ' [DCC02] ' || SQLERRM;
        p_id_err := 1;
END DCC02;

/*********************************************************************
Dato l'id_azienda ed e l'id_Procedimento verifica che esiste
almeno una dichiarazione di consistenza effettuata per motivi
non da escludersi per il procedimento, che essa sia protocollata
e che sia stata effettuata dopo una certa data fornita in input
Tipo:   Procedure
input:  pIdAzienda, pIdProcedimento, pDataDa
output: p_Result, p_Msg, p_Id_Err
ritorno: nessuno
*********************************************************************/
PROCEDURE DCC03(pIdAzienda      IN DB_AZIENDA.ID_AZIENDA%TYPE,
                pIdProcedimento IN DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE,
                pDataDa         IN DATE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

    recTDichConsistenza DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE;
    NO_DICHIARAZIONE    EXCEPTION;
    NO_PROTOCOLLO       EXCEPTION;
    TOO_OLD             EXCEPTION;
BEGIN
     -- cerco la dichiarazione di consistenza per l'azienda ed il procedimento
     recTDichConsistenza := SelectLastDichConsistenza (pIdAzienda,pIdProcedimento,TRUE);
     -- se non la trovo
     IF recTDichConsistenza.ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
        -- do apposita anomlia
        RAISE NO_DICHIARAZIONE;
     ELSE
        -- se la trovo controllo se è protocollata
        IF recTDichConsistenza.DATA_PROTOCOLLO IS NULL OR
           recTDichConsistenza.NUMERO_PROTOCOLLO IS NULL THEN
           -- se non lo è do apposita anomalia
           RAISE NO_PROTOCOLLO;
        END IF;
        -- e controllo se è successiva alla data passata in input
        IF recTDichConsistenza.DATA < pDataDa THEN
           -- se non lo è do apposita anomalia
           RAISE TOO_OLD;
        END IF;

     END IF;

     p_result := RET_OK;
     p_msg    := '';
     p_id_err := NULL;

EXCEPTION
   WHEN NO_DICHIARAZIONE THEN
        p_result := RET_ERR_PROC;
        p_msg    := fncMessaggioErrore(2722);
        p_id_err := 2722;
   WHEN NO_PROTOCOLLO THEN
        p_result := RET_ERR_PROC;
        p_msg    := fncMessaggioErrore(2720);
        p_id_err := 2720;
   WHEN TOO_OLD THEN
        p_result := RET_ERR_PROC;
        p_msg    := REPLACE(fncMessaggioErrore(2717),'$$DATA',TO_CHAR(pDataDa,'DD/MM/YYYY'));
        p_id_err := 2717;
   WHEN OTHERS THEN
        p_result := RET_ERR;
        p_msg    := fncMessaggioErrore(1) || ' [DCC03] ' || SQLERRM;
        p_id_err := 1;
END DCC03;

/*********************************************************************
Dato l'id_azienda ed e l'id_Procedimento verifica che esiste
almeno una dichiarazione di consistenza effettuata per motivi
non da escludersi per il procedimento, che essa sia protocollata
e che sia stata effettuata entro gli N mesi dati in input precedenti
alla data di sistema
Tipo:   Procedure
input:  pIdAzienda, pIdProcedimento, pNumMesi
output: p_Result, p_Msg, p_Id_Err
ritorno: nessuno
*********************************************************************/
PROCEDURE DCC04(pIdAzienda      IN DB_AZIENDA.ID_AZIENDA%TYPE,
                pIdProcedimento IN DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE,
                pNumMesi        IN INTEGER,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

    recTDichConsistenza DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE;
    NO_DICHIARAZIONE    EXCEPTION;
    NO_PROTOCOLLO       EXCEPTION;
    TOO_OLD             EXCEPTION;
BEGIN
     -- cerco la dichiarazione di consistenza per l'azienda ed il procedimento
     recTDichConsistenza := SelectLastDichConsistenza (pIdAzienda,pIdProcedimento,TRUE);
     -- se non la trovo
     IF recTDichConsistenza.ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
        -- do apposita anomalia
        RAISE NO_DICHIARAZIONE;
     ELSE
        -- se la trovo controllo se è protocollata
        IF recTDichConsistenza.DATA_PROTOCOLLO IS NULL OR
           recTDichConsistenza.NUMERO_PROTOCOLLO IS NULL THEN
           -- se non lo è do apposita anomalia
           RAISE NO_PROTOCOLLO;
        END IF;
        -- controllo se è stata effettuata entro i pNumMesi precedenti
        -- dati in input
        IF recTDichConsistenza.DATA < ADD_MONTHS(SYSDATE,- pNumMesi) THEN
           -- se non lo è do apposita anomalia
           RAISE TOO_OLD;
        END IF;

     END IF;

     p_result := RET_OK;
     p_msg    := '';
     p_id_err := NULL;

EXCEPTION
   WHEN NO_DICHIARAZIONE THEN
        p_result := RET_ERR_PROC;
        p_msg    := fncMessaggioErrore(2723);
        p_id_err := 2723;
   WHEN NO_PROTOCOLLO THEN
        p_result := RET_ERR_PROC;
        p_msg    := fncMessaggioErrore(2719);
        p_id_err := 2719;
   WHEN TOO_OLD THEN
        p_result := RET_ERR_PROC;
        p_msg    := REPLACE(fncMessaggioErrore(2718),'$$MESI',pNumMesi);
        p_id_err := 2718;
   WHEN OTHERS THEN
        p_result := RET_ERR;
        p_msg    := fncMessaggioErrore(1) || ' [DCC04] ' || SQLERRM;
        p_id_err := 1;
END DCC04;

/*********************************************************************
Dato un ID_DICHIARAZIONE_CONSISTENZA verifica che essa
sia protocollata e firmata (grafometrica o normale)
Tipo: Procedure
input: pIdDichCons
output: p_Result, p_Msg, p_Id_Err
ritorno: nessuno
*********************************************************************/
PROCEDURE DCC05(pIdDichCons      IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

    recTDichConsistenza DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE;
    nNumMancanti        INTEGER:=0;
    nNumPreseSenzaFirma INTEGER:=0;
    nNumTutti           INTEGER:=0;
    NO_PARAMETRO        EXCEPTION;
    NO_DICHIARAZIONE    EXCEPTION;
    NO_PROTOCOLLO       EXCEPTION;

BEGIN

     IF pIdDichCons IS NULL THEN
        RAISE NO_PARAMETRO;
     ELSE
         -- cerco la dichiarazione di consistenza per l'azienda ed il procedimento
         recTDichConsistenza := SelDichConsistenzaById (pIdDichCons);
         -- se non la trovo
         IF recTDichConsistenza.ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
            -- do apposita anomalia
            RAISE NO_DICHIARAZIONE;
         ELSE
            -- se la trovo controllo se è protocollata
            IF recTDichConsistenza.DATA_PROTOCOLLO IS NULL OR
               recTDichConsistenza.NUMERO_PROTOCOLLO IS NULL THEN
               -- se non lo è do apposita anomalia
               RAISE NO_PROTOCOLLO;
            END IF;

            SELECT COUNT(DECODE(A.EXT_ID_DOCUMENTO_INDEX,NULL,AD.ID_ALLEGATO_DICHIARAZIONE)),
                   COUNT(DECODE(A.EXT_ID_DOCUMENTO_INDEX,NULL,NULL,DECODE(A.ID_TIPO_FIRMA,NULL,AD.ID_ALLEGATO_DICHIARAZIONE))),
                   COUNT(AD.ID_ALLEGATO_DICHIARAZIONE)
              INTO nNumMancanti,
                   nNumPreseSenzaFirma,
                   nNumTutti
              FROM DB_ALLEGATO_DICHIARAZIONE AD,
                   DB_ALLEGATO A
             WHERE AD.ID_DICHIARAZIONE_CONSISTENZA = recTDichConsistenza.ID_DICHIARAZIONE_CONSISTENZA
               AND A.ID_TIPO_ALLEGATO = knIdTipoAllegatoValidazione
               AND AD.DATA_FINE_VALIDITA IS NULL
               AND AD.ID_ALLEGATO = A.ID_ALLEGATO;

            IF nNumTutti = 0 THEN
               p_result := RET_OK;
               p_msg    := 'La stampa della dichiarazione di consistenza e'' antecedente alla gestione della firma grafometrica';
               p_id_err := NULL;
            ELSE
               IF nNumMancanti > 0 THEN
                  p_result := RET_ERR_PROC;
                  p_msg    := fncMessaggioErrore(3775);
                  p_id_err := 3775;
               ELSE
                  IF nNumPreseSenzaFirma > 0 THEN
                     p_result := RET_ERR_PROC;
                     p_msg    := fncMessaggioErrore(3776);
                     p_id_err := 3776;
                  ELSE
                     p_result := RET_OK;
                     p_msg    := NULL;
                     p_id_err := NULL;
                  END IF;

               END IF;
            END IF;
         END IF;
     END IF;

EXCEPTION
   WHEN NO_PARAMETRO THEN
        p_result := RET_ERR_PROC;
        p_msg    := fncMessaggioErrore(3772);
        p_id_err := 3772;
   WHEN NO_DICHIARAZIONE THEN
        p_result := RET_ERR_PROC;
        p_msg    := fncMessaggioErrore(3774);
        p_id_err := 3774;
   WHEN NO_PROTOCOLLO THEN
        p_result := RET_ERR_PROC;
        p_msg    := fncMessaggioErrore(3773);
        p_id_err := 3773;
   WHEN OTHERS THEN
        p_result := RET_ERR;
        p_msg    := fncMessaggioErrore(1) || ' [DCC05] ' || SQLERRM;
        p_id_err := 1;
END DCC05;



/*********************************************************************
Dato un identificativo conto corrente il sistema ricerca se esiste un
documento attivo e valido di tipo conto corrente
Tipo:   Procedure
input:  pIdContoCorrente
output: p_Result, p_Msg, p_Id_Err
ritorno: nessuno
*********************************************************************/
PROCEDURE DOC25(pIdContoCorrente IN DB_CONTO_CORRENTE.ID_CONTO_CORRENTE%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS
    nRec INTEGER:=0;
BEGIN

    SELECT COUNT(D.ID_DOCUMENTO)
      INTO nRec
      FROM DB_DOCUMENTO D,
           DB_TIPO_DOCUMENTO TD
     WHERE D.ID_CONTO_CORRENTE = pIdContoCorrente
       AND D.EXT_ID_DOCUMENTO = TD.ID_DOCUMENTO
       AND TD.ID_TIPOLOGIA_DOCUMENTO = knIdTipoDocumentoCC
       AND D.ID_STATO_DOCUMENTO IS NULL
       AND TRUNC(NVL(D.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','DD/MM/YYYY'))) > SYSDATE
       AND TRUNC(NVL(TD.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','DD/MM/YYYY'))) > SYSDATE;

     IF nRec > 0 THEN
        p_result := RET_OK;
        p_msg    := '';
        p_id_err := NULL;
     ELSE
        p_result := RET_ERR_PROC;
        p_msg    := fncMessaggioErrore(2920);
        p_id_err := 2920;
     END IF;

EXCEPTION
   WHEN OTHERS THEN
        p_result := RET_ERR;
        p_msg    := fncMessaggioErrore(1) || ' [DOC25] ' || SQLERRM;
        p_id_err := 1;
END DOC25;


PROCEDURE TIT01(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- Verifica dati angrafici del titolare / rapp.legale dell'azienda
  --
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------

   vCognome            DB_PERSONA_FISICA.COGNOME%TYPE;
   vNome               DB_PERSONA_FISICA.NOME%TYPE;
   vSesso              DB_PERSONA_FISICA.SESSO%TYPE;
   vDataNascita        DB_PERSONA_FISICA.NASCITA_DATA%TYPE;
   vComuneNascita      DB_PERSONA_FISICA.NASCITA_COMUNE%TYPE;

   nId_ruolo_titolare  CONSTANT INTEGER := 1;

   ERR_COGNOME         EXCEPTION;
   ERR_NOME            EXCEPTION;
   ERR_SESSO           EXCEPTION;
   ERR_DATA_NASCITA    EXCEPTION;
   ERR_COMUNE_NASCITA  EXCEPTION;
   ERR_TROPPI_RAPP     EXCEPTION;
   ERR_DATI            EXCEPTION;

BEGIN
   -- Legge le info da db_persona_fisica, attraverso db_Contitolare,
   -- con ruolo=1, cioè titolare o rappresentante legale
   --
   BEGIN
      SELECT cognome, nome, sesso, nascita_data, nascita_comune
      INTO vCognome, vNome, vSesso, vDataNascita, vComuneNascita
      FROM DB_PERSONA_FISICA
      WHERE id_soggetto = (
         SELECT id_soggetto FROM DB_CONTITOLARE
         WHERE id_ruolo = nId_ruolo_titolare
         AND id_azienda = p_id_azienda
         AND data_fine_ruolo IS NULL
      );

   EXCEPTION
      WHEN OTHERS THEN
         RAISE ERR_DATI;
   END;

   -- Verifica congruenza dei dati
   --
   IF trim(vCognome) IS NULL THEN
      RAISE ERR_COGNOME;

   ELSIF trim(vNome) IS NULL THEN
      RAISE ERR_NOME;

   ELSIF trim(vSesso) IS NULL OR trim(vSesso) NOT IN ('M', 'F') THEN
      RAISE ERR_SESSO;

   ELSIF (trim(vDataNascita) IS NULL OR vDataNascita > TRUNC(SYSDATE)) THEN
      RAISE ERR_DATA_NASCITA;

   ELSIF trim(vComuneNascita) IS NULL OR NOT fncControllaComune(trim(vComuneNascita)) THEN
      RAISE ERR_COMUNE_NASCITA;

   END IF;

   p_result := RET_OK;
   p_msg    := 'Controllo dati anagrafici titolare / rapp.legale positivo';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_COGNOME THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(170);
      p_id_err := 170;

   WHEN ERR_NOME THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(171);
      p_id_err := 171;

   WHEN ERR_SESSO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(172);
      p_id_err := 172;

   WHEN ERR_DATA_NASCITA THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(173);
      p_id_err := 173;

   WHEN ERR_COMUNE_NASCITA THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(174);
      p_id_err := 174;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(175);
      p_id_err := 175;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [TIT01] ' || SQLERRM;
      p_id_err := 1;


END TIT01;



PROCEDURE TIT02(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- Verifica correttezza codice fiscale del titolare / rapp.legale dell'azienda
  --
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------

   vCognome            DB_PERSONA_FISICA.COGNOME%TYPE;
   vNome               DB_PERSONA_FISICA.NOME%TYPE;
   vSesso              DB_PERSONA_FISICA.SESSO%TYPE;
   vDataNascita        DB_PERSONA_FISICA.NASCITA_DATA%TYPE;
   vComuneNascita      DB_PERSONA_FISICA.NASCITA_COMUNE%TYPE;
   vCodFiscale         DB_PERSONA_FISICA.CODICE_FISCALE%TYPE;

   nId_ruolo_titolare     CONSTANT INTEGER := 1;

   ERR_COD_FISCALE        EXCEPTION;
   ERR_DATI               EXCEPTION;

BEGIN
   -- Legge le info da db_persona_fisica, attraverso db_Contitolare,
   -- con ruolo=1, cioè titolare o rappresentante legale
   --
   BEGIN
      SELECT cognome, nome, sesso, nascita_data, nascita_comune, codice_fiscale
      INTO vCognome, vNome, vSesso, vDataNascita, vComuneNascita, vCodFiscale
      FROM DB_PERSONA_FISICA
      WHERE id_soggetto = (
         SELECT id_soggetto FROM DB_CONTITOLARE
         WHERE id_ruolo = nId_ruolo_titolare
         AND id_azienda = p_id_azienda
         AND data_fine_ruolo IS NULL
      );

   EXCEPTION
      WHEN OTHERS THEN
         RAISE ERR_DATI;
   END;

   -- Verifica congruenza del codice fiscale
   --
   IF trim(vCodFiscale) IS NULL
    OR NOT fncCodiceFiscale( trim(vCodFiscale), vCognome, vNome, vComuneNascita, vDataNascita, vSesso )
    OR NOT fncCheckDigit( trim(vCodFiscale)) THEN
      RAISE ERR_COD_FISCALE;
   END IF;

   p_result := RET_OK;
   p_msg    := 'Controllo codice fiscale titolare / rapp.legale positivo ';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_COD_FISCALE THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(180);
      p_id_err := 180;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(181);
      p_id_err := 181;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [TIT02] ' || SQLERRM;
      p_id_err := 1;

END TIT02;



PROCEDURE TIT03(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- Verifica la valorizzazione di almeno uno dei seguenti campi:
  -- recapito telefonico, fax, email relativi al titolare / rapp.legale dell'azienda
  --
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------

   vTelefono           DB_PERSONA_FISICA.RES_TELEFONO%TYPE;
   vFax                DB_PERSONA_FISICA.RES_FAX%TYPE;
   vEmail              DB_PERSONA_FISICA.RES_MAIL%TYPE;

   nId_ruolo_titolare     CONSTANT INTEGER := 1;

   ERR_RIFERIMENTI        EXCEPTION;
   ERR_DATI               EXCEPTION;

BEGIN
   -- Legge le info da db_persona_fisica, attraverso db_Contitolare,
   -- con ruolo=1, cioè titolare o rappresentante legale
   --
   BEGIN
      SELECT res_telefono, res_fax, res_mail
      INTO vTelefono, vFax, vEmail
      FROM DB_PERSONA_FISICA
      WHERE id_soggetto = (
         SELECT id_soggetto FROM DB_CONTITOLARE
         WHERE id_ruolo = nId_ruolo_titolare
         AND id_azienda = p_id_azienda
         AND data_fine_ruolo IS NULL
      );

   EXCEPTION
      WHEN OTHERS THEN
         RAISE ERR_DATI;
   END;

  IF trim(vTelefono) IS NULL AND trim(vFax) IS NULL AND trim(vEmail) IS NULL THEN
     RAISE ERR_RIFERIMENTI;
  END IF;

   p_result := RET_OK;
   p_msg    := 'Controllo rif. contatti titolare / rapp.legale positivo';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_RIFERIMENTI THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(190);
      p_id_err := 190;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(191);
      p_id_err := 191;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [TIT03] ' || SQLERRM;
      p_id_err := 1;


END TIT03;


PROCEDURE TIT04(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Verifica la valorizzazione dei dati di residenza relativi
  -- al titolare / rapp.legale dell'azienda
  --
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------

   vComune             DB_PERSONA_FISICA.RES_COMUNE%TYPE;
   vIndirizzo          DB_PERSONA_FISICA.RES_INDIRIZZO%TYPE;
   vCAP                DB_PERSONA_FISICA.RES_CAP%TYPE;
   vCitta_estero       DB_PERSONA_FISICA.RES_CITTA_ESTERO%TYPE;

   bFlagEstero         COMUNE.FLAG_ESTERO%TYPE;
   nId_ruolo_titolare  CONSTANT INTEGER := 1;

   ERR_INDIRIZZO       EXCEPTION;
   ERR_CAP             EXCEPTION;
   ERR_COMUNE          EXCEPTION;
   ERR_CITTA_ESTERO    EXCEPTION;
   ERR_DATI            EXCEPTION;

BEGIN
   -- Legge le info da db_persona_fisica, attraverso db_Contitolare,
   -- con ruolo=1, cioè titolare o rappresentante legale
   --
   BEGIN
      SELECT res_indirizzo, res_cap, res_comune, res_citta_estero
      INTO vIndirizzo, vCAP, vComune, vCitta_estero
      FROM DB_PERSONA_FISICA
      WHERE id_soggetto = (
         SELECT id_soggetto FROM DB_CONTITOLARE
         WHERE id_ruolo = nId_ruolo_titolare
         AND id_azienda = p_id_azienda
         AND data_fine_ruolo IS NULL
      );

   EXCEPTION
      WHEN OTHERS THEN
         RAISE ERR_DATI;
   END;

  -- Verifica in primis il comune,
  -- dal quale dipende il controllo della città estera
  --
  IF trim(vComune) IS NULL THEN
     RAISE ERR_COMUNE;
  END IF;

  -- Verifica l'indirizzo
  --
  IF trim(vIndirizzo) IS NULL THEN
     RAISE ERR_INDIRIZZO;
  END IF;

  -- Verifica se si tratta di uno stato estero
  BEGIN
     SELECT flag_estero
     INTO bFlagEstero
     FROM COMUNE WHERE istat_comune = vComune;
  EXCEPTION
     WHEN OTHERS THEN
        RAISE ERR_DATI;
  END;

  -- Nel caso di residenza all'estero, controlla la validazione della città
  --
  IF bFlagEstero = 'S' THEN

     IF trim(vCitta_estero) IS NULL THEN
        RAISE ERR_CITTA_ESTERO;
     END IF;

  ELSE
  -- Nel caso di residenza in Italia, controlla la validazione del CAP
  --
     IF trim(vCAP) IS NULL THEN
        RAISE ERR_CAP;
     END IF;

  END IF;

   p_result := RET_OK;
   p_msg    := 'Controllo dati residenza titolare / rapp.legale positivo';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_INDIRIZZO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(200);
      p_id_err := 200;

   WHEN ERR_CAP THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(201);
      p_id_err := 201;

   WHEN ERR_COMUNE THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(202);
      p_id_err := 202;

   WHEN ERR_CITTA_ESTERO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(204);
      p_id_err := 204;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(203);
      p_id_err := 203;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [TIT04] ' || SQLERRM;
      p_id_err := 1;

END TIT04;


PROCEDURE TIT05(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Verifica la valorizzazione del titolo di studio del titolare / rapp. legale
  -- dell'azienda
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------

   nId_ruolo_titolare   CONSTANT INTEGER := 1;
   vDescTitStudio       DB_TIPO_TITOLO_STUDIO.descrizione%TYPE;
   vIdTitolo            DB_TIPO_TITOLO_STUDIO.ID_TITOLO_STUDIO%TYPE;

   ERR_TIT_STUDIO       EXCEPTION;
   ERR_DATI             EXCEPTION;

BEGIN

   BEGIN

      SELECT b.id_titolo_studio, b.descrizione INTO vIdTitolo, vDescTitStudio
      FROM DB_PERSONA_FISICA a, DB_TIPO_TITOLO_STUDIO b
      WHERE id_soggetto = (
         SELECT id_soggetto FROM DB_CONTITOLARE
         WHERE id_ruolo = nId_ruolo_titolare
         AND id_azienda = p_id_azienda
         AND data_fine_ruolo IS NULL
      )
      AND a.id_titolo_studio = b.id_titolo_studio
      ;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RAISE ERR_TIT_STUDIO;

      WHEN TOO_MANY_ROWS THEN
         RAISE ERR_DATI;
   END;

   IF vIdTitolo = 1 THEN
      RAISE ERR_TIT_STUDIO;
   END IF;

   p_result := RET_OK;
   p_msg    := 'Controllo titolo di studio titolare / rapp.legale positivo';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_TIT_STUDIO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(210);
      p_id_err := 210;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(211);
      p_id_err := 211;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || SQLERRM;
      p_id_err := 1;

END TIT05;


PROCEDURE TIT06(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_id_titolo     IN  DB_TIPO_TITOLO_STUDIO.id_titolo_studio%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER,
                p_valore        OUT VARCHAR2) IS

  ----------------------------------------------------------------------
  -- Verifica che il titolo di studio del titolare / rapp. legale dell'azienda
  -- non sia inferiore ad un minimo richiesto
  --
  -- Parameters:
  -- p_id_azienda  : identificativo dell'azienda in esame
  -- p_id_titolo   : minimo valore del titolo di studio richiesto per il titolare / rappresentante legale.
  -- p_result      : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg         : messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  -- p_valore      : id titolo di studio del titolare-rapp.legale
  ----------------------------------------------------------------------

   nId_ruolo_titolare   CONSTANT INTEGER := 1;
   vIdTitStudio         DB_TIPO_TITOLO_STUDIO.id_titolo_studio%TYPE;

   ERR_TIT_STUDIO       EXCEPTION;
   ERR_DATI             EXCEPTION;

BEGIN

   -- Estrae il titolo di studio del titolare / rapp. legale
   --
   BEGIN

      SELECT b.id_titolo_studio INTO vIdTitStudio
      FROM DB_PERSONA_FISICA a, DB_TIPO_TITOLO_STUDIO b
      WHERE id_soggetto = (
         SELECT id_soggetto FROM DB_CONTITOLARE
         WHERE id_ruolo = nId_ruolo_titolare
         AND id_azienda = p_id_azienda
         AND data_fine_ruolo IS NULL
      )
      AND a.id_titolo_studio = b.id_titolo_studio
      ;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RAISE ERR_TIT_STUDIO;

      WHEN TOO_MANY_ROWS THEN
         RAISE ERR_DATI;
   END;

   -- Verifica l'adeguatezza del titolo di studio, confrontandolo con
   -- il contenuto del parametro p_id_titolo
   --
   IF vIdTitStudio < p_id_titolo THEN
      -- Se il valore non è compreso nell'intervallo stabilito, solleva
      -- l'opportuna eccezione
      RAISE ERR_TIT_STUDIO;
   END IF;

   -- Termina con esito positivo
   --
   p_result := RET_OK;
   p_msg    := 'Il titolo di studio titolare / rapp.legale è adeguato';
   p_id_err := NULL;
   p_valore := TO_CHAR(vIdTitStudio);

EXCEPTION
   WHEN ERR_TIT_STUDIO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(220);
      p_id_err := 220;
      p_valore := TO_CHAR(vIdTitStudio);

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(221);
      p_id_err := 221;
      p_valore := '';

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [TIT06] ' || SQLERRM;
      p_id_err := 1;
      p_valore := '';

END TIT06;


PROCEDURE TIT07(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Verifica che il titolo di studio del titolare / rapp. legale
  -- dell'azienda, appartenga ad un indirizzo agrario.
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------

   nId_ruolo_titolare   CONSTANT INTEGER := 1;
   vIdIndirStudio       DB_TIPO_INDIRIZZO_STUDIO.indirizzo_agrario%TYPE;

   ERR_TIT_STUDIO       EXCEPTION;
   ERR_DATI             EXCEPTION;

BEGIN

   -- Estrae il tipo di indirizzo di studio
   -- del titolare / rapp. legale
   --
   BEGIN

      SELECT b.indirizzo_agrario INTO vIdIndirStudio
      FROM DB_PERSONA_FISICA a, DB_TIPO_INDIRIZZO_STUDIO b
      WHERE a.id_soggetto = (
         SELECT id_soggetto FROM DB_CONTITOLARE
         WHERE id_ruolo = nId_ruolo_titolare
         AND id_azienda = p_id_azienda
         AND data_fine_ruolo IS NULL
      )
      AND a.id_indirizzo_studio = b.id_indirizzo_studio;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RAISE ERR_TIT_STUDIO;

      WHEN TOO_MANY_ROWS THEN
         RAISE ERR_DATI;

   END;

   -- Verifica se il flag corrisponde ad un indirizzo agrario
   --
   IF UPPER(trim(NVL(vIdIndirStudio, 'N'))) <> 'S' THEN
      -- Se il titolo di studio non è ad indirizzo agrario, solleva
      -- l'opportuna eccezione
      RAISE ERR_TIT_STUDIO;
   END IF;

   -- Termina con esito positivo
   --
   p_result := RET_OK;
   p_msg    := '[TIT07] Il titolo di studio titolare / rapp.legale corrisponde ad un indirizzo agrario';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_TIT_STUDIO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(230);
      p_id_err := 230;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(231);
      p_id_err := 231;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [TIT07] ' || SQLERRM;
      p_id_err := 1;

END TIT07;


PROCEDURE TIT08(p_id_azienda        IN  DB_AZIENDA.id_azienda%TYPE,
                p_eta_riferimento   IN  NUMBER,
                p_result            OUT VARCHAR2,
                p_msg                 OUT VARCHAR2,
                p_id_err            OUT NUMBER,
                p_valore            OUT VARCHAR2
                ) IS

  ----------------------------------------------------------------------
  -- Verifica che l'età del titolare / rapp. legale
  -- dell'azienda, sia maggiore o uguale ad un valore di riferimento
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result    : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg       : messaggio di errore se la procedura non termina correttamente
  -- p_id_err    : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------
   nId_ruolo_titolare   CONSTANT INTEGER := 1;
   vDataDiNascita       DB_PERSONA_FISICA.nascita_data%TYPE;

   nEta                 NUMBER;
   ERR_DATA_NASCITA     EXCEPTION;
   ERR_DATI             EXCEPTION;

BEGIN

   BEGIN

      SELECT a.nascita_data INTO vDataDiNascita
      FROM DB_PERSONA_FISICA a
      WHERE a.id_soggetto = (
         SELECT id_soggetto FROM DB_CONTITOLARE
         WHERE id_ruolo = nId_ruolo_titolare
         AND id_azienda = p_id_azienda
         AND data_fine_ruolo IS NULL
      );

   EXCEPTION
      WHEN OTHERS THEN
         RAISE ERR_DATI;

   END;

   -- Calcola l'età in base alla data di nascita
   --
   nEta:= TRUNC( MONTHS_BETWEEN( TRUNC(SYSDATE), vDataDiNascita)  / 12 ) ;

   -- Verifica l'adeguatezza del valore, confrontandolo con
   -- i riferimenti riscontrati sulla tabella GNPS_T_VALORI_PREVISTI
   --
   IF nEta < p_eta_riferimento THEN
      -- Se il numero di anni di età del rappresentante legale è inferiore al
      -- numero di anni del riferimento, solleva l'eccezione
      --
      RAISE ERR_DATA_NASCITA;
   END IF;

   -- Termina con esito positivo
   --
   p_result := RET_OK;
   p_msg    := '[TIT08] L''età del titolare / rapp.legale rientra nei parametri';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_DATA_NASCITA THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(240);
      p_id_err := 240;
      p_valore := TO_CHAR(nEta);

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(241);
      p_id_err := 241;
      p_valore := '';

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [TIT08] ' || SQLERRM;
      p_id_err := 1;
      p_valore := '';

END TIT08;


PROCEDURE TIT09(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_mesi_ruolo    IN  NUMBER, -- cambiato da anni a mesi
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER,
                p_valore        OUT VARCHAR2
                ) IS
  ----------------------------------------------------------------------
  -- Verifica che la data di copertura ruolo di titolare / rapp. legale
  -- non sia inferiore al valore passato come parametro in ingresso
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err    : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------

   nId_ruolo_titolare   CONSTANT INTEGER := 1;
   vDataInizioRuolo     DB_CONTITOLARE.data_inizio_ruolo%TYPE;
--   nAnniRuolo number;
   nMesiRuolo    NUMBER(10);

   ERR_DATA_INIZIO_RUOLO EXCEPTION;
   ERR_DATI              EXCEPTION;

BEGIN
   BEGIN
      SELECT data_inizio_ruolo INTO vDataInizioRuolo
      FROM DB_CONTITOLARE
      WHERE id_ruolo = nId_ruolo_titolare
      AND id_azienda = p_id_azienda
      AND data_fine_ruolo IS NULL;

   EXCEPTION
      WHEN OTHERS THEN
         RAISE ERR_DATI;

   END;

   -- Calcola gli anni di ruolo a partire dalla data
   --
   nMesiRuolo := MONTHS_BETWEEN( TRUNC(SYSDATE), vDataInizioRuolo);

   -- Verifica l'adeguatezza del valore, confrontandolo con
   -- i riferimenti riscontrati sulla tabella GNPS_T_VALORI_PREVISTI
   --
   IF nMesiRuolo  < p_mesi_ruolo THEN
      -- Se il numero di mesi di copertura ruolo di rappresentante legale è inferiore al
      -- numero di mesi del riferimento, solleva l'eccezione
      --
      RAISE ERR_DATA_INIZIO_RUOLO;
   END IF;

   -- Termina con esito positivo
   --
   p_result := RET_OK;
   p_msg    := '[TIT09] Il numero di mesi nel ruolo titolare / rapp.legale rientra nei parametri';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_DATA_INIZIO_RUOLO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(250);
      p_id_err := 250;
      p_valore := TO_CHAR(nMesiRuolo);

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(251);
      p_id_err := 251;
      p_valore := '';

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [TIT09] ' || SQLERRM;
      p_id_err := 1;
      p_valore := '';

END TIT09;


PROCEDURE TIT10(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS
  ----------------------------------------------------------------------
  -- Verifica che il soggetto avenente ruolo di titolare / rapp. legale
  -- nell'azienda in esame, non rivesta contemporaneamente ruoli attivi in altre aziende
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result    : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg       : messaggio di errore se la procedura non termina correttamente
  -- p_id_err    : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------
   nId_ruolo_titolare   CONSTANT INTEGER := 1;
   vIdSoggetto          DB_CONTITOLARE.id_soggetto%TYPE;
   nCnt                 INTEGER;
   vDataInizioRuolo     DB_CONTITOLARE.data_inizio_ruolo%TYPE;

   ERR_RUOLI_MULTIPLI    EXCEPTION;
   ERR_DATI              EXCEPTION;

BEGIN
   BEGIN
      -- Preleva il soggetto titolare dell'azienda
      --
      SELECT id_soggetto INTO vIdSoggetto
      FROM DB_CONTITOLARE
      WHERE id_ruolo = nId_ruolo_titolare
      AND id_azienda = p_id_azienda
      AND data_fine_ruolo IS NULL;

      -- Conteggio del numero di aziende per le
      -- quali il soggetto riveste il ruolo di
      -- titolare / rappresentante legale, escludendo
      -- quelle cessate
      --
      SELECT COUNT(1) INTO nCnt
      FROM DB_CONTITOLARE a, DB_ANAGRAFICA_AZIENDA b
      WHERE a.id_ruolo = nId_ruolo_titolare
      AND a.id_soggetto = vIdSoggetto
      AND a.id_azienda = b.id_azienda
      AND b.data_cessazione IS NULL
      AND b.data_fine_validita IS NULL
      AND a.data_fine_ruolo IS NULL;

   EXCEPTION
     WHEN OTHERS THEN
        RAISE ERR_DATI;
   END;

   IF nCnt > 1 THEN
      RAISE ERR_RUOLI_MULTIPLI;
   END IF;

   -- Termina con esito positivo
   --
   p_result := RET_OK;
   p_msg    := '[TIT10] Il ruolo titolare / rapp.legale è coerente';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_RUOLI_MULTIPLI THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(260);
      p_id_err := 260;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(261);
      p_id_err := 261;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [TIT10] ' || SQLERRM;
      p_id_err := 1;

END TIT10;


PROCEDURE TIT11(p_id_soggetto   IN  DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE,
                  p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS
  ----------------------------------------------------------------------
  -- Verifica che il soggetto rihciedente di una misura B del PSR risulti
  -- il titolare dell'azienda in cui ha dichiarato di subentrare
  --
  -- Parameters:
  -- p_id_richiedente: identificativo della persona fisica
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result    : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg       : messaggio di errore se la procedura non termina correttamente
  -- p_id_err    : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------
   nId_ruolo_titolare   CONSTANT INTEGER := 1;
   vIdSoggetto          DB_CONTITOLARE.id_soggetto%TYPE;
   nCnt                 INTEGER;
   vDataInizioRuolo     DB_CONTITOLARE.data_inizio_ruolo%TYPE;

   ERR_NO_TITOLARE       EXCEPTION;
   ERR_DATI              EXCEPTION;

BEGIN
   BEGIN
      -- Preleva il soggetto titolare dell'azienda
      --
      SELECT COUNT(*)
      INTO nCnt
      FROM DB_CONTITOLARE a
      WHERE a.ID_SOGGETTO = p_id_soggetto
      AND a.id_azienda = p_id_azienda
      AND a.ID_RUOLO = nId_ruolo_titolare
      AND a.data_fine_ruolo IS NULL;


   EXCEPTION
     WHEN OTHERS THEN
        RAISE ERR_DATI;
   END;

   IF nCnt = 0 THEN
      RAISE ERR_NO_TITOLARE;
   END IF;

   -- Termina con esito positivo
   --
   p_result := RET_OK;
   p_msg    := '[TIT11] Il titolare è coerente';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_NO_TITOLARE THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(1030);
      p_id_err := 1030;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(261);
      p_id_err := 261;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [TIT11] ' || SQLERRM;
      p_id_err := 1;

END TIT11;



PROCEDURE TIT12(    p_id_azienda        IN  DB_AZIENDA.id_azienda%TYPE,
                        p_eta_riferimento   IN  NUMBER,
                        p_result            OUT VARCHAR2,
                        p_msg                 OUT VARCHAR2,
                        p_id_err            OUT NUMBER,
                        p_valore            OUT VARCHAR2        ) IS

  ----------------------------------------------------------------------
  -- Verifica che l'età del titolare / rapp. legale
  -- dell'azienda, NON sia maggiore ad un valore di riferimento
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result    : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg       : messaggio di errore se la procedura non termina correttamente
  -- p_id_err    : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------
   nId_ruolo_titolare   CONSTANT INTEGER := 1;
   vDataDiNascita       DB_PERSONA_FISICA.nascita_data%TYPE;

   nEta                 NUMBER;
   ERR_DATA_NASCITA     EXCEPTION;
   ERR_DATI             EXCEPTION;

BEGIN

   BEGIN

      SELECT a.nascita_data INTO vDataDiNascita
      FROM DB_PERSONA_FISICA a
      WHERE a.id_soggetto = (
         SELECT id_soggetto FROM DB_CONTITOLARE
         WHERE id_ruolo = nId_ruolo_titolare
         AND id_azienda = p_id_azienda
         AND data_fine_ruolo IS NULL
      );

   EXCEPTION
      WHEN OTHERS THEN
         RAISE ERR_DATI;

   END;

   -- Calcola l'età in base alla data di nascita
   --
   nEta:= TRUNC( MONTHS_BETWEEN( TRUNC(SYSDATE), vDataDiNascita)  / 12 ) ;

   -- Verifica l'adeguatezza del valore, confrontandolo con
   -- i riferimenti riscontrati sulla tabella GNPS_T_VALORI_PREVISTI
   --
   IF nEta > p_eta_riferimento THEN
      -- Se il numero di anni di età del rappresentante legale è inferiore al
      -- numero di anni del riferimento, solleva l'eccezione
      --
      RAISE ERR_DATA_NASCITA;
   END IF;

   -- Termina con esito positivo
   --
   p_result := RET_OK;
   p_msg    := '[TIT12] L''età del titolare / rapp.legale rientra nei parametri';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_DATA_NASCITA THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(2503);
      p_id_err := 2503;
      p_valore := TO_CHAR(nEta);

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(2504);
      p_id_err := 2504;
      p_valore := '';

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [TIT12] ' || SQLERRM;
      p_id_err := 1;
      p_valore := '';

END TIT12;



PROCEDURE RIC01(p_id_persona DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE, p_result OUT VARCHAR2, p_msg OUT VARCHAR2, p_id_err OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Verifica la completa e corretta valorizzazione dei dati anagrafici del richiedente
  --
  -- Parameters:
  -- p_id_persona:  identificativo della persona fisica in esame
  -- p_result :     risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err    : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------

   vCognome            DB_PERSONA_FISICA.COGNOME%TYPE;
   vNome               DB_PERSONA_FISICA.NOME%TYPE;
   vSesso              DB_PERSONA_FISICA.SESSO%TYPE;
   vDataNascita        DB_PERSONA_FISICA.NASCITA_DATA%TYPE;
   vComuneNascita      DB_PERSONA_FISICA.NASCITA_COMUNE%TYPE;

   nId_ruolo_titolare  CONSTANT INTEGER := 1;

   ERR_COGNOME         EXCEPTION;
   ERR_NOME            EXCEPTION;
   ERR_SESSO           EXCEPTION;
   ERR_DATA_NASCITA    EXCEPTION;
   ERR_COMUNE_NASCITA  EXCEPTION;
   ERR_DATI            EXCEPTION;

BEGIN

   --
   -- Estrae le informazioni del richiedente da db_persona_fisica
   --
   BEGIN
      SELECT cognome, nome, sesso, nascita_data, nascita_comune
      INTO vCognome, vNome, vSesso, vDataNascita, vComuneNascita
      FROM DB_PERSONA_FISICA
      WHERE id_persona_fisica = p_id_persona;
   EXCEPTION
         WHEN NO_DATA_FOUND THEN
         -- Se il soggetto non esiste su db_persona_fisica, viene
         -- cercato su db_persona_fisica_comune
         --
         BEGIN
            SELECT cognome, nome, sesso, nascita_data, ext_nascita_comune
            INTO vCognome, vNome, vSesso, vDataNascita, vComuneNascita
            FROM DB_PERSONA_FISICA_COMUNE
            WHERE id_persona_fisica_comune = p_id_persona;
         EXCEPTION
            WHEN OTHERS THEN
               RAISE ERR_DATI;
         END;

         WHEN OTHERS THEN
            RAISE ERR_DATI;
   END;


   -- Verifica congruenza dei dati
   --
   IF trim(vCognome) IS NULL THEN
      RAISE ERR_COGNOME;

   ELSIF trim(vNome) IS NULL THEN
      RAISE ERR_NOME;

   ELSIF trim(vSesso) IS NULL OR trim(vSesso) NOT IN ('M', 'F') THEN
      RAISE ERR_SESSO;

   ELSIF (trim(vDataNascita) IS NULL OR vDataNascita > TRUNC(SYSDATE)) THEN
      RAISE ERR_DATA_NASCITA;

   ELSIF trim(vComuneNascita) IS NULL OR NOT fncControllaComune(trim(vComuneNascita)) THEN
      RAISE ERR_COMUNE_NASCITA;

   END IF;

   p_result := RET_OK;
   p_msg    := 'Controllo dati anagrafici richiedente positivo';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_COGNOME THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(280);
      p_id_err := 280;

   WHEN ERR_NOME THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(281);
      p_id_err := 281;

   WHEN ERR_SESSO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(282);
      p_id_err := 282;

   WHEN ERR_DATA_NASCITA THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(283);
      p_id_err := 283;

   WHEN ERR_COMUNE_NASCITA THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(284);
      p_id_err := 284;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(285);
      p_id_err := 285;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [RIC01] ' || SQLERRM;
      p_id_err := 1;

END RIC01;


PROCEDURE RIC02(p_id_persona DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE, p_result OUT VARCHAR2, p_msg OUT VARCHAR2, p_id_err OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Verifica la completa e corretta valorizzazione del codice fiscale del richiedente
  --
  -- Parameters:
  -- p_id_persona:  identificativo della persona fisica in esame
  -- p_result :     risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err    : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------

   vCognome            DB_PERSONA_FISICA.COGNOME%TYPE;
   vNome               DB_PERSONA_FISICA.NOME%TYPE;
   vSesso              DB_PERSONA_FISICA.SESSO%TYPE;
   vDataNascita        DB_PERSONA_FISICA.NASCITA_DATA%TYPE;
   vComuneNascita      DB_PERSONA_FISICA.NASCITA_COMUNE%TYPE;
   vCodFiscale         DB_PERSONA_FISICA.CODICE_FISCALE%TYPE;

   nId_ruolo_titolare     CONSTANT INTEGER := 1;

   ERR_COD_FISCALE        EXCEPTION;
   ERR_DATI               EXCEPTION;

BEGIN

   --
   -- Estrae le informazioni del richiedente da db_persona_fisica
   --
   BEGIN
      SELECT cognome, nome, sesso, nascita_data, nascita_comune, codice_fiscale
      INTO vCognome, vNome, vSesso, vDataNascita, vComuneNascita, vCodFiscale
      FROM DB_PERSONA_FISICA
      WHERE id_persona_fisica = p_id_persona;
   EXCEPTION
         WHEN NO_DATA_FOUND THEN
         -- Se il soggetto non esiste su db_persona_fisica, viene
         -- cercato su db_persona_fisica_comune
         --
         BEGIN
            SELECT cognome, nome, sesso, nascita_data, ext_nascita_comune, codice_fiscale
            INTO vCognome, vNome, vSesso, vDataNascita, vComuneNascita, vCodFiscale
            FROM DB_PERSONA_FISICA_COMUNE
            WHERE id_persona_fisica_comune = p_id_persona;
         EXCEPTION
            WHEN OTHERS THEN
               RAISE ERR_DATI;
         END;

         WHEN OTHERS THEN
            RAISE ERR_DATI;
   END;

   -- Verifica congruenza del codice fiscale
   --
   IF trim(vCodFiscale) IS NULL
    OR NOT fncCodiceFiscale( trim(vCodFiscale), vCognome, vNome, vComuneNascita, vDataNascita, vSesso ) THEN
      RAISE ERR_COD_FISCALE;
   END IF;

   p_result := RET_OK;
   p_msg    := 'Controllo codice fiscale titolare / rapp.legale positivo ';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_COD_FISCALE THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(290);
      p_id_err := 290;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(291);
      p_id_err := 291;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [RIC02] ' || SQLERRM;
      p_id_err := 1;

END RIC02;


PROCEDURE RIC03(p_id_persona DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE, p_result OUT VARCHAR2, p_msg OUT VARCHAR2, p_id_err OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Verifica la completa valorizzazione di almeno una delle seguenti informazioni:
  -- recapito telefonico || fax || email
  --
  -- Parameters:
  -- p_id_persona:  identificativo della persona fisica in esame
  -- p_result :     risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err    : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------

   vTelefono           DB_PERSONA_FISICA.RES_TELEFONO%TYPE;
   vFax                DB_PERSONA_FISICA.RES_FAX%TYPE;
   vEmail              DB_PERSONA_FISICA.RES_MAIL%TYPE;

   nId_ruolo_titolare     CONSTANT INTEGER := 1;

   ERR_RIFERIMENTI        EXCEPTION;
   ERR_DATI               EXCEPTION;

BEGIN
   --
   -- Estrae le informazioni del richiedente da db_persona_fisica
   --
   BEGIN
      SELECT res_telefono, res_fax, res_mail
      INTO vTelefono, vFax, vEmail
      FROM DB_PERSONA_FISICA
      WHERE id_persona_fisica = p_id_persona;
   EXCEPTION
         WHEN NO_DATA_FOUND THEN
         -- Se il soggetto non esiste su db_persona_fisica, viene
         -- cercato su db_persona_fisica_comune
         --
         BEGIN
            SELECT res_telefono, res_fax, res_mail
        INTO vTelefono, vFax, vEmail
            FROM DB_PERSONA_FISICA_COMUNE
            WHERE id_persona_fisica_comune = p_id_persona;
         EXCEPTION
            WHEN OTHERS THEN
               RAISE ERR_DATI;
         END;

         WHEN OTHERS THEN
            RAISE ERR_DATI;
   END;

  IF trim(vTelefono) IS NULL AND trim(vFax) IS NULL AND trim(vEmail) IS NULL THEN
     RAISE ERR_RIFERIMENTI;
  END IF;

   p_result := RET_OK;
   p_msg    := 'Controllo rif. contatti titolare / rapp.legale positivo';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_RIFERIMENTI THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(300);
      p_id_err := 300;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(301);
      p_id_err := 301;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [RIC03] ' || SQLERRM;
      p_id_err := 1;

END RIC03;


PROCEDURE RIC04(p_id_persona DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE, p_result OUT VARCHAR2, p_msg OUT VARCHAR2, p_id_err OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Verifica la completa valorizzazione dei dati di residenza del richiedente
  --
  -- Parameters:
  -- p_id_persona:  identificativo della persona fisica in esame
  -- p_result :     risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err    : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------

   vComune             DB_PERSONA_FISICA.RES_COMUNE%TYPE;
   vIndirizzo          DB_PERSONA_FISICA.RES_INDIRIZZO%TYPE;
   vCAP                DB_PERSONA_FISICA.RES_CAP%TYPE;
   vCitta_estero       DB_PERSONA_FISICA.RES_CITTA_ESTERO%TYPE;

   bFlagEstero         COMUNE.FLAG_ESTERO%TYPE;
   nId_ruolo_titolare  CONSTANT INTEGER := 1;

   ERR_INDIRIZZO       EXCEPTION;
   ERR_CAP             EXCEPTION;
   ERR_COMUNE          EXCEPTION;
   ERR_CITTA_ESTERO    EXCEPTION;
   ERR_DATI            EXCEPTION;

BEGIN


   BEGIN
      SELECT res_indirizzo, res_cap, res_comune, res_citta_estero
      INTO vIndirizzo, vCAP, vComune, vCitta_estero
      FROM DB_PERSONA_FISICA
      WHERE id_persona_fisica = p_id_persona;
   EXCEPTION
         WHEN NO_DATA_FOUND THEN
         -- Se il soggetto non esiste su db_persona_fisica, viene
         -- cercato su db_persona_fisica_comune
         --
         BEGIN
            SELECT res_indirizzo, res_cap, ext_res_comune, res_citta_estero
            INTO vIndirizzo, vCAP, vComune, vCitta_estero
            FROM DB_PERSONA_FISICA_COMUNE
            WHERE id_persona_fisica_comune = p_id_persona;
         EXCEPTION
            WHEN OTHERS THEN
               RAISE ERR_DATI;
         END;

         WHEN OTHERS THEN
            RAISE ERR_DATI;
   END;


  IF trim(vIndirizzo) IS NULL THEN
     RAISE ERR_INDIRIZZO;
  END IF;

  IF trim(vComune) IS NULL THEN
     RAISE ERR_COMUNE;
  END IF;

  -- Verifica se si tratta di uno stato estero
  BEGIN
     SELECT flag_estero
     INTO bFlagEstero
     FROM COMUNE WHERE istat_comune = vComune;
  EXCEPTION
     WHEN OTHERS THEN
        RAISE ERR_DATI;
  END;

  -- Nel caso di residenza all'estero, controlla la validazione della città
  --
  IF bFlagEstero = 'S' THEN

     IF trim(vCitta_estero) IS NULL THEN
        RAISE ERR_CITTA_ESTERO;
     END IF;

  ELSE
  -- Nel caso di residenza in Italia, controlla la validazione del CAP
  --
     IF trim(vCAP) IS NULL THEN
        RAISE ERR_CAP;
     END IF;

  END IF;

  p_result := RET_OK;
  p_msg    := 'Controllo dati residenza titolare / rapp.legale positivo';
  p_id_err := NULL;

EXCEPTION
   WHEN ERR_INDIRIZZO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(310);
      p_id_err := 310;

   WHEN ERR_CAP THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(311);
      p_id_err := 311;

   WHEN ERR_COMUNE THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(312);
      p_id_err := 312;

   WHEN ERR_CITTA_ESTERO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(204);
      p_id_err := 314;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(313);
      p_id_err := 313;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [RIC04] ' || SQLERRM;
      p_id_err := 1;

END RIC04;


PROCEDURE RIC05(p_id_persona DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE, p_result OUT VARCHAR2, p_msg OUT VARCHAR2, p_id_err OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Verifica la completa valorizzazione dei dati di residenza del richiedente
  --
  -- Parameters:
  -- p_id_persona  :  identificativo della persona fisica in esame
  -- p_result      :  risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg         :  messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------

   nId_ruolo_titolare   CONSTANT INTEGER := 1;
   vDescTitStudio       DB_TIPO_TITOLO_STUDIO.descrizione%TYPE;
   vIdTitolo            DB_TIPO_TITOLO_STUDIO.ID_TITOLO_STUDIO%TYPE;

   ERR_TIT_STUDIO       EXCEPTION;
   ERR_DATI             EXCEPTION;

BEGIN
      -- Estrae le informazioni attraverso db_persona_fisica
      --
      BEGIN
         SELECT b.ID_TITOLO_STUDIO, b.DESCRIZIONE INTO vIdTitolo, vDescTitStudio
         FROM DB_PERSONA_FISICA a, DB_TIPO_TITOLO_STUDIO b
         WHERE a.id_persona_fisica = p_id_persona
         AND a.id_titolo_studio = b.id_titolo_studio;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
            -- Se la persona di riferimento non esiste su db_persona_fisica,
            -- allora ricerca su db_persona_fisica_comune
            --
            BEGIN
               SELECT b.ID_TITOLO_STUDIO, b.DESCRIZIONE INTO vIdTitolo, vDescTitStudio
               FROM DB_PERSONA_FISICA_COMUNE a, DB_TIPO_TITOLO_STUDIO b
               WHERE a.id_persona_fisica_comune = p_id_persona
               AND a.ext_id_titolo_studio = b.id_titolo_studio;

            EXCEPTION
               WHEN NO_DATA_FOUND THEN
                  RAISE ERR_TIT_STUDIO;

               WHEN TOO_MANY_ROWS THEN
                  RAISE ERR_DATI;
            END;

         WHEN TOO_MANY_ROWS THEN
            RAISE ERR_DATI;

      END;

   IF vIdTitolo = 1 THEN
      RAISE ERR_TIT_STUDIO;
   END IF;

   p_result := RET_OK;
   p_msg    := '[RIC05] Controllo titolo di studio richiedente positivo';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_TIT_STUDIO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(320);
      p_id_err := 320;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(321);
      p_id_err := 321;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || SQLERRM;
      p_id_err := 1;


END RIC05;


PROCEDURE RIC06(p_id_persona DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE, p_id_titolo_minimo DB_TIPO_TITOLO_STUDIO.ID_TITOLO_STUDIO%TYPE, p_result OUT VARCHAR2, p_msg OUT VARCHAR2, p_id_err OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Verifica che il titolo di studio del richiedente corrisponda ad un
  -- valore minimo richiesto.
  --
  -- Parameters:
  -- p_id_persona:       identificativo della persona fisica in esame
  -- p_id_titolo_minimo: identificativo del titolo minimo richiesto ( DB_TIPO_TITOLO_STUDIO.ID_TITOLO_STUDIO )
  --                     Si assume che gli id siano sempre direttamente proporzionali al titolo.
  -- p_result:           risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg:              messaggio di errore se la procedura non termina correttamente
  -- p_id_err:           identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------

   vIdTitStudio         DB_TIPO_TITOLO_STUDIO.id_titolo_studio%TYPE;

   ERR_TIT_STUDIO       EXCEPTION;
   ERR_TIT_MIN          EXCEPTION;
   ERR_DATI             EXCEPTION;
   ERR_VALORI_PREVISTI  EXCEPTION;

BEGIN

      BEGIN
         SELECT b.id_titolo_studio INTO vIdTitStudio
         FROM DB_PERSONA_FISICA a, DB_TIPO_TITOLO_STUDIO b
         WHERE a.id_persona_fisica = p_id_persona
         AND a.id_titolo_studio = b.id_titolo_studio;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
            BEGIN
               SELECT b.id_titolo_studio INTO vIdTitStudio
               FROM DB_PERSONA_FISICA_COMUNE a, DB_TIPO_TITOLO_STUDIO b
               WHERE a.id_persona_fisica_comune = p_id_persona
               AND a.ext_id_titolo_studio = b.id_titolo_studio;

            EXCEPTION
               WHEN NO_DATA_FOUND THEN
                  RAISE ERR_TIT_STUDIO;

               WHEN TOO_MANY_ROWS THEN
                  RAISE ERR_DATI;
            END;

         WHEN TOO_MANY_ROWS THEN
            RAISE ERR_DATI;
      END;

   -- Verifica l'adeguatezza del valore, confrontandolo con
   -- i riferimenti riscontrati sulla tabella GNPS_T_VALORI_PREVISTI
   --
   IF vIdTitStudio < p_id_titolo_minimo THEN
      -- Se il valore non è compreso nell'intervallo stabilito, solleva
      -- l'opportuna eccezione
      RAISE ERR_TIT_MIN;
   END IF;

   -- Termina con esito positivo
   --
   p_result := RET_OK;
   p_msg    := '[RIC06] Il titolo di studio richiedente è adeguato';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_TIT_STUDIO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(330);
      p_id_err := 330;

   WHEN ERR_TIT_MIN THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(331);
      p_id_err := 331;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(332);
      p_id_err := 332;

   WHEN ERR_VALORI_PREVISTI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(333);
      p_id_err := 333;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [RIC06] ' || SQLERRM;
      p_id_err := 1;


END RIC06;


PROCEDURE RIC07(p_id_persona DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE, p_indirizzo_agrario IN DB_TIPO_INDIRIZZO_STUDIO.indirizzo_agrario%TYPE, p_result OUT VARCHAR2, p_msg OUT VARCHAR2, p_id_err OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Verifica che il titolo di studio del richiedente corrisponda ad un
  -- indirizzo specifico. Se p_indirizzo_agrario corrisponde a 'S', verifica
  -- il titolo deve corrispondere ad un indirizzo agrario, altrimenti ad un
  -- indirizzo diverso.
  --
  -- Parameters:
  -- p_id_persona:        identificativo della persona fisica in esame
  -- p_indirizzo_agrario: flag che indica se il titolo deve essere ad indirizzo agrario
  -- p_id_aiuto:          identificativo aiuto controllo, necessario per query su GNPS_T_VALORI_PREVISTI
  -- p_result :           risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err:           identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------

   vIdTitStudio         DB_TIPO_TITOLO_STUDIO.id_titolo_studio%TYPE;
   vIdIndirStudio       DB_TIPO_INDIRIZZO_STUDIO.indirizzo_agrario%TYPE;

   ERR_TIT_STUDIO       EXCEPTION;
   ERR_IND_STUDIO       EXCEPTION;
   ERR_DATI             EXCEPTION;
   ERR_VALORI_PREVISTI  EXCEPTION;

BEGIN

      BEGIN
         SELECT b.id_titolo_studio, c.indirizzo_agrario
         INTO vIdTitStudio, vIdIndirStudio
         FROM DB_PERSONA_FISICA a, DB_TIPO_TITOLO_STUDIO b, DB_TIPO_INDIRIZZO_STUDIO c
         WHERE a.id_persona_fisica = p_id_persona
         AND a.id_titolo_studio = b.id_titolo_studio
         AND a.id_indirizzo_studio = c.id_indirizzo_studio;

      EXCEPTION
         WHEN NO_DATA_FOUND THEN
            BEGIN
               SELECT b.id_titolo_studio, c.indirizzo_agrario
               INTO vIdTitStudio, vIdIndirStudio
               FROM DB_PERSONA_FISICA_COMUNE a, DB_TIPO_TITOLO_STUDIO b, DB_TIPO_INDIRIZZO_STUDIO c
               WHERE a.id_persona_fisica_comune = p_id_persona
               AND a.ext_id_titolo_studio = b.id_titolo_studio
               AND a.ext_id_indirizzo_studio = c.id_indirizzo_studio;

            EXCEPTION
               WHEN NO_DATA_FOUND THEN
                  RAISE ERR_TIT_STUDIO;

               WHEN TOO_MANY_ROWS THEN
                  RAISE ERR_DATI;
            END;

         WHEN TOO_MANY_ROWS THEN
            RAISE ERR_DATI;
      END;

   -- Verifica l'adeguatezza del valore, confrontandolo con
   -- i riferimenti riscontrati sulla tabella GNPS_T_VALORI_PREVISTI
   --
   IF UPPER(trim(vIdIndirStudio)) <> p_indirizzo_agrario THEN
      -- Se il valore non è compreso nell'intervallo stabilito, solleva
      -- l'opportuna eccezione
      RAISE ERR_IND_STUDIO;
   END IF;

   -- Termina con esito positivo
   --
   p_result := RET_OK;
   p_msg    := '[RIC07] L''indirizzo di studio titolare / rapp.legale è adeguato';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_TIT_STUDIO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(340);
      p_id_err := 340;

   WHEN ERR_IND_STUDIO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(341);
      p_id_err := 341;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(342);
      p_id_err := 342;

   WHEN ERR_VALORI_PREVISTI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(343);
      p_id_err := 343;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [RIC07] ' || SQLERRM;
      p_id_err := 1;

END RIC07;


PROCEDURE RIC08(p_id_persona DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE, p_result OUT VARCHAR2, p_msg OUT VARCHAR2, p_id_err OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Verifica che la persona sia in attesa di insediamento in agricoltura
  -- (presente in anagrafe con ruolo specifico).
  --
  -- Parameters:
  -- p_id_persona:  identificativo della persona fisica in esame
  -- p_flag_comune: flag che impone la ricerca dei dati su DB_COMUNE
  -- p_result :     risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err:           identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------
BEGIN
--
-- E' da definire il ruolo insediamento in agricoltura
--
   --
   p_result := RET_OK;
   p_msg    := '';
   p_id_err := NULL;

END RIC08;


PROCEDURE RIC09(p_id_persona DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE, p_result OUT VARCHAR2, p_msg OUT VARCHAR2, p_id_err OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Verifica che il richiedente non abbia rivestito in precedenza ruoli
  -- di titolare/rappresentante legale
  --
  -- Parameters:
  -- p_id_persona:  identificativo della persona fisica in esame
  -- p_result :     risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err:           identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------

   nId_ruolo_titolare   CONSTANT INTEGER := 1;
   nRuoliPersona        INTEGER;

   ERR_DATI             EXCEPTION;
   ERR_ID_RUOLO         EXCEPTION;
   ERR_RUOLI_TITOLARI   EXCEPTION;

BEGIN

      BEGIN
         SELECT COUNT(1) INTO nRuoliPersona
         FROM DB_PERSONA_FISICA a, DB_CONTITOLARE b, DB_ANAGRAFICA_AZIENDA c , DB_AZIENDA d
         WHERE a.id_persona_fisica = p_id_persona
         AND a.id_soggetto = b.id_soggetto
         AND b.id_ruolo = nId_ruolo_titolare
        AND b.id_azienda = c.id_azienda
         AND c.id_azienda = d.id_azienda
         AND C.DATA_FINE_VALIDITA IS NULL
         AND c.ID_FORMA_GIURIDICA <> 52
         AND (d.FLAG_azienda_provvisoria IS NULL OR d.FLAG_azienda_provvisoria = 'N');


      EXCEPTION
         WHEN OTHERS THEN
            RAISE ERR_DATI;
      END;


   IF nRuoliPersona > 0 THEN

      RAISE ERR_RUOLI_TITOLARI;

   END IF;

   -- Termina con esito positivo
   --


   p_result := RET_OK;
   p_msg    := '[RIC09] Il richiedente ricopre per la prima volta il ruolo di titolare / rapp.legale è adeguato';
   p_id_err := NULL;

EXCEPTION
      WHEN ERR_DATI THEN
         p_result := RET_ERR_PROC;
         p_msg    := fncMessaggioErrore(350);
         p_id_err := 350;

      WHEN ERR_ID_RUOLO THEN
         p_result := RET_ERR_CNTL;
         p_msg    := fncMessaggioErrore(351);
         p_id_err := 351;

      WHEN ERR_RUOLI_TITOLARI THEN
         p_result := RET_ERR_CNTL;
         p_msg    := fncMessaggioErrore(352);
         p_id_err := 352;

      WHEN OTHERS THEN
         p_result := RET_ERR;
         p_msg    := fncMessaggioErrore(1) || ' [RIC09] ' || SQLERRM;
         p_id_err := 1;

END RIC09;


PROCEDURE RIC10(p_id_persona DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE, p_eta_min IN INTEGER, p_eta_max IN INTEGER, p_result OUT VARCHAR2, p_msg OUT VARCHAR2, p_id_err OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Verifica che l'età della persona fisica passata come parametro in ingresso,
  -- sia incluso all'interno dell'intervallo specificato, estremi compresi.
  --
  -- Parameters:
  -- p_id_persona :  identificativo della persona fisica in esame
  -- p_eta_min    :  soglia di età minima  dell'intervallo
  -- p_eta_max    :  soglia di età massima dell'intervallo
  -- p_result :     risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err:           identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------

   vDataNascita        DB_PERSONA_FISICA.NASCITA_DATA%TYPE;
   vDataOggi           NUMBER(8);
   vDataMin            NUMBER(8);
   vDataMax            NUMBER(8);
   vMeseGiorno         NUMBER(4);
   vAnno               NUMBER(4);

   nId_ruolo_titolare  CONSTANT INTEGER := 1;

   ERR_ETA_RICHIEDENTE EXCEPTION;
   ERR_DATI            EXCEPTION;
   ERR_PARAM           EXCEPTION;

BEGIN

   -- verifica la correttezza dei parametri: l'età minima e massima sono espresse in anno mese (AAMM)
   -- In questo caso il valore minimo non può eguagliare o superare quello massimo
   --
   IF p_eta_min >= p_eta_max THEN
      RAISE ERR_PARAM;

   END IF;

   --
   -- Legge la data del giorno
   --

   BEGIN
      SELECT TO_NUMBER(TO_CHAR(SYSDATE, 'yyyymmdd'))
      INTO vDataOggi FROM dual;
   EXCEPTION
      WHEN OTHERS THEN
            RAISE ERR_DATI;
   END;

   --
   -- Estrae le informazioni del richiedente da db_persona_fisica
   --
   BEGIN
/*      select nascita_data
      into vDataNascita
      from db_persona_fisica
      where id_persona_fisica = p_id_persona; */
       SELECT
       TO_NUMBER(TO_CHAR(nascita_data, 'yyyymmdd')) + (p_eta_min*100),
       TO_NUMBER(TO_CHAR(nascita_data, 'yyyymmdd')) + (p_eta_max*100)
       INTO vDataMin, vDataMax
       FROM DB_PERSONA_FISICA
       WHERE id_persona_fisica = p_id_persona;
   EXCEPTION
         WHEN NO_DATA_FOUND THEN
         -- Se il soggetto non esiste su db_persona_fisica, viene
         -- cercato su db_persona_fisica_comune
         --
         BEGIN
/*            select nascita_data
            into vDataNascita
            from db_persona_fisica_comune
            where id_persona_fisica_comune = p_id_persona; */
       SELECT
       TO_NUMBER(TO_CHAR(nascita_data, 'yyyymmdd')) + (p_eta_min*100),
       TO_NUMBER(TO_CHAR(nascita_data, 'yyyymmdd')) + (p_eta_max*100)
       INTO vDataMin, vDataMax
       FROM DB_PERSONA_FISICA_COMUNE
       WHERE id_persona_fisica_comune = p_id_persona;
       EXCEPTION
            WHEN OTHERS THEN
               RAISE ERR_DATI;
       END;

         WHEN OTHERS THEN
            RAISE ERR_DATI;
   END;

   -- Verifica congruenza dei dati
   --
   IF vDataMin IS NULL THEN
      RAISE ERR_DATI;
   END IF;

   vMeseGiorno := TO_NUMBER(SUBSTR(TO_CHAR(vDataMin), 5, 4));
   IF vMeseGiorno > 1231 THEN
      vDataMin := vDataMin + 8800;
   END IF;
   -- verifico se il giorno è 31 e cade in un mese di 30 giorni
   vMeseGiorno := TO_NUMBER(SUBSTR(TO_CHAR(vDataMin), 5, 4));
   IF vMeseGiorno IN (0431, 0631, 0931, 1131) THEN
      vDataMin := vDataMin - 1;
   END IF;
   -- verifico se il giorno è maggiore di 28 ed è febbraio
   IF vMeseGiorno IN (0229, 0230, 0231) THEN
      vAnno := TO_NUMBER(SUBSTR(TO_CHAR(vDataMin), 1, 4));
      IF MOD(vAnno,4) = 0 THEN
         vDataMin := (vAnno * 10000) + 229;
      ELSE
         vDataMin := (vAnno * 10000) + 228;
      END IF;
   END IF;

   vMeseGiorno := TO_NUMBER(SUBSTR(TO_CHAR(vDataMax), 5, 4));
   IF vMeseGiorno > 1231 THEN
      vDataMax := vDataMax + 8800;
   END IF;
   -- verifico se il giorno è 31 e cade in un mese di 30 giorni
   vMeseGiorno := TO_NUMBER(SUBSTR(TO_CHAR(vDataMax), 5, 4));
   IF vMeseGiorno IN (0431, 0631, 0931, 1131) THEN
      vDataMax := vDataMax - 1;
   END IF;
   -- verifico se il giorno è maggiore di 28 ed è febbraio
   IF vMeseGiorno IN (0229, 0230, 0231) THEN
      vAnno := TO_NUMBER(SUBSTR(TO_CHAR(vDataMax), 1, 4));
      IF MOD(vAnno,4) = 0 THEN
         vDataMax := (vAnno * 10000) + 229;
      ELSE
         vDataMax := (vAnno * 10000) + 228;
      END IF;
   END IF;

   -- Verifica se l'età del rapp. legale rientra nell'intervallo predefinito
   --
   --
   IF vDataOggi NOT BETWEEN vDataMin AND vDataMax THEN
      RAISE ERR_ETA_RICHIEDENTE;

   END IF;

   p_result := RET_OK;
   p_msg    := 'L''età del rappresentante legale è adeguata';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_PARAM THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(360);
      p_id_err := 360;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(361);
      p_id_err := 361;

   WHEN ERR_ETA_RICHIEDENTE THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(362);
      p_id_err := 362;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [RIC10] ' || SQLERRM;
      p_id_err := 1;

END RIC10;


PROCEDURE RIC11(p_id_persona DB_PERSONA_FISICA.ID_PERSONA_FISICA%TYPE, p_eta_min IN INTEGER, p_eta_max IN INTEGER, p_result OUT VARCHAR2, p_msg OUT VARCHAR2, p_id_err OUT NUMBER) IS
  ----------------------------------------------------------------------
  ----------------------------------------------------------------------
  -- Purpose :
  -- Verifica che l'età della persona fisica passata come parametro in ingresso,
  -- sia incluso all'interno dell'intervallo specificato, estremi compresi.
  -- Uguale al controllo RIC10 con la differenza che in questo caso si potrà specificare
  -- solo il limite inferiore per esempio per il controllo della maggiore età
  --
  -- Parameters:
  -- p_id_persona :  identificativo della persona fisica in esame
  -- p_eta_min    :  soglia di età minima  dell'intervallo
  -- p_eta_max    :  soglia di età massima dell'intervallo
  -- p_result :     risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err:           identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------

   vDataNascita        DB_PERSONA_FISICA.NASCITA_DATA%TYPE;
   vDataOggi           NUMBER(8);
   vDataMin            NUMBER(8);
   vDataMax            NUMBER(8);
   vMeseGiorno         NUMBER(4);
   vAnno               NUMBER(4);

   nId_ruolo_titolare  CONSTANT INTEGER := 1;

   ERR_ETA_RICHIEDENTE EXCEPTION;
   ERR_DATI            EXCEPTION;
   ERR_PARAM           EXCEPTION;

BEGIN

   -- verifica la correttezza dei parametri: l'età minima e massima sono espresse in anno mese (AAMM)
   -- In questo caso il valore minimo non può eguagliare o superare quello massimo
   --
   IF p_eta_min >= p_eta_max THEN
      RAISE ERR_PARAM;

   END IF;

   --
   -- Legge la data del giorno
   --

   BEGIN
      SELECT TO_NUMBER(TO_CHAR(SYSDATE, 'yyyymmdd'))
      INTO vDataOggi FROM dual;
   EXCEPTION
      WHEN OTHERS THEN
            RAISE ERR_DATI;
   END;

   --
   -- Estrae le informazioni del richiedente da db_persona_fisica
   --
   BEGIN
/*      select nascita_data
      into vDataNascita
      from db_persona_fisica
      where id_persona_fisica = p_id_persona; */
       SELECT
       TO_NUMBER(TO_CHAR(nascita_data, 'yyyymmdd')) + (p_eta_min*100),
       TO_NUMBER(TO_CHAR(nascita_data, 'yyyymmdd')) + (p_eta_max*100)
       INTO vDataMin, vDataMax
       FROM DB_PERSONA_FISICA
       WHERE id_persona_fisica = p_id_persona;
   EXCEPTION
         WHEN NO_DATA_FOUND THEN
         -- Se il soggetto non esiste su db_persona_fisica, viene
         -- cercato su db_persona_fisica_comune
         --
         BEGIN
/*            select nascita_data
            into vDataNascita
            from db_persona_fisica_comune
            where id_persona_fisica_comune = p_id_persona; */
       SELECT
       TO_NUMBER(TO_CHAR(nascita_data, 'yyyymmdd')) + (p_eta_min*100),
       TO_NUMBER(TO_CHAR(nascita_data, 'yyyymmdd')) + (p_eta_max*100)
       INTO vDataMin, vDataMax
       FROM DB_PERSONA_FISICA_COMUNE
       WHERE id_persona_fisica_comune = p_id_persona;
       EXCEPTION
            WHEN OTHERS THEN
               RAISE ERR_DATI;
       END;

         WHEN OTHERS THEN
            RAISE ERR_DATI;
   END;

   -- Verifica congruenza dei dati
   --
   IF vDataMin IS NULL THEN
      RAISE ERR_DATI;
   END IF;

   vMeseGiorno := TO_NUMBER(SUBSTR(TO_CHAR(vDataMin), 5, 4));
   IF vMeseGiorno > 1231 THEN
      vDataMin := vDataMin + 8800;
   END IF;
   -- verifico se il giorno è 31 e cade in un mese di 30 giorni
   vMeseGiorno := TO_NUMBER(SUBSTR(TO_CHAR(vDataMin), 5, 4));
   IF vMeseGiorno IN (0431, 0631, 0931, 1131) THEN
      vDataMin := vDataMin - 1;
   END IF;
   -- verifico se il giorno è maggiore di 28 ed è febbraio
   IF vMeseGiorno IN (0229, 0230, 0231) THEN
      vAnno := TO_NUMBER(SUBSTR(TO_CHAR(vDataMin), 1, 4));
      IF MOD(vAnno,4) = 0 THEN
         vDataMin := (vAnno * 10000) + 229;
      ELSE
         vDataMin := (vAnno * 10000) + 228;
      END IF;
   END IF;
/*
   vMeseGiorno := to_number(substr(to_char(vDataMax), 5, 4));
   if vMeseGiorno > 1231 then
      vDataMax := vDataMax + 8800;
   end if;
   -- verifico se il giorno è 31 e cade in un mese di 30 giorni
   vMeseGiorno := to_number(substr(to_char(vDataMax), 5, 4));
   if vMeseGiorno in (0431, 0631, 0931, 1131) then
      vDataMax := vDataMax - 1;
   end if;
   -- verifico se il giorno è maggiore di 28 ed è febbraio
   if vMeseGiorno in (0229, 0230, 0231) then
      vAnno := to_number(substr(to_char(vDataMax), 1, 4));
      if mod(vAnno,4) = 0 then
         vDataMax := (vAnno * 10000) + 229;
      else
         vDataMax := (vAnno * 10000) + 228;
      end if;
   end if;
*/
   -- Verifica se l'età del rapp. legale rientra nell'intervallo predefinito
   --
   --
   IF vDataOggi < vDataMin THEN
      RAISE ERR_ETA_RICHIEDENTE;

   END IF;

   p_result := RET_OK;
   p_msg    := 'L''età del rappresentante legale è adeguata';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_PARAM THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(360);
      p_id_err := 360;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(361);
      p_id_err := 361;

   WHEN ERR_ETA_RICHIEDENTE THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(953);
      p_id_err := 953;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [RIC11] ' || SQLERRM;
      p_id_err := 1;

END RIC11;

PROCEDURE RIC12(p_id_soggetto   IN  DB_PERSONA_FISICA.ID_SOGGETTO%TYPE,
                  p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg             OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS
  ----------------------------------------------------------------------
  -- Verifica che il soggetto ricHiedente di una misura o PAC sia
  -- il titolare dell'azienda
  --
  -- Parameters:
  -- p_id_richiedente: identificativo della persona fisica
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result    : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg       : messaggio di errore se la procedura non termina correttamente
  -- p_id_err    : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------
   nId_ruolo_titolare   CONSTANT INTEGER := 1;
   vIdSoggetto          DB_CONTITOLARE.id_soggetto%TYPE;
   nCnt                 INTEGER;
   vDataInizioRuolo     DB_CONTITOLARE.data_inizio_ruolo%TYPE;

   ERR_NO_TITOLARE       EXCEPTION;
   ERR_DATI              EXCEPTION;

BEGIN
   BEGIN
      -- Preleva il soggetto titolare dell'azienda
      --
      SELECT COUNT(*)
      INTO nCnt
      FROM DB_CONTITOLARE a
      WHERE a.ID_SOGGETTO = p_id_soggetto
      AND a.id_azienda = p_id_azienda
      AND a.ID_RUOLO = nId_ruolo_titolare
      AND a.data_fine_ruolo IS NULL;

   EXCEPTION
     WHEN OTHERS THEN
        RAISE ERR_DATI;
   END;

   IF nCnt = 0 THEN
      RAISE ERR_NO_TITOLARE;
   END IF;

   -- Termina con esito positivo
   --
   p_result := RET_OK;
   p_msg    := '[RIC12] Il richiedente coincide con il titolare';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_NO_TITOLARE THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(1046);
      p_id_err := 1046;

   WHEN ERR_DATI THEN
      p_result := RET_ERR_PROC;
      p_msg    := fncMessaggioErrore(1) || ' [RIC12] ' || SQLERRM;
      p_id_err := 1;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [RIC12] ' || SQLERRM;
      p_id_err := 1;

END RIC12;


PROCEDURE UTE01(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Verifica che esistano UTE collegate all'azienda passata come parametro in ingresso,
  -- cioé che esista almeno un'unità produttiva collegata all'azienda in esame.
  --
  -- Parameters:
  -- p_id_aziend  :  identificativo dell'azienda in esame
  -- p_result     :  risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg        :  messaggio di errore se la procedura non termina correttamente
  -- p_id_err     :  identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------

  nUTE INTEGER;
  ERR_NO_UTE EXCEPTION;

BEGIN

   SELECT COUNT(1) INTO nUTE
   FROM DB_UTE
   WHERE id_azienda = p_id_azienda
   AND data_fine_attivita IS NULL;

   IF nUTE = 0 THEN
      RAISE ERR_NO_UTE;

   END IF;

   p_result := RET_OK;
   p_msg    := 'Esistono unità produttive collegate all''azienda';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_NO_UTE THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(370);
      p_id_err := 370;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [UTE01] ' || SQLERRM;
      p_id_err := 1;


END UTE01;


PROCEDURE UTE02(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_comune        IN  COMUNE.istat_comune%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Verifica che esistano UTE collegate all'azienda passata come parametro in p_id_azienda
  -- nel comune specificato da p_comune
  --
  -- Parameters:
  -- p_id_aziend  :  identificativo dell'azienda in esame
  -- p_comune     :  codice istat del comune in esame
  -- p_result     :  risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg        :  messaggio di errore se la procedura non termina correttamente
  -- p_id_err     :  identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------

  nUTE INTEGER;
  ERR_NO_UTE EXCEPTION;

BEGIN

   SELECT COUNT(1) INTO nUTE
   FROM DB_UTE
   WHERE id_azienda = p_id_azienda
   AND COMUNE = p_comune;

   IF nUTE = 0 THEN
      RAISE ERR_NO_UTE;

   END IF;

   p_result := RET_OK;
   p_msg    := 'Esistono unità produttive collegate all''azienda nel comune specificato';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_NO_UTE THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(380);
      p_id_err := 380;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [UTE02] ' || SQLERRM;
      p_id_err := 1;


END UTE02;


PROCEDURE UTE03(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS
    ----------------------------------------------------------------------
  -- Verifica che siano valorizzati i campi indirizzo comune cap
  -- delle unità produttive collegate all'azienda in esame.
  --
  -- Parameters:
  -- p_id_aziend  :  identificativo dell'azienda in esame
  -- p_result     :  risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg        :  messaggio di errore se la procedura non termina correttamente
  -- p_id_err     :  identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------

  nUTE INTEGER;
  ERR_NO_UTE                       EXCEPTION;
  ERR_NO_DATI                     EXCEPTION;
  ERR_COMUNE_ESTINTO            EXCEPTION;
  ERR_STATO_ESTINTO                EXCEPTION;

  CURSOR c1 IS
   SELECT A.indirizzo, A.COMUNE, A.cap, B.FLAG_ESTINTO, B.FLAG_ESTERO
   FROM DB_UTE A, COMUNE B
   WHERE id_azienda = p_id_azienda
   AND A.COMUNE=B.ISTAT_COMUNE;


BEGIN
   -- Verifica che esistano UTE per l'azienda in esame
   SELECT COUNT(1) INTO nUTE
   FROM DB_UTE
   WHERE id_azienda = p_id_azienda
   AND   DATA_FINE_ATTIVITA IS NULL;

   IF nUTE = 0 THEN
      RAISE ERR_NO_UTE;

   END IF;

   -- Scandisce le ute collegate all'azienda (N.B.: COMUNE ora è NOT NULL)
   --
   FOR c1_ IN c1 LOOP

      IF trim(c1_.indirizzo) IS NULL OR trim(c1_.COMUNE) IS NULL OR trim(c1_.cap) IS NULL THEN
        RAISE ERR_NO_DATI;

      -- residenza all'estero
      IF NVL(c1_.Flag_Estero,'N') = 'S' THEN

         /* verifico che il comune non sia estinto */
         IF c1_.Flag_Estinto='S' THEN
             RAISE ERR_COMUNE_ESTINTO;
         END IF;

      ELSE
      -- residenza in Italia

         /* verifico che lo stato estero non sia estinto */
         IF c1_.Flag_Estinto='S' THEN
             RAISE ERR_STATO_ESTINTO;
         END IF;


      END IF;

     END IF;

   END LOOP;

   p_result := RET_OK;
   p_msg    := 'I dati di indirizzo delle unità produttive collegate all''azienda sono completi';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_NO_UTE THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(390);
      p_id_err := 390;

   WHEN ERR_NO_DATI THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(391);
      p_id_err := 391;

   WHEN ERR_COMUNE_ESTINTO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(392); -- [UTE03] Comune dell'unità produttiva estinto
      p_id_err := 392;

   WHEN ERR_STATO_ESTINTO THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(393); -- [UTE03] Stato estero dell'unità produttiva estinto
      p_id_err := 393;


   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [UTE03] ' || SQLERRM;
      p_id_err := 1;


END UTE03;


PROCEDURE UTE04(p_id_azienda    IN  DB_AZIENDA.id_azienda%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Verifica che siano valorizzati i campi telefono e fax
  -- per il record di DB_UTE collegato all'azienda
  --
  -- Parameters:
  -- p_id_aziend  :  identificativo dell'azienda in esame
  -- p_result     :  risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg        :  messaggio di errore se la procedura non termina correttamente
  -- p_id_err     :  identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  ----------------------------------------------------------------------

  nUTE INTEGER;
  ERR_NO_UTE  EXCEPTION;
  ERR_NO_DATI EXCEPTION;

  CURSOR c1 IS
   SELECT telefono, fax
   FROM DB_UTE
   WHERE id_azienda = p_id_azienda;


BEGIN
   -- Verifica che esistano UTE per l'azienda in esame
   --
   SELECT COUNT(1) INTO nUTE
   FROM DB_UTE
   WHERE id_azienda = p_id_azienda;

   IF nUTE = 0 THEN
      RAISE ERR_NO_UTE;

   END IF;

   -- Scandisce le ute collegate all'azienda
   --
   FOR c1_ IN c1 LOOP

     IF trim(c1_.telefono) IS NULL OR trim(c1_.fax) IS NULL THEN
        RAISE ERR_NO_DATI;

     END IF;

   END LOOP;

   p_result := RET_OK;
   p_msg    := 'I dati dei riferimenti telefonici e fax dell''unità produttiva sono completi ';
   p_id_err := NULL;

EXCEPTION
   WHEN ERR_NO_UTE THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(400);
      p_id_err := 400;

   WHEN ERR_NO_DATI THEN
      p_result := RET_ERR_CNTL;
      p_msg    := fncMessaggioErrore(401);
      p_id_err := 401;

   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [UTE04] ' || SQLERRM;
      p_id_err := 1;


END UTE04;

/*********************************************************************
Data un'unità arborea dichiarata controllo che essa sia stata validata
Tipo: Procedure
input: pIdUnitaArbDich
output: p_Result, p_Msg, p_Id_Err
ritorno: nessuno
*********************************************************************/
PROCEDURE UVC01(pIdUnitaArbDich IN DB_UNITA_ARBOREA_DICHIARATA.ID_UNITA_ARBOREA_DICHIARATA%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS
    recTUnitaArboreaDichiarata DB_UNITA_ARBOREA_DICHIARATA%ROWTYPE;

BEGIN
    -- cerco l'unità arborea
    recTUnitaArboreaDichiarata := SelTUnitaArboreaDichById (pIdUnitaArbDich);
    -- se la trovo
    IF recTUnitaArboreaDichiarata.ID_UNITA_ARBOREA_DICHIARATA IS NOT NULL THEN
       -- controllo che sia stata validata
       IF recTUnitaArboreaDichiarata.STATO_UNITA_ARBOREA = 'V' THEN
          p_result := RET_OK;
          p_msg    := '';
          p_id_err := NULL;
       ELSE
          -- altrimenti do apposita anomalia
          p_result := RET_ERR_PROC;
          p_msg    := fncMessaggioErrore(2955);
          p_id_err := 2955;
       END IF;
    ELSE
       -- se non c'era proprio do ancora un'altra anomalia specifica
       p_result := RET_ERR_PROC;
       p_msg    := fncMessaggioErrore(2956);
       p_id_err := 2956;
    END IF;

EXCEPTION
   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [UVC01] ' || SQLERRM;
      p_id_err := 1;
END UVC01;

/*********************************************************************
Verifica che l'azienda abbia eseguito la compensazione aziendale
delle UV oppure il consolidamento delle UV
(a seconda del parametro pTipoCtrl, valore possibili TUTTI, COMP, CONS  )
in caso contrario segnalare l'anomalia :
Tipo: Procedure
input: pIdAzienda, pTipoCtrl
output: p_Result, p_Msg, p_Id_Err
ritorno: nessuno
*********************************************************************/
PROCEDURE UVR25(pIdAzienda  IN DB_COMPENSAZIONE_AZIENDA.ID_AZIENDA%TYPE,
                pTipoCtrl   IN VARCHAR2,
                p_result   OUT VARCHAR2,
                p_msg      OUT VARCHAR2,
                p_id_err   OUT NUMBER) IS

    kvCodControllo  CONSTANT DB_TIPO_CONTROLLO.CODICE_CONTROLLO%TYPE:= 'UVR25';
    recTCompensazioneAzienda DB_COMPENSAZIONE_AZIENDA%ROWTYPE;
    bDataCompKo              BOOLEAN:=FALSE;
    bDataConsKo              BOOLEAN:=FALSE;

BEGIN

    recTCompensazioneAzienda := SelTCompAziendaByIdAzienda(pIdAzienda);

    IF recTCompensazioneAzienda.DATA_COMPENSAZIONE IS NULL THEN
       bDataCompKo := TRUE;
    END IF;

    IF recTCompensazioneAzienda.DATA_CONSOLIDAMENTO_GIS IS NULL THEN
       bDataConsKo := TRUE;
    END IF;

    IF pTipoCtrl = 'TUTTI' THEN
       IF bDataCompKo AND bDataConsKo THEN
          p_id_err := 3429;
       ELSE
          IF bDataCompKo THEN
             p_id_err := 3430;
          END IF;
          IF bDataConsKo THEN
             p_id_err := 3431;
          END IF;
       END IF;
    ELSIF pTipoCtrl = 'COMP' THEN
       IF bDataCompKo THEN
          p_id_err := 3430;
       END IF;
    ELSIF pTipoCtrl = 'CONS' THEN
       IF bDataConsKo THEN
          p_id_err := 3431;
       END IF;
    ELSE
       p_id_err := 3432;
    END IF;

    IF p_id_err IS NOT NULL THEN
       p_result := RET_ERR_PROC;
       p_msg    := fncMessaggioErrore(p_id_err);
    ELSE
       p_result := RET_OK;
       p_msg    := '';
       p_id_err := NULL;
    END IF;

EXCEPTION
   WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [' || kvCodControllo || '] ' || SQLERRM;
      p_id_err := 1;
END UVR25;

  ----------------------------------------------------------------------
  ----------------------------------------------------------------------
  -- Verifica Azienda Giovani.
  -- Verrà controllato che l'azienda abbia l'informazione di "Azienda Provvisoria" oopure
  -- ci sia almeno un giovane tra i contitolari (ruolo = 10)
  --
  -- Parameters:
  -- p_id_aziend  :  identificativo dell'azienda in esame
  -- p_result     :  risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg        :  messaggio di errore se la procedura non termina correttamente
  -- p_id_err     :  identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE

PROCEDURE GIO01(p_id_azienda IN  DB_AZIENDA.id_azienda%TYPE,
               p_result     OUT VARCHAR2,
               p_msg        OUT VARCHAR2,
               p_id_err     OUT NUMBER) IS

 nIdAzienda            DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE;
 sFlagProvvisoria      DB_AZIENDA.FLAG_AZIENDA_PROVVISORIA%TYPE;
 n_giovani              NUMBER;

 ERR_NO_DIC_CONSISTENZA EXCEPTION;
 ERR_DIC_CONSISTENZA    EXCEPTION;
 ERR_DATI               EXCEPTION;

BEGIN

    /* Verifico il FlagAziendaProvvisorio sull'azienda */
    SELECT FLAG_AZIENDA_PROVVISORIA
    INTO sFlagProvvisoria
    FROM SMRGAA.DB_AZIENDA
    WHERE ID_AZIENDA=P_ID_AZIENDA;

    IF sFlagProvvisoria = 'S' THEN
       p_result := RET_OK;
       p_msg    := '';
       p_id_err := NULL;
    ELSE
        SELECT COUNT(1) INTO n_giovani
        FROM SMRGAA.DB_CONTITOLARE
        WHERE ID_AZIENDA=P_ID_AZIENDA AND ID_RUOLO = 10 AND DATA_FINE_RUOLO IS NULL;

        IF n_giovani = 0 THEN
            p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(942);
            p_id_err := 942;
        ELSE
               p_result := RET_OK;
            p_msg    := '';
               p_id_err := NULL;
        END IF;
    END IF;

EXCEPTION

    WHEN OTHERS THEN
       p_result := RET_ERR;
       p_msg    := fncMessaggioErrore(1) || ' [GIO01] ' || SQLERRM;
       p_id_err := 1;

END GIO01;


  ----------------------------------------------------------------------
  ----------------------------------------------------------------------
  -- Verifica Insediamento Giovani
  -- Verrà controllato che l'azienda NON sia più Provvisoria a seguito della richeista di insediamento
  -- Parameters:
  -- p_id_aziend  :  identificativo dell'azienda in esame
  -- p_result     :  risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg        :  messaggio di errore se la procedura non termina correttamente
  -- p_id_err     :  identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE

PROCEDURE ANA16(p_id_azienda IN  DB_AZIENDA.id_azienda%TYPE,
               p_result     OUT VARCHAR2,
               p_msg        OUT VARCHAR2,
               p_id_err     OUT NUMBER) IS


 sFlagProvvisoria      DB_AZIENDA.FLAG_AZIENDA_PROVVISORIA%TYPE;
 DataInsediamento      DB_AZIENDA.DATA_INSEDIAMENTO%TYPE;


BEGIN

    /* Verifico il FlagAziendaProvvisorio sull'azienda */
    SELECT FLAG_AZIENDA_PROVVISORIA
    INTO sFlagProvvisoria
    FROM SMRGAA.DB_AZIENDA
    WHERE ID_AZIENDA=P_ID_AZIENDA;

    IF sFlagProvvisoria = 'S'  THEN
        p_result := RET_ERR_CNTL;
        p_msg    := fncMessaggioErrore(1031);
        p_id_err := 1031;
    ELSE
        p_result := RET_OK;
        p_msg    := '';
        p_id_err := NULL;
    END IF;

EXCEPTION

    WHEN OTHERS THEN
       p_result := RET_ERR;
       p_msg    := fncMessaggioErrore(1) || ' [ANA16] ' || SQLERRM;
       p_id_err := 1;

END ANA16;




PROCEDURE AEP01(p_cuaa DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS


     vFlagPresenzaAAEP DB_AZIENDA_AAEP.FLAG_PRESENTE_IN_AAEP%TYPE;


  BEGIN

      SELECT FLAG_PRESENTE_IN_AAEP
      INTO vFlagPresenzaAAEP
      FROM DB_AZIENDA_AAEP
      WHERE CUAA = p_cuaa;

      IF ( vFlagPresenzaAAEP = 'S' ) THEN

         p_result := RET_OK;
            p_msg    := 'Azienda presente in AAEP';
            p_id_err := NULL;

      ELSE
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(991);
            p_id_err := 991;

      END IF;

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(990);
            p_id_err := 990;
    WHEN TOO_MANY_ROWS THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(990);
            p_id_err := 990;
    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [AEP01] ' || SQLERRM;
      p_id_err  := 1;

--
END AEP01;



----------------------------------------------------------------------
  -- Author  : Luisa Abbona
  -- Created :04/05/2005 10.26
  ----------------------------------------------------------------------
  -- Purpose :
  -- Controllo presenza in AAEP
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------
PROCEDURE AEP02(p_cuaa DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS


     vDataCessazione DB_AZIENDA_AAEP.DATA_CESSAZIONE%TYPE;
     vCausaleCessazione DB_AZIENDA_AAEP.DESCRIZIONE_CAUSALE_CESSAZIONE%TYPE;
     vFlagPresenzaAAEP DB_AZIENDA_AAEP.FLAG_PRESENTE_IN_AAEP%TYPE;


  BEGIN

      SELECT FLAG_PRESENTE_IN_AAEP,data_cessazione, DESCRIZIONE_causale_cessazione
      INTO vFlagPresenzaAAEP, vDataCessazione, vCausaleCessazione
      FROM DB_AZIENDA_AAEP
      WHERE CUAA = p_cuaa;

      IF (vFlagPresenzaAAEP ='S') THEN
          IF ( vDataCessazione IS NULL ) THEN

             p_result := RET_OK;
                p_msg    := 'Azienda attiva in AAEP';
                p_id_err := NULL;

          ELSE
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(992) ||' in data '||TO_CHAR(vDataCessazione,'dd/mm/yyyy') ||' '||vCausaleCessazione;
                p_id_err := 992;

          END IF;
      ELSE
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(991);
            p_id_err := 991;
      END IF;

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(990);
            p_id_err := 990;
    WHEN TOO_MANY_ROWS THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(990);
            p_id_err := 990;
    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [AEP02] ' || SQLERRM;
      p_id_err  := 1;

--
END AEP02;


PROCEDURE AEP03(p_id_azienda DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                  p_cuaa DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS


     vdenominazioneAAEP DB_AZIENDA_AAEP.denominazione%TYPE;
     vdenominazione DB_ANAGRAFICA_AZIENDA.denominazione%TYPE;
     vFlagPresenzaAAEP DB_AZIENDA_AAEP.FLAG_PRESENTE_IN_AAEP%TYPE;


  BEGIN

      SELECT FLAG_PRESENTE_IN_AAEP,UPPER(denominazione)
      INTO vFlagPresenzaAAEP, vdenominazioneAAEP
      FROM DB_AZIENDA_AAEP
      WHERE CUAA = p_cuaa;

      IF vFlagPresenzaAAEP ='S' THEN
          SELECT UPPER(denominazione)
          INTO vdenominazione
          FROM DB_ANAGRAFICA_AZIENDA
          WHERE ID_AZIENDA = p_id_azienda AND DATA_FINE_VALIDITA IS NULL;

          IF ( vdenominazioneAAEP IS NULL OR vdenominazioneAAEP ='') THEN

             p_result := RET_OK;
                p_msg    := 'Denominazione non valorizzata in AAEP';
                p_id_err := NULL;

          ELSIF ( SUBSTR(vdenominazioneAAEP,1,120) = vdenominazione) THEN

             p_result := RET_OK;
                p_msg    := 'Denominazione in anagrafe congruente a quella di AAEP';
                p_id_err := NULL;
          ELSE
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(993) ||': '||vdenominazioneAAEP;
                p_id_err := 993;

          END IF;
      ELSE
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(991);
            p_id_err := 991;
      END IF;

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(990);
            p_id_err := 990;
    WHEN TOO_MANY_ROWS THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(990);
            p_id_err := 990;
    WHEN OTHERS THEN
         p_result  := RET_ERR;
         p_msg     := fncMessaggioErrore(1) || ' [AEP03] ' || SQLERRM;
         p_id_err  := 1;
END AEP03;

PROCEDURE AEP05(p_id_azienda DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                  p_cuaa DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS


     vpivaAAEP DB_AZIENDA_AAEP.partita_iva%TYPE;
     vpiva DB_ANAGRAFICA_AZIENDA.partita_iva%TYPE;
     vFlagPresenzaAAEP DB_AZIENDA_AAEP.FLAG_PRESENTE_IN_AAEP%TYPE;


  BEGIN

      SELECT FLAG_PRESENTE_IN_AAEP, partita_iva
            INTO vFlagPresenzaAAEP, vpivaAAEP
      FROM DB_AZIENDA_AAEP
      WHERE CUAA = p_cuaa;

      IF vFlagPresenzaAAEP='S' THEN
          SELECT partita_iva
          INTO vpiva
          FROM DB_ANAGRAFICA_AZIENDA
          WHERE ID_AZIENDA = p_id_azienda AND DATA_FINE_VALIDITA IS NULL;

          IF ( vpivaAAEP IS NULL) THEN

             p_result := RET_OK;
                p_msg    := 'Partita iva non valorizzata in AAEP';
                p_id_err := NULL;

          ELSIF ( vpivaAAEP <> vpiva) THEN

             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(995) ||': '||vpivaAAEP;
                p_id_err := 995;

          ELSE

             p_result := RET_OK;
                p_msg    := 'Partita iva coerente a quella di AAEP';
                p_id_err := NULL;
          END IF;
      ELSE
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(991);
            p_id_err := 991;
      END IF;

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(990);
            p_id_err := 990;
    WHEN TOO_MANY_ROWS THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(990);
            p_id_err := 990;
    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [AEP05] ' || SQLERRM;
      p_id_err  := 1;

--
END AEP05;

PROCEDURE AEP04(p_id_azienda DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                  p_cuaa DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS


     vFgAAEP DB_ANAGRAFICA_AZIENDA.ID_FORMA_GIURIDICA%TYPE;
     vFG DB_ANAGRAFICA_AZIENDA.ID_FORMA_GIURIDICA%TYPE;
     vDescrFGAAEP VARCHAR2(500);
     vFlagPresenzaAAEP DB_AZIENDA_AAEP.FLAG_PRESENTE_IN_AAEP%TYPE;


  BEGIN

      SELECT FLAG_PRESENTE_IN_AAEP
      INTO vFlagPresenzaAAEP
      FROM DB_AZIENDA_AAEP
      WHERE CUAA = p_cuaa;

      IF ( vFlagPresenzaAAEP = 'S' ) THEN

         BEGIN
              SELECT FLAG_PRESENTE_IN_AAEP, c.DESCRIZIONE, B.ID_FORMA_GIURIDICA_GAA
                    INTO vFlagPresenzaAAEP, vdescrfgaaep, vfgaaep
              FROM DB_AZIENDA_AAEP A, DB_TIPO_FG_AAEP_GAA B, DB_TIPO_FORMA_GIURIDICA C
              WHERE A.CUAA = P_CUAA AND B.CODICE_AAEP=A.ID_NATURA_GIURIDICA AND B.ID_FORMA_GIURIDICA_GAA=C.ID_FORMA_GIURIDICA;
          EXCEPTION
              WHEN NO_DATA_FOUND THEN
                   p_result := RET_OK;
                      p_msg    := 'Forma giuridica non valorizzata in AAEP';
                      p_id_err := NULL;
          END;

          SELECT ID_FORMA_GIURIDICA
          INTO vFG
          FROM DB_ANAGRAFICA_AZIENDA
          WHERE ID_AZIENDA = p_id_azienda AND DATA_FINE_VALIDITA IS NULL;

          IF ( vFgAAEP IS NULL) THEN

             p_result := RET_OK;
                p_msg    := 'Forma giuridica non valorizzata in AAEP';
                p_id_err := NULL;

          ELSIF ( vFgAAEP <> vFG) THEN

             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(994) ||': '||vdescrfgaaep;
                p_id_err := 994;
          ELSE
               p_result := RET_OK;
                p_msg    := 'Forma giuridica coerente con quella in AAEP';
                p_id_err := NULL;
          END IF;


      ELSE
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(991);
            p_id_err := 991;

      END IF;


  EXCEPTION
    WHEN NO_DATA_FOUND THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(990);
            p_id_err := 990;
    WHEN TOO_MANY_ROWS THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(990);
            p_id_err := 990;
    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [AEP04] ' || SQLERRM;
      p_id_err  := 1;

--
END AEP04;

PROCEDURE AEP06(p_id_azienda DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                  p_cuaa DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS


     vIstatSedeLegAAEP DB_SEDE_AAEP.COD_COMUNE%TYPE;
     vIstatSedeLeg DB_ANAGRAFICA_AZIENDA.SEDELEG_COMUNE%TYPE;
     vIndirizzoAAEP VARCHAR2(500);
     vFlagPresenzaAAEP DB_AZIENDA_AAEP.FLAG_PRESENTE_IN_AAEP%TYPE;


  BEGIN

     SELECT FLAG_PRESENTE_IN_AAEP
      INTO vFlagPresenzaAAEP
      FROM DB_AZIENDA_AAEP
      WHERE CUAA = p_cuaa;


      IF vFlagPresenzaAAEP='S' THEN
          SELECT S.COD_COMUNE, s.NOME_COMUNE ||' ' ||s.INDIRIZZO_SEDE
              INTO vIstatSedeLegAAEP, vIndirizzoAAEP
            FROM DB_AZIENDA_AAEP A,
                 DB_SEDE_AAEP S
           WHERE A.CUAA = p_cuaa
             AND A.ID_AZIENDA_AAEP = S.ID_AZIENDA_AAEP(+)
             AND S.DATA_FINE_ATTIVITA IS NULL 
             AND S.ID_TIPO_SEDE (+) = 1;      -- aggiunto controllo sulla data di fine attività ed outer join sul tipo sede

          SELECT SEDELEG_COMUNE
              INTO vIstatSedeLeg
              FROM DB_ANAGRAFICA_AZIENDA
              WHERE ID_AZIENDA = p_id_azienda AND DATA_FINE_VALIDITA IS NULL;

          IF ( vIstatSedeLegAAEP IS NULL) THEN

             p_result := RET_OK;
                p_msg    := 'Sede legale non valorizzata in AAEP';
                p_id_err := NULL;

          ELSIF ( vIstatSedeLegAAEP <> vIstatSedeLeg) THEN

             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(996) ||': '||vIndirizzoAAEP;
                p_id_err := 996;

          ELSE
             p_result := RET_OK;
                p_msg    := 'Sede legale coerente con quella in AAEP';
                p_id_err := NULL;
          END IF;
      ELSE
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(991);
            p_id_err := 991;
      END IF;

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(990);
            p_id_err := 990;
    WHEN TOO_MANY_ROWS THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(990);
            p_id_err := 990;
    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [AEP06] ' || SQLERRM;
      p_id_err  := 1;

--
END AEP06;

PROCEDURE AEP07(p_id_azienda DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                  p_cuaa DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS


     vCFAAEP DB_RAPPRESENTANTE_LEGALE_AAEP.CODICE_FISCALE%TYPE;
     vCF DB_PERSONA_FISICA.CODICE_FISCALE%TYPE;
     vNomeAAEP VARCHAR2(500);
     vFlagPresenzaAAEP DB_AZIENDA_AAEP.FLAG_PRESENTE_IN_AAEP%TYPE;


  BEGIN

     SELECT FLAG_PRESENTE_IN_AAEP
      INTO vFlagPresenzaAAEP
      FROM DB_AZIENDA_AAEP
      WHERE CUAA = p_cuaa;

     IF vFlagPresenzaAAEP='S' THEN

             SELECT S.CODICE_FISCALE, s.COGNOME ||' ' ||s.NOME
                INTO vCFAAEP, vNomeAAEP
              FROM DB_AZIENDA_AAEP A, DB_RAPPRESENTANTE_LEGALE_AAEP S
             WHERE A.CUAA = p_cuaa AND S.ID_AZIENDA_AAEP (+)= A.ID_AZIENDA_AAEP;

             BEGIN

                  SELECT codice_fiscale
                  INTO vCF
                  FROM DB_ANAGRAFICA_AZIENDA a, DB_CONTITOLARE C, DB_PERSONA_FISICA P
                  WHERE A.ID_AZIENDA = p_id_azienda AND A.DATA_FINE_VALIDITA IS NULL
                          AND C.ID_AZIENDA=A.ID_AZIENDA AND C.ID_RUOLO= 1 AND C.DATA_FINE_RUOLO IS NULL
                        AND C.ID_SOGGETTO=P.ID_SOGGETTO;
             EXCEPTION
              WHEN TOO_MANY_ROWS THEN
                 p_result := RET_ERR_CNTL;
                    p_msg    := fncMessaggioErrore(999);
                    p_id_err := 999;
             END;

              IF ( vCFAAEP IS NULL) THEN

                 p_result := RET_OK;
                    p_msg    := 'Rappresentante legale non valorizzato in AAEP';
                    p_id_err := NULL;

              ELSIF ( vCFAAEP <> vCF) THEN

                 p_result := RET_ERR_CNTL;
                    p_msg    := fncMessaggioErrore(997) ||': '||vNomeAAEP;
                    p_id_err := 997;

              ELSE

                 p_result := RET_OK;
                    p_msg    := 'Codice fiscale rappresentante legale coerente a quello in AAEP';
                    p_id_err := NULL;
              END IF;
      ELSE
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(991);
            p_id_err := 991;
      END IF;

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(990);
            p_id_err := 990;
    WHEN TOO_MANY_ROWS THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(990);
            p_id_err := 990;
    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [AEP07] ' || SQLERRM;
      p_id_err  := 1;

--
END AEP07;

PROCEDURE AEP08(p_id_azienda DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                  p_cuaa DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS


     vProvReaAAEP DB_AZIENDA_AAEP.PROVINCIA_CCIAA%TYPE;
     vNumeroReaAAEP DB_AZIENDA_AAEP.NUMERO_CCIAA%TYPE;
     vAnnoCciaaAAEP DB_AZIENDA_AAEP.ANNO_CCIAA%TYPE;
     vNumeroIscrizioneAAEP DB_AZIENDA_AAEP.NUM_REGISTRO_IMPRESE%TYPE;
     vFlagPresenzaAAEP DB_AZIENDA_AAEP.FLAG_PRESENTE_IN_AAEP%TYPE;

     vProvRea DB_ANAGRAFICA_AZIENDA.CCIAA_PROVINCIA_REA%TYPE;
     vNumeroRea DB_ANAGRAFICA_AZIENDA.CCIAA_NUMERO_REA%TYPE;
     vAnnoCciaa DB_ANAGRAFICA_AZIENDA.CCIAA_ANNO_ISCRIZIONE%TYPE;
     vNumeroIscrizione DB_ANAGRAFICA_AZIENDA.CCIAA_NUMERO_REGISTRO_IMPRESE%TYPE;


  BEGIN

      SELECT FLAG_PRESENTE_IN_AAEP, p.SIGLA_PROVINCIA, NUMERO_CCIAA, ANNO_CCIAA, UPPER(NUM_REGISTRO_IMPRESE)
      INTO vFlagPresenzaAAEP, vProvReaAAEP, vNumeroReaAAEP, vAnnoCciaaAAEP, vNumeroIscrizioneAAEP
      FROM DB_AZIENDA_AAEP a, PROVINCIA p
      WHERE CUAA = p_cuaa AND PROVINCIA_CCIAA=istat_provincia(+);

      IF vFlagPresenzaAAEP='S' THEN

          SELECT UPPER(A.CCIAA_PROVINCIA_REA), A.CCIAA_NUMERO_REA, UPPER(A.CCIAA_NUMERO_REGISTRO_IMPRESE)
          INTO vProvRea, vNumeroRea, vNumeroIscrizione
          FROM DB_ANAGRAFICA_AZIENDA A
          WHERE ID_AZIENDA = p_id_azienda AND DATA_FINE_VALIDITA IS NULL;

          IF ( vProvReaAAEP IS NULL OR vNumeroReaAAEP IS NULL OR vNumeroIscrizioneAAEP IS NULL) THEN

             p_result := RET_OK;
                p_msg    := 'Dati di iscrizione alla CCIAA non valorizzati in AAEP';
                p_id_err := NULL;

          ELSIF ( vProvReaAAEP <> vProvRea OR vNumeroRea <>vNumeroReaAAEP OR vNumeroIscrizione<> vNumeroIscrizioneAAEP) THEN

             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(998) ||': '||vProvReaAAEP ||' - ' || vNumeroReaAAEP || ' - ' ||vNumeroIscrizioneAAEP;
                p_id_err := 998;

          ELSE

             p_result := RET_OK;
                p_msg    := 'Dati di iscrizione a CCIAA congruenti con quelli in AAEP';
                p_id_err := NULL;

          END IF;
      ELSE
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(991);
            p_id_err := 991;
      END IF;

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(990);
            p_id_err := 990;
    WHEN TOO_MANY_ROWS THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(990);
            p_id_err := 990;
    WHEN OTHERS THEN
        p_result  := RET_ERR;
        p_msg     := fncMessaggioErrore(1) || ' [AEP08] ' || SQLERRM;
        p_id_err  := 1;
--
END AEP08;


-- nuova versione del contrllo AEP02
-- che esclude le forme giuridiche esenti
-- e lavora alla data passata in input
PROCEDURE AEP09(pIdAzienda  IN  DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                pDataOffSet IN  DATE,
                p_result    OUT VARCHAR2,
                p_msg       OUT VARCHAR2,
                p_id_err    OUT NUMBER) IS

     nEsente            INTEGER:=0;
     dDataCessazione    DB_AZIENDA_AAEP.DATA_CESSAZIONE%TYPE;
     vCausaleCessazione DB_AZIENDA_AAEP.DESCRIZIONE_CAUSALE_CESSAZIONE%TYPE;
     vFlagPresenzaAAEP  DB_AZIENDA_AAEP.FLAG_PRESENTE_IN_AAEP%TYPE;
     vCuaa              DB_ANAGRAFICA_AZIENDA.CUAA%TYPE;
     vProvPiemontese    VARCHAR2(1);

BEGIN


      SELECT COUNT(DECODE(TFG.FLAG_ESENTE_REGISTRO_IMPRESE,'S',AZ.ID_ANAGRAFICA_AZIENDA)),
             MAX(AZ.CUAA),
             MAX(DECODE(P.ID_REGIONE,'01','S', NULL,'S','N')) AS PROVINCIA_PIEMONTESE 
        INTO nEsente,
             vCuaa,
             vProvPiemontese
        FROM DB_ANAGRAFICA_AZIENDA AZ,
             DB_TIPO_FORMA_GIURIDICA TFG,
             PROVINCIA P
       WHERE AZ.ID_AZIENDA = pIdAzienda
         AND AZ.CCIAA_PROVINCIA_REA = P.SIGLA_PROVINCIA (+)
         AND NVL(pDataOffset,SYSDATE) BETWEEN AZ.DATA_INIZIO_VALIDITA
                                          AND NVL(AZ.DATA_FINE_VALIDITA, TO_DATE('09/09/9999','DD/MM/YYYY'))
         AND AZ.ID_FORMA_GIURIDICA = TFG.ID_FORMA_GIURIDICA;

     -- se provincia piemontese
     -- e non esente
     IF nEsente = 0 AND vProvPiemontese = 'S' THEN

        SELECT FLAG_PRESENTE_IN_AAEP,data_cessazione, DESCRIZIONE_causale_cessazione
          INTO vFlagPresenzaAAEP, dDataCessazione, vCausaleCessazione
          FROM DB_AZIENDA_AAEP
         WHERE CUAA = vCuaa;

          IF (vFlagPresenzaAAEP ='S') THEN
              IF dDataCessazione IS NULL THEN
                 p_result := RET_OK;
                 p_msg    := 'Azienda attiva in AAEP';
                 p_id_err := NULL;
              ELSE
                 IF dDataCessazione < NVL(pDataOffset,TRUNC(SYSDATE)) THEN
                    p_result := RET_ERR_CNTL;
                    p_msg    := fncMessaggioErrore(3698) ||' in data '||TO_CHAR(dDataCessazione,'dd/mm/yyyy') ||' '||vCausaleCessazione;
                    p_id_err := 3698;
                 ELSE
                    p_result := RET_OK;
                    p_msg    := 'Azienda attiva in AAEP alla data ' || TO_CHAR(NVL(pDataOffset,TRUNC(SYSDATE)),'DD/MM/YYYY');
                    p_id_err := NULL;
                 END IF;

              END IF;
          ELSE
              p_result := RET_ERR_CNTL;
              p_msg    := fncMessaggioErrore(991);
              p_id_err := 991;
          END IF;
     ELSE
         p_result := RET_OK;
         p_msg    := 'Azienda esente dall''iscrizione al registro delle imprese';
         p_id_err := NULL;
     END IF;

EXCEPTION
    WHEN NO_DATA_FOUND THEN
         p_result := RET_ERR_CNTL;
         p_msg    := fncMessaggioErrore(990);
         p_id_err := 990;
    WHEN OTHERS THEN
         p_result  := RET_ERR;
         p_msg     := fncMessaggioErrore(1) || ' [AEP09] ' || SQLERRM;
         p_id_err  := 1;
END AEP09;


-- Verifica che li codice ateco dichiarato
-- in anagrafe coincide con quello di AAEP (fonte infocamere)
-- se presente
PROCEDURE AEP10(pIdAzienda   IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                pCuaa        IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result    OUT VARCHAR2,
                p_msg       OUT VARCHAR2,
                p_id_err    OUT NUMBER) IS
    recTAziendaAaep DB_AZIENDA_AAEP%ROWTYPE;
    vCodAtecoGaa    DB_TIPO_ATTIVITA_ATECO.CODICE%TYPE;
    vDescAtecoGaa   DB_TIPO_ATTIVITA_ATECO.DESCRIZIONE%TYPE;
BEGIN

    recTAziendaAaep := SelTAziendaAaepByCuaa (pCuaa);

    IF recTAziendaAaep.FLAG_PRESENTE_IN_AAEP = 'S' AND
       recTAziendaAaep.DATA_CESSAZIONE IS NULL AND 
       recTAziendaAaep.ID_ATECO IS NOT NULL THEN

       SELECT TA.CODICE, TA.DESCRIZIONE
         INTO vCodAtecoGaa, vDescAtecoGaa
         FROM DB_ANAGRAFICA_AZIENDA AZ,
              DB_TIPO_ATTIVITA_ATECO TA
        WHERE AZ.ID_AZIENDA = pIdAzienda
          AND AZ.DATA_FINE_VALIDITA IS NULL
          AND AZ.ID_ATTIVITA_ATECO = TA.ID_ATTIVITA_ATECO (+);

       IF vCodAtecoGaa IS NOT NULL THEN
          IF SUBSTR(vCodAtecoGaa,1,2) <> SUBSTR(recTAziendaAaep.ID_ATECO,1,2) THEN
             p_result := RET_ERR_CNTL;
             p_msg    := 'Codice ATECO azienda (' || vCodAtecoGaa || '-' || vDescAtecoGaa || ' ) diverso da codice ATECO AAEP (' || recTAziendaAaep.ID_ATECO || ' - ' || recTAziendaAaep.DESCRIZIONE_ATECO || ')';
             p_id_err := 3750;
          ELSE
             p_result := RET_OK;
             p_msg    := NULL;
             p_id_err := NULL;
          END IF;
       ELSE
          -- segnalo anche quando su anagrafe non e' valorizzato proprio
          p_result := RET_ERR_CNTL;
          p_msg    := 'Codice ATECO azienda non specificato';
          p_id_err := 3750;
       END IF;
    ELSE
       p_result := RET_OK;
       p_msg    := NULL;
       p_id_err := NULL;
    END IF;

EXCEPTION
    WHEN OTHERS THEN
         p_result  := RET_ERR;
         p_msg     := fncMessaggioErrore(1) || ' [AEP10] ' || SQLERRM;
         p_id_err  := 1;
END AEP10;


-- Verifica se l'azienda è attiva su Fonte Infocamare AAEP e che i codici ateco secondari
-- in anagrafe coincidono con quello di AAEP (fonte infocamere)
PROCEDURE AEP11(pIdAzienda   IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                pCuaa        IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result    OUT VARCHAR2,
                p_msg       OUT VARCHAR2,
                p_id_err    OUT NUMBER) IS

    recTAziendaAaep         DB_AZIENDA_AAEP%ROWTYPE;
    vCodAtecoAAEP           VARCHAR2(500);
    vCodAtecoAnagrafe       VARCHAR2(500);

--Cursore che esegue la FULL join di tutti gli ateco secondari da anagrafe e infocamere
--associandoli per i primi due caratteri dei codici ateco
    CURSOR curCodiciAtecoSec ( nIdAziendaAAep NUMBER) IS
        SELECT AZAS.CODICE COD_ATECO_SEC_ANAG, AZAAEPAS.CODICE COD_ATECO_SEC_AAEP
        FROM
        (
                 SELECT CODICE
                     FROM DB_AZIENDA_ATECO_SEC AAS,
                          DB_TIPO_ATTIVITA_ATECO TAA
                    WHERE AAS.DATA_FINE_VALIDITA IS NULL
                      AND AAS.ID_ATTIVITA_ATECO=TAA.ID_ATTIVITA_ATECO
                       AND AAS.ID_AZIENDA=pIdAzienda
        ) AZAS
        FULL JOIN
        (
                SELECT CODICE
                  FROM DB_AZIENDA_AAEP_ATECO_SEC AAAS,
                       DB_TIPO_ATTIVITA_ATECO TAA
                 WHERE AAAS.DATA_FINE_VALIDITA IS NULL
                   AND AAAS.ID_ATTIVITA_ATECO=TAA.ID_ATTIVITA_ATECO
                   AND AAAS.ID_AZIENDA_AAEP=nIdAziendaAAep
        ) AZAAEPAS
        ON SUBSTR(AZAS.CODICE,1,2)=SUBSTR(AZAAEPAS.CODICE,1,2);

BEGIN

    recTAziendaAaep := SelTAziendaAaepByCuaa(pCuaa);

    IF recTAziendaAaep.FLAG_PRESENTE_IN_AAEP = 'S' THEN

        FOR RecCodiciAtecoSec IN curCodiciAtecoSec (recTAziendaAaep.ID_AZIENDA_AAEP)
        LOOP
            vCodAtecoAAEP:='';
            vCodAtecoAnagrafe:='';
            vCodAtecoAAEP       :=trim(vCodAtecoAAEP||' '||RecCodiciAtecoSec.COD_ATECO_SEC_AAEP);
            vCodAtecoAnagrafe   :=trim(vCodAtecoAnagrafe||' '||RecCodiciAtecoSec.COD_ATECO_SEC_ANAG);
            --se esiste un codice ateco secondario presente solo in anagrafe o AAEG errore
            IF NVL(RecCodiciAtecoSec.COD_ATECO_SEC_ANAG, ' ') <> NVL(RecCodiciAtecoSec.COD_ATECO_SEC_AAEP, ' ') THEN
                p_result  := RET_ERR_CNTL;
                p_id_err  :=3827;

            END IF;

        END LOOP;

        IF p_result = RET_ERR_CNTL AND p_id_err =3827   THEN
             p_msg    :='I codici ATECO secondari dichiarati in anagrafe non corrispondono ai codici presenti su AAEP. ATECO anagrafe: ('||
                       vCodAtecoAnagrafe||') ATECO AAEP ('||vCodAtecoAAEP||')';
        ELSE
            p_result := RET_OK;
            p_msg    := NULL;
            p_id_err := NULL;
        END IF;

    ELSE
       p_result := RET_OK;
       p_msg    := NULL;
       p_id_err := NULL;
    END IF;

EXCEPTION
    WHEN OTHERS THEN
         p_result  := RET_ERR;
         p_msg     := fncMessaggioErrore(1) || ' [AEP11] ' || SQLERRM;
         p_id_err  := 1;
END AEP11;


PROCEDURE TRB01(p_id_azienda DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                  p_cuaa DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS


     vFlagPresenzaTRIBUTARIA DB_AZIENDA_TRIBUTARIA.FLAG_PRESENTE_AT%TYPE;
     vMessaggioErrore         DB_AZIENDA_TRIBUTARIA.MESSAGGIO_ERRORE%TYPE;
     vPartitaIvaTRIBUTARIA     DB_AZIENDA_TRIBUTARIA.PARTITA_IVA%TYPE;
     vPartitaIvaAZIENDA      DB_ANAGRAFICA_AZIENDA.PARTITA_IVA%TYPE;
     vStatoAttivita             DB_AZIENDA_TRIBUTARIA.STATO_ATTIVITA%TYPE;


  BEGIN

       p_result := RET_OK;
     p_id_err := NULL;

      SELECT FLAG_PRESENTE_AT, A.MESSAGGIO_ERRORE, A.PARTITA_IVA, NVL(A.STATO_ATTIVITA,'A')
      INTO vFlagPresenzaTRIBUTARIA, vMessaggioErrore, vPartitaIvaTRIBUTARIA, vStatoAttivita
      FROM DB_AZIENDA_TRIBUTARIA A
      WHERE CUAA = p_cuaa;

      IF (vFlagPresenzaTRIBUTARIA <> 'I' OR (vFlagPresenzaTRIBUTARIA = 'E'  AND TRIM(vMessaggioErrore) = 'COD.FISC./P.IVA NON VALIDATA')) THEN
          IF ( vFlagPresenzaTRIBUTARIA = 'S' ) THEN

              SELECT Az.PARTITA_IVA
              INTO vPartitaIvaAZIENDA
              FROM DB_ANAGRAFICA_AZIENDA Az
              WHERE Az.ID_AZIENDA = p_id_azienda
              AND AZ.DATA_FINE_VALIDITA IS NULL;

              IF (vPartitaIvaTributaria IS NOT NULL AND vPartitaIvaTRIBUTARIA <> vPartitaIvaAZIENDA) THEN
                   p_result := RET_ERR_CNTL;
                    p_msg    := fncMessaggioErrore(1216);
                    p_id_err := 1216; --La partita iva dell'azienda non coincide con quella presente su AT
              ELSIF vStatoAttivita <> 'A' THEN
                   p_result := RET_ERR_CNTL;
                    p_msg    := fncMessaggioErrore(1779);
                    p_id_err := 1779; --azienda cessata su AT
              ELSE
                 p_result := RET_OK;
                    p_msg    := 'Azienda presente in anagrafe tributaria';
                    p_id_err := NULL;
              END IF;

          ELSIF vFlagPresenzaTRIBUTARIA = 'N'  THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1089);
                p_id_err := 1089;

          ELSIF vFlagPresenzaTRIBUTARIA = 'I' THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1181);
                p_id_err := 1181; /* trb00 servizio non disponibile entro il time out*/
          ELSIF TRIM(vMessaggioErrore) = 'COD.FISC./P.IVA NON VALIDATA' THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1089);
                p_id_err := 1089; /* trb00 CUAA NON VALIDATO IN ANAGRAFE TRIBUTARIA */

          ELSE
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1182) || ' ' || vMessaggioErrore;
                p_id_err := 1182;
          END IF;
     END IF;


  EXCEPTION
    WHEN NO_DATA_FOUND THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(1100);
            p_id_err := 1100;
    WHEN TOO_MANY_ROWS THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(1100);
            p_id_err := 1100;
    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [TRB01] ' || SQLERRM;
      p_id_err  := 1;

--
END TRB01;

PROCEDURE TRB02(p_id_azienda DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                  p_cuaa DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS


     vFlagPresenzaTRIBUTARIA DB_AZIENDA_TRIBUTARIA.FLAG_PRESENTE_AT%TYPE;
     vDenominazioneTRIBUTARIA DB_AZIENDA_TRIBUTARIA.DENOMINAZIONE%TYPE;
     vCognomeTRIBUTARIA DB_AZIENDA_TRIBUTARIA.COGNOME%TYPE;
     vNomeTRIBUTARIA DB_AZIENDA_TRIBUTARIA.NOME%TYPE;
     vdenominazione DB_ANAGRAFICA_AZIENDA.denominazione%TYPE;
     vCognome DB_PERSONA_FISICA.COGNOME%TYPE;
     vNome DB_PERSONA_FISICA.NOME%TYPE;
     vMessaggioErrore DB_AZIENDA_TRIBUTARIA.MESSAGGIO_ERRORE%TYPE;


     N_PERC_CONFRONTO      NUMBER(5,2);

  BEGIN

       p_result := RET_OK;
     p_id_err := NULL;

      SELECT FLAG_PRESENTE_AT, UPPER(denominazione), cognome, nome, messaggio_errore
      INTO vFlagPresenzaTRIBUTARIA, vDenominazioneTRIBUTARIA, vCognomeTRIBUTARIA, vNomeTRIBUTARIA, vMessaggioErrore
      FROM DB_AZIENDA_TRIBUTARIA
      WHERE CUAA = p_cuaa;


      IF (vFlagPresenzaTRIBUTARIA <> 'I' OR (vFlagPresenzaTRIBUTARIA = 'E'  AND TRIM(vMessaggioErrore) = 'COD.FISC./P.IVA NON VALIDATA')) THEN
          IF ( vFlagPresenzaTRIBUTARIA = 'S' ) THEN
         -- se il cuaa è di 11
             IF LENGTH(p_cuaa)=11 THEN
                  SELECT UPPER(denominazione)
                  INTO vdenominazione
                  FROM DB_ANAGRAFICA_AZIENDA
                  WHERE ID_AZIENDA = p_id_azienda AND DATA_FINE_VALIDITA IS NULL;

                  IF ( vdenominazioneTRIBUTARIA IS NULL OR vdenominazioneTRIBUTARIA ='') THEN

                     p_result := RET_OK;
                        p_msg    := 'Denominazione non valorizzata in ANAGRAFE TRIBUTARIA';
                        p_id_err := NULL;

--                  ELSIF ( REPLACE(vdenominazioneTRIBUTARIA,' ','') = REPLACE(vdenominazione,' ','')) then
                  ELSE

                       N_PERC_CONFRONTO:=confrontastringhe(TRIM(vdenominazioneTRIBUTARIA),TRIM(vdenominazione),0);

                      IF N_PERC_CONFRONTO >= LIMITE_PERC THEN

                         p_result := RET_OK;
                            p_msg    := 'Denominazione in anagrafe congruente a quella di anagrafe tributaria';
                            p_id_err := NULL;

                      ELSE

                         p_result := RET_ERR_CNTL;
                            p_msg    := fncMessaggioErrore(1104) ||': '||vdenominazioneTRIBUTARIA;
                            p_id_err := 1104;

                      END IF;

                  END IF;
             END IF;
         -- se il cuaa è di 16
/*             if length(p_cuaa)=16 then
                  select upper(COGNOME), UPPER(NOME)
                  into VCOGNOME, VNOME
                  from DB_PERSONA_FISICA PF, DB_CONTITOLARE C
                  where C.ID_AZIENDA = p_id_azienda AND C.DATA_FINE_RUOLO IS NULL
                  AND C.ID_RUOLO=1 AND C.ID_SOGGETTO=PF.ID_SOGGETTO;

                  if ( REPLACE(vcognome,' ','') =REPLACE(vcognomeTributaria,' ','')) then

                     p_result := RET_OK;
                        p_msg    := 'Cognome titolare coerente con ANAGRAFE TRIBUTARIA';
                        p_id_err := null;
                  ELSE
                     p_result := RET_ERR_CNTL;
                        p_msg    := fncMessaggioErrore(1105) ||': '||vcognomeTRIBUTARIA;
                        p_id_err := 1105;

                  end if;
                  if ( REPLACE(vnome,' ','') =REPLACE(vnomeTributaria,' ','')) then

                     p_result := RET_OK;
                        p_msg    := 'Nome titolare coerente con ANAGRAFE TRIBUTARIA';
                        p_id_err := null;
                  ELSE
                     p_result := RET_ERR_CNTL;
                        p_msg    := fncMessaggioErrore(1106) ||': '||vnomeTRIBUTARIA;
                        p_id_err := 1106;

                  end if;
             END IF;
*/
          ELSIF vFlagPresenzaTRIBUTARIA = 'N'  THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1089);
                p_id_err := 1089;

          ELSIF vFlagPresenzaTRIBUTARIA = 'I' THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1181);
                p_id_err := 1181; /* trb00 servizio non disponibile entro il time out*/

          ELSIF TRIM(vMessaggioErrore) = 'COD.FISC./P.IVA NON VALIDATA' THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1089);
                p_id_err := 1089; /* trb00 CUAA NON VALIDATO IN ANAGRAFE TRIBUTARIA */

          ELSE
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1182) || ' ' || vMessaggioErrore;
                p_id_err := 1182;
          END IF;
     END IF;


  EXCEPTION
    WHEN NO_DATA_FOUND THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(1100);
            p_id_err := 1100;
    WHEN TOO_MANY_ROWS THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(1100);
            p_id_err := 1100;
    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [TRB02] ' || SQLERRM;
      p_id_err  := 1;

--
END TRB02;

PROCEDURE TRB03(p_cuaa DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS


     vFlagPresenzaTRIBUTARIA DB_AZIENDA_TRIBUTARIA.FLAG_PRESENTE_AT%TYPE;
     vcuaaTRIBUTARIA DB_AZIENDA_TRIBUTARIA.CUAA_ANAGRAFE_TRIBUTARIA%TYPE;
     vMessaggioErrore DB_AZIENDA_TRIBUTARIA.MESSAGGIO_ERRORE%TYPE;

  BEGIN

        p_result := RET_OK;
     p_id_err := NULL;

      SELECT FLAG_PRESENTE_AT,CUAA_ANAGRAFE_TRIBUTARIA, MESSAGGIO_ERRORE
      INTO vFlagPresenzaTRIBUTARIA, vcuaaTRIBUTARIA, vMessaggioErrore
      FROM DB_AZIENDA_TRIBUTARIA
      WHERE CUAA = p_cuaa;

      IF (vFlagPresenzaTRIBUTARIA <> 'I' OR (vFlagPresenzaTRIBUTARIA = 'E'  AND TRIM(vMessaggioErrore) = 'COD.FISC./P.IVA NON VALIDATA')) THEN
          IF ( vFlagPresenzaTRIBUTARIA = 'S' ) THEN
         -- guardo se i cuaa sono diversi
             IF p_cuaa = vcuaaTRIBUTARIA THEN
                     p_result := RET_OK;
                        p_msg    := 'CUAA coerente con quello di ANAGRAFE TRIBUTARIA';
                        p_id_err := NULL;
              ELSE
                 p_result := RET_ERR_CNTL;
                    p_msg    := fncMessaggioErrore(1150) ||': '||vcuaaTRIBUTARIA;
                    p_id_err := 1150;

              END IF;

          ELSIF vFlagPresenzaTRIBUTARIA = 'N'  THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1089);
                p_id_err := 1089;

          ELSIF vFlagPresenzaTRIBUTARIA = 'I' THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1181);
                p_id_err := 1181; /* trb00 servizio non disponibile entro il time out*/

          ELSIF TRIM(vMessaggioErrore) = 'COD.FISC./P.IVA NON VALIDATA' THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1089);
                p_id_err := 1089; /* trb00 CUAA NON VALIDATO IN ANAGRAFE TRIBUTARIA */

          ELSE
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1182) || ' ' || vMessaggioErrore;
                p_id_err := 1182;
          END IF;
     END IF;


  EXCEPTION
    WHEN NO_DATA_FOUND THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(1100);
            p_id_err := 1100;
    WHEN TOO_MANY_ROWS THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(1100);
            p_id_err := 1100;
    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [TRB03] ' || SQLERRM;
      p_id_err  := 1;
END TRB03;

PROCEDURE TRB04(p_id_azienda DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                p_cuaa DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS

     vFlagPresenzaTRIBUTARIA DB_AZIENDA_TRIBUTARIA.FLAG_PRESENTE_AT%TYPE;
     vProvinciaTRIBUTARIA      DB_AZIENDA_TRIBUTARIA.PROVINCIA%TYPE;
     vComuneSedeTRIBUTARIA  DB_AZIENDA_TRIBUTARIA.COMUNE%TYPE;
     vMessaggioErrore DB_AZIENDA_TRIBUTARIA.MESSAGGIO_ERRORE%TYPE;
     vCAPTRIBUTARIA        DB_AZIENDA_TRIBUTARIA.CAP%TYPE;

     vProvinciaAzienda           PROVINCIA.SIGLA_PROVINCIA%TYPE;
     vComuneSedeAZIENDA     COMUNE.DESCOM%TYPE;
     nFormaGiuridica         DB_ANAGRAFICA_AZIENDA.ID_FORMA_GIURIDICA%TYPE;
     vProvinciaSoggetto     PROVINCIA.SIGLA_PROVINCIA%TYPE;
     vComuneSoggetto    COMUNE.DESCOM%TYPE;
     vCAPAZIENDA        DB_ANAGRAFICA_AZIENDA.SEDELEG_CAP%TYPE;

  BEGIN

        p_result := RET_OK;
      p_id_err := NULL;

      SELECT FLAG_PRESENTE_AT, A.PROVINCIA_sede_legale, A.COMUNE_sede_legale, A.MESSAGGIO_ERRORE, A.CAP_sede_legale
      INTO vFlagPresenzaTRIBUTARIA, vProvinciaTRIBUTARIA, vComuneSedeTRIBUTARIA, vMessaggioErrore, vCAPTRIBUTARIA
      FROM DB_AZIENDA_TRIBUTARIA A
      WHERE CUAA = p_cuaa;

      IF (vFlagPresenzaTRIBUTARIA <> 'I' OR (vFlagPresenzaTRIBUTARIA = 'E'  AND TRIM(vMessaggioErrore) = 'COD.FISC./P.IVA NON VALIDATA')) THEN
          IF ( vFlagPresenzaTRIBUTARIA = 'S' ) THEN

              SELECT C.SIGLA_PROVINCIA, B.DESCOM, CS.SIGLA_PROVINCIA, BS.DESCOM, A.ID_FORMA_GIURIDICA, A.SEDELEG_CAP
              INTO vProvinciaAzienda, vComuneSedeAZIENDA, vProvinciaSoggetto, vComuneSoggetto, nFormaGiuridica, vCAPAZIENDA
              FROM DB_ANAGRAFICA_AZIENDA A, COMUNE B, PROVINCIA C, COMUNE BS, PROVINCIA CS, DB_CONTITOLARE CO, DB_PERSONA_FISICA PF
              WHERE A.ID_AZIENDA = p_id_azienda
              AND CO.ID_AZIENDA = p_id_azienda
              AND PF.ID_SOGGETTO = CO.ID_SOGGETTO
              AND A.DATA_FINE_VALIDITA IS NULL
              AND A.SEDELEG_COMUNE = B.ISTAT_COMUNE
              AND B.ISTAT_PROVINCIA = C.ISTAT_PROVINCIA
              AND PF.RES_COMUNE = BS.ISTAT_COMUNE
              AND BS.ISTAT_PROVINCIA = CS.ISTAT_PROVINCIA
              AND  CO.ID_RUOLO = 1
              AND CO.DATA_FINE_RUOLO IS NULL;

              IF (nFormaGiuridica =1 OR nFormaGiuridica = 52) THEN
                   NULL;
/*
                    if ((vProvinciaTRIBUTARIA is not null and vComuneSedeTRIBUTARIA is not null) and (vProvinciaTRIBUTARIA <> vProvinciaSoggetto or vComuneSedeTRIBUTARIA <> vComuneSoggetto)) then

                     p_result := RET_ERR_CNTL;
                         p_msg    := fncMessaggioErrore(1213);
                         p_id_err := 1213;
                    end if;
*/
              ELSE

                  IF ((vProvinciaTRIBUTARIA IS NOT NULL AND vComuneSedeTRIBUTARIA IS NOT NULL) AND
                        (vProvinciaTRIBUTARIA <> vProvinciaAzienda OR vComuneSedeTRIBUTARIA <> vComuneSedeAZIENDA)) THEN

                     p_result := RET_ERR_CNTL;
                         p_msg    := fncMessaggioErrore(1183);
                         p_id_err := 1183; --[TRB04] La provincia o il comune della sede legale non coincidono con quelli presenti su Anagrafe Tributaria
                     IF vCAPTRIBUTARIA IS NOT NULL AND vCAPTRIBUTARIA <> vCAPAZIENDA THEN
                         p_result := RET_ERR_CNTL;
                             p_msg    := fncMessaggioErrore(1789);
                             p_id_err := 1789; -- [TRB04] Il CAP della sede legale non coincide con quello presente su Anagrafe Tributaria
                     END IF;
                  END IF;
              END IF;

          ELSIF vFlagPresenzaTRIBUTARIA = 'N'  THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1089);
                p_id_err := 1089;

          ELSIF vFlagPresenzaTRIBUTARIA = 'I' THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1181);
                p_id_err := 1181; /* trb00 servizio non disponibile entro il time out*/

          ELSIF TRIM(vMessaggioErrore) = 'COD.FISC./P.IVA NON VALIDATA' THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1089);
                p_id_err := 1089; /* trb00 CUAA NON VALIDATO IN ANAGRAFE TRIBUTARIA */

          ELSE
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1182) || ' ' || vMessaggioErrore;
                p_id_err := 1182;
          END IF;
     END IF;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(1100);
            p_id_err := 1100;
    WHEN TOO_MANY_ROWS THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(1100);
            p_id_err := 1100;
    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [TRB04] ' || SQLERRM;
      p_id_err  := 1;

--
END TRB04;

PROCEDURE TRB05(p_cuaa DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS


     vFlagPresenzaTRIBUTARIA DB_AZIENDA_TRIBUTARIA.FLAG_PRESENTE_AT%TYPE;
     vMessaggioErrore         DB_AZIENDA_TRIBUTARIA.MESSAGGIO_ERRORE%TYPE;


  BEGIN

      p_result := RET_OK;
      p_id_err := NULL;

      SELECT FLAG_PRESENTE_AT, A.MESSAGGIO_ERRORE
      INTO vFlagPresenzaTRIBUTARIA, vMessaggioErrore
      FROM DB_AZIENDA_TRIBUTARIA A
      WHERE CUAA = p_cuaa;

      IF ( vFlagPresenzaTRIBUTARIA = 'I' OR (vFlagPresenzaTRIBUTARIA = 'E'  AND TRIM(vMessaggioErrore) <> 'COD.FISC./P.IVA NON VALIDATA')) THEN -- il servizio non è raggiungibile. E' giustificabile
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(1182) || ' ' ||vMessaggioErrore;
            p_id_err := 1182;      /*TRB00 ERRORE SIAN*/
      END IF;

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(1100);
            p_id_err := 1100; /*TRB00 servizio non disponibile*/
    WHEN TOO_MANY_ROWS THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(1100);
            p_id_err := 1100;
    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [TRB05] ' || SQLERRM;
      p_id_err  := 1;

--
END TRB05;

PROCEDURE TRB06(p_id_azienda DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                p_cuaa DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS


     vFlagPresenzaTRIBUTARIA DB_AZIENDA_TRIBUTARIA.FLAG_PRESENTE_AT%TYPE;
     vMessaggioErrore         DB_AZIENDA_TRIBUTARIA.MESSAGGIO_ERRORE%TYPE;
     vCognomeTributaria         DB_AZIENDA_TRIBUTARIA.COGNOME%TYPE;
     vNomeTributaria         DB_AZIENDA_TRIBUTARIA.NOME%TYPE;
     vComuneNascitaTributaria DB_AZIENDA_TRIBUTARIA.COMUNE_NASCITA%TYPE;
      vCognome                  DB_PERSONA_FISICA.COGNOME%TYPE;
     vNome                       DB_PERSONA_FISICA.NOME%TYPE;
     vComuneNascita                COMUNE.DESCOM%TYPE;
     p_cuaa_pf                  DB_PERSONA_FISICA.CODICE_FISCALE%TYPE;

     dDataNascita              DB_PERSONA_FISICA.NASCITA_DATA%TYPE;
     dDataNascitaTributaria      DB_AZIENDA_TRIBUTARIA.DATA_NASCITA%TYPE;

  BEGIN
      p_result := RET_OK;
      p_id_err := NULL;

      BEGIN
          SELECT PF.CODICE_FISCALE, PF.COGNOME, PF.NOME, CN.DESCOM, Pf.NASCITA_DATA
          INTO p_cuaa_pf, vCognome, vNome, vComuneNascita, dDataNascita
          FROM DB_PERSONA_FISICA PF, DB_CONTITOLARE CO, COMUNE CN
          WHERE PF.ID_SOGGETTO = CO.ID_SOGGETTO
          AND CO.ID_RUOLO = 1
          AND CO.DATA_FINE_RUOLO IS NULL
          AND CO.ID_AZIENDA = p_id_azienda
          AND CN.ISTAT_COMUNE = PF.NASCITA_COMUNE;
      EXCEPTION
           WHEN TOO_MANY_ROWS THEN
               p_result := RET_ERR_CNTL;
              p_msg := fncMessaggioErrore(1218);
              p_id_err:= 1218;

         WHEN NO_DATA_FOUND THEN
               p_result := RET_ERR_CNTL;
              p_msg := fncMessaggioErrore(1219);
              p_id_err:= 1219;
      END;
      SELECT FLAG_PRESENTE_AT, A.MESSAGGIO_ERRORE, A.COGNOME, A.NOME,  A.COMUNE_NASCITA, A.DATA_NASCITA
      INTO vFlagPresenzaTRIBUTARIA, vMessaggioErrore, vCognomeTributaria, vNomeTributaria, vComuneNascitaTributaria, dDataNascitaTributaria
      FROM DB_AZIENDA_TRIBUTARIA A
      WHERE A.CUAA = p_cuaa_pf;

      IF (vFlagPresenzaTRIBUTARIA <> 'I' OR (vFlagPresenzaTRIBUTARIA = 'E'  AND TRIM(vMessaggioErrore) = 'COD.FISC./P.IVA NON VALIDATA')) THEN
          IF ( vFlagPresenzaTRIBUTARIA = 'S' ) THEN

--          begin
    /*
               SELECT DISTINCT PF.COGNOME, PF.NOME, CN.DESCOM
             INTO vCognome, vNome, vComuneNascita
             FROM DB_PERSONA_FISICA PF, COMUNE CR, COMUNE CN, PROVINCIA PR, PROVINCIA PN
             WHERE CODICE_FISCALE = p_cuaa_pf
             AND PF.NASCITA_COMUNE = CN.ISTAT_COMUNE
             AND PF.RES_COMUNE = CR.ISTAT_COMUNE
             AND CR.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA;
*/
              IF (( vCognomeTributaria IS NOT NULL AND vNomeTributaria IS NOT NULL
                AND vComuneNascitaTributaria IS NOT NULL )
                AND (REPLACE(SUBSTR(vCognomeTributaria,1,24),' ','') <> REPLACE(SUBSTR(vCognome,1,24),' ','')
                OR REPLACE(SUBSTR(vNomeTributaria,1,20),' ','') <> REPLACE(SUBSTR(vNome,1,20),' ','')
                OR vComuneNascitaTributaria <> vComuneNascita
                OR dDataNascita <> dDataNascitaTributaria))THEN -- il servizio non è raggiungibile. E' giustificabile
                 p_result := RET_ERR_CNTL;
                    p_msg    := fncMessaggioErrore(1215);
                    p_id_err := 1215;
              END IF;
/*

             exception
             when TOO_MANY_ROWS THEN
                   p_result := RET_ERR_CNTL;
                  p_msg := fncMessaggioErrore(1214);
                  p_id_err:= 1214;

             when NO_DATA_FOUND THEN
                   p_result := RET_ERR_CNTL;
                  p_msg := fncMessaggioErrore(1217);
                  p_id_err:= 1217;

          end;
*/
     ELSIF vFlagPresenzaTRIBUTARIA = 'N'  THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1089);
                p_id_err := 1089;

          ELSIF vFlagPresenzaTRIBUTARIA = 'I' THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1181);
                p_id_err := 1181; /* trb00 servizio non disponibile entro il time out*/
          ELSIF TRIM(vMessaggioErrore) = 'COD.FISC./P.IVA NON VALIDATA' THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1089);
                p_id_err := 1089; /* trb00 CUAA NON VALIDATO IN ANAGRAFE TRIBUTARIA */
          ELSE
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1182) || ' ' || vMessaggioErrore;
                p_id_err := 1182;
          END IF;
     END IF;


  EXCEPTION
    WHEN NO_DATA_FOUND THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(1220);
            p_id_err := 1220;
    WHEN TOO_MANY_ROWS THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(1220);
            p_id_err := 1220;
    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [TRB06] ' || SQLERRM;
      p_id_err  := 1;
END TRB06;

PROCEDURE TRB07(p_id_azienda DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                p_cuaa DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS


     vFlagPresenzaTRIBUTARIA DB_AZIENDA_TRIBUTARIA.FLAG_PRESENTE_AT%TYPE;
     vMessaggioErrore         DB_AZIENDA_TRIBUTARIA.MESSAGGIO_ERRORE%TYPE;
     vProvinciaResTributaria DB_AZIENDA_TRIBUTARIA.PROVINCIA%TYPE;
     vComuneResTributaria     DB_AZIENDA_TRIBUTARIA.COMUNE%TYPE;
     vProvinciaResidenza      PROVINCIA.SIGLA_PROVINCIA%TYPE;
     vComuneResidenza          COMUNE.DESCOM%TYPE;
     vCAPResidenza                DB_PERSONA_FISICA.RES_CAP%TYPE;
     vCAPTributaria                DB_AZIENDA_TRIBUTARIA.CAP%TYPE;
     p_cuaa_pf                 DB_PERSONA_FISICA.CODICE_FISCALE%TYPE;


  BEGIN

      p_result := RET_OK;
      p_id_err := NULL;

      BEGIN

      SELECT PF.CODICE_FISCALE, PR.SIGLA_PROVINCIA, CR.DESCOM, PF.RES_CAP
      INTO p_cuaa_pf, vProvinciaResidenza, vComuneResidenza, vCAPResidenza
      FROM DB_PERSONA_FISICA PF, DB_CONTITOLARE CO, COMUNE CR,PROVINCIA PR
      WHERE PF.ID_SOGGETTO = CO.ID_SOGGETTO
      AND CO.ID_RUOLO = 1
      AND CO.DATA_FINE_RUOLO IS NULL
      AND CO.ID_AZIENDA = p_id_azienda
      AND CR.ISTAT_COMUNE = PF.RES_COMUNE
      AND CR.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA;

      EXCEPTION
           WHEN TOO_MANY_ROWS THEN
               p_result := RET_ERR_CNTL;
              p_msg := fncMessaggioErrore(1236); -- [TRB07] Sono stati trovati più rappresentanti legali/titolari attivi per l'azienda
              p_id_err:= 1236;

         WHEN NO_DATA_FOUND THEN
               p_result := RET_ERR_CNTL;
              p_msg := fncMessaggioErrore(1235); -- [TRB07] Non è stato trovato il rappresentante legale/titolare dell'azienda
              p_id_err:= 1235;

      END;
      SELECT FLAG_PRESENTE_AT, A.MESSAGGIO_ERRORE, A.PROVINCIA, A.COMUNE, a.CAP
      INTO vFlagPresenzaTRIBUTARIA, vMessaggioErrore, vProvinciaResTributaria, vComuneResTributaria, vCAPTributaria
      FROM DB_AZIENDA_TRIBUTARIA A
      WHERE A.CUAA = p_cuaa_pf;

      IF (vFlagPresenzaTRIBUTARIA <> 'I' OR (vFlagPresenzaTRIBUTARIA = 'E'  AND TRIM(vMessaggioErrore) = 'COD.FISC./P.IVA NON VALIDATA')) THEN
          IF ( vFlagPresenzaTRIBUTARIA = 'S' ) THEN
/*
          begin
               SELECT DISTINCT PR.SIGLA_PROVINCIA, CR.DESCOM
             INTO vProvinciaResidenza, vComuneResidenza
             FROM DB_PERSONA_FISICA PF, COMUNE CR,PROVINCIA PR
             WHERE CODICE_FISCALE = p_cuaa_pf
             AND PF.RES_COMUNE = CR.ISTAT_COMUNE
             AND CR.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA;
*/
              IF (vProvinciaResTributaria IS NOT NULL AND vComuneResTributaria IS NOT NULL) THEN
                  IF vProvinciaResTributaria <> vProvinciaResidenza
                  OR TRIM(vComuneResTributaria)    <> SUBSTR(TRIM(vComuneResidenza),1,45)
                  OR vCAPResidenza             <> vCAPTributaria THEN
                     p_result := RET_ERR_CNTL;
                        p_msg    := fncMessaggioErrore(1234);
                        p_id_err := 1234; -- [TRB07] I dati di residenza del titolare non coincidono con quelli presenti su Anagrafe Tributaria
                  END IF;
              END IF;

/*
             exception
             when TOO_MANY_ROWS THEN
                   p_result := RET_ERR_CNTL;
                  p_msg := fncMessaggioErrore(1233);
                  p_id_err:= 1233; -- [TRB07]  Codice fiscale della persona non univoco

             when NO_DATA_FOUND THEN
                   p_result := RET_ERR_CNTL;
                  p_msg := fncMessaggioErrore(1232);
                  p_id_err:= 1232; -- [TRB07] Codice fiscale della persona non trovato

          end;
*/
     ELSIF vFlagPresenzaTRIBUTARIA = 'N'  THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1089);
                p_id_err := 1089; -- [TRB00] CUAA non validato in Anagrafe Tributaria

          ELSIF vFlagPresenzaTRIBUTARIA = 'I' THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1181);
                p_id_err := 1181; /* trb00 servizio non disponibile entro il time out*/
          ELSIF TRIM(vMessaggioErrore) = 'COD.FISC./P.IVA NON VALIDATA' THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1089);
                p_id_err := 1089; /* trb00 CUAA NON VALIDATO IN ANAGRAFE TRIBUTARIA */
          ELSE
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1182) || ' ' || vMessaggioErrore;
                p_id_err := 1182; -- [TRB00] Errore SIAN
          END IF;
     END IF;


  EXCEPTION
    WHEN NO_DATA_FOUND THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(1231);
            p_id_err := 1231; -- [TRB07] Codice del rappresentante legale/titolare non presente su Anagrafe Tributaria o servizio non disponibile
    WHEN TOO_MANY_ROWS THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(1231);
            p_id_err := 1231; --[TRB07] Codice del rappresentante legale/titolare non presente su Anagrafe Tributaria o servizio non disponibile
    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [TRB07] ' || SQLERRM;
      p_id_err  := 1;

END TRB07;

PROCEDURE TRB08(p_id_azienda DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                p_cuaa         DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS

     vFlagPresenzaTRIBUTARIA DB_AZIENDA_TRIBUTARIA.FLAG_PRESENTE_AT%TYPE;
     vMessaggioErrore         DB_AZIENDA_TRIBUTARIA.MESSAGGIO_ERRORE%TYPE;
/*     vProvinciaResTributaria DB_AZIENDA_TRIBUTARIA.PROVINCIA%TYPE;
     vComuneResTributaria     DB_AZIENDA_TRIBUTARIA.COMUNE%TYPE;
     vProvinciaResidenza      DB_AZIENDA_TRIBUTARIA.PROVINCIA%TYPE;
     vComuneResidenza          DB_AZIENDA_TRIBUTARIA.COMUNE%TYPE;
     vCAPResidenza                DB_PERSONA_FISICA.RES_CAP%TYPE;
     vCAPTributaria                DB_AZIENDA_TRIBUTARIA.CAP%TYPE;*/
     p_cuaa_pf                 DB_PERSONA_FISICA.CODICE_FISCALE%TYPE;
     vCodiceFiscaleRappresentante DB_AZIENDA_TRIBUTARIA.CODICE_FISCALE_RAPPRESENTANTE%TYPE;


  BEGIN

      p_result := RET_OK;
      p_id_err := NULL;

      BEGIN
          SELECT PF.CODICE_FISCALE
          INTO p_cuaa_pf
          FROM DB_PERSONA_FISICA PF, DB_CONTITOLARE CO
          WHERE PF.ID_SOGGETTO = CO.ID_SOGGETTO
          AND CO.ID_RUOLO = 1
          AND CO.DATA_FINE_RUOLO IS NULL
          AND CO.ID_AZIENDA = p_id_azienda;

          EXCEPTION
               WHEN TOO_MANY_ROWS THEN
                   p_result := RET_ERR_CNTL;
                  p_msg := fncMessaggioErrore(1792); -- [TRB08] Sono stati trovati più rappresentanti legali/titolari attivi per l'azienda
                  p_id_err:= 1792;

             WHEN NO_DATA_FOUND THEN
                   p_result := RET_ERR_CNTL;
                  p_msg := fncMessaggioErrore(1793); -- [TRB08] Non è stato trovato il rappresentante legale/titolare dell'azienda
                  p_id_err:= 1793;
      END;

      BEGIN
          SELECT FLAG_PRESENTE_AT, A.MESSAGGIO_ERRORE, CODICE_FISCALE_RAPPRESENTANTE
          INTO vFlagPresenzaTRIBUTARIA, vMessaggioErrore, vCodiceFiscaleRappresentante
          FROM DB_AZIENDA_TRIBUTARIA A
          WHERE A.CUAA = p_cuaa;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1794);
                p_id_err := 1794; -- [TRB08] Codice del rappresentante legale/titolare non presente su Anagrafe Tributaria o servizio non disponibile
        WHEN TOO_MANY_ROWS THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(1794);
                p_id_err := 1794; --[TRB08] Codice del rappresentante legale/titolare non presente su Anagrafe Tributaria o servizio non disponibile
        WHEN OTHERS THEN
          p_result  := RET_ERR;
          p_msg     := fncMessaggioErrore(1) || ' [TRB08] ' || SQLERRM;
          p_id_err  := 1;
      END;

      IF (vFlagPresenzaTRIBUTARIA <> 'I' OR (vFlagPresenzaTRIBUTARIA = 'E'  AND TRIM(vMessaggioErrore) = 'COD.FISC./P.IVA NON VALIDATA')) THEN
          IF ( vFlagPresenzaTRIBUTARIA = 'S' ) THEN
              IF LENGTH(p_cuaa) = 11 THEN --controllo solo per cuaa = piva
                IF p_cuaa_pf <> vCodiceFiscaleRappresentante THEN
                     p_result := RET_ERR_CNTL;
                        p_msg    := fncMessaggioErrore(1795);
                        p_id_err := 1795; -- [TRB08] Il titolare/rappr.legale dichiarato in Anagrafe non coincide con quello di AT
                END IF;
            END IF;
          END IF;
     ELSIF vFlagPresenzaTRIBUTARIA = 'N'  THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(1089);
            p_id_err := 1089; -- [TRB00] CUAA non validato in Anagrafe Tributaria

     ELSIF vFlagPresenzaTRIBUTARIA = 'I' THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(1181);
            p_id_err := 1181; /* trb00 servizio non disponibile entro il time out*/
    ELSIF TRIM(vMessaggioErrore) = 'COD.FISC./P.IVA NON VALIDATA' THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(1089);
            p_id_err := 1089; /* trb00 CUAA NON VALIDATO IN ANAGRAFE TRIBUTARIA */
    ELSE
         p_result := RET_ERR_CNTL;
           p_msg    := fncMessaggioErrore(1182) || ' ' || vMessaggioErrore;
           p_id_err := 1182; -- [TRB00] Errore SIAN
     END IF;
EXCEPTION WHEN OTHERS THEN
    p_result  := RET_ERR;
    p_msg     := fncMessaggioErrore(1) || ' [TRB08] ' || SQLERRM;
    p_id_err  := 1;

END TRB08;

-- restyling di TRB09 ora cerca su anagrafe (SIAP) il titolare / rappresentante legale
-- attivo e vede su anagrafe tributaria se e' deceduto
PROCEDURE TRB09(p_id_azienda IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS

     vMessaggioErrore        DB_AZIENDA_TRIBUTARIA.MESSAGGIO_ERRORE%TYPE;
     vCfTitolareGaa          DB_PERSONA_FISICA.CODICE_FISCALE%TYPE;
     dDataDecesso            DB_AZIENDA_TRIBUTARIA.DATA_DECESSO%TYPE;
     dDataDecessoRappr       DB_AZIENDA_TRIBUTARIA.DATA_DECESSO_RAPPRESENTANTE%TYPE;
     vFlagPresenzaTRIBUTARIA DB_AZIENDA_TRIBUTARIA.FLAG_PRESENTE_AT%TYPE;
BEGIN

    BEGIN

         SELECT PF.CODICE_FISCALE
           INTO vCfTitolareGaa
           FROM DB_CONTITOLARE CT,
                DB_PERSONA_FISICA PF
          WHERE CT.ID_AZIENDA = p_id_azienda
            AND CT.ID_RUOLO = knIdRuoloTitRPLeg
            AND CT.DATA_FINE_RUOLO IS NULL
            AND CT.ID_SOGGETTO = PF.ID_SOGGETTO;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             p_result := RET_ERR_CNTL;
             p_msg    := fncMessaggioErrore(3632);
             p_id_err := 3632;
             vCfTitolareGaa := NULL;
        WHEN TOO_MANY_ROWS THEN
             p_result := RET_ERR_CNTL;
             p_msg    := fncMessaggioErrore(3632);
             p_id_err := 3632;
             vCfTitolareGaa := NULL;
    END;

    IF vCfTitolareGaa IS NOT NULL THEN
       BEGIN
           SELECT FLAG_PRESENTE_AT,
                  MESSAGGIO_ERRORE,
                  DATA_DECESSO,
                  DATA_DECESSO_RAPPRESENTANTE
             INTO vFlagPresenzaTRIBUTARIA,
                  vMessaggioErrore,
                  dDataDecesso,
                  dDataDecessoRappr
             FROM DB_AZIENDA_TRIBUTARIA
            WHERE CUAA = vCfTitolareGaa;


            IF vFlagPresenzaTRIBUTARIA = 'S' THEN
                IF NVL(dDataDecesso,dDataDecessoRappr) IS NOT NULL THEN
                    p_result := RET_ERR_CNTL;
                    p_msg    := fncMessaggioErrore(3634) || ' - Data decesso : ' || TO_CHAR(NVL(dDataDecesso,dDataDecessoRappr),'DD/MM/YYYY');
                    p_id_err := 3634;
                ELSE
                    p_result := RET_OK;
                    p_msg := NULL;
                    p_id_err := NULL;
                END IF;
            ELSE
                 p_result := RET_ERR_CNTL;
                 p_msg    := fncMessaggioErrore(3633);
                 p_id_err := 3633;
            END IF;

       EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 p_result := RET_ERR_CNTL;
                 p_msg    := fncMessaggioErrore(3633);
                 p_id_err := 3633;
       END;
    END IF;

EXCEPTION
    WHEN OTHERS THEN
         p_result  := RET_ERR;
         p_msg := fncMessaggioErrore(1) || ' [TRB09] ' || SQLERRM;
         p_id_err  := 1;
END TRB09;


PROCEDURE CNC01(p_id_azienda DB_AZIENDA.ID_AZIENDA%TYPE,
                     P_ID_SPORTELLO IN DB_TIPO_SPORTELLO.ID_SPORTELLO%TYPE,
                p_result       OUT VARCHAR2,
                p_msg          OUT VARCHAR2,
                p_id_err       OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- Controllo validità conti correnti dell'azienda o di uno solo di essa
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_id_sportello: identificativo dello sportello (ergo di un singolo CC). Può essere null
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------

  N_CONT                INTEGER;
  N_ID_BANCA            DB_TIPO_SPORTELLO.ID_BANCA%TYPE;
  N_ID_SPORTELLO        DB_TIPO_SPORTELLO.ID_SPORTELLO%TYPE;

  ERR_NO_CAB            EXCEPTION;
  ERR_NO_ABI            EXCEPTION;
  ERR_NO_CAB_ALL        EXCEPTION;
  ERR_NO_ABI_ALL        EXCEPTION;

CURSOR C_CC IS
  SELECT KK.ID_SPORTELLO
  FROM DB_CONTO_CORRENTE C, DB_TIPO_SPORTELLO KK
  WHERE C.ID_AZIENDA=P_ID_AZIENDA
  AND C.DATA_FINE_VALIDITA IS NULL
  AND C.DATA_ESTINZIONE IS NULL
  AND C.ID_SPORTELLO=KK.ID_SPORTELLO;


  BEGIN

   IF P_ID_SPORTELLO IS NULL THEN

      FOR REC_CC IN C_CC LOOP

             /* ciclo su tutti i c/c dell'azienda */
          N_ID_SPORTELLO:=REC_CC.ID_SPORTELLO;

             /* verifico la validità del CAB */
          BEGIN
              SELECT KK.ID_BANCA
              INTO N_ID_BANCA
              FROM DB_TIPO_SPORTELLO KK
              WHERE KK.DATA_FINE_VALIDITA IS NULL
              AND KK.ID_SPORTELLO=N_ID_SPORTELLO;
          EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     RAISE ERR_NO_CAB_ALL;
          END;

          /* indi poscia, verifico la validità dell'ABI */
            SELECT COUNT(1)
          INTO N_CONT
          FROM DB_TIPO_BANCA JJ
          WHERE JJ.DATA_FINE_VALIDITA IS NULL
          AND JJ.ID_BANCA=N_ID_BANCA;

          IF N_CONT=0 THEN
               RAISE ERR_NO_ABI_ALL;
          END IF;

      END LOOP;

   ELSE
         /* controllo un unico c/c */
         /* verifico la validità del CAB */
      BEGIN
          SELECT KK.ID_BANCA
          INTO N_ID_BANCA
          FROM DB_TIPO_SPORTELLO KK
          WHERE KK.DATA_FINE_VALIDITA IS NULL
          AND KK.ID_SPORTELLO=P_ID_SPORTELLO;
      EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 RAISE ERR_NO_CAB;
      END;

      /* indi poscia, verifico la validità dell'ABI */
        SELECT COUNT(1)
      INTO N_CONT
      FROM DB_TIPO_BANCA JJ
      WHERE JJ.DATA_FINE_VALIDITA IS NULL
      AND JJ.ID_BANCA=N_ID_BANCA;

      IF N_CONT=0 THEN
           RAISE ERR_NO_ABI;
      END IF;

   END IF;

   p_result := RET_OK;
   p_msg    := '';
   p_id_err := NULL;

  EXCEPTION
    WHEN ERR_NO_CAB_ALL THEN
      p_result  :=  RET_ERR_CNTL;
      p_msg     :=  fncMessaggioErrore(1807);
      p_id_err  :=  1807;
    WHEN ERR_NO_ABI_ALL THEN
      p_result  :=  RET_ERR_CNTL;
      p_msg     :=  fncMessaggioErrore(1808);
      p_id_err  :=  1808;
    WHEN ERR_NO_CAB THEN
      p_result  :=  RET_ERR_CNTL;
      p_msg     :=  fncMessaggioErrore(1805);
      p_id_err  :=  1805;
    WHEN ERR_NO_ABI THEN
      p_result  :=  RET_ERR_CNTL;
      p_msg     :=  fncMessaggioErrore(1806);
      p_id_err  :=  1806;
    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [CNC01] ' || SQLERRM;
      p_id_err  := 1;

END CNC01;

PROCEDURE CNC02(p_id_azienda DB_AZIENDA.ID_AZIENDA%TYPE,
                p_result       OUT VARCHAR2,
                p_msg          OUT VARCHAR2,
                p_id_err       OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- Controllo che il cin dei conti correnti attivi dell'azienda non siano '*'
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------

  N_CONT                INTEGER;
  N_ID_BANCA            DB_TIPO_SPORTELLO.ID_BANCA%TYPE;
  N_ID_SPORTELLO        DB_TIPO_SPORTELLO.ID_SPORTELLO%TYPE;


  ERR_NO_CAB_ALL        EXCEPTION;
  ERR_NO_ABI_ALL        EXCEPTION;
  ERR_CIN                EXCEPTION;

CURSOR C_CC IS
  SELECT KK.ID_SPORTELLO, C.CIN
  FROM DB_CONTO_CORRENTE C, DB_TIPO_SPORTELLO KK
  WHERE C.ID_AZIENDA=P_ID_AZIENDA
  AND C.DATA_FINE_VALIDITA IS NULL
  AND C.DATA_ESTINZIONE IS NULL
  AND C.ID_SPORTELLO=KK.ID_SPORTELLO;


  BEGIN


  FOR REC_CC IN C_CC LOOP

         /* ciclo su tutti i c/c dell'azienda */
      N_ID_SPORTELLO:=REC_CC.ID_SPORTELLO;

         /* verifico la validità del CAB */
      BEGIN
          SELECT KK.ID_BANCA
          INTO N_ID_BANCA
          FROM DB_TIPO_SPORTELLO KK
          WHERE KK.DATA_FINE_VALIDITA IS NULL
          AND KK.ID_SPORTELLO=N_ID_SPORTELLO;
      EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 RAISE ERR_NO_CAB_ALL;
      END;

      /* indi poscia, verifico la validità dell'ABI */
        SELECT COUNT(1)
      INTO N_CONT
      FROM DB_TIPO_BANCA JJ
      WHERE JJ.DATA_FINE_VALIDITA IS NULL
      AND JJ.ID_BANCA=N_ID_BANCA;

      IF N_CONT=0 THEN
           RAISE ERR_NO_ABI_ALL;
      END IF;

      IF NVL(REC_CC.CIN,' ')='*' THEN
           RAISE ERR_CIN;
      END IF;

  END LOOP;


   p_result := RET_OK;
   p_msg    := '';
   p_id_err := NULL;

  EXCEPTION
    WHEN ERR_NO_CAB_ALL THEN
      p_result  :=  RET_ERR_CNTL;
      p_msg     :=  fncMessaggioErrore(1844);
      p_id_err  :=  1844;
    WHEN ERR_NO_ABI_ALL THEN
      p_result  :=  RET_ERR_CNTL;
      p_msg     :=  fncMessaggioErrore(1845);
      p_id_err  :=  1845;
    WHEN ERR_CIN THEN
      p_result  :=  RET_ERR_CNTL;
      p_msg     :=  fncMessaggioErrore(1846);
      p_id_err  :=  1846;
    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [CNC02] ' || SQLERRM;
      p_id_err  := 1;

END CNC02;

PROCEDURE CNC03(p_id_azienda DB_AZIENDA.ID_AZIENDA%TYPE,
                p_result       OUT VARCHAR2,
                p_msg          OUT VARCHAR2,
                p_id_err       OUT NUMBER) IS

  ----------------------------------------------------------------------
  -- Purpose :
  -- Controllo che il codice IBAN dei conti correnti attivi dell'azienda siano valorizzati
  --
  -- Parameters:
  -- p_id_azienda: identificativo dell'azienda in esame
  -- p_result : risultato dell'operazione ('0' se termina correttamente. '1' altrimenti )
  -- p_msg: messaggio di errore se la procedura non termina correttamente
  -- p_id_err      : identificativo dell'errore codificato su SMRCOMUNE.DB_MESSAGGIO_ERRORE
  --
  ----------------------------------------------------------------------

  N_CONT                INTEGER;
  N_ID_BANCA            DB_TIPO_SPORTELLO.ID_BANCA%TYPE;
  N_ID_SPORTELLO        DB_TIPO_SPORTELLO.ID_SPORTELLO%TYPE;


  ERR_NO_CAB_ALL        EXCEPTION;
  ERR_NO_ABI_ALL        EXCEPTION;
  ERR_IBAN                EXCEPTION;

CURSOR C_CC IS
  SELECT KK.ID_SPORTELLO, C.IBAN
  FROM DB_CONTO_CORRENTE C, DB_TIPO_SPORTELLO KK
  WHERE C.ID_AZIENDA=P_ID_AZIENDA
  AND C.DATA_FINE_VALIDITA IS NULL
  AND C.DATA_ESTINZIONE IS NULL
  AND C.ID_SPORTELLO=KK.ID_SPORTELLO;


  BEGIN


  FOR REC_CC IN C_CC LOOP

         /* ciclo su tutti i c/c dell'azienda */
      N_ID_SPORTELLO:=REC_CC.ID_SPORTELLO;

         /* verifico la validità del CAB */
      BEGIN
          SELECT KK.ID_BANCA
          INTO N_ID_BANCA
          FROM DB_TIPO_SPORTELLO KK
          WHERE KK.DATA_FINE_VALIDITA IS NULL
          AND KK.ID_SPORTELLO=N_ID_SPORTELLO;
      EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 RAISE ERR_NO_CAB_ALL;
      END;

      /* indi poscia, verifico la validità dell'ABI */
        SELECT COUNT(1)
      INTO N_CONT
      FROM DB_TIPO_BANCA JJ
      WHERE JJ.DATA_FINE_VALIDITA IS NULL
      AND JJ.ID_BANCA=N_ID_BANCA;

      IF N_CONT=0 THEN
           RAISE ERR_NO_ABI_ALL;
      END IF;

      IF REC_CC.IBAN IS NULL THEN
           RAISE ERR_IBAN;
      END IF;

  END LOOP;


   p_result := RET_OK;
   p_msg    := '';
   p_id_err := NULL;

  EXCEPTION
    WHEN ERR_NO_CAB_ALL THEN
      p_result  :=  RET_ERR_CNTL;
      p_msg     :=  fncMessaggioErrore(2050);
      p_id_err  :=  2050;
    WHEN ERR_NO_ABI_ALL THEN
      p_result  :=  RET_ERR_CNTL;
      p_msg     :=  fncMessaggioErrore(2051);
      p_id_err  :=  2051;
    WHEN ERR_IBAN THEN
      p_result  :=  RET_ERR_CNTL;
      p_msg     :=  fncMessaggioErrore(2052);
      p_id_err  :=  2052;
    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [CNC03] ' || SQLERRM;
      p_id_err  := 1;

END CNC03;

/* controllo che verifica la presenza degli allevamenti nella base dati SIAN */
PROCEDURE ALL05(p_id_azienda DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                  p_cuaa DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS


     vFlagPresenzaALL_SIAN   DB_ALLEVAMENTI_SIAN.FLAG_PRESENZA_SIAN%TYPE;
     vMessaggioErrore         DB_ALLEVAMENTI_SIAN.MESSAGGIO_ERRORE%TYPE;
--     vCodAzZootSIAN              DB_ALLEVAMENTI_SIAN.CODICE_AZIENDA %TYPE;
     vCodAzZootALLEV           DB_ALLEVAMENTO.CODICE_AZIENDA_ZOOTECNICA%TYPE;

     N_CONT                     INTEGER;
     FLAG_FOUND                 BOOLEAN:=TRUE;

     elencoCodici             VARCHAR2(1000):='';

CURSOR C_ALLEV IS
      SELECT DISTINCT TRIM(Allev.CODICE_AZIENDA_ZOOTECNICA) CODICE_AZIENDA_ZOOTECNICA
      FROM DB_ANAGRAFICA_AZIENDA Az, DB_UTE Ut, DB_ALLEVAMENTO Allev
      WHERE Az.ID_AZIENDA = p_id_azienda
      AND AZ.DATA_FINE_VALIDITA IS NULL
      AND Az.ID_AZIENDA=Ut.ID_AZIENDA
      AND Ut.DATA_FINE_ATTIVITA IS NULL
      AND Ut.ID_UTE=Allev.ID_UTE
      AND Allev.DATA_FINE IS NULL
      AND Allev.CODICE_AZIENDA_ZOOTECNICA IS NOT NULL;


  BEGIN

       p_result := RET_OK;
     p_id_err := NULL;

     /* eseguo il controllo solo se l'azienda ha allevamenti attivi con codice valorizzato */
      SELECT COUNT(1)
      INTO N_CONT
      FROM DB_ANAGRAFICA_AZIENDA Az, DB_UTE Ut, DB_ALLEVAMENTO Allev
      WHERE Az.ID_AZIENDA = p_id_azienda
      AND AZ.DATA_FINE_VALIDITA IS NULL
      AND Az.ID_AZIENDA=Ut.ID_AZIENDA
      AND Ut.DATA_FINE_ATTIVITA IS NULL
      AND Ut.ID_UTE=Allev.ID_UTE
      AND Allev.DATA_FINE IS NULL
      AND Allev.CODICE_AZIENDA_ZOOTECNICA IS NOT NULL;

      IF N_CONT > 0 THEN

          /* ricerco il record dell'azienda */
          SELECT DISTINCT FLAG_PRESENZA_SIAN, A.MESSAGGIO_ERRORE
          INTO vFlagPresenzaALL_SIAN, vMessaggioErrore
          FROM DB_ALLEVAMENTI_SIAN A
          WHERE CUAA = p_cuaa;

          IF ( vFlagPresenzaALL_SIAN = 'S' ) THEN

              /* ciclo su tutti gli allevamenti attivi dell'azienda. Se ne trovo uno che non ritrovo nella BDN esco e segnalo errore */
              FOR REC_ALLEV IN C_ALLEV LOOP

                  vCodAzZootALLEV:=REC_ALLEV.CODICE_AZIENDA_ZOOTECNICA;

                  SELECT COUNT(1)
                  INTO N_CONT
                  FROM DB_ALLEVAMENTI_SIAN A
                  WHERE CUAA = p_cuaa
                  AND NVL(TRIM(A.CODICE_AZIENDA),'#')=vCodAzZootALLEV;

                  IF N_CONT=0 THEN
                       FLAG_FOUND:=FALSE;
                       elencoCodici:=elencoCodici||vCodAzZootALLEV||';';
                  END IF;

              END LOOP;

              IF NOT FLAG_FOUND THEN
                   p_result := RET_ERR_CNTL;
                    p_msg    := fncMessaggioErrore(2058)||' - Codici :'||elencoCodici;
                    p_id_err := 2058;
              END IF;

          ELSIF vFlagPresenzaALL_SIAN = 'N'  THEN
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(2059);
                p_id_err := 2059;
          ELSE -- 'E'
             p_result := RET_ERR_CNTL;
                p_msg    := fncMessaggioErrore(2060) || ' ' || vMessaggioErrore;
                p_id_err := 2060;
          END IF;
     END IF;

  EXCEPTION
    WHEN NO_DATA_FOUND THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(2057);
            p_id_err := 2057;
    WHEN TOO_MANY_ROWS THEN
         p_result := RET_ERR_CNTL;
            p_msg    := fncMessaggioErrore(2057);
            p_id_err := 2057;
    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [ALL05] ' || SQLERRM;
      p_id_err  := 1;

--
END ALL05;

/* controllo che verifica che gli allevamenti nella base dati SIAN siano allevamenti attivi dell'azienda */
PROCEDURE ALL06(p_id_azienda IN DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE,
                  p_cuaa       IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                p_result     OUT VARCHAR2,
                p_msg        OUT VARCHAR2,
                p_id_err     OUT NUMBER) IS

     bAllevAnomalo      BOOLEAN:=FALSE;
     vIdRegione         REGIONE.ID_REGIONE%TYPE:='01';
     vElencoAziendeZoo  VARCHAR2(2000);

       /* ciclo solo sui record con 'S'!!! (Tanto o ci sono n record con 'S' o uno solo con 'E' o 'N' */
      -- e' a null controllo tutti gli allevamenti dell'azienda
      -- altrimenti solo quelli della regione (PIEMONTE) passata in input
      CURSOR C_ALLEV_BDN (pIdRegione IN REGIONE.ID_REGIONE%TYPE) IS
      SELECT A.CODICE_AZIENDA,
             A.CODICE_SPECIE,
             STS.DESCRIZIONE
        FROM DB_ALLEVAMENTI_SIAN A,
             DB_SIAN_TIPO_SPECIE STS
       WHERE A.CUAA = p_cuaa
         AND A.FLAG_PRESENZA_SIAN = 'S'
         AND A.CODICE_SPECIE = STS.CODICE_SPECIE
         AND (pIdRegione IS NULL OR
             (pIdRegione IS NOT NULL AND
              SUBSTR(A.CODICE_AZIENDA,4,2) IN (SELECT SIGLA_PROVINCIA
                                                 FROM PROVINCIA
                                                WHERE ID_REGIONE = pIdRegione)))
         AND NOT EXISTS (SELECT AL.ID_ALLEVAMENTO
                           FROM DB_UTE UT,
                                DB_ALLEVAMENTO AL,
                                DB_R_SPECIE_AN_SIAN_SIAP SASP
                          WHERE UT.ID_AZIENDA = p_id_azienda
                            AND UT.DATA_FINE_ATTIVITA IS NULL
                            AND UT.ID_UTE = AL.ID_UTE
                            AND AL.ID_SPECIE_ANIMALE = SASP.ID_SPECIE_ANIMALE
                            AND SASP.CODICE_SPECIE = A.CODICE_SPECIE
                            AND SASP.FLAG_RELAZIONE_ATTIVA = 'S'
                            AND AL.DATA_FINE IS NULL
                            AND AL.CODICE_AZIENDA_ZOOTECNICA = A.CODICE_AZIENDA);
BEGIN

     -- se il fascicolo e' di competenza piemontese
     -- tutti gli allevamenti di BDN devono esser anche in anagrafe
     IF IsAziendaInOprPiemonte (p_id_azienda) THEN
        vIdRegione := NULL;
     ELSE
        -- altrimenti verifichiamo che solo tutti gli allevamenti
        -- del PIEMONTE presenti in BDN siano anche in anagrafe
        -- e non quelli delle altre regioni ...
        vIdRegione := '01';
     END IF;

       p_result := RET_OK;
     p_id_err := NULL;
     AccodaMessaggio(vElencoAziendeZoo,fncMessaggioErrore(2061) || ' - Codice/Specie : ');
     FOR REC_ALLEV_BDN IN C_ALLEV_BDN (vIdRegione)LOOP
         AccodaMessaggio(vElencoAziendeZoo, ' ' || REC_ALLEV_BDN.CODICE_AZIENDA || '/' || REC_ALLEV_BDN.DESCRIZIONE);
         bAllevAnomalo := TRUE;
     END LOOP;

     IF bAllevAnomalo THEN
          p_result := RET_ERR_CNTL;
           p_msg    := vElencoAziendeZoo;
           p_id_err := 2061;
     END IF;

EXCEPTION
    WHEN OTHERS THEN
      p_result  := RET_ERR;
      p_msg     := fncMessaggioErrore(1) || ' [ALL06] ' || SQLERRM;
      p_id_err  := 1;
END ALL06;

-- verifica che l'azienda abbia fatto validazione
-- dopo aver consolidato il gis delle UV
PROCEDURE VAL03(p_id_azienda    IN  DB_AZIENDA.ID_AZIENDA%TYPE,
                p_id_proc       IN  DB_MOTIVO_ESCLUSO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE,
                p_result        OUT VARCHAR2,
                p_msg           OUT VARCHAR2,
                p_id_err        OUT NUMBER) IS

    nRec            INTEGER:=0;
    dDataApp        DATE;
    recTpCtrlParam  DB_TIPO_CONTROLLO_PARAMETRO%ROWTYPE;
    dDataOffSet     DATE;

BEGIN

    -- cerco su DB_TIPO_CONTROLLO_PARAMETRO il parametro del controllo contenente la data fino alla quale
    -- eseguire il controllo
    recTpCtrlParam := SelValoreParametroCtrlByCodice (knIdControlloVal03, kvCodParControlloVal03);

    IF recTpCtrlParam.ID_CONTROLLO_PARAMETRO IS NOT NULL THEN
       BEGIN
           dDataOffSet := NVL(TO_DATE(recTpCtrlParam.VALORE_STRINGA,'DD/MM/YYYY'), TO_DATE('31/01/2014','DD/MM/YYYY'));
       EXCEPTION
           WHEN OTHERS THEN
                dDataOffSet := TO_DATE('31/01/2014','DD/MM/YYYY');
       END;
    ELSE
       dDataOffSet := TO_DATE('31/01/2014','DD/MM/YYYY');
    END IF;

    -- controllo se l'azienda ha almeno un UV
    SELECT COUNT(ID_STORICO_UNITA_ARBOREA)
      INTO nRec
      FROM DB_STORICO_UNITA_ARBOREA
     WHERE ID_AZIENDA = p_id_azienda
       AND DATA_FINE_VALIDITA IS NULL
       AND ROWNUM < 2;

     -- se si
     IF nRec > 0 THEN
        -- controllo se l'azienda ha validato dopo la data offset
        SELECT COUNT(DC.ID_DICHIARAZIONE_CONSISTENZA)
          INTO nRec
          FROM DB_DICHIARAZIONE_CONSISTENZA DC,
               DB_TIPO_MOTIVO_DICHIARAZIONE MD
         WHERE DC.ID_AZIENDA = p_id_azienda
           AND DC.ID_MOTIVO_DICHIARAZIONE = MD.ID_MOTIVO_DICHIARAZIONE
           AND MD.TIPO_DICHIARAZIONE NOT IN ('C', 'R')
           -- AND DC.NUMERO_PROTOCOLLO IS NOT NULL
           AND DC.DATA_INSERIMENTO_DICHIARAZIONE > dDataOffSet
           AND MD.ID_MOTIVO_DICHIARAZIONE NOT IN (SELECT ID_MOTIVO_DICHIARAZIONE
                                                    FROM DB_MOTIVO_ESCLUSO_PROCEDIMENTO
                                                   WHERE ID_PROCEDIMENTO = p_id_proc);
        -- se non l'ha fatto
        IF nRec = 0 THEN
            -- controllo se ha consolidato
            SELECT MAX(CA.DATA_CONSOLIDAMENTO_GIS)
              INTO dDataApp
              FROM DB_COMPENSAZIONE_AZIENDA CA
             WHERE CA.ID_AZIENDA = p_id_azienda
               AND CA.DATA_FINE_VALIDITA IS NULL
               AND CA.DATA_CONSOLIDAMENTO_GIS IS NOT NULL;

           -- se ha consolidato
           IF dDataApp IS NOT NULL THEN
              -- controllo se ha validato dopo il consolidamento
              SELECT COUNT(DC.ID_DICHIARAZIONE_CONSISTENZA)
                INTO nRec
                FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                     DB_TIPO_MOTIVO_DICHIARAZIONE MD
               WHERE DC.ID_AZIENDA = p_id_azienda
                 AND DC.ID_MOTIVO_DICHIARAZIONE = MD.ID_MOTIVO_DICHIARAZIONE
                 AND MD.TIPO_DICHIARAZIONE NOT IN ('C', 'R')
                 AND DC.NUMERO_PROTOCOLLO IS NOT NULL
                 AND DC.DATA_INSERIMENTO_DICHIARAZIONE > dDataApp
                 AND MD.ID_MOTIVO_DICHIARAZIONE NOT IN (SELECT ID_MOTIVO_DICHIARAZIONE
                                                          FROM DB_MOTIVO_ESCLUSO_PROCEDIMENTO
                                                         WHERE ID_PROCEDIMENTO = p_id_proc);
               -- se non ha validato neppure dopo il consolidamento
               -- non va bene
               IF nRec = 0 THEN
                  p_result := RET_ERR_CNTL;
                  p_msg    := fncMessaggioErrore(3530);
                  p_id_err := 3530;
               ELSE
                  -- se ha validato dopo il consolidamento va bene
                  p_result := RET_OK;
                  p_msg    := NULL;
                  p_id_err := NULL;
               END IF;
           ELSE
               -- se non ha consolidato non va bene
               -- in quanto comunque non ha validato dopo la data offset
               p_result := RET_ERR_CNTL;
               p_msg    := fncMessaggioErrore(3530);
               p_id_err := 3530;
           END IF;
        ELSE
           -- se ha validato dopo la data offset va bene
           p_result := RET_OK;
           p_msg    := NULL;
           p_id_err := NULL;
        END IF;
     ELSE
        -- se l'azienda non ha u.v. il controllo
        -- e' verificato
        p_result := RET_OK;
        p_msg    := NULL;
        p_id_err := NULL;
     END IF;

EXCEPTION
  WHEN OTHERS THEN
      p_result := RET_ERR;
      p_msg    := fncMessaggioErrore(1) || ' [VAL03] ' || SQLERRM;
      p_id_err := 1;
END VAL03;


FUNCTION IBAN_OK(pIban    IN  VARCHAR2, -- IBAN,
                 pErrCode OUT VARCHAR2)
RETURN BOOLEAN IS
    nLengthIban     NUMBER(2); -- lunghezza della stringa IBAN
    vIbanSwapped    VARCHAR2(34); -- IBAN swapped
    nAsciiCode      NUMBER(3); -- codice ascii del carattere
    nCodAsciiNorm   NUMBER(2); -- code ascii del carattere normalizzato
                               -- per essere compreso tra 0 e 35
    nRestoDiv       PLS_INTEGER := 0; -- resto della divisione x 97
BEGIN
    -- controllo la lunghezza
    nLengthIban := LENGTH(pIban);
    IF pIban IS NULL THEN
       pErrCode := 'Codice Iban non valorizzato';
       RETURN FALSE;
    ELSIF nLengthIban NOT BETWEEN 5 AND 34 THEN
       pErrCode := 'Lunghezza Codice Iban errata (< 5 o > 34)';
       RETURN FALSE;
    END IF;

    -- concateno i primi 4 caratteri dell'iban al fondo
    -- dei restanti
    vIbanSwapped := SUBSTR(pIban, 5, nLengthIban-4) || SUBSTR(pIban, 1, 4);

    -- ciclo sulla stringa iban
    FOR i IN 1 .. nLengthIban LOOP

        -- prendo il codice ASCII del carattere
        nAsciiCode := ASCII(SUBSTR(vIbanSwapped, I, 1) );

        -- trasformo il codice ascii nel numero
        -- corrispondente da 0 a 35 quindi
        -- per i numeri sottraggo 48
        IF nAsciiCode BETWEEN 48 AND 57 THEN
           IF i BETWEEN nLengthIban-3 AND nLengthIban-2 THEN
              pErrCode := 'Codice Iban errato caratteri in posizione 1 e 2 non alfabetici';
              RETURN FALSE;
           END IF;
           nCodAsciiNorm := nAsciiCode - 48;
           -- trasformo il codice ascii nel numero
           -- corrispondente da 0 a 35 quindi
           -- per le lettere sottraggo 55 (A=10 , B= 11, C= 12, etc, Z=35)
        ELSIF nAsciiCode BETWEEN 65 AND 90 THEN
           -- le ultime due lettere devono essere per
           -- forza un numero
           IF I BETWEEN nLengthIban-1 AND nLengthIban THEN
              pErrCode := 'Codice Iban errato caratteri in posizione 3 e 4 non numerici';
              RETURN FALSE;
           END IF;
           nCodAsciiNorm := nAsciiCode - 55;
        ELSE
           pErrCode := 'Il codice Iban contiene caratteri non ammessi';
           RETURN FALSE;
        END IF;

        -- cumulo il resto della divisione
        -- per 97 della cifra che ho ricavato dal codice ascii
        -- del carattere
        IF nCodAsciiNorm > 9 THEN
           nRestoDiv := (100 * nRestoDiv + nCodAsciiNorm) MOD 97;
        ELSE
           nRestoDiv := (10 * nRestoDiv + nCodAsciiNorm) MOD 97;
        END IF;

    END LOOP;

    -- se il resto della divisione è <> 1 vuol dire
    -- che il codice iban non è corretto
    IF nRestoDiv <> 1 THEN
        pErrCode := 'Controllo sul check digits di IBAN fallito.';
        RETURN FALSE;
    END IF;

    RETURN TRUE;

EXCEPTION
    WHEN OTHERS THEN
         pErrCode := 'Errore oracle in function IBAN_OK : ' || SQLCODE || ' - ' || SUBSTR(SQLERRM,1,150);
         RETURN FALSE;
END IBAN_OK;



END Pack_Controlli;

/
--------------------------------------------------------
--  DDL for Package Body PACK_CONTROLLI_PARTICELLARE
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PACK_CONTROLLI_PARTICELLARE" IS


N_COUNT_BLOCCANTI        NUMBER(5):=0;
N_COUNT_ANOMALIE        NUMBER(5):=0;
ERRORE                    EXCEPTION;
N_ID_PARTICELLA            DB_PARTICELLA.ID_PARTICELLA%TYPE;
ter01_bloccante       DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE;
ter02_bloccante       DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE;
ter03_bloccante       DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE;
ter04_bloccante       DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE;
ter05_bloccante       DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE;
ter06_bloccante       DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE;
ter07_bloccante       DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE;
ter08_bloccante       DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE;
ter01_id_controllo       DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE;
ter02_id_controllo       DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE;
ter03_id_controllo       DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE;
ter04_id_controllo       DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE;
ter05_id_controllo       DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE;
ter06_id_controllo       DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE;
ter07_id_controllo       DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE;
ter08_id_controllo       DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE;

ter01_obbligatorio       DB_TIPO_CONTROLLO.OBBLIGATORIO%TYPE;
ter02_obbligatorio       DB_TIPO_CONTROLLO.OBBLIGATORIO%TYPE;
ter03_obbligatorio       DB_TIPO_CONTROLLO.OBBLIGATORIO%TYPE;
ter04_obbligatorio       DB_TIPO_CONTROLLO.OBBLIGATORIO%TYPE;
ter05_obbligatorio       DB_TIPO_CONTROLLO.OBBLIGATORIO%TYPE;
ter06_obbligatorio       DB_TIPO_CONTROLLO.OBBLIGATORIO%TYPE;
ter07_obbligatorio       DB_TIPO_CONTROLLO.OBBLIGATORIO%TYPE;
ter08_obbligatorio       DB_TIPO_CONTROLLO.OBBLIGATORIO%TYPE;


FUNCTION SCRIVI_SEGNALAZIONE (P_ID_CONDUZIONE_PARTICELLA   IN     DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE,
                               P_ID_CONTROLLO IN     DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                              P_DESCRIZIONE     IN     DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE,
                              P_BLOCCANTE     IN     DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                  P_MSGERR       IN OUT VARCHAR2,
                              P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

BEGIN

      INSERT INTO DB_ESITO_CONTROLLO_PARTICELLA (ID_ESITO_CONTROLLO_PARTICELLA,
     ID_CONDUZIONE_PARTICELLA, ID_CONTROLLO,bloccante, DESCRIZIONE) VALUES
     (SEQ_ESITO_CONTROLLO_PARTICELLA.NEXTVAL, P_ID_CONDUZIONE_PARTICELLA, P_ID_CONTROLLO,P_BLOCCANTE,
     P_DESCRIZIONE);

     IF P_BLOCCANTE = 'S' THEN
         N_COUNT_BLOCCANTI := N_COUNT_BLOCCANTI + 1;
     ELSE
         N_COUNT_ANOMALIE  := N_COUNT_ANOMALIE + 1;
     END IF;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE SCRIVI_SEGNALAZIONE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END SCRIVI_SEGNALAZIONE;





FUNCTION CANCELLA_ANOMALIE (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                            P_MSGERR       IN OUT VARCHAR2,
                            P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS
BEGIN


     UPDATE DB_CONDUZIONE_PARTICELLA SET esito_controllo=NULL WHERE id_conduzione_particella IN
     ( SELECT D.ID_CONDUZIONE_PARTICELLA
         FROM DB_UTE A, DB_CONDUZIONE_PARTICELLA D
         WHERE A.ID_UTE = D.ID_UTE
           AND A.ID_AZIENDA = P_ID_AZIENDA);

     DELETE FROM DB_ESITO_CONTROLLO_PARTICELLA WHERE id_conduzione_particella IN
     ( SELECT D.ID_CONDUZIONE_PARTICELLA
         FROM DB_UTE A, DB_CONDUZIONE_PARTICELLA D
         WHERE A.ID_UTE = D.ID_UTE
           AND A.ID_AZIENDA = P_ID_AZIENDA);

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CANCELLA_ANOMALIE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CANCELLA_ANOMALIE;


FUNCTION CONTROLLA_SUPERO (P_ID_UTE   IN      DB_UTE.ID_UTE%TYPE,
                          P_ID_AZIENDA IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                            P_MSGERR       IN OUT VARCHAR2,
                           P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS
CURSOR C_particelle IS
     SELECT A.ID_PARTICELLA, A.SUP_CATASTALE, B.SUPERFICIE_CONDOTTA + SUM(E.SUPERFICIE_CONDOTTA) AS SUP_TOTALE
FROM DB_STORICO_PARTICELLA a, DB_CONDUZIONE_PARTICELLA b,DB_DICHIARAZIONE_CONSISTENZA d, DB_CONDUZIONE_DICHIARATA e,
     DB_ANAGRAFICA_AZIENDA F, DB_AZIENDA G
WHERE a.id_particella = b.id_particella
  AND A.DATA_FINE_VALIDITA IS NULL
  AND b.data_fine_conduzione IS NULL
  AND B.id_ute = P_id_ute
  AND a.id_particella = e.id_particella
  AND D.CODICE_FOTOGRAFIA_TERRENI = E.CODICE_FOTOGRAFIA_TERRENI
  AND F.ID_AZIENDA = G.ID_AZIENDA
  AND F.DATA_FINE_VALIDITA IS NULL
  AND (G.FLAG_AZIENDA_PROVVISORIA IS NULL OR G.FLAG_AZIENDA_PROVVISORIA = 'N')
  AND d.ID_DICHIARAZIONE_CONSISTENZA = (SELECT MAX(ID_DICHIARAZIONE_CONSISTENZA) FROM DB_DICHIARAZIONE_CONSISTENZA WHERE id_azienda = d.id_azienda
                                           AND ID_AZIENDA <> P_ID_AZIENDA)
GROUP BY A.ID_PARTICELLA,A.SUP_CATASTALE, B.SUPERFICIE_CONDOTTA
HAVING A.SUP_CATASTALE < B.SUPERFICIE_CONDOTTA + SUM(E.SUPERFICIE_CONDOTTA);

CURSOR C_AZI_SUPERO IS
   SELECT C.CUAA, C.DENOMINAZIONE, A.SUPERFICIE_CONDOTTA, F.CODICE_FISCALE AS CAA
FROM DB_CONDUZIONE_DICHIARATA A, DB_DICHIARAZIONE_CONSISTENZA B, DB_ANAGRAFICA_AZIENDA C, DB_AZIENDA D, DB_DELEGA E, DB_INTERMEDIARIO F
WHERE A.ID_PARTICELLA = N_ID_PARTICELLA
  AND A.CODICE_FOTOGRAFIA_TERRENI = B.CODICE_FOTOGRAFIA_TERRENI
  AND C.ID_AZIENDA = B.ID_AZIENDA
  AND C.DATA_FINE_VALIDITA IS NULL
  AND C.DATA_CESSAZIONE IS NULL
  AND D.ID_AZIENDA = C.ID_AZIENDA
  AND C.ID_AZIENDA <> P_ID_AZIENDA
  AND E.ID_AZIENDA(+) = D.ID_AZIENDA
  AND E.DATA_FINE IS NULL
  -- AND E.ID_PROCEDIMENTO = 7 
  AND E.ID_AZIENDA IS NOT NULL
  AND F.ID_INTERMEDIARIO = E.ID_INTERMEDIARIO
  AND B.ID_DICHIARAZIONE_CONSISTENZA = (SELECT MAX(ID_DICHIARAZIONE_CONSISTENZA) FROM DB_DICHIARAZIONE_CONSISTENZA WHERE id_azienda = b.id_azienda
                                           AND ID_AZIENDA <> P_ID_AZIENDA)
UNION
SELECT C.CUAA, C.DENOMINAZIONE, A.SUPERFICIE_CONDOTTA, 'ASSENTE' AS CAA
FROM DB_CONDUZIONE_DICHIARATA A, DB_DICHIARAZIONE_CONSISTENZA B, DB_ANAGRAFICA_AZIENDA C, DB_AZIENDA D
WHERE A.ID_PARTICELLA = N_ID_PARTICELLA
  AND A.CODICE_FOTOGRAFIA_TERRENI = B.CODICE_FOTOGRAFIA_TERRENI
  AND C.ID_AZIENDA = B.ID_AZIENDA
  AND C.DATA_FINE_VALIDITA IS NULL
  AND C.DATA_CESSAZIONE IS NULL
  AND D.ID_AZIENDA = C.ID_AZIENDA
  AND C.ID_AZIENDA <> P_ID_AZIENDA
  AND B.ID_DICHIARAZIONE_CONSISTENZA = (SELECT MAX(ID_DICHIARAZIONE_CONSISTENZA) FROM DB_DICHIARAZIONE_CONSISTENZA WHERE id_azienda = b.id_azienda
                                           AND ID_AZIENDA <> P_ID_AZIENDA)
  AND NOT EXISTS (SELECT ID_AZIENDA FROM DB_DELEGA WHERE ID_AZIENDA = D.ID_AZIENDA AND DATA_FINE IS NULL AND ID_PROCEDIMENTO = 7) ;


CURSOR C_CONDUZIONI IS
     SELECT ID_CONDUZIONE_PARTICELLA
     FROM DB_CONDUZIONE_PARTICELLA
     WHERE DATA_FINE_CONDUZIONE IS NULL
     AND ID_PARTICELLA = N_ID_PARTICELLA;


S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_DESC_AZIENDE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_CUAA                    DB_ANAGRAFICA_AZIENDA.CUAA%TYPE;
S_DENOMINAZIONE            DB_ANAGRAFICA_AZIENDA.DENOMINAZIONE%TYPE;
N_TOTALE_SUP_CONDOTTA    DB_CONDUZIONE_PARTICELLA.SUPERFICIE_CONDOTTA%TYPE;
S_DETENTORE_FASCICOLO    DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
var_differenza NUMBER(20,4);

N_LUNGHEZZA_DENOM NUMBER;
var_denominazione VARCHAR2(3000);

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_part IN C_particelle LOOP
        N_ID_PARTICELLA := REC_part.ID_PARTICELLA;

        N_TOTALE_SUP_CONDOTTA := REC_part.SUP_TOTALE;
        S_DESCRIZIONE := 'Supero pari a '||TRIM(TO_CHAR(N_TOTALE_SUP_CONDOTTA - NVL(REC_part.SUP_CATASTALE,0),'999G990D9999')) || ' ettari: ';
        FOR REC_AZI_SUPERO IN C_AZI_SUPERO LOOP
              -- SOMMO LE SUPERFICI CONDOTTE DELLE AZIENDE ATTIVECHE HANNO DICHIARATO QUELLA PARTICELLA
              N_LUNGHEZZA_DENOM := LENGTH(REC_AZI_SUPERO.DENOMINAZIONE);
              IF  LENGTH(REC_AZI_SUPERO.DENOMINAZIONE) > 50 THEN
                  VAR_DENOMINAZIONE :=  SUBSTR(REC_AZI_SUPERO.DENOMINAZIONE,1,50);
              ELSE
                    VAR_DENOMINAZIONE :=  REC_AZI_SUPERO.DENOMINAZIONE;
              END IF;
              S_DETENTORE_FASCICOLO :='(CAA: '||REC_AZI_SUPERO.CAA||')';
              S_DESC_AZIENDE     := S_DESC_AZIENDE     ||
                                  REC_AZI_SUPERO.CUAA||'-'||VAR_DENOMINAZIONE || S_DETENTORE_FASCICOLO
                                  ||' ha dichiarato di condurre  '||TRIM(TO_CHAR(NVL(REC_AZI_SUPERO.supERFICIE_condotta,0),'999G990D9999')) ||' ha. ';
        END LOOP;

        S_DESCRIZIONE := S_DESCRIZIONE || ' ' ||S_DESC_AZIENDE;
        FOR rec_cond IN c_conduzioni
        LOOP
            IF NOT SCRIVI_SEGNALAZIONE (REC_COND.ID_CONDUZIONE_PARTICELLA, ter02_id_controllo, S_DESCRIZIONE,
                     ter02_bloccante, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
            END IF;
        END LOOP;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_SUPERO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLA_SUPERO;

FUNCTION CONTROLLA_SUPERO_CATASTALE (P_ID_UTE   IN      DB_UTE.ID_UTE%TYPE,
                            P_MSGERR       IN OUT VARCHAR2,
                           P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS
CURSOR C_particelle IS
     SELECT SP.ID_PARTICELLA, C.DESCOM, SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA, SP.SUBALTERNO, SP.SUP_CATASTALE,
             SUM(SUPERFICIE_CONDOTTA) AS SUPERFICIE_CONDOTTA_AZ
     FROM DB_STORICO_PARTICELLA SP, DB_CONDUZIONE_PARTICELLA D, COMUNE C
     WHERE D.ID_UTE=P_ID_UTE
       AND SP.DATA_FINE_VALIDITA IS NULL
       AND D.DATA_FINE_CONDUZIONE IS NULL
       AND SP.ID_PARTICELLA = D.ID_PARTICELLA
       AND SP.COMUNE=C.ISTAT_COMUNE
     GROUP BY SP.ID_PARTICELLA, C.DESCOM, SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA, SP.SUBALTERNO, SP.SUP_CATASTALE
     HAVING SUM(SUPERFICIE_CONDOTTA)> SP.SUP_CATASTALE;

CURSOR C_CONDUZIONI IS
     SELECT ID_CONDUZIONE_PARTICELLA
     FROM DB_CONDUZIONE_PARTICELLA
     WHERE DATA_FINE_CONDUZIONE IS NULL
     AND ID_PARTICELLA = N_ID_PARTICELLA;

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
var_differenza NUMBER(20,4);

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_part IN C_particelle LOOP
        N_ID_PARTICELLA := REC_part.id_particella;
        var_differenza := NVL(REC_part.SUPERFICIE_CONDOTTA_az,0) - NVL(REC_part.SUP_CATASTALE,0);
             S_DESCRIZIONE := 'La superficie condotta dichiarata supera la superficie catastale di '||
                              TRIM(TO_CHAR(var_differenza,'999G990D9999')) || ' ettari';
        FOR rec_cond IN c_conduzioni
        LOOP
            IF NOT SCRIVI_SEGNALAZIONE (rec_cond.id_conduzione_particella, ter03_id_controllo, S_DESCRIZIONE,
                     ter03_bloccante, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
            END IF;
        END LOOP;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_SUPERO_CATASTALE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLA_SUPERO_CATASTALE;



FUNCTION CONTROLLA_CONTENZIOSO (P_ID_UTE   IN      DB_UTE.ID_UTE%TYPE,
                                 P_MSGERR       IN OUT VARCHAR2,
                                P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS
CURSOR C_CONTENZIOSO IS
     SELECT a.ID_CONDUZIONE_PARTICELLA, B.DATA_CESSAZIONE DATA_CESSAZIONE
     FROM DB_CONDUZIONE_PARTICELLA A, DB_PARTICELLA B
     WHERE A.ID_PARTICELLA = B.ID_PARTICELLA
       AND A.ID_UTE=P_ID_UTE
       AND B.DATA_CESSAZIONE IS NOT NULL
       AND A.DATA_FINE_CONDUZIONE IS NULL;

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_CONTENZIOSO IN C_CONTENZIOSO LOOP

           S_DESCRIZIONE := 'La particella è stata CESSATA il ' ||
          TO_CHAR(REC_CONTENZIOSO.DATA_CESSAZIONE,'DD/MM/YYYY');

          IF NOT SCRIVI_SEGNALAZIONE (rec_contenzioso.id_conduzione_particella,ter01_id_controllo, S_DESCRIZIONE,
               ter01_bloccante, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;
     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_CONTENZIOSO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLA_CONTENZIOSO;


FUNCTION SUPERFICIE_USO_DEL_SUOLO (P_ID_UTE   IN      DB_UTE.ID_UTE%TYPE,
                                P_ANNO_RIF      IN     DB_UTILIZZO_PARTICELLA.ANNO%TYPE,
                                P_MSGERR       IN OUT VARCHAR2,
                               P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS
CURSOR C_CONDUZIONI IS
     SELECT D.ID_CONDUZIONE_PARTICELLA, D.SUPERFICIE_CONDOTTA
     FROM DB_CONDUZIONE_PARTICELLA D
     WHERE D.ID_UTE= P_ID_UTE
       AND D.DATA_FINE_CONDUZIONE IS NULL;

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_TOTALE_SUP_UTILIZZATA    DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_CONDUZIONI IN C_CONDUZIONI LOOP

         SELECT SUM (SUPERFICIE_UTILIZZATA)
         INTO    N_TOTALE_SUP_UTILIZZATA
         FROM    DB_UTILIZZO_PARTICELLA A
         WHERE
           A.ID_CONDUZIONE_PARTICELLA = REC_CONDUZIONI.ID_CONDUZIONE_PARTICELLA
           AND A.ANNO = P_ANNO_RIF;

         IF NVL(REC_CONDUZIONI.SUPERFICIE_CONDOTTA,0) < NVL(N_TOTALE_SUP_UTILIZZATA,0) THEN
                S_DESCRIZIONE := 'Uso del suolo specificato per ettari ' ||
                              TRIM(TO_CHAR(NVL(N_TOTALE_SUP_UTILIZZATA,0),'999G990D9999'))||
                              ' su una superficie condotta di '||
                              TRIM(TO_CHAR(NVL(REC_CONDUZIONI.SUPERFICIE_CONDOTTA,0),'999G990D9999'))||' ettari' ;
              IF TER06_OBBLIGATORIO='S' THEN
                  IF NOT SCRIVI_SEGNALAZIONE (REC_CONDUZIONI.ID_CONDUZIONE_PARTICELLA, ter06_id_controllo, S_DESCRIZIONE,
                       ter06_bloccante, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
              END IF;
         ELSIF NVL(REC_CONDUZIONI.SUPERFICIE_CONDOTTA,0) > NVL(N_TOTALE_SUP_UTILIZZATA,0) THEN
                S_DESCRIZIONE := 'Uso del suolo NON specificato per ettari ' ||
                              TRIM(TO_CHAR(NVL(REC_CONDUZIONI.SUPERFICIE_CONDOTTA,0)-NVL(N_TOTALE_SUP_UTILIZZATA,0),'999G990D9999'));
              IF TER04_OBBLIGATORIO='S' THEN
                   IF NOT SCRIVI_SEGNALAZIONE (REC_CONDUZIONI.ID_CONDUZIONE_PARTICELLA, ter04_id_controllo, S_DESCRIZIONE,
                        ter04_bloccante, P_MSGERR, P_CODERR) THEN
                      RETURN (FALSE);
                   END IF;
              END IF;
         END IF;

     END LOOP;

     RETURN (TRUE);
END;

FUNCTION USO_DEL_SUOLO_NON_VALIDO(P_ID_UTE   IN      DB_UTE.ID_UTE%TYPE,
                                    P_ANNO_RIF      IN     DB_UTILIZZO_PARTICELLA.ANNO%TYPE,
                                   P_MSGERR       IN OUT VARCHAR2,
                                   P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

CURSOR C_USO_NON_VALIDO IS
     SELECT B.ID_CONDUZIONE_PARTICELLA, D.DESCRIZIONE DESCRIZIONE_UTILIZZO , D.ANNO_FINE_VALIDITA,
            TD.DESCRIZIONE_DESTINAZIONE,TDU.DESCRIZIONE_DETTAGLIO_USO,TQU.DESCRIZIONE_QUALITA_USO,
            TV.DESCRIZIONE DESCRIZIONE_VARIETA
     FROM DB_CONDUZIONE_PARTICELLA B, DB_UTILIZZO_PARTICELLA C, DB_TIPO_UTILIZZO D,
          DB_R_CATALOGO_MATRICE CM,DB_TIPO_DESTINAZIONE TD,DB_TIPO_DETTAGLIO_USO TDU,
          DB_TIPO_QUALITA_USO TQU,DB_TIPO_VARIETA TV
     WHERE B.ID_UTE = P_ID_UTE
       AND B.ID_CONDUZIONE_PARTICELLA = C.ID_CONDUZIONE_PARTICELLA
       AND B.DATA_FINE_CONDUZIONE IS NULL                          
       AND C.ANNO = P_ANNO_RIF
       AND C.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE  
       AND CM.DATA_FINE_VALIDITA IS NULL 
       AND CM.ID_UTILIZZO = D.ID_UTILIZZO 
       AND CM.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE(+) 
       AND CM.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO(+) 
       AND CM.ID_TIPO_QUALITA_USO = TQU.ID_TIPO_QUALITA_USO(+) 
       AND CM.ID_VARIETA = TV.ID_VARIETA 
       --AND D.ID_UTILIZZO = C.ID_UTILIZZO
       --AND D.ANNO_FINE_VALIDITA IS NOT NULL
     GROUP BY B.ID_CONDUZIONE_PARTICELLA, D.DESCRIZIONE, D.ANNO_FINE_VALIDITA,
     TD.DESCRIZIONE_DESTINAZIONE,TDU.DESCRIZIONE_DETTAGLIO_USO,TQU.DESCRIZIONE_QUALITA_USO,
            TV.DESCRIZIONE;

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_USO_NON_VALIDO IN C_USO_NON_VALIDO LOOP

           S_DESCRIZIONE := 'L''USO DEL SUOLO ' || REC_USO_NON_VALIDO.DESCRIZIONE_UTILIZZO ||' - '||
         REC_USO_NON_VALIDO.DESCRIZIONE_DESTINAZIONE ||' - '||REC_USO_NON_VALIDO.DESCRIZIONE_DETTAGLIO_USO ||' - '||
         REC_USO_NON_VALIDO.DESCRIZIONE_QUALITA_USO ||' - '|| REC_USO_NON_VALIDO.DESCRIZIONE_VARIETA||
         ' NON E'' PIU'' VALIDO';

          IF NOT SCRIVI_SEGNALAZIONE (REC_USO_NON_VALIDO.ID_CONDUZIONE_PARTICELLA, ter05_id_controllo, S_DESCRIZIONE,
               ter05_bloccante, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE USO_DEL_SUOLO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END USO_DEL_SUOLO_NON_VALIDO;




FUNCTION CONTROLLA_PRESENZA_AGEA (P_ID_UTE   IN      DB_UTE.ID_UTE%TYPE,
                                 P_MSGERR       IN OUT VARCHAR2,
                                P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS
CURSOR C_MANCANTI IS
     SELECT CP.ID_CONDUZIONE_PARTICELLA
        FROM DB_CONDUZIONE_PARTICELLA CP, DB_STORICO_PARTICELLA SP
        WHERE CP.ID_UTE= P_ID_UTE AND CP.DATA_FINE_CONDUZIONE IS NULL
        AND CP.ID_PARTICELLA=SP.ID_PARTICELLA AND SP.DATA_FINE_VALIDITA IS NULL
        AND SUBSTR(SP.COMUNE,1,3) IN ('001','002','003','004','005','006','103','096')
        AND NOT EXISTS (SELECT PC.ID_PARTICELLA FROM DB_PARTICELLA_CERTIFICATA PC WHERE sp.COMUNE=pc.COMUNE AND sp.foglio=pc.foglio AND sp.particella=pc.PARTICELLA
        AND NVL(SP.SEZIONE,'-')=NVL(PC.SEZIONE,'-')
        AND NVL(SP.SUBALTERNO,'-')=NVL(PC.SUBALTERNO,'-'));

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_MANCANTI IN C_MANCANTI LOOP

           S_DESCRIZIONE := 'La particella non risulta presente sul catasto di riferimento di AGEA DEL 31/12/2005';

          IF NOT SCRIVI_SEGNALAZIONE (rec_mancanti.id_conduzione_particella,ter07_id_controllo, S_DESCRIZIONE,
               ter07_bloccante, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;
     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_PRESENZA_AGEA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLA_PRESENZA_AGEA;


FUNCTION CONTROLLA_SUPERFICIE_AGEA (P_ID_UTE   IN      DB_UTE.ID_UTE%TYPE,
                                 P_MSGERR       IN OUT VARCHAR2,
                                P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS
CURSOR C_DISCORDI IS
     SELECT CP.ID_CONDUZIONE_PARTICELLA, PC.SUP_CATASTALE
        FROM DB_CONDUZIONE_PARTICELLA CP, DB_STORICO_PARTICELLA SP, DB_PARTICELLA_CERTIFICATA PC
        WHERE CP.ID_UTE= P_ID_UTE AND CP.DATA_FINE_CONDUZIONE IS NULL
        AND CP.ID_PARTICELLA=SP.ID_PARTICELLA AND SP.DATA_FINE_VALIDITA IS NULL
        AND sp.COMUNE=pc.COMUNE AND sp.foglio=pc.foglio AND sp.particella=pc.PARTICELLA
        AND NVL(SP.SEZIONE,'-')=NVL(PC.SEZIONE,'-')
        AND NVL(SP.SUBALTERNO,'-')=NVL(PC.SUBALTERNO,'-')
        AND SP.SUP_CATASTALE <> PC.SUP_CATASTALE;

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_DISCORDI IN C_DISCORDI LOOP

           S_DESCRIZIONE := 'La particella sul catasto di riferimento di AGEA DEL 31/12/2005 risulta avere come superficie catastale '||TRIM(TO_CHAR(NVL(rec_DISCORDI.sup_catastale,0),'999G990D9999')) ;

          IF NOT SCRIVI_SEGNALAZIONE (rec_DISCORDI.id_conduzione_particella,ter08_id_controllo, S_DESCRIZIONE,
               ter08_bloccante, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;
     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_SUPERFICIE_AGEA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLA_SUPERFICIE_AGEA;

-- aggiunto parametro P_ID_UTENTE_IRIDE
PROCEDURE ESEGUI_CONTROLLI(P_ID_AZIENDA         IN DB_AZIENDA.ID_AZIENDA%TYPE,
                           P_ANNO_RIF            IN DB_UTILIZZO_PARTICELLA.ANNO%TYPE,
                           P_ID_UTENTE_LOGIN    IN PAPUA_V_UTENTE_LOGIN.ID_UTENTE_LOGIN%TYPE, 
                              P_MSGERR                IN OUT VARCHAR2,
                            P_CODERR             IN OUT VARCHAR2) IS
CURSOR C_CONTROLLI IS
    SELECT A.ID_CONTROLLO, A.CODICE_CONTROLLO, B.BLOCCANTE, a.OBBLIGATORIO
    FROM   DB_TIPO_CONTROLLO A, DB_TIPO_CONTROLLO_FASE B
    WHERE  FASE = 3
    AND    A.ID_CONTROLLO=B.ID_CONTROLLO
    ORDER BY A.ID_CONTROLLO;

CURSOR C_UTE IS
    SELECT ID_UTE
    FROM   DB_UTE
    WHERE  ID_AZIENDA = P_ID_AZIENDA AND DATA_FINE_ATTIVITA IS NULL;

S_PRESENZA_ANOM VARCHAR2(10);

BEGIN

  Pack_Dichiarazione_Consistenza.CONTROLLI_VERIFICA(P_ID_AZIENDA, TO_NUMBER(TO_CHAR(SYSDATE,'YYYY')),
         4, P_ID_UTENTE_LOGIN, S_PRESENZA_ANOM, P_MSGERR, P_CODERR);

/*
  IF NOT CANCELLA_ANOMALIE (P_ID_AZIENDA, P_MSGERR, P_CODERR) THEN
          RAISE ERRORE;
  END IF;

 UPDATE DB_CONDUZIONE_PARTICELLA SET ESITO_CONTROLLO=NULL
  WHERE DATA_FINE_CONDUZIONE IS NULL AND ID_CONDUZIONE_PARTICELLA IN (SELECT ID_CONDUZIONE_PARTICELLA FROM DB_CONDUZIONE_PARTICELLA A, DB_UTE B
  WHERE A.ID_UTE=B.ID_UTE AND B.ID_AZIENDA=P_ID_AZIENDA) ;

  /** MEMORIZZO I PARAMETRI DEI CONTROLLI*/
/*
    for rec_controlli in c_controlli
    loop
       if rec_controlli.codice_controllo='TER01' THEN
           TER01_BLOCCANTE:=rec_controlli.BLOCCANTE;
           TER01_obbligatorio:=rec_controlli.obbligatorio;
           TER01_id_controllo:=rec_controlli.id_controllo;
       END IF;
       if rec_controlli.codice_controllo='TER02' THEN
           TER02_BLOCCANTE:=rec_controlli.BLOCCANTE;
           TER02_obbligatorio:=rec_controlli.obbligatorio;
           TER02_id_controllo:=rec_controlli.id_controllo;
       END IF;
       if rec_controlli.codice_controllo='TER03' THEN
           TER03_BLOCCANTE:=rec_controlli.BLOCCANTE;
           TER03_obbligatorio:=rec_controlli.obbligatorio;
           TER03_id_controllo:=rec_controlli.id_controllo;
       END IF;
       if rec_controlli.codice_controllo='TER04' THEN
           TER04_BLOCCANTE:=rec_controlli.BLOCCANTE;
           TER04_obbligatorio:=rec_controlli.obbligatorio;
           TER04_id_controllo:=rec_controlli.id_controllo;
       END IF;
       if rec_controlli.codice_controllo='TER05' THEN
           TER05_BLOCCANTE:=rec_controlli.BLOCCANTE;
           TER05_obbligatorio:=rec_controlli.obbligatorio;
           TER05_id_controllo:=rec_controlli.id_controllo;
       END IF;
       if rec_controlli.codice_controllo='TER06' THEN
           TER06_BLOCCANTE:=rec_controlli.BLOCCANTE;
           TER06_obbligatorio:=rec_controlli.obbligatorio;
           TER06_id_controllo:=rec_controlli.id_controllo;
       END IF;
       if rec_controlli.codice_controllo='TER07' THEN
           TER07_BLOCCANTE:=rec_controlli.BLOCCANTE;
           TER07_obbligatorio:=rec_controlli.obbligatorio;
           TER07_id_controllo:=rec_controlli.id_controllo;
       END IF;
       if rec_controlli.codice_controllo='TER08' THEN
           TER08_BLOCCANTE:=rec_controlli.BLOCCANTE;
           TER08_obbligatorio:=rec_controlli.obbligatorio;
           TER08_id_controllo:=rec_controlli.id_controllo;
       END IF;
    END LOOP;
*/
    --******* CICLO SULLE UTE IN MODOD DA EVITARE ANCHE LA JOIN CON DB_UTE ***********
--    FOR REC_UTE IN C_UTE
--    LOOP
             /***************************contenzioso-******************************/
--        IF TER01_OBBLIGATORIO='S' THEN

--            IF NOT CONTROLLA_CONTENZIOSO (REC_UTE.ID_UTE, P_MSGERR, P_CODERR) THEN
--               RAISE ERRORE;
--            END IF;
--        END IF;


             /***************************SUPERO  ******************************/
        /*IF TER02_OBBLIGATORIO='S' THEN
            IF NOT CONTROLLA_supero (REC_UTE.ID_UTE,P_ID_AZIENDA, P_MSGERR, P_CODERR) THEN
               RAISE ERRORE;
            END IF;
        END IF;*/
--        IF TER03_OBBLIGATORIO='S' THEN
--            IF NOT CONTROLLA_supero_CATASTALE (REC_UTE.ID_UTE,P_MSGERR, P_CODERR) THEN
--               RAISE ERRORE;
--            END IF;
--        END IF;

--
          /*************************** supero uso del suolo  E USO NON SPECIFICATO******************************/
--          /*** TER04 E TER06*****/

--         IF NOT SUPERFICIE_USO_DEL_SUOLO(REC_UTE.ID_UTE,P_ANNO_RIF, P_MSGERR, P_CODERR) THEN
--           RAISE ERRORE;
--        END IF;

          /*************************** uso del suolo non valido ******************************/
--        IF TER05_OBBLIGATORIO='S' THEN
--              IF NOT USO_DEL_SUOLO_NON_VALIDO(REC_UTE.ID_UTE,P_ANNO_RIF, P_MSGERR, P_CODERR) THEN
--               RAISE ERRORE;
--            END IF;
--        END IF;

            /*************************** CONTROLLO PRESENZA SU TABELLONE AGEA DB_PARTICELLA_CERTIFICATA ******************************/
--        IF TER07_OBBLIGATORIO='S' THEN
--              IF NOT CONTROLLA_PRESENZA_AGEA(REC_UTE.ID_UTE, P_MSGERR, P_CODERR)  THEN
--               RAISE ERRORE;
--            END IF;
--        END IF;

            /*************************** CONTROLLO superficie catastale SU TABELLONE AGEA DB_PARTICELLA_CERTIFICATA ******************************/
--        IF TER08_OBBLIGATORIO='S' THEN
--              IF NOT CONTROLLA_SUPERFICIE_AGEA(REC_UTE.ID_UTE, P_MSGERR, P_CODERR)  THEN
--               RAISE ERRORE;
--    -        END IF;
--        END IF;


/*

          UPDATE DB_CONDUZIONE_PARTICELLA SET ESITO_CONTROLLO='B', DATA_ESECUZIONE = SYSDATE
          WHERE DATA_FINE_CONDUZIONE IS NULL AND ID_CONDUZIONE_PARTICELLA IN
          (SELECT A.ID_CONDUZIONE_PARTICELLA
          FROM DB_CONDUZIONE_PARTICELLA A, DB_ESITO_CONTROLLO_PARTICELLA C
          WHERE A.ID_UTE=REC_UTE.ID_UTE
          AND A.ID_CONDUZIONE_PARTICELLA=C.ID_CONDUZIONE_PARTICELLA AND C.BLOCCANTE='S') ;


          UPDATE DB_CONDUZIONE_PARTICELLA SET ESITO_CONTROLLO='W', DATA_ESECUZIONE = SYSDATE
          WHERE esito_controllo is null AND DATA_FINE_CONDUZIONE IS NULL AND ID_CONDUZIONE_PARTICELLA IN
          (SELECT A.ID_CONDUZIONE_PARTICELLA
                    FROM DB_CONDUZIONE_PARTICELLA a,DB_ESITO_CONTROLLO_PARTICELLA C
                  WHERE A.ID_UTE=REC_UTE.ID_UTE AND A.ID_CONDUZIONE_PARTICELLA=C.ID_CONDUZIONE_PARTICELLA AND C.BLOCCANTE='N') ;


          UPDATE DB_CONDUZIONE_PARTICELLA SET ESITO_CONTROLLO='P', DATA_ESECUZIONE = SYSDATE
          WHERE DATA_FINE_CONDUZIONE IS NULL AND ESITO_CONTROLLO IS NULL AND ID_CONDUZIONE_PARTICELLA IN
          (SELECT ID_CONDUZIONE_PARTICELLA FROM DB_CONDUZIONE_PARTICELLA
          WHERE ID_UTE=REC_UTE.ID_UTE) ;

    END LOOP;
*/
  COMMIT;
EXCEPTION
 WHEN ERRORE THEN
     IF P_CODERR IS NULL THEN
       P_CODERR := SQLCODE;
       P_MSGERR := SQLERRM;
    END IF;
 WHEN OTHERS THEN
     IF P_CODERR IS NULL THEN
       P_CODERR := SQLCODE;
       P_MSGERR := SQLERRM;
    END IF;
END ESEGUI_CONTROLLI;

END Pack_Controlli_Particellare;          -- Package

/
--------------------------------------------------------
--  DDL for Package Body PACK_DICHIARAZIONE_CONSISTENZA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PACK_DICHIARAZIONE_CONSISTENZA" IS

nMaxLenghtMessaggio INTEGER:=0;

--N_ID_PARTICELLA            DB_PARTICELLA.ID_PARTICELLA%TYPE;
N_ID_AZIENDA_SUPERO         DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE;
N_COUNT_BLOCCANTI           NUMBER(10); 
N_COUNT_ANOMALIE            NUMBER(10); 
N_ID_GRUPPO_CONTROLLO       DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE;
ERRORE                      EXCEPTION;
costanteGruppoAnagrafe              DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE :=1;
costanteGruppoSoggetti              DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE :=2;
costanteGruppoUte                   DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE :=3;
costanteGruppoTerreni               DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE :=4;
costanteGruppoFabbricati            DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE :=5;
costanteGruppoAllevamenti           DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE :=6;
costanteGruppoManodopera            DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE :=7;
costanteGruppoMotori                DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE :=8;
costanteGruppoConti                 DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE :=9;
costanteGruppoNotifiche             DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE :=10;
costanteGruppoDocumenti             DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE :=11;
costanteGruppoUnar                  DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE :=12;
costanteGruppoDichiarazioni         DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE :=13;
costanteGruppoValidazioni           DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE :=14;
costanteGruppoComunicazione10R      DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE :=15;
constantGruppoElencoSoci            DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE :=16;

costanteFaseInsediamento            DB_TIPO_CONTROLLO_FASE.FASE%TYPE :=2;

nAnnoCampagna                        NUMBER;
dDataConfCorrettiva                  DATE;

VAR_AZIENDA_GIOVANE                 BOOLEAN :=FALSE;
var_PRESENZA_AAEP                   BOOLEAN :=FALSE;
VAR_PRESENZA_TRIBUTARIA             BOOLEAN :=FALSE;
VAR_PRESENZA_DOC_IDENTITA           BOOLEAN;

var_cuaa                    DB_ANAGRAFICA_AZIENDA.CUAA%TYPE;
var_piva                    DB_ANAGRAFICA_AZIENDA.PARTITA_IVA%TYPE;
var_flag_provvisoria        DB_AZIENDA.FLAG_AZIENDA_PROVVISORIA%TYPE;
var_tipo_azienda            DB_ANAGRAFICA_AZIENDA.ID_TIPOLOGIA_AZIENDA%TYPE;
var_forma_giuridica         DB_ANAGRAFICA_AZIENDA.ID_FORMA_GIURIDICA%TYPE;
var_flag_partitaiva         DB_TIPO_FORMA_GIURIDICA.FLAG_PARTITA_IVA%TYPE;
var_flag_cciaa              DB_TIPO_FORMA_GIURIDICA.FLAG_CCIAA%TYPE;
var_data_fine_fg            DB_TIPO_FORMA_GIURIDICA.DATA_FINE_FORMA_GIURIDICA%TYPE;


S_CODICE_FISCALE         DB_PERSONA_FISICA.CODICE_FISCALE%TYPE;
N_DELEGA                 NUMBER(10);

    -- mi è stata imposta dall'alto questa modifica al cursore
    -- ovvero il flag bloccante è preso dalla nuova tabella DB_AZIENDA_CONTROLLO
    -- se il controllo è presente per l'azienda in elaborazione
    CURSOR C_CONTROLLI_VER_CONTR (pIdFase    IN NUMBER,
                                  pIdAzienda IN DB_AZIENDA_CONTROLLO.ID_AZIENDA%TYPE)IS
    WITH CONTROLLO_AZIENDALE AS (
    SELECT AC.*
      FROM DB_AZIENDA_CONTROLLO AC
     WHERE AC.ID_AZIENDA = pIdAzienda
       AND (AC.ID_FASE = pIdFase OR AC.ID_FASE IS NULL)
       AND SYSDATE BETWEEN AC.DATA_INIZIO AND NVL(AC.DATA_FINE,SYSDATE))
    SELECT A.ID_CONTROLLO, A.ID_GRUPPO_CONTROLLO, NVL(CA.BLOCCANTE,B.BLOCCANTE) AS BLOCCANTE,B.CONTROLLO_EMERGENZA
      FROM DB_TIPO_CONTROLLO A,
           DB_TIPO_CONTROLLO_FASE B,
           CONTROLLO_AZIENDALE CA
     WHERE B.FASE = pIdFase
       AND B.ID_FASE = pIdFase
       AND A.ID_CONTROLLO = B.ID_CONTROLLO
       AND A.ID_GRUPPO_CONTROLLO = N_ID_GRUPPO_CONTROLLO
       AND A.OBBLIGATORIO = 'S'
       AND A.ID_CONTROLLO = CA.ID_CONTROLLO (+)
  ORDER BY A.ID_GRUPPO_CONTROLLO, A.ORDINAMENTO;
    CURSOR C_CONTROLLI_VER (pIdFase IN NUMBER,
                            pIdAzienda IN DB_AZIENDA_CONTROLLO.ID_AZIENDA%TYPE) IS
    WITH CONTROLLO_AZIENDALE AS (
    SELECT AC.*
      FROM DB_AZIENDA_CONTROLLO AC
     WHERE AC.ID_AZIENDA = pIdAzienda
       AND (AC.ID_FASE = pIdFase OR AC.ID_FASE IS NULL)
       AND SYSDATE BETWEEN AC.DATA_INIZIO AND NVL(AC.DATA_FINE,SYSDATE))
    SELECT A.ID_CONTROLLO, A.ID_GRUPPO_CONTROLLO,NVL(CA.BLOCCANTE,B.BLOCCANTE) AS BLOCCANTE,B.CONTROLLO_EMERGENZA
      FROM DB_TIPO_CONTROLLO A,
           DB_TIPO_CONTROLLO_FASE B,
           CONTROLLO_AZIENDALE CA
     WHERE B.FASE = pIdFase
       AND B.ID_FASE = pIdFase
       AND A.ID_CONTROLLO = B.ID_CONTROLLO
       AND A.OBBLIGATORIO = 'S'
       AND A.ID_CONTROLLO = CA.ID_CONTROLLO (+)
  ORDER BY A.ID_GRUPPO_CONTROLLO, A.ORDINAMENTO;

    CURSOR C_CONTROLLI_INSEDIAMENTO(pIdFase IN NUMBER,
                                    pIdAzienda IN DB_AZIENDA_CONTROLLO.ID_AZIENDA%TYPE) IS
    WITH CONTROLLO_AZIENDALE AS (
    SELECT AC.*
      FROM DB_AZIENDA_CONTROLLO AC
     WHERE AC.ID_AZIENDA = pIdAzienda
       AND (AC.ID_FASE = pIdFase OR AC.ID_FASE IS NULL)
       AND SYSDATE BETWEEN AC.DATA_INIZIO AND NVL(AC.DATA_FINE,SYSDATE))
    SELECT A.ID_CONTROLLO, ID_GRUPPO_CONTROLLO, NVL(CA.BLOCCANTE,B.BLOCCANTE) AS BLOCCANTE,B.CONTROLLO_EMERGENZA
      FROM DB_TIPO_CONTROLLO A,
           DB_TIPO_CONTROLLO_FASE B,
           CONTROLLO_AZIENDALE CA
     WHERE B.FASE = pIdFase
       AND B.ID_FASE = pIdFase
       AND A.ID_CONTROLLO = B.ID_CONTROLLO
       AND A.OBBLIGATORIO = 'S'
       AND A.ID_CONTROLLO = CA.ID_CONTROLLO (+)
    ORDER BY A.ID_GRUPPO_CONTROLLO, A.ORDINAMENTO;


    /*********************************************************************
    Accoda al messaggio dato in input / output la stringa data in input se
    essa non provoca un supero della dimensione massima
    Tipo:    procedure
    Input:   pMessaggio, vStringa
    Output:  pMessaggio
    Return:  nessuno
    ********************************************************************/
    PROCEDURE AccodaMessaggio (pMessaggio IN OUT VARCHAR2,
                               vStringa   IN VARCHAR2) IS

        nLengthMsg  INTEGER:=0; -- conterra la lunghezza del messaggio attuale
        nLengthStr  INTEGER:=0; -- contiene la lunghezza della stringa da aggiungere

    BEGIN

        IF NVL(nMaxLenghtMessaggio,0) = 0 THEN
            BEGIN
                -- mi cerco la lunghezza
                -- massima per la colonna messaggio_esteso
                SELECT DATA_LENGTH
                  INTO nMaxLenghtMessaggio
                  FROM USER_TAB_COLUMNS
                 WHERE TABLE_NAME = 'DB_DICHIARAZIONE_SEGNALAZIONE'
                   AND COLUMN_NAME = 'DESCRIZIONE';
            EXCEPTION
                WHEN OTHERS THEN
                     nMaxLenghtMessaggio := 2000;
            END;

        END IF;

        -- setto la lunghezza del messaggio attuale
        nLengthMsg := NVL(LENGTH(pMessaggio),0);
        -- setto la lunghezza della stringa da aggiungere al messaggio attuale
        nLengthStr := NVL(LENGTH(vStringa),0);
        -- se la somma della lunghezza del messagio attuale + la stringa da aggiungere
        -- e minore della lunghezza massima disponibile
        IF nLengthMsg + nLengthStr <= nMaxLenghtMessaggio THEN
           -- accoda la stringa nel messaggio
           pMessaggio := pMessaggio || vStringa;
        ELSE
           IF nLengthMsg = 0 THEN
              -- e se e maggiore di zero accodo solamente un pezzo della stringa
              pMessaggio := substr(vStringa,1,nMaxLenghtMessaggio);
           END IF;
        END IF;

    END AccodaMessaggio;


/*********************************************************************
Controlla se la dichiarazione in oggetto e' di quelle che prevedono
la chiusura automatica delle notifiche
input:  pCodFotoTerreni
output: nessuno
ritorno: TRUE / FALSE
*********************************************************************/
FUNCTION IsValidazioneWithCloseNotifica (pCodFotoTerreni IN DB_DICHIARAZIONE_CONSISTENZA.CODICE_FOTOGRAFIA_TERRENI%TYPE)
RETURN BOOLEAN IS
    bRet BOOLEAN:=FALSE;
    nRec INTEGER:=0;
BEGIN
    SELECT COUNT(DC.ID_DICHIARAZIONE_CONSISTENZA)
      INTO nRec
      FROM DB_DICHIARAZIONE_CONSISTENZA DC,
           DB_TIPO_MOTIVO_DICHIARAZIONE TMD
     WHERE DC.CODICE_FOTOGRAFIA_TERRENI = pCodFotoTerreni
       AND DC.ID_MOTIVO_DICHIARAZIONE = TMD.ID_MOTIVO_DICHIARAZIONE
       AND TMD.CHIUDI_NOTIFICHE = 'S';

    IF nRec > 0 THEN
       bRet := TRUE;
    END IF;

    RETURN bRet;

END IsValidazioneWithCloseNotifica;

/*********************************************************************
Data una tipologia vino ed una provincia ritorna il totale di superficie
iscritta nell'albo CCIAA
input:  pIdTipologiaVino , pSiglaProvincia
output: nessuno
ritorno: nTotSupIscritta
*********************************************************************/
FUNCTION SelTotVinoCCIAAPerProvincia (pIdTipologiaVino  IN DB_CCIAA_ALBO_VIGNETI_MASSIVO.ID_TIPOLOGIA_VINO%TYPE,
                                      pSiglaProvincia   IN DB_CCIAA_ALBO_VIGNETI_MASSIVO.SIGLA_PROVINCIA%TYPE
                                      )RETURN DB_CCIAA_ALBO_VIGNETI_MASSIVO.SUPERFICIE_ISCRITTA%TYPE IS
    nTotSupIscritta  DB_CCIAA_ALBO_VIGNETI_MASSIVO.SUPERFICIE_ISCRITTA%TYPE;
BEGIN

    SELECT NVL(SUM(SUPERFICIE_ISCRITTA),0)
      INTO nTotSupIscritta
      FROM DB_CCIAA_ALBO_VIGNETI_MASSIVO CAVM,
           DB_TIPO_VINO_CCIAA_SIAP TVCS
     WHERE CAVM.SIGLA_PROVINCIA = pSiglaProvincia
       AND NVL(CAVM.ESCLUDI,'N') = 'N'
       AND CAVM.ID_CCIAA_ALBO_VIGNETO = TVCS.ID_CCIAA_ALBO_VIGNETO
       AND TVCS.ID_TIPOLOGIA_VINO = pIdTipologiaVino
       AND TVCS.DATA_FINE_VALIDITA IS NULL; 

    RETURN nTotSupIscritta;

END SelTotVinoCCIAAPerProvincia;

/*********************************************************************
Data una tipologia vino ed una provincia ritorna il totale di superficie
ad unità vitate per tutte le aziende attive presenti su anagrafe (
considerando l'ultima dichiarazione di consistenza) tranne che per l'azienda
da escludere passato in input
input:  pIdTipologiaVino , pIstatProvincia, pSiglaProvincia, pIdAziendaDaEscludere
output: nessuno
ritorno: nTotAreaVinoProv
*********************************************************************/
FUNCTION SelTotVinoPerProvAltreAziende (pIdTipologiaVino       IN DB_TIPO_TIPOLOGIA_VINO.ID_TIPOLOGIA_VINO%TYPE,
                                        pIstatProvincia        IN PROVINCIA.ISTAT_PROVINCIA%TYPE,
                                        pSiglaProvincia        IN PROVINCIA.SIGLA_PROVINCIA%TYPE,
                                        pIdAziendaDaEscludere  IN DB_STORICO_UNITA_ARBOREA.ID_AZIENDA%TYPE
                                        ) RETURN DB_STORICO_UNITA_ARBOREA.AREA%TYPE IS
    nTotAreaVinoProv DB_STORICO_UNITA_ARBOREA.AREA%TYPE;
BEGIN

     WITH AZIENDA_CON_UV AS (
     SELECT DISTINCT ID_AZIENDA
       FROM DB_STORICO_UNITA_ARBOREA
      WHERE ID_TIPOLOGIA_VINO = pIdTipologiaVino
        AND PROVINCIA_CCIAA =  pSiglaProvincia
        AND ID_AZIENDA <> pIdAziendaDaEscludere
        AND ID_TIPOLOGIA_UNAR = 2)
     SELECT NVL(SUM(UAD.SUPERFICIE_DA_ISCRIVERE_ALBO),0) 
       INTO nTotAreaVinoProv
       FROM DB_UNITA_ARBOREA_DICHIARATA UAD,
            DB_DICHIARAZIONE_CONSISTENZA DC,
            DB_ANAGRAFICA_AZIENDA AZ,
            DB_TIPO_MOTIVO_DICHIARAZIONE TM,
            AZIENDA_CON_UV ACU
      WHERE AZ.ID_AZIENDA <> pIdAziendaDaEscludere
        AND AZ.ID_AZIENDA = ACU.ID_AZIENDA
        AND AZ.DATA_FINE_VALIDITA IS NULL
        AND AZ.DATA_CESSAZIONE IS NULL
        AND AZ.ID_AZIENDA = DC.ID_AZIENDA
        AND DC.ID_AZIENDA = ACU.ID_AZIENDA
        AND DC.ID_MOTIVO_DICHIARAZIONE <> 7
        AND DC.ID_MOTIVO_DICHIARAZIONE = TM.ID_MOTIVO_DICHIARAZIONE
        AND TM.TIPO_DICHIARAZIONE <> 'C'
        AND DC.DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DCX.DATA_INSERIMENTO_DICHIARAZIONE)
                                                   FROM DB_DICHIARAZIONE_CONSISTENZA DCX,
                                                        DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                  WHERE DCX.ID_AZIENDA = DC.ID_AZIENDA
                                                    AND DCX.ID_MOTIVO_DICHIARAZIONE <> 7
                                                    AND TI.ID_MOTIVO_DICHIARAZIONE = DCX.ID_MOTIVO_DICHIARAZIONE
                                                    AND TI.TIPO_DICHIARAZIONE <> 'C'
                                                    )
        AND DC.CODICE_FOTOGRAFIA_TERRENI = UAD.CODICE_FOTOGRAFIA_TERRENI
        AND UAD.DATA_FINE_VALIDITA IS NULL
        AND UAD.MATRICOLA_CCIAA IS NOT NULL
        AND UAD.PROVINCIA_CCIAA IS NOT NULL
        AND UAD.ID_TIPOLOGIA_VINO = pIdTipologiaVino
        AND UAD.PROVINCIA_CCIAA =  pSiglaProvincia
        AND UAD.ID_TIPOLOGIA_UNAR = 2;

    RETURN nTotAreaVinoProv;

END SelTotVinoPerProvAltreAziende;

/*********************************************************************
Dato un valore numerico con decimali inserito in un varchar2, lo
rende numerico nel formato specificato (solo formati con seperatore dinamico
ex : '99999D99' , NO --> '9999.99' o '9999,99')
input:  pValore , pFormato
output: nessuno
ritorno: NUMBER
*********************************************************************/
FUNCTION my_to_number (pvalore IN VARCHAR2, pformato IN VARCHAR2)
  RETURN NUMBER
IS
  vsepdecimale   VARCHAR2 (1) := NULL;
  vsepmigliaia   VARCHAR2 (1) := NULL;
BEGIN
  SELECT SUBSTR (VALUE, 1, 1), SUBSTR (VALUE, 2, 1)
    INTO vsepdecimale, vsepmigliaia
    FROM nls_session_parameters
   WHERE parameter = 'NLS_NUMERIC_CHARACTERS';

  IF INSTR (pvalore, vsepmigliaia) > 0
  THEN
     RETURN TO_NUMBER (REPLACE (pvalore, vsepmigliaia, vsepdecimale),
                       pformato
                      );
  ELSE
     RETURN TO_NUMBER (pvalore, pformato);
  END IF;
END my_to_number;

/*********************************************************************
Effettua l'impostazione dell'ID_GENERE_ISCRIZIONE a DEFINITIVO per le unità vitate
dell'azienda presenti sull'albo vigneti CCIAA ed a PROVVISORIO per le unità vitate
non ancora presenti
Tipo:  procedure
input:  pIdAzienda
output: pMsgErr, pCodErr
ritorno: VARCHAR2
*********************************************************************/
PROCEDURE ImpostaGenIscrizUVAzienda(pIdAzienda IN DB_STORICO_UNITA_ARBOREA.ID_AZIENDA%TYPE,
                                    pMsgErr    OUT     VARCHAR2,
                                    PCodErr    OUT     VARCHAR2) IS
BEGIN
     -- estrapolati filtri su DB_STORICO_UNITA_ARBOREA da subselect EXISTS
     -- e riportati in select principale
     UPDATE DB_STORICO_UNITA_ARBOREA SUA
        SET SUA.ID_GENERE_ISCRIZIONE = (SELECT ID_GENERE_ISCRIZIONE FROM DB_TIPO_GENERE_ISCRIZIONE WHERE FLAG_DEFINITIVA = 'S')
      WHERE SUA.DATA_FINE_VALIDITA IS NULL
        AND SUA.ID_CAUSALE_MODIFICA NOT IN (SELECT ID_CAUSALE_MODIFICA       
                                              FROM DB_TIPO_CAUSALE_MODIFICA  
                                             WHERE ALTRO_PROCEDIMENTO = 'S') 
        AND SUA.ID_AZIENDA = pIdAzienda
        AND SUA.ID_TIPOLOGIA_UNAR = 2
        AND SUA.ID_UTILIZZO = 487
        AND EXISTS
          (SELECT SP.ID_STORICO_PARTICELLA
             FROM DB_STORICO_PARTICELLA SP,
                  DB_CONDUZIONE_PARTICELLA CO,
                  DB_UTE U,
                  COMUNE CM,
                  PROVINCIA PR,
                  DB_CCIAA_ALBO_VIGNETI AV,
                  DB_CCIAA_ALBO_DETTAGLIO AD,
                  DB_TIPO_VITIGNO_CCIAA TVC,
                  DB_R_VITIGNO_CCIAA_VARIETA RVCV
            WHERE SUA.ID_PARTICELLA = SP.ID_PARTICELLA
              AND SP.DATA_FINE_VALIDITA IS NULL
              AND CO.ID_PARTICELLA = SP.ID_PARTICELLA
              AND CO.DATA_FINE_CONDUZIONE IS NULL
              AND CO.ID_UTE=U.ID_UTE
              AND U.ID_AZIENDA=SUA.ID_AZIENDA
              AND U.DATA_FINE_ATTIVITA IS NULL
              AND CM.ISTAT_COMUNE = SP.COMUNE
              AND CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
              AND PR.ID_REGIONE = '01' -- SOLO PIEMONTE
              AND AD.DESC_VARIETA = TVC.DESCRIZIONE
              AND TVC.ID_VITIGNO_CCIAA = RVCV.ID_VITIGNO_CCIAA
              AND AV.ID_AZIENDA = SUA.ID_AZIENDA
              AND AV.ID_CCIAA_ALBO_VIGNETI = AD.ID_CCIAA_ALBO_VIGNETI
              AND RVCV.ID_VARIETA = SUA.ID_VARIETA
              AND SUA.MATRICOLA_CCIAA = AD.MATRICOLA
              AND SP.COMUNE = AD.ISTAT_COMUNE
              AND NVL(SP.SEZIONE,' ') = NVL(AD.SEZIONE,' ')
              AND SP.FOGLIO = AD.FOGLIO
              AND SP.PARTICELLA = AD.PARTICELLA
              AND NVL(SP.SUBALTERNO,' ') = NVL(AD.SUBALTERNO,' '));

    pMsgErr := 'Aggiornato ID_GENERE_ISCRIZIONE a DEFINITIVO per : ' || SQL%ROWCOUNT || ' records su DB_STORICO_UNITA_ARBOREA' ;
     -- estrapolati filtri su DB_STORICO_UNITA_ARBOREA da subselect NOT EXISTS
     -- e riportati in select principale
     UPDATE DB_STORICO_UNITA_ARBOREA SUA
        SET SUA.ID_GENERE_ISCRIZIONE = (SELECT ID_GENERE_ISCRIZIONE FROM DB_TIPO_GENERE_ISCRIZIONE WHERE FLAG_DEFINITIVA = 'N')
      WHERE NVL(SUA.STATO_UNITA_ARBOREA,'N.V.') <> 'V' 
        AND SUA.DATA_FINE_VALIDITA IS NULL
        AND SUA.ID_CAUSALE_MODIFICA NOT IN (SELECT ID_CAUSALE_MODIFICA       
                                              FROM DB_TIPO_CAUSALE_MODIFICA  
                                             WHERE ALTRO_PROCEDIMENTO = 'S') 
        AND SUA.ID_AZIENDA = pIdAzienda
        AND SUA.ID_TIPOLOGIA_UNAR = 2
        AND SUA.ID_UTILIZZO = 487
        AND NOT EXISTS
          (SELECT SP.ID_STORICO_PARTICELLA
             FROM DB_STORICO_PARTICELLA SP,
                  DB_CONDUZIONE_PARTICELLA CO,
                  DB_UTE U,
                  COMUNE CM,
                  PROVINCIA PR,
                  DB_CCIAA_ALBO_VIGNETI AV,
                  DB_CCIAA_ALBO_DETTAGLIO AD,
                  DB_TIPO_VITIGNO_CCIAA TVC,
                  DB_R_VITIGNO_CCIAA_VARIETA RVCV
            WHERE SUA.ID_PARTICELLA = SP.ID_PARTICELLA
              AND SP.DATA_FINE_VALIDITA IS NULL
              AND CO.ID_PARTICELLA = SP.ID_PARTICELLA
              AND CO.DATA_FINE_CONDUZIONE IS NULL
              AND CO.ID_UTE=U.ID_UTE
              AND U.ID_AZIENDA=SUA.ID_AZIENDA
              AND U.DATA_FINE_ATTIVITA IS NULL
              AND CM.ISTAT_COMUNE = SP.COMUNE
              AND CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
              AND PR.ID_REGIONE = '01' -- SOLO PIEMONTE
              AND AD.DESC_VARIETA = TVC.DESCRIZIONE
              AND TVC.ID_VITIGNO_CCIAA = RVCV.ID_VITIGNO_CCIAA
              AND AV.ID_AZIENDA = SUA.ID_AZIENDA
              AND AV.ID_CCIAA_ALBO_VIGNETI = AD.ID_CCIAA_ALBO_VIGNETI
              AND RVCV.ID_VARIETA = SUA.ID_VARIETA
              AND SUA.MATRICOLA_CCIAA = AD.MATRICOLA
              AND SP.COMUNE = AD.ISTAT_COMUNE
              AND NVL(SP.SEZIONE,' ') = NVL(AD.SEZIONE,' ')
              AND SP.FOGLIO = AD.FOGLIO
              AND SP.PARTICELLA = AD.PARTICELLA
              AND NVL(SP.SUBALTERNO,' ') = NVL(AD.SUBALTERNO,' '));

    pMsgErr := pMsgErr || ' - Aggiornato ID_GENERE_ISCRIZIONE a PROVVISORIO per : ' || SQL%ROWCOUNT || ' records su DB_STORICO_UNITA_ARBOREA' ;

EXCEPTION
    WHEN OTHERS THEN
        pMsgErr := 'ImpostaGenIscrizUVAzienda - ' || SQLERRM;
        PCodErr := SQLCODE;
END ImpostaGenIscrizUVAzienda;

/*********************************************************************
Ricerca il valore del parametro con codice dato in input nella tavola
DB_TIPO_CONTROLLO_PARAMETRO per l'id_controllo dato in input e ne
ritorna il ROWTYPE
Tipo: function
input: pIdControllo , pCodice
output: nessuno
ritorno: DB_TIPO_CONTROLLO_PARAMETRO%ROWTYPE
*********************************************************************/
FUNCTION SelValoreParametroCtrlByCodice (pIdControllo IN DB_TIPO_CONTROLLO_PARAMETRO.ID_CONTROLLO%TYPE,
                                         pCodice      IN DB_TIPO_CONTROLLO_PARAMETRO.CODICE%TYPE
                                         ) RETURN DB_TIPO_CONTROLLO_PARAMETRO%ROWTYPE IS

    recTipoControlloParametro DB_TIPO_CONTROLLO_PARAMETRO%ROWTYPE;
BEGIN
    SELECT *
      INTO recTipoControlloParametro
      FROM DB_TIPO_CONTROLLO_PARAMETRO
     WHERE ID_CONTROLLO = pIdControllo
       AND CODICE = pCodice
       AND DATA_FINE_VALIDITA IS NULL;

    RETURN recTipoControlloParametro;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
         recTipoControlloParametro := NULL;
         RETURN recTipoControlloParametro;
END SelValoreParametroCtrlByCodice;

/*********************************************************************
Ricerca il codice parametro nella tavola DB_PARAMENTRO e ne
espone il valore
Tipo:    function
input:  pCodParamentro
output: nessuno
ritorno: VARCHAR2
*********************************************************************/
FUNCTION SelectValoreParametro (pCodParametro IN VARCHAR2) RETURN VARCHAR2 IS
    vValParametro DB_PARAMETRO.VALORE%TYPE;
BEGIN

    SELECT VALORE
      INTO vValParametro
      FROM DB_PARAMETRO
     WHERE ID_PARAMETRO = pCodParametro;

    RETURN vValParametro;

END SelectValoreParametro;

/* funzione che verifica se un controllo è stato giustificato */
FUNCTION IS_JUSTIFIED(P_ID_AZIENDA   IN     DB_AZIENDA.ID_AZIENDA%TYPE,
                       P_COD_CONTROLLO IN     DB_TIPO_CONTROLLO.CODICE_CONTROLLO%TYPE) RETURN BOOLEAN IS

N_CONT                  INTEGER;

BEGIN

     /* ricerco se il cotnrollo è stato giustificato */
     SELECT COUNT(1)
     INTO N_CONT
     FROM DB_DICHIARAZIONE_CORREZIONE Z, DB_TIPO_CONTROLLO Y
     WHERE Z.ID_AZIENDA=P_ID_AZIENDA
     AND Z.ID_CONTROLLO=Y.ID_CONTROLLO
     AND TRIM(Y.CODICE_CONTROLLO)=TRIM(P_COD_CONTROLLO)
     AND Z.ID_DICHIARAZIONE_CONSISTENZA IS NULL;

     IF N_CONT > 0 THEN
         RETURN(TRUE);
     ELSE
         RETURN(FALSE);
     END IF;

EXCEPTION
    WHEN OTHERS THEN
         RETURN(FALSE);
END IS_JUSTIFIED;

/* funzione che transcodifica gli "annosi" comuni da quelli nuovi a quelli vecchi */
FUNCTION TRANSCOD(P_COMUNE                        IN OUT COMUNE.ISTAT_COMUNE%TYPE,
                  P_SEZIONE                        IN OUT DB_STORICO_PARTICELLA.SEZIONE%TYPE
                  ) RETURN BOOLEAN IS


BEGIN

/*
     IF P_COMUNE='005121' THEN --MONTIGLIO MONFERRATO

         IF NVL(P_SEZIONE,'-')='A' THEN
           P_COMUNE:='005043';
           P_SEZIONE:=NULL;
         ELSIF NVL(P_SEZIONE,'-')='B' THEN
           P_COMUNE:='005078';
           P_SEZIONE:=NULL;
         ELSIF NVL(P_SEZIONE,'-')='C' THEN
           P_COMUNE:='005102';
           P_SEZIONE:=NULL;
        END IF;
*/
     IF P_COMUNE='096084' THEN --MOSSO

         IF NVL(P_SEZIONE,'-')='A' THEN
           P_COMUNE:='096036';
           P_SEZIONE:=NULL;
         ELSIF NVL(P_SEZIONE,'-')='B' THEN
           P_COMUNE:='096045';
           P_SEZIONE:=NULL;
        END IF;

     END IF;

     RETURN(TRUE);

END;

FUNCTION SCRIVI_SEGNALAZIONE (P_ID_AZIENDA   IN     DB_AZIENDA.ID_AZIENDA%TYPE,
                               P_ID_CONTROLLO IN     DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                              P_DESCRIZIONE     IN     DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE,
                              P_BLOCCANTE     IN     DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                              P_ID_STORICO_PARTICELLA IN DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE,
                              P_ID_STORICO_UNITA_ARBOREA IN DB_STORICO_UNITA_ARBOREA.ID_STORICO_UNITA_ARBOREA%TYPE,
                                  P_MSGERR       IN OUT VARCHAR2,
                              P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

BEGIN




      INSERT INTO DB_DICHIARAZIONE_SEGNALAZIONE (ID_DICHIARAZIONE_SEGNALAZIONE,
     ID_AZIENDA, ID_DICHIARAZIONE_CONSISTENZA, ID_CONTROLLO,bloccante, DESCRIZIONE, DATA_CONTROLLO,
     ID_STORICO_PARTICELLA, ID_STORICO_UNITA_ARBOREA) VALUES
     (SEQ_DICHIARAZIONE_SEGNALAZIONE.NEXTVAL, P_ID_AZIENDA, NULL,P_ID_CONTROLLO,P_BLOCCANTE,
     DECODE(P_DESCRIZIONE,NULL,' ',P_DESCRIZIONE), SYSDATE, P_ID_STORICO_PARTICELLA, P_ID_STORICO_UNITA_ARBOREA );

     IF P_BLOCCANTE = 'S' THEN
         N_COUNT_BLOCCANTI := N_COUNT_BLOCCANTI + 1;
     ELSE
         N_COUNT_ANOMALIE  := N_COUNT_ANOMALIE + 1;
     END IF;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE SCRIVI_SEGNALAZIONE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END SCRIVI_SEGNALAZIONE;

FUNCTION SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA   IN     DB_AZIENDA.ID_AZIENDA%TYPE,
                               P_ID_CONTROLLO IN     DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                              P_DESCRIZIONE     IN     DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE,
                              P_BLOCCANTE     IN     DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                              P_ID_CONDUZIONE_PARTICELLA IN DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE,
                                  P_MSGERR       IN OUT VARCHAR2,
                              P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

BEGIN

     INSERT INTO DB_ESITO_CONTROLLO_PARTICELLA (ID_ESITO_CONTROLLO_PARTICELLA,
     ID_CONDUZIONE_PARTICELLA, ID_CONTROLLO,bloccante, DESCRIZIONE) VALUES
     (SEQ_ESITO_CONTROLLO_PARTICELLA.NEXTVAL, P_ID_CONDUZIONE_PARTICELLA, P_ID_CONTROLLO,P_BLOCCANTE,
     P_DESCRIZIONE);

     IF P_BLOCCANTE = 'S' THEN
         N_COUNT_BLOCCANTI := N_COUNT_BLOCCANTI + 1;
     ELSE
         N_COUNT_ANOMALIE  := N_COUNT_ANOMALIE + 1;
     END IF;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE SCRIVI_SEGNALAZIONE_PARTICELLA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END SCRIVI_SEGNALAZIONE_PARTICELLA;

FUNCTION SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA   IN     DB_AZIENDA.ID_AZIENDA%TYPE,
                               P_ID_CONTROLLO IN     DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                              P_DESCRIZIONE     IN     DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE,
                              P_BLOCCANTE     IN     DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                              P_ID_STORICO_UNITA_ARBOREA IN DB_STORICO_UNITA_ARBOREA.ID_STORICO_UNITA_ARBOREA%TYPE,
                                  P_MSGERR       IN OUT VARCHAR2,
                              P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

BEGIN

     INSERT INTO DB_ESITO_CONTROLLO_UNAR (ID_ESITO_CONTROLLO_UNAR, ID_STORICO_UNITA_ARBOREA, ID_CONTROLLO, BLOCCANTE, DESCRIZIONE) VALUES
     (SEQ_ESITO_CONTROLLO_UNAR.NEXTVAL, P_ID_STORICO_UNITA_ARBOREA, P_ID_CONTROLLO,P_BLOCCANTE, P_DESCRIZIONE);

     IF P_BLOCCANTE = 'S' THEN
         N_COUNT_BLOCCANTI := N_COUNT_BLOCCANTI + 1;
     ELSE
         N_COUNT_ANOMALIE  := N_COUNT_ANOMALIE + 1;
     END IF;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE SCRIVI_SEGNALAZIONE_UNAR: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END SCRIVI_SEGNALAZIONE_UNAR;

FUNCTION SCRIVI_SEGNALAZIONE_DOCUMENTO(P_ID_CONTROLLO IN     DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                         P_DESCRIZIONE  IN     DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE,
                                         P_BLOCCANTE      IN     DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                         P_ID_DOCUMENTO IN     DB_DOCUMENTO.ID_DOCUMENTO%TYPE,
                                             P_MSGERR       IN OUT VARCHAR2,
                                         P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS

BEGIN

     INSERT INTO DB_ESITO_CONTROLLO_DOCUMENTO (ID_ESITO_CONTROLLO_DOCUMENTO,
     ID_DOCUMENTO, ID_CONTROLLO,bloccante, DESCRIZIONE) VALUES
     (SEQ_ESITO_CONTROLLO_DOCUMENTO.NEXTVAL, P_ID_DOCUMENTO, P_ID_CONTROLLO,P_BLOCCANTE,
     P_DESCRIZIONE);

     IF P_BLOCCANTE = 'S' THEN
         N_COUNT_BLOCCANTI := N_COUNT_BLOCCANTI + 1;
     ELSE
         N_COUNT_ANOMALIE  := N_COUNT_ANOMALIE + 1;
     END IF;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE SCRIVI_SEGNALAZIONE_DOCUMENTO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END SCRIVI_SEGNALAZIONE_DOCUMENTO;

-- nuova funzione che scrive anomalia su allevamenti
FUNCTION SCRIVI_ANOMALIA_ALLEVAMENTO(P_ID_CONTROLLO   IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                     P_DESCRIZIONE    IN DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE,
                                     P_BLOCCANTE      IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                     P_ID_ALLEVAMENTO IN DB_ALLEVAMENTO.ID_ALLEVAMENTO%TYPE,
                                     P_MSGERR         IN OUT VARCHAR2,
                                     P_CODERR         IN OUT VARCHAR2) RETURN BOOLEAN IS

BEGIN

     INSERT INTO DB_ESITO_CONTROLLO_ALLEVAMENTO
        (
        ID_ESITO_CONTROLLO_ALLEVAMENTO,
        ID_ALLEVAMENTO,
        ID_CONTROLLO,
        BLOCCANTE,
        DESCRIZIONE
        )
     VALUES
        (SEQ_DB_ESITO_CONTROLLO_ALLEV.NEXTVAL,
         P_ID_ALLEVAMENTO,
         P_ID_CONTROLLO,
         P_BLOCCANTE,
         P_DESCRIZIONE);

      IF P_BLOCCANTE = 'S' THEN
         N_COUNT_BLOCCANTI := N_COUNT_BLOCCANTI + 1;
      ELSE
         N_COUNT_ANOMALIE  := N_COUNT_ANOMALIE + 1;
      END IF;

      RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
         p_MsgErr   := 'ERRORE SCRIVI_ANOMALIA_ALLEVAMENTO: ' || SQLERRM;
         p_CodErr   := SQLCODE;
         RETURN (FALSE);
END SCRIVI_ANOMALIA_ALLEVAMENTO;


---------------------------------------------------------------------------------------
--  CONTROLLI C/C
---------------------------------------------------------------------------------------

FUNCTION Controlla_Iban    (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                    P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                    P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                    P_MSGERR       IN OUT VARCHAR2,
                                    P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS

--    182
--    [CNC04] Verifica che il codice Iban sia formalmente corretto
CURSOR CUR_CC IS     SELECT SPO.CODICE_PAESE||CON.CIFRA_CONTROLLO||CON.CIN||BAN.ABI||SPO.CAB||CON.NUMERO_CONTO_CORRENTE IBAN_COSTRUITO, CON.IBAN, CON.BBAN
                        FROM     DB_CONTO_CORRENTE CON,
                                DB_TIPO_SPORTELLO    SPO,
                                DB_TIPO_BANCA     BAN
                        WHERE CON.DATA_FINE_VALIDITA IS NULL
                        AND    CON.DATA_ESTINZIONE IS NULL
                        AND    CON.ID_AZIENDA     =     P_ID_AZIENDA
                        AND    CON.ID_SPORTELLO     =    SPO.ID_SPORTELLO
                        AND    SPO.ID_BANCA        =    BAN.ID_BANCA;

vDescErr VARCHAR2(500);
S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

BEGIN
    FOR REC_CC IN CUR_CC LOOP

        IF NOT Pack_Controlli.IBAN_OK( REC_CC.IBAN_COSTRUITO,vDescErr ) THEN

            S_DESCRIZIONE := 'Nel C/C N.'||REC_CC.BBAN||' '||vDescErr;

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
            END IF;

        ELSE
            IF REC_CC.IBAN_COSTRUITO != REC_CC.IBAN THEN
                S_DESCRIZIONE := 'Nel C/C N.'||REC_CC.BBAN||'il codice Iban e'' erraro.';

                IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
                END IF;
            END IF;
        END IF;

    END LOOP;
    RETURN (TRUE);
EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE CONTROLLA_IBAN: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END Controlla_Iban;

FUNCTION Conto_Corrente_Invalidato( P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                    P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                    P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                    P_MSGERR       IN OUT VARCHAR2,
                                    P_CODERR       IN OUT VARCHAR2)    RETURN BOOLEAN IS

    -- 183
    -- [CNC05] Verifica che il conto corrente non sia stato invalidato da SIGOP
    CURSOR curContoCorrente IS
    SELECT CON.*
      FROM DB_CONTO_CORRENTE CON
     WHERE CON.DATA_FINE_VALIDITA IS NULL
       AND CON.DATA_ESTINZIONE IS NULL
       AND CON.ID_AZIENDA = P_ID_AZIENDA;

    vResult     VARCHAR2(1);
    vMsg        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    nIdErrore   DB_MESSAGGIO_ERRORE.ID_MESSAGGIO_ERRORE%TYPE;

BEGIN

    FOR recContoCorrente IN curContoCorrente LOOP

        PACK_CONTROLLI.CNC05(recContoCorrente.ID_CONTO_CORRENTE,
                             vResult,
                             vMsg,
                             nIdErrore);

        IF vResult <> '0' THEN
           vMsg := vMsg || '( IBAN : ' || recContoCorrente.IBAN || ')';
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, recContoCorrente.IBAN, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;

    END LOOP;

    RETURN (TRUE);
EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE Conto_Corrente_Invalidato : ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END Conto_Corrente_Invalidato;

FUNCTION Conto_Corrente_NoDocumenti( P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                     P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                     P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                     P_MSGERR       IN OUT VARCHAR2,
                                     P_CODERR       IN OUT VARCHAR2)    RETURN BOOLEAN IS

    -- 531
    CURSOR curContoCorrente IS
    SELECT CON.*
      FROM DB_CONTO_CORRENTE CON
     WHERE CON.DATA_FINE_VALIDITA IS NULL
       AND CON.DATA_ESTINZIONE IS NULL
       AND CON.ID_AZIENDA = P_ID_AZIENDA;

    vResult     VARCHAR2(1);
    vMsg        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    nIdErrore   DB_MESSAGGIO_ERRORE.ID_MESSAGGIO_ERRORE%TYPE;

BEGIN

    FOR recContoCorrente IN curContoCorrente LOOP

        PACK_CONTROLLI.DOC25(recContoCorrente.ID_CONTO_CORRENTE,
                             vResult,
                             vMsg,
                             nIdErrore);

        IF vResult <> '0' THEN
           vMsg := vMsg || '( IBAN : ' || recContoCorrente.IBAN || ')';
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, recContoCorrente.IBAN, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;

    END LOOP;

    RETURN (TRUE);
EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE Conto_Corrente_NoDocumenti : ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END Conto_Corrente_NoDocumenti;

-- aggiunto controllo per verificare se l''azienda che ha aderito alla deroga dei nitrati
-- ha effettivamente inserito l'apposito documento
FUNCTION Deroga_Nitrati    (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                            P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                            P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                            P_MSGERR       IN OUT VARCHAR2,
                            P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS
    nCom10RConDeroga INTEGER;
    nDocDeroga       INTEGER;

BEGIN
    -- controllo se ci sono comunicazioni 10R attive con adesione alla deroga dei nitrati
    SELECT COUNT(C.ID_COMUNICAZIONE_10R)
      INTO nCom10RConDeroga
      FROM DB_COMUNICAZIONE_10R C,
           DB_UTE U
     WHERE U.ID_AZIENDA = P_ID_AZIENDA
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND U.ID_UTE = C.ID_UTE
       AND C.DATA_FINE_VALIDITA IS NULL
       AND C.ADESIONE_DEROGA = 'S';

    -- controllo se ci sono documenti attivi di adesione alla deroga
    WITH DOCUMENTO_STRINGA AS
       (SELECT VALORE_STRINGA AS VAL_STRINGA
          FROM DB_ALTRI_DATI
         WHERE CODICE = kvCodAltroDatoDocNitrati
           AND DATA_FINE_VALIDITA IS NULL),
         DOCUMENTI_CONCATENATI AS
       ( SELECT VAL_STRINGA AS TipoDoc,
                LEVEL AS pos,
                SUBSTR(VAL_STRINGA,ROWNUM,1) AS CH,
                COUNT(CASE WHEN SUBSTR(VAL_STRINGA,ROWNUM,1) = ',' THEN '#' END)
                OVER (ORDER BY LEVEL) AS section
           FROM DOCUMENTO_STRINGA
     CONNECT BY LEVEL <= LENGTH(VAL_STRINGA)),
         TIPO_DOCUMENTO AS
       ( SELECT SUBSTR(TipoDoc,MIN(pos), 1 + MAX(pos) - MIN(pos)) AS DOCUMENTO
           FROM DOCUMENTI_CONCATENATI
          WHERE CH <> ','
       GROUP BY TipoDoc,section )
    SELECT COUNT(D.ID_DOCUMENTO)
      INTO nDocDeroga
      FROM DB_TIPO_CATEGORIA_DOCUMENTO TCD,
           DB_DOCUMENTO_CATEGORIA DCT,
           DB_DOCUMENTO D,
           DB_TIPO_DOCUMENTO TD
     WHERE TCD.TIPO_IDENTIFICATIVO = 'DE'
       AND TCD.ID_CATEGORIA_DOCUMENTO = DCT.ID_CATEGORIA_DOCUMENTO
       AND DCT.ID_DOCUMENTO = TD.ID_DOCUMENTO
       AND TD.ID_DOCUMENTO IN (SELECT DOCUMENTO
                                 FROM TIPO_DOCUMENTO) 
       AND D.EXT_ID_DOCUMENTO = TD.ID_DOCUMENTO
       AND D.ID_AZIENDA = P_ID_AZIENDA
       AND D.ID_STATO_DOCUMENTO IS NULL
       AND SYSDATE BETWEEN D.DATA_INIZIO_VALIDITA AND NVL(D.DATA_FINE_VALIDITA,SYSDATE);

    -- se c'e' comunicazione 10R attiva con adesione della deroga dei nitrati
    IF nCom10RConDeroga > 0 THEN
        -- controllo se ci sono documenti attivi di adesione alla deroga dei nitrati
        -- se non ce ne sono
        IF nDocDeroga = 0 THEN
           -- do apposita anomalia
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, 'Non sono presenti documenti di adesione alla deroga dei nitrati', P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;
    ELSE
        -- se invece non c'e' comunicazione 10R attiva con adesione della deroga dei nitrati
        -- controllo se ci sono documetni attivi di adesione alla deroga dei nitrati
        -- se ce ne sono
        IF nDocDeroga > 0 THEN
           -- do apposita anomalia
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, 'Sono presenti documenti di adesione alla deroga dei nitrati ma la stessa non e'' stata selezionata', P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;
    END IF;

    RETURN (TRUE);
EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE Deroga_Nitrati: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END Deroga_Nitrati;

-- controlla che sia presente il file allegato per tutti i documenti
-- con tipologia documento che lo prevede
FUNCTION Upload_Documento (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                           P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                           P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                           P_MSGERR       IN OUT VARCHAR2,
                           P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

    CURSOR curDocSenzaAllegato IS
    SELECT D.ID_DOCUMENTO,
           D.NUMERO_PROTOCOLLO,
           D.DATA_PROTOCOLLO,
           TD.DESCRIZIONE
      FROM DB_DOCUMENTO D,
           DB_TIPO_DOCUMENTO TD
     WHERE D.ID_AZIENDA = P_ID_AZIENDA
       AND D.EXT_ID_DOCUMENTO = TD.ID_DOCUMENTO
       AND TD.FLAG_UPLOAD = 'S'
       AND D.ID_STATO_DOCUMENTO IS NULL
       AND SYSDATE BETWEEN D.DATA_INIZIO_VALIDITA AND NVL(D.DATA_FINE_VALIDITA,SYSDATE)
       AND NOT EXISTS (SELECT AD.ID_ALLEGATO_DOCUMENTO
                         FROM DB_ALLEGATO_DOCUMENTO AD
                        WHERE AD.ID_DOCUMENTO = D.ID_DOCUMENTO);

    vMessaggio DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

BEGIN

    FOR recDocSenzaAllegato IN curDocSenzaAllegato LOOP
        vMessaggio := 'Per il documento: ' || recDocSenzaAllegato.DESCRIZIONE || ' Prot.' || NVL(recDocSenzaAllegato.NUMERO_PROTOCOLLO, 'N.P') || ' del ' || NVL(TO_CHAR(recDocSenzaAllegato.DATA_PROTOCOLLO,'DD/MM/YYYY'),'N.P.') ||
                      ' non e'' presente il corrispettivo file allegato';

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vMessaggio, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_DOCUMENTO (P_ID_CONTROLLO, vMessaggio, P_BLOCCANTE, recDocSenzaAllegato.ID_DOCUMENTO, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

    END LOOP;

    RETURN (TRUE);
EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE Upload_Documento: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END Upload_Documento;

-- controlla se ci sono documenti territoriali
-- con i flags flag_anag_terr = T e flag_obbligo_proprietario S
-- per i quali il proprietario presente su DB_DOCUMENTO_PROPRIETARIO
-- risulta deceduto su anagrafe tributaria
FUNCTION Proprietario_Deceduto (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                P_MSGERR       IN OUT VARCHAR2,
                                P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

    CURSOR curPropDocumentoDeceduto IS
    WITH CAT_DOC_SCTRINGA AS
       (SELECT VALORE_STRINGA AS VAL_STRINGA
          FROM DB_TIPO_CONTROLLO_PARAMETRO
         WHERE ID_CONTROLLO = P_ID_CONTROLLO
           AND CODICE = kvCodParametroIdCatDocConProp
           AND DATA_FINE_VALIDITA IS NULL),
         CATEGORIA_DOC_CONCATENATA AS
       ( SELECT VAL_STRINGA AS CatDoc,
                LEVEL AS pos,
                SUBSTR(VAL_STRINGA,ROWNUM,1) AS CH,
                COUNT(CASE WHEN SUBSTR(VAL_STRINGA,ROWNUM,1) = ',' THEN '#' END)
                OVER (ORDER BY LEVEL) AS section
           FROM CAT_DOC_SCTRINGA
     CONNECT BY LEVEL <= LENGTH(VAL_STRINGA)),
         CATEGORIA_DOCUMENTO AS
       ( SELECT SUBSTR(CatDoc,MIN(pos), 1 + MAX(pos) - MIN(pos)) AS CATEGORIA
           FROM CATEGORIA_DOC_CONCATENATA
          WHERE CH <> ','
       GROUP BY CatDoc,section )
    SELECT D.ID_DOCUMENTO,
           D.NUMERO_PROTOCOLLO,
           D.DATA_PROTOCOLLO,
           TD.DESCRIZIONE,
           DP.CUAA,
           AZT.DATA_DECESSO
      FROM DB_DOCUMENTO D,
           DB_TIPO_DOCUMENTO TD,
           DB_DOCUMENTO_PROPRIETARIO DP,
           DB_AZIENDA_TRIBUTARIA AZT,
           DB_DOCUMENTO_CATEGORIA DC
     WHERE D.ID_AZIENDA = P_ID_AZIENDA
       AND D.EXT_ID_DOCUMENTO = TD.ID_DOCUMENTO
       AND TD.FLAG_ANAG_TERR = 'T'
       -- AND TD.FLAG_OBBLIGO_PROPRIETARIO = 'S'
       AND D.ID_STATO_DOCUMENTO IS NULL
       AND D.ID_DOCUMENTO = DP.ID_DOCUMENTO
       AND TD.ID_DOCUMENTO = DC.ID_DOCUMENTO
       AND DC.ID_CATEGORIA_DOCUMENTO IN (SELECT CATEGORIA
                                           FROM CATEGORIA_DOCUMENTO)
       AND SYSDATE BETWEEN D.DATA_INIZIO_VALIDITA AND NVL(D.DATA_FINE_VALIDITA,SYSDATE)
       AND AZT.CUAA = DP.CUAA
       AND AZT.DATA_DECESSO < D.DATA_INIZIO_VALIDITA;



    vMessaggio DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

BEGIN

    FOR recPropDocumentoDeceduto IN curPropDocumentoDeceduto LOOP

        vMessaggio := 'Per il documento: ' || recPropDocumentoDeceduto.DESCRIZIONE || ' Prot.' || NVL(recPropDocumentoDeceduto.NUMERO_PROTOCOLLO, 'N.P') || ' del ' || NVL(TO_CHAR(recPropDocumentoDeceduto.DATA_PROTOCOLLO,'DD/MM/YYYY'),'N.P.') ||
                      ' il proprietario indicato : ' || recPropDocumentoDeceduto.CUAA || ' risulta deceduto il : ' || TO_CHAR(recPropDocumentoDeceduto.DATA_DECESSO,'DD/MM/YYYY');

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vMessaggio, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_DOCUMENTO (P_ID_CONTROLLO, vMessaggio, P_BLOCCANTE, recPropDocumentoDeceduto.ID_DOCUMENTO, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

    END LOOP;

    RETURN (TRUE);
EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE Proprietario_Deceduto: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END Proprietario_Deceduto;

-- verifica che i proprietari presenti
-- sui documenti territoriali attivi
-- siano anche presenti e proprietari sul catasto
-- per almeno una delle particelle associate al documento
FUNCTION Prop_Doc_EQ_Prop_Part_Catasto (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                        P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                        P_MSGERR       IN OUT VARCHAR2,
                                        P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS
    vMessaggio DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

    CURSOR curPropDocSenzaPartInPropCata IS
    WITH CAT_DOC_SCTRINGA AS
       (SELECT VALORE_STRINGA AS VAL_STRINGA
          FROM DB_TIPO_CONTROLLO_PARAMETRO
         WHERE ID_CONTROLLO = P_ID_CONTROLLO
           AND CODICE = kvCodParametroIdCatDocConProp
           AND DATA_FINE_VALIDITA IS NULL),
         CATEGORIA_DOC_CONCATENATA AS
       ( SELECT VAL_STRINGA AS CatDoc,
                LEVEL AS pos,
                SUBSTR(VAL_STRINGA,ROWNUM,1) AS CH,
                COUNT(CASE WHEN SUBSTR(VAL_STRINGA,ROWNUM,1) = ',' THEN '#' END)
                OVER (ORDER BY LEVEL) AS section
           FROM CAT_DOC_SCTRINGA
     CONNECT BY LEVEL <= LENGTH(VAL_STRINGA)),
         CATEGORIA_DOCUMENTO AS
       ( SELECT SUBSTR(CatDoc,MIN(pos), 1 + MAX(pos) - MIN(pos)) AS CATEGORIA
           FROM CATEGORIA_DOC_CONCATENATA
          WHERE CH <> ','
       GROUP BY CatDoc,section )
    SELECT D.ID_DOCUMENTO,
           D.NUMERO_PROTOCOLLO,
           D.DATA_PROTOCOLLO,
           TD.DESCRIZIONE,
           DP.CUAA
      FROM DB_DOCUMENTO D,
           DB_TIPO_DOCUMENTO TD,
           DB_DOCUMENTO_PROPRIETARIO DP,
           DB_DOCUMENTO_CATEGORIA DCAT
     WHERE D.ID_AZIENDA = P_ID_AZIENDA
       AND D.EXT_ID_DOCUMENTO = TD.ID_DOCUMENTO
       AND TD.FLAG_ANAG_TERR = 'T'
       -- AND TD.FLAG_OBBLIGO_PROPRIETARIO = 'S'
       AND D.ID_STATO_DOCUMENTO IS NULL
       AND D.ID_DOCUMENTO = DP.ID_DOCUMENTO
       AND TD.ID_DOCUMENTO = DCAT.ID_DOCUMENTO
       AND DCAT.ID_CATEGORIA_DOCUMENTO IN (SELECT CATEGORIA
                                             FROM CATEGORIA_DOCUMENTO)
       AND SYSDATE BETWEEN D.DATA_INIZIO_VALIDITA AND NVL(D.DATA_FINE_VALIDITA,SYSDATE)
       AND EXISTS (SELECT PC.ID_PARTICELLA_CERTIFICATA
                     FROM DB_DOCUMENTO_CONDUZIONE DC,
                          DB_CONDUZIONE_PARTICELLA CP,
                          DB_PARTICELLA_CERTIFICATA PC,
                          DB_PROPRIETA_CERTIFICATA PRC
                    WHERE DC.ID_DOCUMENTO = D.ID_DOCUMENTO
                      AND SYSDATE BETWEEN DC.DATA_INIZIO_VALIDITA AND NVL(DC.DATA_FINE_VALIDITA,SYSDATE)
                      AND DC.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
                      AND PC.ID_PARTICELLA = CP.ID_PARTICELLA
                      AND PC.ID_PARTICELLA_CERTIFICATA = PRC.ID_PARTICELLA_CERTIFICATA
                      AND PRC.DATA_FINE_VALIDITA IS NULL) 
       AND NOT EXISTS (SELECT PRC.ID_SOGGETTO
                         FROM DB_DOCUMENTO_CONDUZIONE DC,
                              DB_CONDUZIONE_PARTICELLA CP,
                              DB_PARTICELLA_CERTIFICATA PC,
                              DB_PROPRIETA_CERTIFICATA PRC,
                              DB_TIPO_DIRITTO TD,
                              DB_PERSONA_FISICA PF,
                              DB_SOGGETTO S
                        WHERE DC.ID_DOCUMENTO = D.ID_DOCUMENTO
                          AND SYSDATE BETWEEN DC.DATA_INIZIO_VALIDITA AND NVL(DC.DATA_FINE_VALIDITA,SYSDATE)
                          AND DC.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
                          AND PC.ID_PARTICELLA = CP.ID_PARTICELLA
                          AND PC.ID_PARTICELLA_CERTIFICATA = PRC.ID_PARTICELLA_CERTIFICATA
                          AND PRC.DATA_FINE_VALIDITA IS NULL
                          AND PRC.ID_TIPO_DIRITTO = TD.ID_TIPO_DIRITTO
                          AND TD.ID_TITOLO_POSSESSO = 1 -- proprieta
                          AND PRC.ID_SOGGETTO = S.ID_SOGGETTO
                          AND S.FLAG_FISICO = 'S'
                          AND S.ID_SOGGETTO = PF.ID_SOGGETTO
                          AND PF.CODICE_FISCALE = DP.CUAA)
       AND NOT EXISTS (SELECT PRC.ID_SOGGETTO
                         FROM DB_DOCUMENTO_CONDUZIONE DC,
                              DB_CONDUZIONE_PARTICELLA CP,
                              DB_PARTICELLA_CERTIFICATA PC,
                              DB_PROPRIETA_CERTIFICATA PRC,
                              DB_TIPO_DIRITTO TD,
                              DB_PERSONA_GIURIDICA PG,
                              DB_SOGGETTO S
                        WHERE DC.ID_DOCUMENTO = D.ID_DOCUMENTO
                          AND SYSDATE BETWEEN DC.DATA_INIZIO_VALIDITA AND NVL(DC.DATA_FINE_VALIDITA,SYSDATE)
                          AND DC.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
                          AND PC.ID_PARTICELLA = CP.ID_PARTICELLA
                          AND PC.ID_PARTICELLA_CERTIFICATA = PRC.ID_PARTICELLA_CERTIFICATA
                          AND PRC.DATA_FINE_VALIDITA IS NULL
                          AND PRC.ID_TIPO_DIRITTO = TD.ID_TIPO_DIRITTO
                          AND TD.ID_TITOLO_POSSESSO = 1 -- proprieta
                          AND PRC.ID_SOGGETTO = S.ID_SOGGETTO
                          AND S.FLAG_FISICO = 'N'
                          AND S.ID_SOGGETTO = PG.ID_SOGGETTO
                          AND (PG.CODICE_FISCALE = DP.CUAA OR PG.PARTITA_IVA = DP.CUAA));

BEGIN

    FOR recPropDocSenzaPartInPropCata IN curPropDocSenzaPartInPropCata LOOP

        vMessaggio := 'Il proprietario ' || recPropDocSenzaPartInPropCata.CUAA || ' indicato sul documento Prot. ' || NVL(recPropDocSenzaPartInPropCata.NUMERO_PROTOCOLLO, 'N.P') || ' del ' || NVL(TO_CHAR(recPropDocSenzaPartInPropCata.DATA_PROTOCOLLO,'DD/MM/YYYY'),'N.P.') || ' non e'' dichiarato a catasto come proprietario delle particelle del documento';

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vMessaggio, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_DOCUMENTO (P_ID_CONTROLLO, vMessaggio, P_BLOCCANTE, recPropDocSenzaPartInPropCata.ID_DOCUMENTO, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE Prop_Doc_EQ_Prop_Part_Catasto: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END Prop_Doc_EQ_Prop_Part_Catasto;


-- Verifica che il proprietario indicato sul documento attivo
-- sia effettivamente presente anche sul catasto per ogni particella
-- associata al documento
FUNCTION Prop_Doc_EQ_Prop_All_Part_Cat (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                        P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                        P_POST_DATA    IN VARCHAR2,
                                        P_MSGERR       IN OUT VARCHAR2,
                                        P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS
    vMessaggio DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

    CURSOR curPartDocNoProprietarioCata IS
    WITH CAT_DOC_SCTRINGA AS
       (SELECT VALORE_STRINGA AS VAL_STRINGA
          FROM DB_TIPO_CONTROLLO_PARAMETRO
         WHERE ID_CONTROLLO = P_ID_CONTROLLO
           AND CODICE = kvCodParametroIdCatDocConProp
           AND DATA_FINE_VALIDITA IS NULL),
         CATEGORIA_DOC_CONCATENATA AS
       ( SELECT VAL_STRINGA AS CatDoc,
                LEVEL AS pos,
                SUBSTR(VAL_STRINGA,ROWNUM,1) AS CH,
                COUNT(CASE WHEN SUBSTR(VAL_STRINGA,ROWNUM,1) = ',' THEN '#' END)
                OVER (ORDER BY LEVEL) AS section
           FROM CAT_DOC_SCTRINGA
     CONNECT BY LEVEL <= LENGTH(VAL_STRINGA)),
         CATEGORIA_DOCUMENTO AS
       ( SELECT SUBSTR(CatDoc,MIN(pos), 1 + MAX(pos) - MIN(pos)) AS CATEGORIA
           FROM CATEGORIA_DOC_CONCATENATA
          WHERE CH <> ','
       GROUP BY CatDoc,section )
    SELECT D.ID_DOCUMENTO,
           D.NUMERO_PROTOCOLLO,
           D.DATA_PROTOCOLLO,
           TD.DESCRIZIONE,
           DP.CUAA,
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           C.DESCOM,
           CP.ID_CONDUZIONE_PARTICELLA
      FROM DB_DOCUMENTO D,
           DB_TIPO_DOCUMENTO TD,
           DB_DOCUMENTO_PROPRIETARIO DP,
           DB_DOCUMENTO_CONDUZIONE DC,
           DB_DOCUMENTO_CATEGORIA DCAT,
           DB_CONDUZIONE_PARTICELLA CP,
           DB_STORICO_PARTICELLA SP,
           COMUNE C
     WHERE D.ID_AZIENDA = P_ID_AZIENDA
       AND D.EXT_ID_DOCUMENTO = TD.ID_DOCUMENTO
       AND TD.FLAG_ANAG_TERR = 'T'
       -- AND TD.FLAG_OBBLIGO_PROPRIETARIO = 'S'
       AND D.ID_STATO_DOCUMENTO IS NULL
       AND D.ID_DOCUMENTO = DP.ID_DOCUMENTO
       AND ((P_POST_DATA = 'S' AND D.DATA_INIZIO_VALIDITA >
                                    (SELECT TO_DATE(VALORE_STRINGA, 'DD/MM/YYYY')
                                       FROM DB_TIPO_CONTROLLO_PARAMETRO
                                      WHERE ID_CONTROLLO = P_ID_CONTROLLO
                                        AND CODICE = kvCodParamDataDaDocConPropB
                                        AND DATA_FINE_VALIDITA IS NULL)) 
         OR (P_POST_DATA = 'N' AND D.DATA_INIZIO_VALIDITA <
                                    (SELECT TO_DATE(VALORE_STRINGA, 'DD/MM/YYYY')
                                       FROM DB_TIPO_CONTROLLO_PARAMETRO
                                      WHERE ID_CONTROLLO = P_ID_CONTROLLO
                                        AND CODICE = kvCodParamDataDaDocConPropB
                                        AND DATA_FINE_VALIDITA IS NULL))) 
       AND DCAT.ID_DOCUMENTO = TD.ID_DOCUMENTO
       AND DCAT.ID_CATEGORIA_DOCUMENTO IN (SELECT CATEGORIA
                                             FROM CATEGORIA_DOCUMENTO)
       AND SYSDATE BETWEEN D.DATA_INIZIO_VALIDITA AND NVL(D.DATA_FINE_VALIDITA,SYSDATE)
       AND DC.ID_DOCUMENTO = D.ID_DOCUMENTO
       AND SYSDATE BETWEEN DC.DATA_INIZIO_VALIDITA AND NVL(DC.DATA_FINE_VALIDITA,SYSDATE)
       AND DC.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
       AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
       AND SP.DATA_FINE_VALIDITA IS NULL
       AND SP.COMUNE = C.ISTAT_COMUNE
       AND EXISTS (SELECT PC.ID_PARTICELLA_CERTIFICATA
                     FROM DB_PARTICELLA_CERTIFICATA PC,
                          DB_PROPRIETA_CERTIFICATA PRC
                    WHERE PC.ID_PARTICELLA = CP.ID_PARTICELLA
                      AND PC.ID_PARTICELLA_CERTIFICATA = PRC.ID_PARTICELLA_CERTIFICATA
                      AND PRC.DATA_FINE_VALIDITA IS NULL) 
       AND NOT EXISTS (SELECT PRC.ID_SOGGETTO
                         FROM DB_PARTICELLA_CERTIFICATA PC,
                              DB_PROPRIETA_CERTIFICATA PRC,
                              DB_TIPO_DIRITTO TD,
                              DB_PERSONA_FISICA PF,
                              DB_SOGGETTO S
                        WHERE PC.ID_PARTICELLA = CP.ID_PARTICELLA
                          AND PC.ID_PARTICELLA_CERTIFICATA = PRC.ID_PARTICELLA_CERTIFICATA
                          AND PRC.DATA_FINE_VALIDITA IS NULL
                          AND PRC.ID_TIPO_DIRITTO = TD.ID_TIPO_DIRITTO
                          AND TD.ID_TITOLO_POSSESSO = 1 -- proprieta
                          AND PRC.ID_SOGGETTO = S.ID_SOGGETTO
                          AND S.FLAG_FISICO = 'S'
                          AND S.ID_SOGGETTO = PF.ID_SOGGETTO
                          AND PF.CODICE_FISCALE = DP.CUAA)
       AND NOT EXISTS (SELECT PRC.ID_SOGGETTO
                         FROM DB_PARTICELLA_CERTIFICATA PC,
                              DB_PROPRIETA_CERTIFICATA PRC,
                              DB_TIPO_DIRITTO TD,
                              DB_PERSONA_GIURIDICA PG,
                              DB_SOGGETTO S
                        WHERE PC.ID_PARTICELLA = CP.ID_PARTICELLA
                          AND PC.ID_PARTICELLA_CERTIFICATA = PRC.ID_PARTICELLA_CERTIFICATA
                          AND PRC.DATA_FINE_VALIDITA IS NULL
                          AND PRC.ID_TIPO_DIRITTO = TD.ID_TIPO_DIRITTO
                          AND TD.ID_TITOLO_POSSESSO = 1 -- proprieta
                          AND PRC.ID_SOGGETTO = S.ID_SOGGETTO
                          AND S.FLAG_FISICO = 'N'
                          AND S.ID_SOGGETTO = PG.ID_SOGGETTO
                          AND (PG.CODICE_FISCALE = DP.CUAA OR PG.PARTITA_IVA = DP.CUAA));

BEGIN

    FOR recPartDocNoProprietarioCata IN curPartDocNoProprietarioCata LOOP

        vMessaggio := 'Il proprietario ' || recPartDocNoProprietarioCata.CUAA || ' indicato sul documento Prot. ' || NVL(recPartDocNoProprietarioCata.NUMERO_PROTOCOLLO, 'N.P') || ' del ' || NVL(TO_CHAR(recPartDocNoProprietarioCata.DATA_PROTOCOLLO,'DD/MM/YYYY'),'N.P.') || ' per la particella : ' ||
                      '[' || recPartDocNoProprietarioCata.DESCOM || ' Sez : ' || NVL(recPartDocNoProprietarioCata.SEZIONE,'N.P.') ||' Fgl:' || recPartDocNoProprietarioCata.FOGLIO || ' Part:' || recPartDocNoProprietarioCata.PARTICELLA || ' Sub : ' || NVL(recPartDocNoProprietarioCata.SUBALTERNO,'N.P.') || ']' ||
                      ' non e'' dichiarato a catasto';


        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vMessaggio, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_DOCUMENTO (P_ID_CONTROLLO, vMessaggio, P_BLOCCANTE, recPartDocNoProprietarioCata.ID_DOCUMENTO, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, vMessaggio, P_BLOCCANTE, recPartDocNoProprietarioCata.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;


    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE Prop_Doc_EQ_Prop_All_Part_Cat: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END Prop_Doc_EQ_Prop_All_Part_Cat;

-- Per i documenti territoriali attivi che prevedono l'indicazione del proprietario
-- controlla prendendo l'eventuale proprietario di ogni particella associata al documento
-- dal catasto (DB_PROPRIETA_CERTIFICATA) che esso sia anche presente su
-- DB_DOCUMENTO_PROPRIETARIO
FUNCTION Prop_Part_Cat_Eq_Prop_Doc_Part (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                         P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                         P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                         P_MSGERR       IN OUT VARCHAR2,
                                         P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

    vMessaggio DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

    CURSOR curDocConPartSenzaPropCatasto IS
    WITH CAT_DOC_SCTRINGA AS
       (SELECT VALORE_STRINGA AS VAL_STRINGA
          FROM DB_TIPO_CONTROLLO_PARAMETRO
         WHERE ID_CONTROLLO = P_ID_CONTROLLO
           AND CODICE = kvCodParametroIdCatDocConProp
           AND DATA_FINE_VALIDITA IS NULL),
         CATEGORIA_DOC_CONCATENATA AS
       ( SELECT VAL_STRINGA AS CatDoc,
                LEVEL AS pos,
                SUBSTR(VAL_STRINGA,ROWNUM,1) AS CH,
                COUNT(CASE WHEN SUBSTR(VAL_STRINGA,ROWNUM,1) = ',' THEN '#' END)
                OVER (ORDER BY LEVEL) AS section
           FROM CAT_DOC_SCTRINGA
     CONNECT BY LEVEL <= LENGTH(VAL_STRINGA)),
         CATEGORIA_DOCUMENTO AS
       ( SELECT SUBSTR(CatDoc,MIN(pos), 1 + MAX(pos) - MIN(pos)) AS CATEGORIA
           FROM CATEGORIA_DOC_CONCATENATA
          WHERE CH <> ','
       GROUP BY CatDoc,section )
    SELECT D.ID_DOCUMENTO,
           D.NUMERO_PROTOCOLLO,
           D.DATA_PROTOCOLLO,
           TDOC.DESCRIZIONE,
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           C.DESCOM,
           CP.ID_CONDUZIONE_PARTICELLA,
           CASE WHEN S.FLAG_FISICO = 'S' THEN
                (SELECT CODICE_FISCALE
                   FROM DB_PERSONA_FISICA
                  WHERE ID_SOGGETTO = S.ID_SOGGETTO)
           ELSE
                (SELECT NVL(CODICE_FISCALE,PARTITA_IVA)
                   FROM DB_PERSONA_GIURIDICA
                  WHERE ID_SOGGETTO = S.ID_SOGGETTO)
           END AS CUAA
      FROM DB_DOCUMENTO D,
           DB_TIPO_DOCUMENTO TDOC,
           DB_DOCUMENTO_CATEGORIA DCAT,
           DB_DOCUMENTO_CONDUZIONE DC,
           DB_CONDUZIONE_PARTICELLA CP,
           DB_STORICO_PARTICELLA SP,
           COMUNE C,
           DB_PARTICELLA_CERTIFICATA PC,
           DB_PROPRIETA_CERTIFICATA PRC,
           DB_TIPO_DIRITTO TD,
           DB_SOGGETTO S
     WHERE D.ID_AZIENDA = P_ID_AZIENDA
       AND D.EXT_ID_DOCUMENTO = TDOC.ID_DOCUMENTO
       AND DCAT.ID_DOCUMENTO = TDOC.ID_DOCUMENTO
       AND DCAT.ID_CATEGORIA_DOCUMENTO IN (SELECT CATEGORIA
                                             FROM CATEGORIA_DOCUMENTO)
       AND TDOC.FLAG_ANAG_TERR = 'T'
       -- AND TDOC.FLAG_OBBLIGO_PROPRIETARIO = 'S'
       AND D.ID_STATO_DOCUMENTO IS NULL
       AND SYSDATE BETWEEN D.DATA_INIZIO_VALIDITA AND NVL(D.DATA_FINE_VALIDITA,SYSDATE)
       AND DC.ID_DOCUMENTO = D.ID_DOCUMENTO
       AND SYSDATE BETWEEN DC.DATA_INIZIO_VALIDITA AND NVL(DC.DATA_FINE_VALIDITA,SYSDATE)
       AND DC.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
       AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
       AND SP.DATA_FINE_VALIDITA IS NULL
       AND SP.COMUNE = C.ISTAT_COMUNE
       AND PC.ID_PARTICELLA = CP.ID_PARTICELLA
       AND PC.ID_PARTICELLA_CERTIFICATA = PRC.ID_PARTICELLA_CERTIFICATA
       AND PRC.DATA_FINE_VALIDITA IS NULL
       AND PRC.ID_TIPO_DIRITTO = TD.ID_TIPO_DIRITTO
       AND TD.ID_TITOLO_POSSESSO = 1 -- proprieta
       AND PRC.ID_SOGGETTO = S.ID_SOGGETTO
       AND NOT EXISTS (SELECT DP.ID_DOCUMENTO_PROPRIETARIO
                         FROM DB_DOCUMENTO_PROPRIETARIO DP,
                              DB_PERSONA_FISICA PF
                        WHERE DP.ID_DOCUMENTO = D.ID_DOCUMENTO
                          AND DP.CUAA = PF.CODICE_FISCALE
                          AND PF.ID_SOGGETTO = S.ID_SOGGETTO
                          AND S.FLAG_FISICO = 'S')
       AND NOT EXISTS (SELECT DP.ID_DOCUMENTO_PROPRIETARIO
                         FROM DB_DOCUMENTO_PROPRIETARIO DP,
                              DB_PERSONA_GIURIDICA PG
                        WHERE DP.ID_DOCUMENTO = D.ID_DOCUMENTO
                          AND PG.ID_SOGGETTO = S.ID_SOGGETTO
                          AND S.FLAG_FISICO = 'N'
                          AND (PG.CODICE_FISCALE = DP.CUAA OR PG.PARTITA_IVA = DP.CUAA));



BEGIN

    FOR recDocConPartSenzaPropCatasto IN curDocConPartSenzaPropCatasto LOOP

        vMessaggio := 'Per la particella : ' ||
                      '[' || recDocConPartSenzaPropCatasto.DESCOM || ' Sez : ' || NVL(recDocConPartSenzaPropCatasto.SEZIONE,'N.P.') ||' Fgl:' || recDocConPartSenzaPropCatasto.FOGLIO || ' Part:' || recDocConPartSenzaPropCatasto.PARTICELLA || ' Sub : ' || NVL(recDocConPartSenzaPropCatasto.SUBALTERNO,'N.P.') || ']' ||
                      ' dichiarata nel documento Prot. ' || NVL(recDocConPartSenzaPropCatasto.NUMERO_PROTOCOLLO, 'N.P') || ' del ' || NVL(TO_CHAR(recDocConPartSenzaPropCatasto.DATA_PROTOCOLLO,'DD/MM/YYYY'),'N.P.') ||
                      ' il proprietario dichiarato a catasto : ' || recDocConPartSenzaPropCatasto.CUAA || ' non e'' stato indicato nel documento';


        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vMessaggio, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_DOCUMENTO (P_ID_CONTROLLO, vMessaggio, P_BLOCCANTE, recDocConPartSenzaPropCatasto.ID_DOCUMENTO, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, vMessaggio, P_BLOCCANTE, recDocConPartSenzaPropCatasto.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE Prop_Part_Cat_Eq_Prop_Doc_Part: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END Prop_Part_Cat_Eq_Prop_Doc_Part;

---------------------------------------------------------------------------------------
-- INIZIO CONTROLLI ATTESTAZIONI
---------------------------------------------------------------------------------------
FUNCTION Congruenza_Matrice_Norme    (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                     P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                    P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                     P_MSGERR       IN OUT VARCHAR2,
                                                    P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS


--    701
--    [ATT02] Verifica che siano state sottoscritte le norme previste
--    dalla matrice condizionalità varietà

CURSOR CUR_CONTROLLI IS SELECT MIN(NVL(ORDINAMENTO,0)), VALORE_NUMERICO ATTESTAZIONI_PADRE, SEGNALAZIONE, SEGNALAZIONE1
                                FROM DB_TIPO_CONTROLLO_PARAMETRO
                                WHERE ID_CONTROLLO = 701
                                  AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE) 
                                  AND CODICE='COND'
                                GROUP BY VALORE_NUMERICO,SEGNALAZIONE, SEGNALAZIONE1
                                ORDER BY 1;



CURSOR CURR_ATT (pAttPadre IN NUMBER)IS
                SELECT DISTINCT(c.id_attestazione)
                FROM
                DB_TIPO_ATTESTAZIONE b,
                DB_ATTESTAZIONE_AZIENDA c
                WHERE  B.DATA_FINE_VALIDITA IS NULL
                AND       B.ID_PADRE_CONTROLLO    =    pAttPadre
                AND      C.ID_AZIENDA                =    P_ID_AZIENDA
                AND     C.ID_ATTESTAZIONE=B.ID_ATTESTAZIONE;

/*                        SELECT DISTINCT(TIP.ID_ATTESTAZIONE) ID_ATTESTAZIONE
                        FROM     DB_UTE                                     UTE,
                                DB_CONDUZIONE_PARTICELLA             CP,
                                DB_UTILIZZO_PARTICELLA                 UP,
                                DB_TIPO_ATTESTAZIONE_VARIETA         TAV,
                                 DB_ATTESTAZIONE_AZIENDA                ATT,
                                DB_TIPO_ATTESTAZIONE                    TIP
                        WHERE UTE.DATA_FINE_ATTIVITA             IS NULL
                        AND     UTE.ID_AZIENDA                     =     P_ID_AZIENDA
                        AND     CP.ID_UTE                             =     UTE.ID_UTE
                        AND    CP.DATA_FINE_CONDUZIONE         IS NULL
                        AND    CP.ID_TITOLO_POSSESSO            !=    5
                        AND     UP.ID_CONDUZIONE_PARTICELLA     =     CP.ID_CONDUZIONE_PARTICELLA
                        AND     TAV.ID_VARIETA                     =     UP.ID_VARIETA
                        AND     TAV.DATA_FINE_VALIDITA             IS NULL
                        AND    ATT.ID_ATTESTAZIONE                =    TAV.ID_ATTESTAZIONE
                        AND     UTE.ID_AZIENDA                        =     ATT.ID_AZIENDA
                        AND    TIP.ID_ATTESTAZIONE                =    ATT.ID_ATTESTAZIONE
                        AND    TIP.DATA_FINE_VALIDITA            IS NULL
                        AND    ID_PADRE_CONTROLLO                = pAttPadre;*/


S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

nCountAtt                NUMBER;
nCount1                    NUMBER;
nCount2                    NUMBER;
nCountTot                NUMBER;
nCountPadreControlli    NUMBER;

BEGIN

    SELECT COUNT(*) INTO nCountAtt
    FROM     DB_ATTESTAZIONE_AZIENDA    ATT,
            DB_TIPO_ATTESTAZIONE        TIP
    WHERE ATT.ID_AZIENDA                     =     P_ID_AZIENDA
    AND    TIP.ID_ATTESTAZIONE                =    ATT.ID_ATTESTAZIONE
    AND    TIP.CODICE_ATTESTAZIONE            = 'COND'
    AND    TIP.DATA_FINE_VALIDITA            IS NULL;

    IF nCountAtt > 0 THEN
        FOR REC_CONTROLLI IN CUR_CONTROLLI LOOP

            -- 1)    Verificare se è prevista la condizionalità per la norma identificata
            --    dal VALORE_NUMERICO in relazione alla matrice di condizionalità

            SELECT COUNT(*) INTO nCountPadreControlli
            FROM     DB_TIPO_ATTESTAZIONE_VARIETA     a,
                    DB_TIPO_ATTESTAZIONE             b,
                    DB_CONDUZIONE_PARTICELLA         c,
                    DB_UTE                                 d,
                    DB_UTILIZZO_PARTICELLA             e
            WHERE A.DATA_FINE_VALIDITA         IS NULL
            AND     A.ID_ATTESTAZIONE                =     B.ID_ATTESTAZIONE
            AND     B.DATA_FINE_VALIDITA         IS NULL
            AND     B.ID_PADRE_CONTROLLO            =    REC_CONTROLLI.ATTESTAZIONI_PADRE
            AND     C.DATA_FINE_CONDUZIONE         IS NULL
            AND     C.ID_TITOLO_POSSESSO            !=    5
            AND     D.DATA_FINE_ATTIVITA         IS NULL
            AND     D.ID_AZIENDA                    =    P_ID_AZIENDA
            AND     C.ID_UTE                            =     D.ID_UTE
            AND     E.ID_CONDUZIONE_PARTICELLA    =     C.ID_CONDUZIONE_PARTICELLA
            AND     E.ID_VARIETA                    =     A.ID_VARIETA;


            IF nCountPadreControlli = 0 THEN
                SELECT COUNT(*) INTO nCountTot
                FROM     DB_TIPO_ATTESTAZIONE b,
                DB_ATTESTAZIONE_AZIENDA c
                WHERE  B.DATA_FINE_VALIDITA IS NULL
                AND       B.ID_PADRE_CONTROLLO    =    REC_CONTROLLI.ATTESTAZIONI_PADRE
                AND      C.ID_AZIENDA                =    P_ID_AZIENDA
                AND     C.ID_ATTESTAZIONE=B.ID_ATTESTAZIONE;

                IF nCountTot > 0 THEN
                    S_DESCRIZIONE := REC_CONTROLLI.SEGNALAZIONE1;

                    IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                        RETURN (FALSE);
                    END IF;
                END IF;

            ELSE


                nCountTot     :=    0;
                nCount1         :=    0;
                nCount2        :=    0;

                FOR REC_ATT IN CURR_ATT(REC_CONTROLLI.ATTESTAZIONI_PADRE) LOOP

                    SELECT COUNT(*) + nCount1 INTO nCount1
                    FROM DB_TIPO_CONTROLLO_PARAMETRO
                    WHERE ID_CONTROLLO = 701
                    AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE) 
                    AND    CODICE='COND'
                    AND    VALORE_NUMERICO1 = REC_ATT.ID_ATTESTAZIONE;


                    SELECT COUNT(*) + nCount2 INTO nCount2
                    FROM DB_TIPO_CONTROLLO_PARAMETRO
                    WHERE ID_CONTROLLO = 701
                    AND    CODICE='COND_EXT'
                    AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE) 
                    AND    VALORE_NUMERICO1 = REC_ATT.ID_ATTESTAZIONE;

                    nCountTot :=  nCountTot + nCount1 + nCount2;

                END LOOP;


                IF nCountTot = 0 OR (nCount1 > 0 AND  nCount2 > 0) THEN
                    S_DESCRIZIONE := REC_CONTROLLI.SEGNALAZIONE;

                    IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                        RETURN (FALSE);
                    END IF;

                END IF;

            END IF;

        END LOOP;
    END IF;

    RETURN (TRUE);
EXCEPTION
WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE CONGRUENZA_MATRICE_NORME: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END Congruenza_Matrice_Norme;



FUNCTION Condizionalita_Norme (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                             P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                            P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                             P_MSGERR       IN OUT VARCHAR2,
                                            P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS


-- 702
-- [ATT03] Verifica che siano state sottoscritte le norme previste

CURSOR CUR_CONTROLLI IS SELECT MIN(NVL(ORDINAMENTO,0)), VALORE_NUMERICO ATTESTAZIONI_PADRE, SEGNALAZIONE
                                FROM DB_TIPO_CONTROLLO_PARAMETRO
                                WHERE ID_CONTROLLO = 702
                                AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE) 
                                AND    CODICE='COND'
                                GROUP BY VALORE_NUMERICO,SEGNALAZIONE, SEGNALAZIONE1
                                ORDER BY 1;


CURSOR CURR_ATT (pAttPadre IN NUMBER)IS
                        SELECT DISTINCT(TIP.ID_ATTESTAZIONE) ID_ATTESTAZIONE
                        FROM     DB_ATTESTAZIONE_AZIENDA                ATT,
                                DB_TIPO_ATTESTAZIONE                    TIP
                        WHERE ATT.ID_AZIENDA                     =     P_ID_AZIENDA
                        AND    TIP.ID_ATTESTAZIONE                =    ATT.ID_ATTESTAZIONE
                        AND    TIP.DATA_FINE_VALIDITA            IS NULL
                        AND    ID_PADRE_CONTROLLO                = pAttPadre;



S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

nCountAtt    NUMBER;
nCount1        NUMBER;
nCount2        NUMBER;
nCountTot    NUMBER;
BEGIN

    SELECT COUNT(*) INTO nCountAtt
    FROM     DB_ATTESTAZIONE_AZIENDA    ATT,
            DB_TIPO_ATTESTAZIONE        TIP
    WHERE ATT.ID_AZIENDA                     =     P_ID_AZIENDA
    AND    TIP.ID_ATTESTAZIONE                =    ATT.ID_ATTESTAZIONE
    AND    TIP.CODICE_ATTESTAZIONE            = 'COND'
    AND    TIP.DATA_FINE_VALIDITA            IS NULL;

    IF nCountAtt > 0 THEN

        FOR REC_CONTROLLI IN CUR_CONTROLLI LOOP

            nCountTot     :=    0;
            nCount1         :=    0;
            nCount2        :=    0;

            FOR REC_ATT IN CURR_ATT(REC_CONTROLLI.ATTESTAZIONI_PADRE) LOOP

                SELECT COUNT(*) + nCount1 INTO nCount1
                FROM DB_TIPO_CONTROLLO_PARAMETRO
                WHERE ID_CONTROLLO = 702
                AND    CODICE='COND'
                AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE) 
                AND    VALORE_NUMERICO1 = REC_ATT.ID_ATTESTAZIONE;


                SELECT COUNT(*) + nCount2 INTO nCount2
                FROM DB_TIPO_CONTROLLO_PARAMETRO
                WHERE ID_CONTROLLO = 702
                AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE) 
                AND    CODICE='COND_EXT'
                AND    VALORE_NUMERICO1 = REC_ATT.ID_ATTESTAZIONE;

                nCountTot :=  nCountTot + nCount1 + nCount2;

            END LOOP;

            IF nCountTot = 0 OR (nCount1 > 0 AND  nCount2 > 0) THEN
                S_DESCRIZIONE := REC_CONTROLLI.SEGNALAZIONE;

                IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
                END IF;

            END IF;

        END LOOP;

    END IF;

    RETURN (TRUE);
EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE CONDIZIONALITA_NORME: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);


END Condizionalita_Norme;


FUNCTION Condizionalita_Piano_Colturale (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                         P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                        P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                         P_MSGERR       IN OUT VARCHAR2,
                                                        P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS


-- 703
-- [ATT04] Verifica che le condizionalità sottoscritte siano congruenti
--    con i controlli ad essi associati

CURSOR CUR_CONTROLLI_A IS SELECT DISTINCT VALORE_NUMERICO ATTESTAZIONI_PADRE, SEGNALAZIONE
                                FROM     DB_TIPO_CONTROLLO_PARAMETRO        PAR,
                                        DB_ATTESTAZIONE_AZIENDA                ATT
                                WHERE PAR.ID_CONTROLLO     =     703
                                AND    PAR.CODICE            =    'NATURA2000'
                                AND SYSDATE BETWEEN PAR.DATA_INIZIO_VALIDITA AND NVL(PAR.DATA_FINE_VALIDITA,SYSDATE)
                                AND    ATT.ID_AZIENDA                     =     P_ID_AZIENDA
                                AND    ATT.ID_ATTESTAZIONE                =     VALORE_NUMERICO;


CURSOR CUR_CONTROLLI_B IS SELECT DISTINCT VALORE_NUMERICO ATTESTAZIONI_PADRE, SEGNALAZIONE
                                FROM     DB_TIPO_CONTROLLO_PARAMETRO        PAR,
                                        DB_ATTESTAZIONE_AZIENDA                ATT
                                WHERE PAR.ID_CONTROLLO     =     703
                                AND    PAR.CODICE            =    'NO_NATURA2000'
                                AND SYSDATE BETWEEN PAR.DATA_INIZIO_VALIDITA AND NVL(PAR.DATA_FINE_VALIDITA,SYSDATE) 
                                AND    ATT.ID_AZIENDA                     =     P_ID_AZIENDA
                                AND    ATT.ID_ATTESTAZIONE                =     VALORE_NUMERICO;


CURSOR CUR_CONTROLLI_C IS SELECT DISTINCT VALORE_NUMERICO ATTESTAZIONI_PADRE, SEGNALAZIONE
                                FROM     DB_TIPO_CONTROLLO_PARAMETRO        PAR,
                                        DB_ATTESTAZIONE_AZIENDA                ATT
                                WHERE PAR.ID_CONTROLLO     =     703
                                AND    PAR.CODICE            =    'SIC_ZPS'
                                AND SYSDATE BETWEEN PAR.DATA_INIZIO_VALIDITA AND NVL(PAR.DATA_FINE_VALIDITA,SYSDATE)
                                AND    ATT.ID_AZIENDA                     =     P_ID_AZIENDA
                                AND    ATT.ID_ATTESTAZIONE                =     VALORE_NUMERICO;



S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

nZonaNat2000    NUMBER;
nNoZonaNat2000    NUMBER;
nZonaSICZPS        NUMBER;
nCountAtt        NUMBER;

BEGIN

    SELECT COUNT(*) INTO nCountAtt
    FROM     DB_ATTESTAZIONE_AZIENDA    ATT,
            DB_TIPO_ATTESTAZIONE        TIP
    WHERE ATT.ID_AZIENDA                     =     P_ID_AZIENDA
    AND    TIP.ID_ATTESTAZIONE                =    ATT.ID_ATTESTAZIONE
    AND    TIP.CODICE_ATTESTAZIONE            = 'COND'
    AND    TIP.DATA_FINE_VALIDITA            IS NULL;

    IF nCountAtt > 0 THEN

-- A
        -- Tutte le particelle ricadono in zona Naturale 2000:
        SELECT COUNT(*) INTO nZonaNat2000
        FROM     DB_CONDUZIONE_PARTICELLA     CP,
                DB_STORICO_PARTICELLA         ST,
                DB_UTE UTE
        WHERE CP.DATA_FINE_CONDUZIONE         IS NULL
        AND     ST.ID_PARTICELLA                     =    CP.ID_PARTICELLA
        AND    DATA_FINE_VALIDITA                IS NULL
        AND    NVL(ID_AREA_C,1)                    =    1
        AND     CP.ID_UTE                             =    UTE.ID_UTE
        AND     UTE.DATA_FINE_ATTIVITA             IS NULL
        AND     UTE.ID_AZIENDA                     =    P_ID_AZIENDA
        AND    CP.ID_TITOLO_POSSESSO            !=    5;

        FOR REC_CONTROLLI_A IN CUR_CONTROLLI_A LOOP
            IF nZonaNat2000 = 0 THEN
                S_DESCRIZIONE := REC_CONTROLLI_A.SEGNALAZIONE;
                IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
                END IF;
            END IF;
        END LOOP;
/*
-- B
-- Tutte le particelle non ricadono in zona Naturale 2000:
        SELECT COUNT(*) INTO nNoZonaNat2000
        FROM     DB_CONDUZIONE_PARTICELLA     CP,
                DB_STORICO_PARTICELLA         ST,
                DB_UTE UTE
        WHERE CP.DATA_FINE_CONDUZIONE         IS NULL
        AND     ST.ID_PARTICELLA                     =    CP.ID_PARTICELLA
        AND    DATA_FINE_VALIDITA                IS NULL
        AND    NVL(ID_AREA_C,-1)                    IN (2,3,4,5)
        AND     CP.ID_UTE                             =    UTE.ID_UTE
        AND     UTE.DATA_FINE_ATTIVITA             IS NULL
        AND     UTE.ID_AZIENDA                     =    P_ID_AZIENDA
        AND    CP.ID_TITOLO_POSSESSO            !=    5;

        FOR REC_CONTROLLI_B IN CUR_CONTROLLI_B LOOP
            IF nNoZonaNat2000 = 0 THEN
                S_DESCRIZIONE := REC_CONTROLLI_B.SEGNALAZIONE;
                IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
                END IF;
            END IF;
        END LOOP;
*/

-- C
-- Tutte le particelle non ricadono in zona Naturale 2000:
        SELECT COUNT(*) INTO nZonaSICZPS
        FROM     DB_CONDUZIONE_PARTICELLA     CP,
                DB_STORICO_PARTICELLA         ST,
                DB_UTE UTE
        WHERE CP.DATA_FINE_CONDUZIONE         IS NULL
        AND     ST.ID_PARTICELLA                     =    CP.ID_PARTICELLA
        AND    DATA_FINE_VALIDITA                IS NULL
        AND    NVL(ID_AREA_C,-1)                    IN (2,3,4)
        AND     CP.ID_UTE                             =    UTE.ID_UTE
        AND     UTE.DATA_FINE_ATTIVITA             IS NULL
        AND     UTE.ID_AZIENDA                     =    P_ID_AZIENDA
        AND    CP.ID_TITOLO_POSSESSO            !=    5;

        FOR REC_CONTROLLI_C IN CUR_CONTROLLI_C LOOP
            IF nZonaSICZPS = 0 THEN
                S_DESCRIZIONE := REC_CONTROLLI_C.SEGNALAZIONE;
                IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
                END IF;
            END IF;
        END LOOP;


    END IF;
    RETURN (TRUE);
EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE CONDIZIONALITA_PIANO_COLTURALE: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END Condizionalita_Piano_Colturale;

---------------------------------------------------------------------------------------
-- INIZIO CONTROLLI DICHIARAZIONE 10 R
---------------------------------------------------------------------------------------
FUNCTION RICALCOLA_COMUNICAZIONE_10R (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                     P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                    P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                     P_MSGERR       IN OUT VARCHAR2,
                                                    P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS

-- 900
CURSOR CUR_UTE IS SELECT     COM.DATA_RICALCOLO,
                                    COM.ID_UTE,
                                    COM.DATA_AGGIORNAMENTO
                        FROM     DB_COMUNICAZIONE_10R COM,
                                DB_UTE UT
                        WHERE ut.ID_AZIENDA = P_ID_AZIENDA
                        AND    UT.ID_UTE        = COM.ID_UTE
                        AND    COM.DATA_FINE_VALIDITA     IS NULL
                        AND    UT.DATA_FINE_ATTIVITA     IS NULL;


S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

--RecComunicazione10r DB_COMUNICAZIONE_10R%ROWTYPE;

dDataDich        DATE;
dDataFab            DATE;
dDataCond        DATE;
dDataAll            DATE;

ERR_COMU            EXCEPTION;
BEGIN



    S_DESCRIZIONE := NULL;

/*    BEGIN
        SELECT * INTO RecComunicazione10r FROM DB_COMUNICAZIONE_10R     WHERE ID_AZIENDA = P_ID_AZIENDA     AND    DATA_FINE_VALIDITA IS NULL;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE ERR_COMU;
    END;*/

    FOR  RecComunicazione10r IN CUR_UTE LOOP

        SELECT NVL(MAX(DATA_INSERIMENTO_DICHIARAZIONE),SYSDATE-(365*100)) INTO dDataDich FROM DB_DICHIARAZIONE_CONSISTENZA WHERE ID_AZIENDA  = P_ID_AZIENDA;

        IF NOT RecComunicazione10r.DATA_RICALCOLO > dDataDich THEN
             RAISE ERR_COMU;
        END IF;


        SELECT NVL(MAX(FA.DATA_AGGIORNAMENTO),SYSDATE-(365*100)) INTO dDataFab
        FROM  DB_UTE UT,
                DB_FABBRICATO FA,
                DB_TIPO_TIPOLOGIA_FABBRICATO TI
        WHERE UT.ID_AZIENDA = P_ID_AZIENDA
        AND    UT.DATA_FINE_ATTIVITA IS NULL
        AND    FA.ID_UTE = UT.ID_UTE
        AND    FA.DATA_FINE_VALIDITA IS NULL
        AND    TI.ID_TIPOLOGIA_FABBRICATO = FA.ID_TIPOLOGIA_FABBRICATO
        AND   TI.FLAG_PER_STOCCAGGIO = 'S';

        IF NOT RecComunicazione10r.DATA_RICALCOLO > dDataFab THEN
            RAISE ERR_COMU;
        END IF;

        IF NOT RecComunicazione10r.DATA_RICALCOLO >= RecComunicazione10r.DATA_AGGIORNAMENTO THEN
            RAISE ERR_COMU;
        END IF;

        SELECT NVL(MAX(CO.DATA_AGGIORNAMENTO),SYSDATE-(365*100)) INTO dDataCond
        FROM  DB_UTE UT,
                DB_CONDUZIONE_PARTICELLA CO
        WHERE UT.ID_AZIENDA                 = P_ID_AZIENDA
        AND    UT.DATA_FINE_ATTIVITA     IS NULL
        AND    CO.ID_UTE                     = UT.ID_UTE
        AND    CO.DATA_FINE_CONDUZIONE IS NULL;

        IF NOT RecComunicazione10r.DATA_RICALCOLO > dDataCond THEN
            RAISE ERR_COMU;
        END IF;


        SELECT NVL(MAX(AL.DATA_AGGIORNAMENTO),SYSDATE-(365*100)) INTO dDataAll
        FROM  DB_UTE UT,
                DB_ALLEVAMENTO AL
        WHERE UT.ID_AZIENDA = P_ID_AZIENDA
        AND    UT.DATA_FINE_ATTIVITA IS NULL
        AND    AL.ID_UTE = UT.ID_UTE
        AND    AL.DATA_FINE IS NULL;


        IF NOT RecComunicazione10r.DATA_RICALCOLO > dDataAll THEN
            RAISE ERR_COMU;
        END IF;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN ERR_COMU    THEN
        S_DESCRIZIONE :='E'' stata modificata la consistenza aziendale dopo l''ultimo ricalcolo della Comunicazione 10/R. Rieseguire il Ricalcolo (Voce di menu Comunicazione 10/R >>> ricalcola';

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;
        RETURN (TRUE);
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE RICALCOLA_COMUNICAZIONE_10R: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END RICALCOLA_COMUNICAZIONE_10R;

-- corretto il controllo per verificare solamente le aziende in ZVN
-- tolte inoltre numerose parti di codice commentato che facevano la muffa
FUNCTION AZOTO_PRODOTTO (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                         P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                         P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                         P_MSGERR       IN OUT VARCHAR2,
                         P_CODERR           IN OUT VARCHAR2
                         ) RETURN BOOLEAN IS


    CURSOR CUR_UTE IS
    SELECT COM.ID_COMUNICAZIONE_10R,
           COM.DATA_RICALCOLO,
           COM.ID_UTE,
           COM.DATA_AGGIORNAMENTO,
           COM.TOTALE_AZOTO_AZIENDALE
      FROM DB_COMUNICAZIONE_10R COM,
           DB_UTE UT
     WHERE UT.ID_AZIENDA = P_ID_AZIENDA
       AND UT.ID_UTE = COM.ID_UTE
       AND COM.DATA_FINE_VALIDITA IS NULL
       AND UT.DATA_FINE_ATTIVITA IS NULL;


    S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    nTotAzotoAz                NUMBER;
    nTotAzoto                NUMBER;
    vCodErr                    VARCHAR2(1);
    vDesErr                    VARCHAR2(500);
    nTotTmp1                NUMBER;
    nTotTmp2                NUMBER;
    nTmp1                    NUMBER;
    nTmp2                    NUMBER;
    nLimiteAz                NUMBER;
    vFlagZvn                VARCHAR2(1);
    ERR_TROVA_AZOTO            EXCEPTION;
BEGIN

    S_DESCRIZIONE     := NULL;
    nTotAzoto        := 0;

    SELECT NVL(SUM(NVL(TOTALE_AZOTO_AZIENDALE,0)),0)
      INTO nTotAzotoAz
      FROM DB_COMUNICAZIONE_10R COM,
           DB_UTE UT
     WHERE UT.ID_AZIENDA = P_ID_AZIENDA
       AND UT.ID_UTE = COM.ID_UTE
       AND COM.DATA_FINE_VALIDITA IS NULL
       AND UT.DATA_FINE_ATTIVITA IS NULL;

    nTotAzoto :=  ROUND(nTotAzotoAz);
    vFlagZvn := 'N';
    nTotTmp1 := 0;
    nTotTmp2 := 0;

    FOR RecComunicazione10r IN CUR_UTE LOOP
        Pack_Comunicazione_10r.CALCOLA_SUPERF_SAU_BIS (    RecComunicazione10r.ID_UTE,nTmp1,vCodErr,vDesErr);
        nTotTmp1    := nTotTmp1 + nTmp1;
        IF vCodErr = 1 THEN
            vDesErr :=     'procedura CALCOLA_SUPERF_SAU_BIS '||vDesErr;
            RAISE ERR_TROVA_AZOTO;
        END IF;

        Pack_Comunicazione_10r.CALCOLA_SUPERF_ZVN_SAU_BIS (    RecComunicazione10r.ID_UTE,nTmp2,vCodErr,vDesErr);
        nTotTmp2    := nTotTmp2 + nTmp2;
        IF vCodErr = 1 THEN
            vDesErr :=     'procedura CALCOLA_SUPERF_ZVN_SAU_BIS '||vDesErr;
            RAISE ERR_TROVA_AZOTO;
        END IF;
    END LOOP;

    -- setto il flag ZVN in base al rapporto tra superficie agricola utilizzata
    -- e superficie agricola utilizzata in ZVN
    IF nTotTmp1 <> 0 THEN
        -- divido superficie agricola utilizzata ZVN per superficie agricola utilizzata non in ZVN
        IF nTotTmp2 / nTotTmp1 * 100 >= 25  THEN
            -- se è dal 25% in poi sono in ZVN
            vFlagZvn := 'S';
        END IF;
    ELSE
        -- se la superficie agricola non in ZVN è a zero vuol dire che deve essere per forza ZVN (opinabile)
        vFlagZvn := 'S';
    END IF;

    IF vFlagZvn = 'S' THEN
        -- setto il limite massimo di azoto
        nLimiteAz := 3000;
        -- ed in caso quello prodotto sia superiore do apposita anomalia
        IF nTotAzoto > nLimiteAz  THEN
            S_DESCRIZIONE := 'L''azoto aziendale prodotto, per l''azienda in ZVN, è ' || nTotAzoto || ' kg. Verificare la necessità di fare il PUA /PUAS poiché superiore a ' || nLimiteAz || ' kg.';

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;

        END IF;
    END IF;

    RETURN (TRUE);

EXCEPTION
    WHEN ERR_TROVA_AZOTO THEN
        p_MsgErr   := 'ERRORE AZOTO_PRODOTTO: ' || vDesErr;
        p_CodErr   := '1';
        RETURN (FALSE);
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE AZOTO_PRODOTTO: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END AZOTO_PRODOTTO;


FUNCTION RICETTIVITA_AZOTO_TERRENI (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                    P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                    P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                     P_MSGERR       IN OUT VARCHAR2,
                                                    P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS

/*

    902
    Verifica che la q.ta' di azoto aziendale prodotto dall'azienda al netto delle
    cessioni e acquisizioni sia inferiore alla ricettivita' massima di azoto disponibile sui terreni dell'azienda.

*/

CURSOR CUR_UTE IS SELECT     COM.ID_COMUNICAZIONE_10R,
                                    COM.DATA_RICALCOLO,
                                    COM.ID_UTE,
                                    COM.DATA_AGGIORNAMENTO,
                                    COM.TOTALE_AZOTO_AZIENDALE,
--                                    COM.TOTALE_AZOTO,
                                    COM.AZOTO_CONDUZIONE_ZVN,
                                    COM.AZOTO_ASSERVIMENTO_ZVN,
                                    COM.AZOTO_CONDUZIONE_NO_ZVN,
                                    COM.AZOTO_ASSERVIMENTO_NO_ZVN
                        FROM     DB_COMUNICAZIONE_10R COM,
                                DB_UTE UT,
                                COMUNE CM,
                                PROVINCIA PR
                        WHERE ut.ID_AZIENDA                 = P_ID_AZIENDA
                        AND    UT.ID_UTE                    = COM.ID_UTE
                        AND    UT.COMUNE                    = CM.ISTAT_COMUNE
                        AND   CM.ISTAT_PROVINCIA         = PR.ISTAT_PROVINCIA
                        AND   PR.ID_REGIONE = '01' -- Piemonte MS 21/04/2011
                        AND    COM.DATA_FINE_VALIDITA     IS NULL
                        AND    UT.DATA_FINE_ATTIVITA     IS NULL;


S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

--RecComunicazione10r DB_COMUNICAZIONE_10R%ROWTYPE;

nQuantitaAzotoAcq        NUMBER;
nQuantitaAzotoCeduto    NUMBER;
nTotAzoto                NUMBER;
nMaxRicetTerr            NUMBER;

ERR_AZOTO        EXCEPTION;
BEGIN

    S_DESCRIZIONE := NULL;
    nTotAzoto         := 0;
    nMaxRicetTerr    := 0;

    BEGIN
--        SELECT * INTO RecComunicazione10r FROM DB_COMUNICAZIONE_10R     WHERE ID_AZIENDA = P_ID_AZIENDA     AND    DATA_FINE_VALIDITA IS NULL;

        FOR  RecComunicazione10r IN CUR_UTE LOOP

            SELECT NVL(SUM(NVL(QUANTITA_AZOTO_DICHIARATO,0)),0)  --NVL(SUM(NVL(QUANTITA_AZOTO,0)),0)
            INTO nQuantitaAzotoAcq
            FROM  DB_EFFLUENTE_CES_ACQ_10R EF,
                    DB_TIPO_EFFLUENTE        TI
            WHERE EF.ID_COMUNICAZIONE_10R        = RecComunicazione10r.ID_COMUNICAZIONE_10R
            AND    EF.ID_CAUSALE_EFFLUENTE        = 2
            AND    TI.ID_EFFLUENTE                 = EF.ID_EFFLUENTE
            AND    TI.DATA_FINE_VALIDITA         IS NULL;


            SELECT NVL(SUM(NVL(QUANTITA_AZOTO_DICHIARATO,0)),0)  --NVL(SUM(NVL(QUANTITA_AZOTO,0)),0)
            INTO nQuantitaAzotoCeduto
            FROM  DB_EFFLUENTE_CES_ACQ_10R EF,
                    DB_TIPO_EFFLUENTE        TI
            WHERE EF.ID_COMUNICAZIONE_10R        = RecComunicazione10r.ID_COMUNICAZIONE_10R
            AND    EF.ID_CAUSALE_EFFLUENTE        = 1
            AND    TI.ID_EFFLUENTE                 = EF.ID_EFFLUENTE
            AND    TI.DATA_FINE_VALIDITA         IS NULL;

--            nTotAzoto :=  nTotAzoto + (ROUND(RecComunicazione10r.TOTALE_AZOTO) + ROUND(nQuantitaAzotoAcq) - ROUND(nQuantitaAzotoCeduto));
            nTotAzoto :=  nTotAzoto + (ROUND(RecComunicazione10r.TOTALE_AZOTO_AZIENDALE) + ROUND(nQuantitaAzotoAcq) - ROUND(nQuantitaAzotoCeduto));

            nMaxRicetTerr    := nMaxRicetTerr + (ROUND(RecComunicazione10r.AZOTO_CONDUZIONE_ZVN) + ROUND(RecComunicazione10r.AZOTO_ASSERVIMENTO_ZVN) + ROUND(RecComunicazione10r.AZOTO_CONDUZIONE_NO_ZVN) + ROUND(RecComunicazione10r.AZOTO_ASSERVIMENTO_NO_ZVN));
        END LOOP;

        IF NOT nTotAzoto <= nMaxRicetTerr THEN
            RAISE ERR_AZOTO;
        END IF;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            NULL;
    END;

    RETURN (TRUE);

EXCEPTION
    WHEN ERR_AZOTO    THEN
--      S_DESCRIZIONE := 'L''azoto aziendale prodotto '||nTotAzoto|| '(kg) e'' superiore alla ricettività massima dell''azienda ' || nMaxRicetTerr || '(kg)';
      S_DESCRIZIONE := 'L''azoto aziendale prodotto al netto delle cessioni/acquisizioni di altre aziende è '||nTotAzoto|| '(kg) ,superiore alla massima ricettività di azoto disponibile sui terreni dell''azienda ' || nMaxRicetTerr || '(kg)';

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;
      RETURN (TRUE);
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE RICETTIVITA_AZOTO_TERRENI: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END RICETTIVITA_AZOTO_TERRENI;



FUNCTION STOC_INSUFFICIENTE     (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                            P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                            P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                             P_MSGERR       IN OUT VARCHAR2,
                                            P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS


-- 903
S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

CURSOR CUR_UTE IS SELECT     COM.ID_COMUNICAZIONE_10R,
                                    COM.DATA_RICALCOLO,
                                    COM.ID_UTE,
                                    COM.DATA_AGGIORNAMENTO,
                                    COM.STOC_DISP_PALABILE_VOL,
                                    COM.STOC_DISP_NONPALABILE_VOL,
                                    COM.VOLUME_REFLUO_AZIENDA,
                                    COM.VOLUME_PIOGGE,
                                    COM.ACQUE_LAVAGGIO,
                                    STOC_ACQUE_NEC_VOL
                        FROM     DB_COMUNICAZIONE_10R COM,
                                DB_UTE UT,
                                COMUNE CM,
                                PROVINCIA PR
                        WHERE ut.ID_AZIENDA                 = P_ID_AZIENDA
                        AND    UT.ID_UTE                    = COM.ID_UTE
                        AND    UT.COMUNE                    = CM.ISTAT_COMUNE
                        AND   CM.ISTAT_PROVINCIA         = PR.ISTAT_PROVINCIA
                        AND   PR.ID_REGIONE = '01' -- PIEMONTE MS 21/04/2011
                        AND    COM.DATA_FINE_VALIDITA     IS NULL
                        AND    UT.DATA_FINE_ATTIVITA     IS NULL;


--RecComunicazione10r DB_COMUNICAZIONE_10R%ROWTYPE;

nStoc_1                    NUMBER;
nStoc_2                    NUMBER;
nStoc_3                     NUMBER;
nStoc_4                     NUMBER;
nStoc_5                     NUMBER;
nStoc_6                    NUMBER;
nStocNec                    NUMBER;
nVolumeRefluoExtra    NUMBER;

ERR_AZOTO                EXCEPTION;

BEGIN

    S_DESCRIZIONE := NULL;
    nStoc_1 := 0;
    nStoc_2 := 0;
    nStocNec:= 0;
    nStoc_3 := 0;
    nStoc_4 := 0;
    nStoc_5 := 0;
    nStoc_6 := 0;
    BEGIN
--        SELECT * INTO RecComunicazione10r FROM DB_COMUNICAZIONE_10R     WHERE ID_AZIENDA = P_ID_AZIENDA     AND    DATA_FINE_VALIDITA IS NULL;
        FOR  RecComunicazione10r IN CUR_UTE LOOP
        -- primo controllo
            nStoc_1   := nStoc_1 + ROUND(RecComunicazione10r.STOC_DISP_PALABILE_VOL);-- + ROUND(RecComunicazione10r.STOC_DISP_NONPALABILE_VOL);

            SELECT NVL(SUM(NVL(EFF.STOC_NECESSARIO_VOL,0)),0) INTO nStocNec
            FROM     DB_EFFLUENTE_10R        EFF,
                    DB_TIPO_EFFLUENTE        TIP
            WHERE EFF.ID_COMUNICAZIONE_10R        = RecComunicazione10r.ID_COMUNICAZIONE_10R
            AND    TIP.ID_EFFLUENTE                =    EFF.ID_EFFLUENTE
            AND    TIP.FLAG_PALABILE = 'S';

            nStoc_2 := nStoc_2 + nStocNec;


        -- secondo controllo
            nStoc_3   :=  nStoc_3 + ROUND(RecComunicazione10r.STOC_DISP_NONPALABILE_VOL);

            SELECT NVL(SUM(NVL(EFF.STOC_NECESSARIO_VOL,0)),0)  + NVL(RecComunicazione10r.STOC_ACQUE_NEC_VOL,0)
            INTO nStocNec
            FROM     DB_EFFLUENTE_10R        EFF,
                    DB_TIPO_EFFLUENTE        TIP
            WHERE EFF.ID_COMUNICAZIONE_10R    = RecComunicazione10r.ID_COMUNICAZIONE_10R
            AND    TIP.ID_EFFLUENTE                =    EFF.ID_EFFLUENTE
            AND    TIP.FLAG_PALABILE = 'N';


            nStoc_4 := nStoc_4 + nStocNec;


            -- terzo controllo
            nStoc_5   := nStoc_5 + ROUND(RecComunicazione10r.STOC_DISP_PALABILE_VOL) + ROUND(RecComunicazione10r.STOC_DISP_NONPALABILE_VOL);

            SELECT NVL(SUM(NVL(STOC_NECESSARIO_VOL,0)),0) +  NVL(RecComunicazione10r.STOC_ACQUE_NEC_VOL,0) INTO nStocNec
            FROM DB_EFFLUENTE_10R
            WHERE ID_COMUNICAZIONE_10R        = RecComunicazione10r.ID_COMUNICAZIONE_10R;

            nStoc_6 := nStoc_6 + nStocNec;

        END LOOP;

        -- primo controllo
        IF nStoc_1 - nStoc_2  < 0 THEN
            S_DESCRIZIONE := 'Lo stoccaggio disponibile per i reflui palabili prodotti '||ROUND(nStoc_1,1)||' m3 ,risulta insufficiente rispetto a quello necessario '||ROUND(nStoc_2,1)||' m3.';

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                RAISE ERR_AZOTO;
            END IF;

        END IF;

        -- secondo controllo
        IF nStoc_3 - nStoc_4  < 0 THEN
            S_DESCRIZIONE := 'Lo stoccaggio disponibile per i reflui non palabili prodotti '||ROUND(nStoc_3,1)||' m3 ,risulta insufficiente rispetto a quello necessario '||ROUND(nStoc_4,1)||' m3.';

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                RAISE ERR_AZOTO;
            END IF;

        END IF;

        -- terzo controllo
        IF nStoc_5 - nStoc_6  < 0 THEN
            S_DESCRIZIONE := 'Lo stoccaggio disponibile per i reflui prodotti '||ROUND(nStoc_5,1)||' m3 ,risulta insufficiente rispetto a quello necessario '||ROUND(nStoc_6,1)||' m3.';

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                RAISE ERR_AZOTO;
            END IF;

        END IF;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            NULL;
    END;

    RETURN (TRUE);

EXCEPTION
    WHEN ERR_AZOTO    THEN
        RETURN (FALSE);

    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE STOC_INSUFFICIENTE: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END STOC_INSUFFICIENTE;


FUNCTION SUPERFICIE_AGRONOMIC_SAU     (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                    P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                    P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                     P_MSGERR       IN OUT VARCHAR2,
                                                    P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS

/*
    904
    [10R05] Verifica , per le conduzioni diverse da asservimento, che la somma degli usi del suolo idonei alla spandibilita'
    per conduzioni non asservimento +  la somma degli usi del suolo idonei alla spandibilita'
    per conduzioni non asservimento dichiarate nelle ultime d.c. di altre aziende le cui particelle
    ricadono in conduzione asservimento sul piano in lavorazione sia maggiore delle superfici
    agronomiche + le superfici condotte in asservimento.
*/

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

nSupSpandibileUte            NUMBER;
nSupAgro    NUMBER;

vCodErr            VARCHAR2(100);
vDesErr            VARCHAR2(100);

ERR_AZOTO        EXCEPTION;


BEGIN

    S_DESCRIZIONE := NULL;


    /*
        Calcolo la superfice agronomica dichiarata
        Come somma delle superfice agronomica per conduzioni diverse da asservimento
        e superfice condotta per conduzioni asservimento
     */

    BEGIN
        SELECT NVL(SUM(NVL(SUPERFICIE_UTILIZZATA,0)),0)
        INTO nSupSpandibileUte
        FROM  DB_UTE UT,
                DB_CONDUZIONE_PARTICELLA CO,
                DB_UTILIZZO_PARTICELLA   UT,
                DB_TIPO_UTILIZZO             TI,
                COMUNE CM,
                PROVINCIA PR
        WHERE    ut.ID_AZIENDA                         = P_ID_AZIENDA
        AND    CO.ID_UTE                             =     UT.ID_UTE
        AND    CO.DATA_FINE_CONDUZIONE         IS NULL
        AND    ID_TITOLO_POSSESSO                 != 5
        AND    UT.ID_CONDUZIONE_PARTICELLA    = CO.ID_CONDUZIONE_PARTICELLA
        AND    UT.ID_UTILIZZO                        = TI.ID_UTILIZZO
        AND    TI.FLAG_USO_AGRONOMICO            = 'S'
        AND    UT.COMUNE                            = CM.ISTAT_COMUNE
        AND   CM.ISTAT_PROVINCIA                 = PR.ISTAT_PROVINCIA
        AND   PR.ID_REGIONE = '01' 
        AND    UT.DATA_FINE_ATTIVITA             IS NULL;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            nSupSpandibileUte := 0;
    END;


    BEGIN
    SELECT NVL(SUM(NVL(CO.SUPERFICIE_AGRONOMICA,0)),0)
    INTO nSupAgro
    FROM  DB_UTE UT,
            DB_CONDUZIONE_PARTICELLA CO,
            COMUNE CM,
            PROVINCIA PR
    WHERE UT.ID_AZIENDA                 = P_ID_AZIENDA
    AND    UT.DATA_FINE_ATTIVITA     IS NULL
    AND    CO.ID_UTE                     = UT.ID_UTE
    AND    UT.COMUNE                    = CM.ISTAT_COMUNE
    AND   CM.ISTAT_PROVINCIA         = PR.ISTAT_PROVINCIA
    AND   PR.ID_REGIONE = '01' 
    AND    CO.DATA_FINE_CONDUZIONE IS NULL
    AND    ID_TITOLO_POSSESSO         != 5;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            nSupAgro:=0;
    END;


--        Pack_Comunicazione_10r.CALCOLA_SUPERF_SAU_SPANDIBILE(RecComunicazione10r.ID_UTE,nSupSpandibileUte,vCodErr,vDesErr);
    IF   nSupSpandibileUte >= nSupAgro  THEN
        NULL;
    ELSE
        RAISE ERR_AZOTO;
    END IF;

    RETURN (TRUE);

EXCEPTION
    WHEN ERR_AZOTO    THEN

            S_DESCRIZIONE :='Le  superfici relative agli usi del suolo, congruenti con la SAU, legate alle particelle in conduzione diversa da asservimento presenti sul piano in lavorazione dell ''azienda '|| TRIM(TO_CHAR(NVL(nSupSpandibileUte,0),'999G990D9999'))||' ha, sono inferiori alla superficie ad uso agronomico dichiarata per le stesse particelle presenti sul piano in lavorazione dell''azienda';
        IF vCodErr = '1' THEN
            S_DESCRIZIONE := S_DESCRIZIONE||vDesErr;
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;
      RETURN (TRUE);
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE SUPERFICIE_AGRONOMIC_SAU: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END SUPERFICIE_AGRONOMIC_SAU;



FUNCTION SUPERFICIE_AGRO_SAU_NO_CONGRUO     (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                            P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                            P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                             P_MSGERR       IN OUT VARCHAR2,
                                                            P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS

/*
    913
        [10R14] Verifica, per le conduzioni in asservimento, che la somma degli usi del suolo
        idonei alla spandibilità per conduzioni non asservimento +  la somma degli usi
        del suolo idonei alla spandibilità per conduzioni non asservimento dichiarate
        nelle ultime d.c. di altre aziende le cui particelle ricadono in conduzione
        asservimento sul piano in lavorazione sia maggiore delle superfici agronomiche +
        le superfici condotte in asservimento.*/

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

nSupSpandibileUte            NUMBER;
nSupCond                        NUMBER;
vCodErr            VARCHAR2(100);
vDesErr            VARCHAR2(100);

ERR_AZOTO        EXCEPTION;


BEGIN

    S_DESCRIZIONE := NULL;

    /*
        Calcolo la superfice agronomica dichiarata
        Come somma delle superfice agronomica per conduzioni diverse da asservimento
        e superfice condotta per conduzioni asservimento
     */

        BEGIN
        SELECT NVL(SUM(NVL(UT.SUPERFICIE_UTILIZZATA,0)),0)
        INTO nSupSpandibileUte
        FROM      DB_CONDUZIONE_DICHIARATA CD,
                    DB_DICHIARAZIONE_CONSISTENZA DC,
                    DB_ANAGRAFICA_AZIENDA AA,
                    DB_UTILIZZO_DICHIARATO   UT,
                    DB_TIPO_UTILIZZO             TI,
                    DB_UTE                        UTE,
                    COMUNE CM,
                    PROVINCIA PR
        WHERE CD.CODICE_FOTOGRAFIA_TERRENI         =     DC.CODICE_FOTOGRAFIA_TERRENI
        AND    AA.ID_AZIENDA                             =     DC.ID_AZIENDA
        AND     AA.DATA_FINE_VALIDITA                 IS NULL
        AND     AA.DATA_CESSAZIONE                     IS NULL
        AND    AA.ID_AZIENDA                             <> P_ID_AZIENDA
        AND    AA.ID_AZIENDA                             =     UTE.ID_AZIENDA
        AND    UTE.COMUNE                                =     CM.ISTAT_COMUNE
        AND   CM.ISTAT_PROVINCIA                     =     PR.ISTAT_PROVINCIA
        AND   PR.ID_REGIONE = '01' 
        AND    UTE.DATA_FINE_ATTIVITA                 IS NULL
       AND    DC.ID_MOTIVO_DICHIARAZIONE             <> 7
        AND    DC.DATA_INSERIMENTO_DICHIARAZIONE     =  (    SELECT MAX(DCX.DATA_INSERIMENTO_DICHIARAZIONE)
                                                                        FROM     DB_DICHIARAZIONE_CONSISTENZA    DCX,
                                                                                DB_TIPO_MOTIVO_DICHIARAZIONE     TI
                                                                    WHERE DCX.ID_AZIENDA = DC.ID_AZIENDA
                                                                   AND   DCX.ID_MOTIVO_DICHIARAZIONE <> 7
                                                                        AND    TI.ID_MOTIVO_DICHIARAZIONE = DCX.ID_MOTIVO_DICHIARAZIONE
                                                                        AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                                                    )
        AND    ID_TITOLO_POSSESSO                     != 5
        AND     UT.ID_CONDUZIONE_DICHIARATA        =    CD.ID_CONDUZIONE_DICHIARATA
        AND    UT.ID_UTILIZZO                            =    TI.ID_UTILIZZO
       AND    (TI.FLAG_USO_AGRONOMICO                = 'S')
        AND CD.ID_PARTICELLA IN (    SELECT  DISTINCT (CO1.ID_PARTICELLA)
                                            FROM      DB_UTE UT1,
                                                        COMUNE CM,
                                                        PROVINCIA PR,
                                                        DB_CONDUZIONE_PARTICELLA CO1
                                            WHERE UT1.ID_AZIENDA                 = P_ID_AZIENDA
                                            AND    UT1.COMUNE                        = CM.ISTAT_COMUNE
                                            AND   CM.ISTAT_PROVINCIA             = PR.ISTAT_PROVINCIA
                                            AND   PR.ID_REGIONE = '01' 
                                            AND    UT1.DATA_FINE_ATTIVITA         IS NULL
                                            AND    CO1.ID_UTE                         = UT1.ID_UTE
                                            AND    CO1.DATA_FINE_CONDUZIONE     IS NULL
                                            AND    CO1.ID_TITOLO_POSSESSO         = 5
                                        );
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                nSupSpandibileUte := 0;
        END;






    BEGIN
        SELECT NVL(SUM(NVL(CO.SUPERFICIE_CONDOTTA,0)),0)
        INTO nSupCond
        FROM      DB_UTE UT,
                  DB_CONDUZIONE_PARTICELLA CO,
                    COMUNE CM,
                    PROVINCIA PR
        WHERE UT.ID_AZIENDA                 = P_ID_AZIENDA
        AND    UT.DATA_FINE_ATTIVITA     IS NULL
        AND    UT.COMUNE                    = CM.ISTAT_COMUNE
        AND   CM.ISTAT_PROVINCIA         = PR.ISTAT_PROVINCIA
        AND   PR.ID_REGIONE = '01' 
        AND    CO.ID_UTE                     = UT.ID_UTE
        AND    CO.DATA_FINE_CONDUZIONE IS NULL
        AND    ID_TITOLO_POSSESSO         = 5
        AND    ID_PARTICELLA        IN    (            SELECT ID_PARTICELLA
                                                            FROM      DB_CONDUZIONE_DICHIARATA CD,
                                                                        DB_DICHIARAZIONE_CONSISTENZA DC,
                                                                        DB_ANAGRAFICA_AZIENDA AA,
                                                                        DB_UTILIZZO_DICHIARATO   UT,
                                                                        DB_TIPO_UTILIZZO             TI,
                                                                        DB_UTE                        UTE,
                                                                        COMUNE CM,
                                                                        PROVINCIA PR
                                                            WHERE CD.CODICE_FOTOGRAFIA_TERRENI         =     DC.CODICE_FOTOGRAFIA_TERRENI
                                                            AND    AA.ID_AZIENDA                             =     DC.ID_AZIENDA
                                                            AND AA.DATA_FINE_VALIDITA                 IS NULL
                                                            AND AA.DATA_CESSAZIONE                     IS NULL
                                                            AND    AA.ID_AZIENDA                             <> P_ID_AZIENDA
                                                            AND    AA.ID_AZIENDA                             =     UTE.ID_AZIENDA
                                                            AND    UTE.COMUNE                                =     CM.ISTAT_COMUNE
                                                            AND CM.ISTAT_PROVINCIA                     =     PR.ISTAT_PROVINCIA
                                                            AND PR.ID_REGIONE = '01' 
                                                            AND    UTE.DATA_FINE_ATTIVITA                 IS NULL
                                                            AND    DC.ID_MOTIVO_DICHIARAZIONE             <> 7
                                                            AND    DC.DATA_INSERIMENTO_DICHIARAZIONE     =  (    SELECT MAX(DCX.DATA_INSERIMENTO_DICHIARAZIONE)
                                                                                                                            FROM     DB_DICHIARAZIONE_CONSISTENZA    DCX,
                                                                                                                                    DB_TIPO_MOTIVO_DICHIARAZIONE     TI
                                                                                                                        WHERE DCX.ID_AZIENDA = DC.ID_AZIENDA
                                                                                                                       AND   DCX.ID_MOTIVO_DICHIARAZIONE <> 7
                                                                                                                            AND    TI.ID_MOTIVO_DICHIARAZIONE = DCX.ID_MOTIVO_DICHIARAZIONE
                                                                                                                            AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                                                                                                        )
                                                            AND    ID_TITOLO_POSSESSO                     != 5
                                                            AND     UT.ID_CONDUZIONE_DICHIARATA        =    CD.ID_CONDUZIONE_DICHIARATA
                                                            AND    UT.ID_UTILIZZO                            =    TI.ID_UTILIZZO
                                                           AND    (TI.FLAG_USO_AGRONOMICO                    = 'S')
                                                            AND CD.ID_PARTICELLA IN (    SELECT  DISTINCT (CO1.ID_PARTICELLA)
                                                                                                FROM      DB_UTE UT1,
                                                                                                            COMUNE CM,
                                                                                                            PROVINCIA PR,
                                                                                                            DB_CONDUZIONE_PARTICELLA CO1
                                                                                                WHERE UT1.ID_AZIENDA                 = P_ID_AZIENDA
                                                                                                AND    UT1.COMUNE                        = CM.ISTAT_COMUNE
                                                                                                AND   CM.ISTAT_PROVINCIA             = PR.ISTAT_PROVINCIA
                                                                                                AND   PR.ID_REGIONE = '01' 
                                                                                                AND    UT1.DATA_FINE_ATTIVITA         IS NULL
                                                                                                AND    CO1.ID_UTE                         = UT1.ID_UTE
                                                                                                AND    CO1.DATA_FINE_CONDUZIONE     IS NULL
                                                                                                AND    CO1.ID_TITOLO_POSSESSO         = 5
                                                        )
                                        );


    EXCEPTION
         WHEN NO_DATA_FOUND THEN
            nSupCond:=0;
    END;


/*
    BEGIN

        SELECT NVL(SUM(NVL(SUPERFICIE_AGRONOMICA,0)),0)
        INTO nSupAgro
        FROM      DB_CONDUZIONE_DICHIARATA CD,
                    DB_DICHIARAZIONE_CONSISTENZA DC,
                    DB_ANAGRAFICA_AZIENDA AA,
                    DB_UTILIZZO_DICHIARATO   UT,
                    DB_TIPO_UTILIZZO             TI,
                    DB_UTE                        UTE
        WHERE CD.CODICE_FOTOGRAFIA_TERRENI         =     DC.CODICE_FOTOGRAFIA_TERRENI
        AND    AA.ID_AZIENDA                             =     DC.ID_AZIENDA
        AND     AA.DATA_FINE_VALIDITA                 IS NULL
        AND     AA.DATA_CESSAZIONE                     IS NULL
        AND    AA.ID_AZIENDA                             <> P_ID_AZIENDA
        AND    AA.ID_AZIENDA                             =     UTE.ID_AZIENDA
        AND    UTE.DATA_FINE_ATTIVITA                 IS NULL
       AND    DC.ID_MOTIVO_DICHIARAZIONE             <> 7
        AND    DC.DATA_INSERIMENTO_DICHIARAZIONE     =  (    SELECT MAX(DATA_INSERIMENTO_DICHIARAZIONE)
                                                                        FROM   DB_DICHIARAZIONE_CONSISTENZA
                                                                        WHERE  ID_AZIENDA = DC.ID_AZIENDA
                                                                        AND     ID_MOTIVO_DICHIARAZIONE <> 7
                                                                    )
        AND    ID_TITOLO_POSSESSO                     = 5
        AND     UT.ID_CONDUZIONE_DICHIARATA        =    CD.ID_CONDUZIONE_DICHIARATA
        AND    UT.ID_UTILIZZO                            =    TI.ID_UTILIZZO
       AND    (TI.FLAG_USO_AGRONOMICO                = 'S')
        AND CD.ID_PARTICELLA IN (SELECT  DISTINCT (CO1.ID_PARTICELLA)
                                            FROM      DB_UTE UT1,
                                                        COMUNE CM,
                                                        PROVINCIA PR,
                                                        REGIONE    RG,
                                                        DB_CONDUZIONE_PARTICELLA CO1
                                            WHERE UT1.ID_AZIENDA                 = P_ID_AZIENDA
                                            AND    UT1.COMUNE                        = CM.ISTAT_COMUNE
                                            AND   CM.ISTAT_PROVINCIA             = PR.ISTAT_PROVINCIA
                                            AND   PR.ID_REGIONE                     = RG.ID_REGIONE
                                            AND    RG.DESCRIZIONE                 = 'PIEMONTE'
                                            AND    UT1.DATA_FINE_ATTIVITA         IS NULL
                                            AND    CO1.ID_UTE                         = UT1.ID_UTE
                                            AND    CO1.DATA_FINE_CONDUZIONE     IS NULL
--                                            AND    CO1.ID_TITOLO_POSSESSO         = 5
                                        );
    EXCEPTION
         WHEN NO_DATA_FOUND THEN
                nSupAgro:=0;
    END;
*/
    IF   nSupCond  > nSupSpandibileUte    THEN
        RAISE ERR_AZOTO;
    END IF;

    RETURN (TRUE);

EXCEPTION
    WHEN ERR_AZOTO    THEN

        S_DESCRIZIONE :='Le  superfici relative agli usi del suolo, congruenti con la SAU, legate alle particelle in conduzione asservimento presenti sul piano in lavorazione dell ''azienda '|| TRIM(TO_CHAR(NVL(nSupSpandibileUte,0),'999G990D9999'))||' ha, sono inferiori alla superficie ad uso agronomico dichiarata per le stesse particelle presenti sul piano in lavorazione dell''azienda';
        IF vCodErr = '1' THEN
            S_DESCRIZIONE := S_DESCRIZIONE||vDesErr;
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;
      RETURN (TRUE);
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE SUPERFICIE_AGRONOMIC_SAU: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END SUPERFICIE_AGRO_SAU_NO_CONGRUO;



FUNCTION STRU_STOC_PARTICELLARE         (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                    P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                    P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                     P_MSGERR       IN OUT VARCHAR2,
                                                    P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS



S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

nRecFab    NUMBER;

CURSOR CUR_FAB IS     SELECT TI.DESCRIZIONE,ID_FABBRICATO,UNITA_MISURA,DIMENSIONE, DESCOM, SIGLA_PROVINCIA
                    FROM  DB_UTE UT,
                            DB_FABBRICATO FA,
                            DB_TIPO_TIPOLOGIA_FABBRICATO TI,
                            COMUNE CO,
                            PROVINCIA PR
                    WHERE UT.ID_AZIENDA = P_ID_AZIENDA
                    AND    UT.DATA_FINE_ATTIVITA IS NULL
                    AND    FA.ID_UTE = UT.ID_UTE
                    AND    FA.DATA_FINE_VALIDITA IS NULL
                    AND    TI.ID_TIPOLOGIA_FABBRICATO = FA.ID_TIPOLOGIA_FABBRICATO
                    AND   TI.FLAG_PER_STOCCAGGIO = 'S'
                    AND    CO.ISTAT_COMUNE = UT.COMUNE
                    AND    PR.ISTAT_PROVINCIA = CO.ISTAT_PROVINCIA;


BEGIN

    S_DESCRIZIONE := NULL;

     FOR REC_FAB IN CUR_FAB  LOOP

        SELECT COUNT(1)
        INTO nRecFab
        FROM DB_FABBRICATO_PARTICELLA
        WHERE  ID_FABBRICATO = REC_FAB.ID_FABBRICATO
        AND     DATA_FINE_VALIDITA IS NULL;

        IF nRecFab = 0 THEN
            S_DESCRIZIONE := 'Il fabbricato: '||REC_FAB.DESCRIZIONE||',con dimensioni: '||REC_FAB.DIMENSIONE||'('||REC_FAB.UNITA_MISURA||'), presente sull unita'' produttiva ('||REC_FAB.SIGLA_PROVINCIA||') '||REC_FAB.DESCOM||', non ha l''indicazione del particellare';

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
            END IF;
        END IF;

    END LOOP;


    RETURN (TRUE);

EXCEPTION

    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE STRU_STOC_PARTICELLARE: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END STRU_STOC_PARTICELLARE;


-- 408
FUNCTION ALLEVAMENTO_STA         (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                            P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                            P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                            P_MSGERR       IN OUT VARCHAR2,
                                            P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS



S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

CURSOR CUR_ALL IS
SELECT  AL.ID_ALLEVAMENTO,
        AL.CODICE_AZIENDA_ZOOTECNICA,
        SP.DESCRIZIONE  AS DESC_SPECIE,
        CTA.DESCRIZIONE AS DESC_CATEGORIA,
        SCTA.DESCRIZIONE AS DESC_SOTTOCATEGORIA
  FROM  DB_UTE UT,
        DB_ALLEVAMENTO AL,
        DB_CATEGORIE_ALLEVAMENTO CA,
        DB_SOTTOCATEGORIA_ALLEVAMENTO SO,
        DB_TIPO_SPECIE_ANIMALE SP,
        DB_TIPO_CATEGORIA_ANIMALE CTA,
        DB_TIPO_SOTTOCATEGORIA_ANIMALE SCTA,
        COMUNE CM,
        PROVINCIA PR
WHERE UT.ID_AZIENDA = P_ID_AZIENDA
  AND UT.DATA_FINE_ATTIVITA IS NULL
  AND AL.DATA_FINE IS NULL
  AND AL.ID_UTE = UT.ID_UTE
  AND UT.COMUNE = CM.ISTAT_COMUNE
  AND CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
  AND PR.ID_REGIONE = '01' 
  AND SP.ID_SPECIE_ANIMALE = AL.ID_SPECIE_ANIMALE
  AND SP.DATA_FINE_VALIDITA IS NULL
  AND SP.FLAG_STALLA_PASCOLO = 'S'
  AND CA.ID_ALLEVAMENTO  = AL.ID_ALLEVAMENTO
  AND CA.QUANTITA > 0 
  AND NVL(AL.FLAG_SOCCIDA,'N') = 'N'
  AND SO.ID_CATEGORIE_ALLEVAMENTO = CA.ID_CATEGORIE_ALLEVAMENTO
  AND CA.ID_CATEGORIA_ANIMALE = CTA.ID_CATEGORIA_ANIMALE
  AND SO.ID_SOTTOCATEGORIA_ANIMALE = SCTA.ID_SOTTOCATEGORIA_ANIMALE
  AND (NVL(GIORNI_PASCOLO_ESTATE,0) + NVL(GIORNI_PASCOLO_INVERNO,0)) < 365
  AND NOT EXISTS (SELECT ID_STABULAZIONE_TRATTAMENTO
                    FROM DB_STABULAZIONE_TRATTAMENTO ST
                   WHERE ST.ID_SOTTOCATEGORIA_ALLEVAMENTO = SO.ID_SOTTOCATEGORIA_ALLEVAMENTO);

BEGIN

    S_DESCRIZIONE := NULL;

     FOR REC_ALL IN CUR_ALL  LOOP

         S_DESCRIZIONE := 'Per l''allevamento con codice azienda zootecnica: '|| REC_ALL.CODICE_AZIENDA_ZOOTECNICA || ' ( Specie : ' || REC_ALL.DESC_SPECIE || ', Categoria : ' ||  REC_ALL.DESC_CATEGORIA || ', Sottocategoria : ' || REC_ALL.DESC_SOTTOCATEGORIA || ' ) non e'' stata indicata la stabulazione.';

         IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
         END IF;

         IF NOT SCRIVI_ANOMALIA_ALLEVAMENTO (P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, REC_ALL.ID_ALLEVAMENTO, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
         END IF;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE ALLEVAMENTO_STA: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END ALLEVAMENTO_STA;


-- 410
FUNCTION ALLEVAMENTO_SOCCIDA         (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                            P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                            P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                            P_MSGERR       IN OUT VARCHAR2,
                                            P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS



S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

nRecFab    NUMBER;

    CURSOR CUR_ALL IS
    SELECT DISTINCT
           AL.ID_ALLEVAMENTO,
           AL.CODICE_AZIENDA_ZOOTECNICA,
           SP.DESCRIZIONE
      FROM DB_UTE UT,
           DB_ALLEVAMENTO AL,
           DB_CATEGORIE_ALLEVAMENTO CA,
           DB_SOTTOCATEGORIA_ALLEVAMENTO SO,
           DB_TIPO_SPECIE_ANIMALE SP,
           COMUNE CM,
           PROVINCIA PR
    WHERE UT.ID_AZIENDA = P_ID_AZIENDA
      AND UT.DATA_FINE_ATTIVITA IS NULL
      AND AL.DATA_FINE IS NULL
      AND AL.ID_UTE  = UT.ID_UTE
      AND UT.COMUNE  = CM.ISTAT_COMUNE
      AND CM.ISTAT_PROVINCIA  = PR.ISTAT_PROVINCIA
      AND PR.ID_REGIONE = '01' 
      AND SP.ID_SPECIE_ANIMALE = AL.ID_SPECIE_ANIMALE
      AND DATA_FINE_VALIDITA IS NULL
      AND FLAG_STALLA_PASCOLO = 'S'
      AND CA.ID_ALLEVAMENTO = AL.ID_ALLEVAMENTO
      AND NVL(AL.FLAG_SOCCIDA,'N') = 'S'
      AND SO.ID_CATEGORIE_ALLEVAMENTO = CA.ID_CATEGORIE_ALLEVAMENTO
      AND (NVL(GIORNI_PASCOLO_ESTATE,0) + NVL(GIORNI_PASCOLO_INVERNO,0)) < 365;

BEGIN

    S_DESCRIZIONE := NULL;

     FOR REC_ALL IN CUR_ALL  LOOP

        SELECT COUNT(1)
          INTO nRecFab
          FROM DB_STABULAZIONE_TRATTAMENTO    ST,
               DB_SOTTOCATEGORIA_ALLEVAMENTO SO,
               DB_CATEGORIE_ALLEVAMENTO CA
         WHERE ST.ID_SOTTOCATEGORIA_ALLEVAMENTO = SO.ID_SOTTOCATEGORIA_ALLEVAMENTO
           AND CA.ID_ALLEVAMENTO                    = REC_ALL.ID_ALLEVAMENTO
           AND SO.ID_CATEGORIE_ALLEVAMENTO    = CA.ID_CATEGORIE_ALLEVAMENTO;

        IF nRecFab = 0 THEN
            S_DESCRIZIONE := 'Per l''allevamento in soccida con codice azienda zootecnica: '||REC_ALL.CODICE_AZIENDA_ZOOTECNICA||'('||REC_ALL.DESCRIZIONE||') non e'' stata indicata la stabulazione.';

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;

            IF NOT SCRIVI_ANOMALIA_ALLEVAMENTO (P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, REC_ALL.ID_ALLEVAMENTO, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;


        END IF;

    END LOOP;


    RETURN (TRUE);

EXCEPTION

    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE ALLEVAMENTO_STA: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END ALLEVAMENTO_SOCCIDA;


-- ALL12 correttezza dichiarazione soccida
FUNCTION SOCCIDA_INCONGRUENTE ( P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                P_MSGERR       IN OUT VARCHAR2,
                                P_CODERR       IN OUT VARCHAR2)    RETURN BOOLEAN IS

    CURSOR curAllevConSoccidaIncongruente IS
    SELECT AL.ID_ALLEVAMENTO,
           AL.CODICE_AZIENDA_ZOOTECNICA,
           SA.DESCRIZIONE,
           AL.FLAG_SOCCIDA,
           AL.CODICE_FISCALE_PROPRIETARIO,
           AL.CODICE_FISCALE_DETENTORE
      FROM DB_UTE UT,
           DB_ALLEVAMENTO AL,
           DB_TIPO_SPECIE_ANIMALE SA
     WHERE UT.ID_AZIENDA = P_ID_AZIENDA
       AND UT.DATA_FINE_ATTIVITA IS NULL
       AND UT.ID_UTE = AL.ID_UTE
       AND AL.DATA_FINE IS NULL
       AND AL.FLAG_SOCCIDA = 'S'
       AND AL.ID_SPECIE_ANIMALE = SA.ID_SPECIE_ANIMALE
       AND AL.CODICE_FISCALE_PROPRIETARIO = AL.CODICE_FISCALE_DETENTORE
       AND AL.MOTIVO_SOCCIDA IS NULL 
     UNION
    SELECT AL.ID_ALLEVAMENTO,
           AL.CODICE_AZIENDA_ZOOTECNICA,
           SA.DESCRIZIONE,
           NVL(AL.FLAG_SOCCIDA,'N')  AS FLAG_SOCCIDA,
           AL.CODICE_FISCALE_PROPRIETARIO,
           AL.CODICE_FISCALE_DETENTORE
      FROM DB_UTE UT,
           DB_ALLEVAMENTO AL,
           DB_TIPO_SPECIE_ANIMALE SA
     WHERE UT.ID_AZIENDA = P_ID_AZIENDA
       AND UT.DATA_FINE_ATTIVITA IS NULL
       AND UT.ID_UTE = AL.ID_UTE
       AND AL.DATA_FINE IS NULL
       AND NVL(AL.FLAG_SOCCIDA,'N') = 'N'
       AND AL.ID_SPECIE_ANIMALE = SA.ID_SPECIE_ANIMALE
       AND AL.CODICE_FISCALE_PROPRIETARIO <> AL.CODICE_FISCALE_DETENTORE
       AND AL.MOTIVO_SOCCIDA IS NULL;

    vMessaggioAnomalia DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

BEGIN

    FOR recAllevConSoccidaIncongruente IN curAllevConSoccidaIncongruente LOOP

        IF recAllevConSoccidaIncongruente.FLAG_SOCCIDA = 'S' THEN
           vMessaggioAnomalia := 'Allevamento ' || recAllevConSoccidaIncongruente.DESCRIZIONE || ' : ' || recAllevConSoccidaIncongruente.CODICE_AZIENDA_ZOOTECNICA || ' indicata soccida ma il detentore coincide col proprietario (' || recAllevConSoccidaIncongruente.CODICE_FISCALE_DETENTORE || ')';
        ELSE
           vMessaggioAnomalia := 'Allevamento ' || recAllevConSoccidaIncongruente.DESCRIZIONE || ' : ' || recAllevConSoccidaIncongruente.CODICE_AZIENDA_ZOOTECNICA || ' non e'' stata indicata soccida ma il detentore ed il proprietario differiscono (' || recAllevConSoccidaIncongruente.CODICE_FISCALE_DETENTORE || '/' || recAllevConSoccidaIncongruente.CODICE_FISCALE_PROPRIETARIO || ')';
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vMessaggioAnomalia, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_ANOMALIA_ALLEVAMENTO (P_ID_CONTROLLO, vMessaggioAnomalia, P_BLOCCANTE, recAllevConSoccidaIncongruente.ID_ALLEVAMENTO, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;


    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE SOCCIDA_INCONGRUENTE: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END SOCCIDA_INCONGRUENTE;


-- controlla che il detentore ed il proprietario presenti
-- sull'anagrafe coincidano con quelli in BDN
FUNCTION DET_PROP_ALLEV_SIAP_EQUAL_BDN ( P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                         P_CUAA         IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                                         P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                         P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                         P_MSGERR       IN OUT VARCHAR2,
                                         P_CODERR       IN OUT VARCHAR2)    RETURN BOOLEAN IS

    -- se non coincidono perfettamente i codici fiscali detentore e proprietario
    -- posso salvarmi se sono comunque presenti nelle persone fisiche
    -- di alcuni ruoli legati all'azienda
    CURSOR curAllevDetenPropIncBDN IS
        WITH RUOLO_STRINGA AS
           ( SELECT MAX(VALORE_STRINGA) AS VAL_STRINGA
               FROM DB_ALTRI_DATI
              WHERE CODICE = 'CTRL_ALLEVAMENTI'),
             RUOLI_CONCATENATI AS
           ( SELECT VAL_STRINGA AS RuoloConc,
                    LEVEL AS pos,
                    SUBSTR(VAL_STRINGA,ROWNUM,1) AS CH,
                    COUNT(CASE WHEN SUBSTR(VAL_STRINGA,ROWNUM,1) = ',' THEN '#' END)
                    OVER (ORDER BY LEVEL) AS section
               FROM RUOLO_STRINGA
         CONNECT BY LEVEL <= LENGTH(VAL_STRINGA)),
             RUOLI AS
           ( SELECT SUBSTR(RuoloConc,MIN(pos), 1 + MAX(pos) - MIN(pos)) AS RUOLO
               FROM RUOLI_CONCATENATI
              WHERE CH <> ','
           GROUP BY RuoloConc,section )
    SELECT AL.ID_ALLEVAMENTO,
           AL.CODICE_AZIENDA_ZOOTECNICA,
           SA.DESCRIZIONE,
           AL.CODICE_FISCALE_PROPRIETARIO,
           AL.CODICE_FISCALE_DETENTORE
      FROM DB_UTE UT,
           DB_ALLEVAMENTO AL,
           DB_TIPO_SPECIE_ANIMALE SA,
           DB_ALLEVAMENTI_SIAN ALS,
           DB_R_SPECIE_AN_SIAN_SIAP SASS
     WHERE UT.ID_AZIENDA = P_ID_AZIENDA
       AND UT.DATA_FINE_ATTIVITA IS NULL
       AND UT.ID_UTE = AL.ID_UTE
       AND AL.DATA_FINE IS NULL
       AND AL.ID_SPECIE_ANIMALE = SA.ID_SPECIE_ANIMALE
       AND SA.FLAG_MODIFICA_COD_AZ_ZOO = 'N'
       AND ALS.CUAA = P_CUAA
       AND ALS.FLAG_PRESENZA_SIAN = 'S'
       AND ALS.CODICE_SPECIE = SASS.CODICE_SPECIE
       AND SASS.ID_SPECIE_ANIMALE = SA.ID_SPECIE_ANIMALE
       AND SASS.FLAG_RELAZIONE_ATTIVA = 'S'
       AND ALS.CODICE_AZIENDA = AL.CODICE_AZIENDA_ZOOTECNICA
       AND ((ALS.CODICE_FISCALE_DETENTORE <> AL.CODICE_FISCALE_DETENTORE
       AND   NOT EXISTS (SELECT CO.ID_SOGGETTO
                           FROM DB_CONTITOLARE CO,
                                RUOLI RL,
                                DB_PERSONA_FISICA PF
                          WHERE CO.ID_AZIENDA = P_ID_AZIENDA
                            AND CO.DATA_FINE_RUOLO IS NULL
                            AND CO.ID_RUOLO = RL.RUOLO
                            AND CO.ID_SOGGETTO = PF.ID_SOGGETTO
                            AND PF.CODICE_FISCALE = ALS.CODICE_FISCALE_DETENTORE
                            ))
        OR  (ALS.CODICE_FISCALE_PROPRIETARIO <> AL.CODICE_FISCALE_PROPRIETARIO
       AND   NOT EXISTS (SELECT CO.ID_SOGGETTO
                          FROM DB_CONTITOLARE CO,
                               RUOLI RL,
                               DB_PERSONA_FISICA PF
                         WHERE CO.ID_AZIENDA = P_ID_AZIENDA
                           AND CO.DATA_FINE_RUOLO IS NULL
                           AND CO.ID_RUOLO = RL.RUOLO
                           AND CO.ID_SOGGETTO = PF.ID_SOGGETTO
                           AND PF.CODICE_FISCALE = ALS.CODICE_FISCALE_PROPRIETARIO
                           )))
       AND NOT EXISTS (SELECT ASI.*
                         FROM DB_ALLEVAMENTI_SIAN ASI
                        WHERE ASI.CUAA = P_CUAA
                          AND ASI.CODICE_SPECIE = ALS.CODICE_SPECIE
                          AND ASI.CODICE_AZIENDA = ALS.CODICE_AZIENDA
                          AND ASI.CODICE_FISCALE_DETENTORE = AL.CODICE_FISCALE_DETENTORE
                          AND ASI.CODICE_FISCALE_PROPRIETARIO = AL.CODICE_FISCALE_PROPRIETARIO); 

    vMessaggioAnomalia DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

BEGIN

    FOR recAllevDetenPropIncBDN IN curAllevDetenPropIncBDN LOOP


        vMessaggioAnomalia := 'Allevamento ' || recAllevDetenPropIncBDN.DESCRIZIONE || ' : ' || recAllevDetenPropIncBDN.CODICE_AZIENDA_ZOOTECNICA || ' il proprietario e il detentore indicati in fascicolo non coincidono con quelli presenti in BDN';


        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vMessaggioAnomalia, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_ANOMALIA_ALLEVAMENTO (P_ID_CONTROLLO, vMessaggioAnomalia, P_BLOCCANTE, recAllevDetenPropIncBDN.ID_ALLEVAMENTO, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;


    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE DET_PROP_ALLEV_SIAP_EQUAL_BDN: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END DET_PROP_ALLEV_SIAP_EQUAL_BDN;


-- controlla che le coordinate geografiche dell'allavamento
-- dell'anagrafe coincidano con quelle in BDN
FUNCTION CORDINATE_ALLEV_SIAP_EQUAL_BDN ( P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                          P_CUAA         IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                                          P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                          P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                          P_MSGERR       IN OUT VARCHAR2,
                                          P_CODERR       IN OUT VARCHAR2)    RETURN BOOLEAN IS

    CURSOR curAllevCoordinateIncBDN IS
    SELECT AL.ID_ALLEVAMENTO,
           AL.CODICE_AZIENDA_ZOOTECNICA,
           SA.DESCRIZIONE
      FROM DB_UTE UT,
           DB_ALLEVAMENTO AL,
           DB_TIPO_SPECIE_ANIMALE SA
     WHERE UT.ID_AZIENDA = P_ID_AZIENDA
       AND UT.DATA_FINE_ATTIVITA IS NULL
       AND UT.ID_UTE = AL.ID_UTE
       AND AL.DATA_FINE IS NULL
       AND AL.ID_SPECIE_ANIMALE = SA.ID_SPECIE_ANIMALE
       AND SA.FLAG_MODIFICA_COD_AZ_ZOO = 'N'
       AND EXISTS (SELECT ALS.ID_ALLEVAMENTI_SIAN
                     FROM DB_ALLEVAMENTI_SIAN ALS,
                          DB_R_SPECIE_AN_SIAN_SIAP SASS
                    WHERE ALS.CUAA = P_CUAA
                      AND ALS.FLAG_PRESENZA_SIAN = 'S'
                      AND ALS.CODICE_SPECIE = SASS.CODICE_SPECIE
                      AND SASS.ID_SPECIE_ANIMALE = SA.ID_SPECIE_ANIMALE
                      AND SASS.FLAG_RELAZIONE_ATTIVA = 'S'
                      AND ALS.CODICE_AZIENDA = AL.CODICE_AZIENDA_ZOOTECNICA)
       AND NOT EXISTS (SELECT ALS.ID_ALLEVAMENTI_SIAN
                         FROM DB_ALLEVAMENTI_SIAN ALS,
                              DB_R_SPECIE_AN_SIAN_SIAP SASS
                        WHERE ALS.CUAA = P_CUAA
                          AND ALS.FLAG_PRESENZA_SIAN = 'S'
                          AND ALS.CODICE_SPECIE = SASS.CODICE_SPECIE
                          AND SASS.ID_SPECIE_ANIMALE = SA.ID_SPECIE_ANIMALE
                          AND SASS.FLAG_RELAZIONE_ATTIVA = 'S'
                          AND ALS.CODICE_AZIENDA = AL.CODICE_AZIENDA_ZOOTECNICA
                          AND NVL(AL.LATITUDINE,-1) = NVL(ALS.LATITUDINE,-1)
                          AND NVL(AL.LONGITUDINE, -1) = NVL(ALS.LONGITUDINE,-1));

    vMessaggioAnomalia DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;


BEGIN

    FOR recAllevCoordinateIncBDN IN curAllevCoordinateIncBDN LOOP

        vMessaggioAnomalia := 'Allevamento ' || recAllevCoordinateIncBDN.DESCRIZIONE || ' : ' || recAllevCoordinateIncBDN.CODICE_AZIENDA_ZOOTECNICA || ' coordinate geografiche presenti in fascicolo non congruenti con quelle in BDN';

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vMessaggioAnomalia, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_ANOMALIA_ALLEVAMENTO (P_ID_CONTROLLO, vMessaggioAnomalia, P_BLOCCANTE, recAllevCoordinateIncBDN.ID_ALLEVAMENTO, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE CORDINATE_ALLEV_SIAP_EQUAL_BDN: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END CORDINATE_ALLEV_SIAP_EQUAL_BDN;

-- controlla se l'allevamento ha la denominaziona valorizzata
FUNCTION PRESENTE_DENOMINAZIONE_ALLEV ( P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                        P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                        P_MSGERR       IN OUT VARCHAR2,
                                        P_CODERR       IN OUT VARCHAR2)    RETURN BOOLEAN IS

    CURSOR curAllevSenzaDenominazione IS
    SELECT AL.ID_ALLEVAMENTO,
           AL.CODICE_AZIENDA_ZOOTECNICA,
           SA.DESCRIZIONE
      FROM DB_UTE UT,
           DB_ALLEVAMENTO AL,
           DB_TIPO_SPECIE_ANIMALE SA
     WHERE UT.ID_AZIENDA = P_ID_AZIENDA
       AND UT.DATA_FINE_ATTIVITA IS NULL
       AND UT.ID_UTE = AL.ID_UTE
       AND AL.DATA_FINE IS NULL
       AND AL.ID_SPECIE_ANIMALE = SA.ID_SPECIE_ANIMALE
       AND SA.FLAG_MODIFICA_COD_AZ_ZOO = 'N'
       AND AL.DENOMINAZIONE_ALLEVAMENTO IS NULL;

    vMessaggioAnomalia DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

BEGIN

    FOR recAllevSenzaDenominazione IN curAllevSenzaDenominazione LOOP

        vMessaggioAnomalia := 'Allevamento ' || recAllevSenzaDenominazione.DESCRIZIONE || ' : ' || recAllevSenzaDenominazione.CODICE_AZIENDA_ZOOTECNICA || ' denominazione non presente';

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vMessaggioAnomalia, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_ANOMALIA_ALLEVAMENTO (P_ID_CONTROLLO, vMessaggioAnomalia, P_BLOCCANTE, recAllevSenzaDenominazione.ID_ALLEVAMENTO, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE PRESENTE_DENOMINAZIONE_ALLEV: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END PRESENTE_DENOMINAZIONE_ALLEV;


-- controlla se l'allevamento ha i dati dell'orientamento produttivo / tipo produzione valorizzati
FUNCTION ORIENTAMENTO_PRODUTTIVO_ALLEV ( P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                         P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                         P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                         P_MSGERR       IN OUT VARCHAR2,
                                         P_CODERR       IN OUT VARCHAR2)    RETURN BOOLEAN IS

    CURSOR curAllevSenzaOrientamento IS
    SELECT AL.ID_ALLEVAMENTO,
           AL.CODICE_AZIENDA_ZOOTECNICA,
           AL.ID_SPECIE_ANIMALE,
           SA.DESCRIZIONE,
           AL.ID_TIPO_PRODUZIONE,
           AL.ID_ORIENTAMENTO_PRODUTTIVO,
           AL.ID_TIPO_PRODUZIONE_COSMAN
      FROM DB_UTE UT,
           DB_ALLEVAMENTO AL,
           DB_TIPO_SPECIE_ANIMALE SA
     WHERE UT.ID_AZIENDA = P_ID_AZIENDA
       AND UT.DATA_FINE_ATTIVITA IS NULL
       AND UT.ID_UTE = AL.ID_UTE
       AND AL.DATA_FINE IS NULL
       AND AL.ID_SPECIE_ANIMALE = SA.ID_SPECIE_ANIMALE
       --AND SA.FLAG_MODIFICA_COD_AZ_ZOO = 'S'
       AND (AL.ID_TIPO_PRODUZIONE IS NULL OR
            AL.ID_ORIENTAMENTO_PRODUTTIVO IS NULL OR
            AL.ID_TIPO_PRODUZIONE_COSMAN IS NULL); 

    vMessaggioAnomalia DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    nRecTpCosmanDisp   INTEGER:=0;

BEGIN

    FOR recAllevSenzaOrientamento IN curAllevSenzaOrientamento LOOP
        vMessaggioAnomalia := NULL;

        IF recAllevSenzaOrientamento.ID_TIPO_PRODUZIONE IS NULL THEN
           vMessaggioAnomalia := ' e'' obbligatorio indicare il tipo di produzione ';
        END IF;

        IF recAllevSenzaOrientamento.ID_ORIENTAMENTO_PRODUTTIVO IS NULL THEN
           IF vMessaggioAnomalia IS NOT NULL THEN
              vMessaggioAnomalia := vMessaggioAnomalia || 'e l''orientamento produttivo';
           ELSE
              vMessaggioAnomalia := ' e'' obbligatorio indicare l''orientamento produttivo ';
           END IF;
        END IF;

        IF recAllevSenzaOrientamento.ID_TIPO_PRODUZIONE IS NOT NULL AND
           recAllevSenzaOrientamento.ID_ORIENTAMENTO_PRODUTTIVO IS NOT NULL THEN

           SELECT COUNT(OPC.ID_ORIENTAMENTO_PROD_COSMAN)
             INTO nRecTpCosmanDisp
             FROM DB_TIPO_SPECIE_ORIENTAM_PROD TSOP,
                  DB_ORIENTAMENTO_PROD_COSMAN OPC
            WHERE TSOP.ID_SPECIE_ANIMALE = recAllevSenzaOrientamento.ID_SPECIE_ANIMALE
              AND TSOP.ID_ORIENTAMENTO_PRODUTTIVO = recAllevSenzaOrientamento.ID_ORIENTAMENTO_PRODUTTIVO
              AND TSOP.ID_TIPO_PRODUZIONE = recAllevSenzaOrientamento.ID_TIPO_PRODUZIONE
              AND TSOP.ID_SPECIE_ORIENTAM_PROD = OPC.ID_SPECIE_ORIENTAM_PROD
              AND OPC.DATA_FINE_VALIDITA IS NULL;

           IF nRecTpCosmanDisp > 0 THEN
              vMessaggioAnomalia := ' l''orientamento produttivo dell''allevamento richiede che sia dettagliato anche l''orientamento produttivo cosman';
           END IF;

        END IF;

        IF vMessaggioAnomalia IS NOT NULL THEN
           vMessaggioAnomalia := 'Allevamento ' || recAllevSenzaOrientamento.DESCRIZIONE || ' : ' || recAllevSenzaOrientamento.CODICE_AZIENDA_ZOOTECNICA || vMessaggioAnomalia;

           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vMessaggioAnomalia, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;

           IF NOT SCRIVI_ANOMALIA_ALLEVAMENTO (P_ID_CONTROLLO, vMessaggioAnomalia, P_BLOCCANTE, recAllevSenzaOrientamento.ID_ALLEVAMENTO, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;

        END IF;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE ORIENTAMENTO_PRODUTTIVO_ALLEV: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END ORIENTAMENTO_PRODUTTIVO_ALLEV;


-- controlla se l'azienda e' solo proprietaria dell'allevamento non deve
-- avere capi in dentenzione
FUNCTION CAPI_ALLEVAMENTO_IN_DETENZIONE  ( P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                           P_CUAA         IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                                           P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                           P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                           P_MSGERR       IN OUT VARCHAR2,
                                           P_CODERR       IN OUT VARCHAR2)    RETURN BOOLEAN IS

    CURSOR curAllevInPropConCapiInDeten IS
    WITH RUOLO_STRINGA AS
       ( SELECT MAX(VALORE_STRINGA) AS VAL_STRINGA
           FROM DB_ALTRI_DATI
          WHERE CODICE = 'CTRL_ALLEVAMENTI'),
         RUOLI_CONCATENATI AS
       ( SELECT VAL_STRINGA AS RuoloConc,
                LEVEL AS pos,
                SUBSTR(VAL_STRINGA,ROWNUM,1) AS CH,
                COUNT(CASE WHEN SUBSTR(VAL_STRINGA,ROWNUM,1) = ',' THEN '#' END)
                OVER (ORDER BY LEVEL) AS section
           FROM RUOLO_STRINGA
     CONNECT BY LEVEL <= LENGTH(VAL_STRINGA)),
         RUOLI AS
       ( SELECT SUBSTR(RuoloConc,MIN(pos), 1 + MAX(pos) - MIN(pos)) AS RUOLO
           FROM RUOLI_CONCATENATI
          WHERE CH <> ','
       GROUP BY RuoloConc,section ),
    CF_AZIENDA AS (
            SELECT PF.CODICE_FISCALE
              FROM DB_CONTITOLARE CO,
                   RUOLI RL,
                   DB_PERSONA_FISICA PF
             WHERE CO.ID_AZIENDA = P_ID_AZIENDA
               AND CO.DATA_FINE_RUOLO IS NULL
               AND CO.ID_RUOLO = RL.RUOLO
               AND CO.ID_SOGGETTO = PF.ID_SOGGETTO
             UNION
             SELECT P_CUAA
               FROM DUAL
               )
    SELECT AL.ID_ALLEVAMENTO,
           AL.CODICE_AZIENDA_ZOOTECNICA,
           AL.CODICE_FISCALE_PROPRIETARIO,
           AL.CODICE_FISCALE_DETENTORE,
           SA.DESCRIZIONE,
           SUM(CA.QUANTITA) AS TOT_CAPI_DETEN
      FROM DB_ALLEVAMENTO AL,
           DB_UTE UT,
           DB_TIPO_SPECIE_ANIMALE SA,
           DB_CATEGORIE_ALLEVAMENTO CA
     WHERE UT.ID_AZIENDA = P_ID_AZIENDA
       AND UT.DATA_FINE_ATTIVITA IS NULL
       AND UT.ID_UTE = AL.ID_UTE
       AND AL.DATA_FINE IS NULL
       AND AL.ID_SPECIE_ANIMALE = SA.ID_SPECIE_ANIMALE
       AND AL.ID_ALLEVAMENTO = CA.ID_ALLEVAMENTO
       AND AL.CODICE_FISCALE_PROPRIETARIO IN (SELECT CODICE_FISCALE
                                                FROM CF_AZIENDA)
       AND AL.CODICE_FISCALE_DETENTORE NOT IN (SELECT CODICE_FISCALE
                                                 FROM CF_AZIENDA)
  GROUP BY AL.ID_ALLEVAMENTO, AL.CODICE_AZIENDA_ZOOTECNICA, SA.DESCRIZIONE, AL.CODICE_FISCALE_PROPRIETARIO , AL.CODICE_FISCALE_DETENTORE
  HAVING SUM(CA.QUANTITA) > 0;

    vMessaggioAnomalia DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

BEGIN

    FOR recAllevInPropConCapiInDeten IN curAllevInPropConCapiInDeten LOOP

        vMessaggioAnomalia := 'Allevamento ' || recAllevInPropConCapiInDeten.DESCRIZIONE || ' : ' || recAllevInPropConCapiInDeten.CODICE_AZIENDA_ZOOTECNICA || ' in proprieta'' ma detenuto da altra azienda (' || recAllevInPropConCapiInDeten.CODICE_FISCALE_DETENTORE || ') non puo'' avere capi in detenzione maggiore di zero (' || TRIM(TO_CHAR(recAllevInPropConCapiInDeten.TOT_CAPI_DETEN)) || ')';

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vMessaggioAnomalia, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_ANOMALIA_ALLEVAMENTO (P_ID_CONTROLLO, vMessaggioAnomalia, P_BLOCCANTE, recAllevInPropConCapiInDeten.ID_ALLEVAMENTO, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

    END LOOP;

    RETURN TRUE;

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE CAPI_ALLEVAMENTO_IN_DETENZIONE: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END CAPI_ALLEVAMENTO_IN_DETENZIONE;

-- 417 (ALL18)
FUNCTION ALLEVAMENTO_SOCCIDA_SENZA_DOC  ( P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                          P_CUAA         IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                                          P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                          P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                          P_MSGERR       IN OUT VARCHAR2,
                                          P_CODERR       IN OUT VARCHAR2)    RETURN BOOLEAN IS

    CURSOR curAllevamentoSoccidaSenzaDoc IS
    SELECT AL.ID_ALLEVAMENTO,
           AL.CODICE_AZIENDA_ZOOTECNICA,
           SA.DESCRIZIONE,
           AL.FLAG_SOCCIDA,
           AL.CODICE_FISCALE_PROPRIETARIO,
           AL.CODICE_FISCALE_DETENTORE
      FROM DB_UTE UT,
           DB_ALLEVAMENTO AL,
           DB_TIPO_SPECIE_ANIMALE SA
     WHERE UT.ID_AZIENDA = P_ID_AZIENDA
       AND UT.DATA_FINE_ATTIVITA IS NULL
       AND UT.ID_UTE = AL.ID_UTE
       AND AL.DATA_FINE IS NULL
       AND AL.FLAG_SOCCIDA = 'S'
       AND AL.ID_SPECIE_ANIMALE = SA.ID_SPECIE_ANIMALE
       AND AL.CODICE_FISCALE_PROPRIETARIO <> AL.CODICE_FISCALE_DETENTORE
       AND NOT EXISTS (SELECT D.ID_DOCUMENTO
                         FROM DB_DOCUMENTO D,
                              DB_TIPO_DOCUMENTO TD,
                              DB_DOCUMENTO_CATEGORIA DC,
                              DB_TIPO_CONTROLLO_PARAMETRO TCP
                        WHERE D.EXT_ID_DOCUMENTO = TD.ID_DOCUMENTO
                          AND TD.ID_DOCUMENTO = DC.ID_DOCUMENTO
                          AND D.ID_AZIENDA = P_ID_AZIENDA
                          AND D.ID_STATO_DOCUMENTO IS NULL
                          AND SYSDATE BETWEEN D.DATA_INIZIO_VALIDITA AND NVL(D.DATA_FINE_VALIDITA,SYSDATE)
                          AND DC.ID_CATEGORIA_DOCUMENTO = TCP.VALORE_NUMERICO
                          AND TCP.ID_CONTROLLO = P_ID_CONTROLLO
                          AND TCP.DATA_FINE_VALIDITA IS NULL);


    vMessaggioAnomalia DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

BEGIN

    FOR recAllevamentoSoccidaSenzaDoc IN curAllevamentoSoccidaSenzaDoc LOOP

        vMessaggioAnomalia := 'Allevamento in soccida ' || recAllevamentoSoccidaSenzaDoc.DESCRIZIONE || ' : ' || recAllevamentoSoccidaSenzaDoc.CODICE_AZIENDA_ZOOTECNICA || ' privo del documento giustificativo della soccida';

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vMessaggioAnomalia, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_ANOMALIA_ALLEVAMENTO (P_ID_CONTROLLO, vMessaggioAnomalia, P_BLOCCANTE, recAllevamentoSoccidaSenzaDoc.ID_ALLEVAMENTO, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

    END LOOP;

    RETURN TRUE;

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE ALLEVAMENTO_SOCCIDA_SENZA_DOC: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END ALLEVAMENTO_SOCCIDA_SENZA_DOC;


-- 418 (ALL19)
-- nuovo controllo che verifica la presenza di allevamenti duplicati
-- stessa specie, stesso codice azienda zootecnica, stesso cuaa detentore , stesso cuaa proprietario
FUNCTION ALLEVAMENTO_DUPLICATO  ( P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                  P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                  P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                  P_MSGERR       IN OUT VARCHAR2,
                                  P_CODERR       IN OUT VARCHAR2)    RETURN BOOLEAN IS

    vMessaggioAnomalia DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

    CURSOR curAllevamentoDoppio IS
    SELECT AL.CODICE_AZIENDA_ZOOTECNICA,
           AL.ID_UTE,
           SA.DESCRIZIONE,
           SA.ID_SPECIE_ANIMALE,
           AL.CODICE_FISCALE_PROPRIETARIO,
           AL.CODICE_FISCALE_DETENTORE,
           AL.LATITUDINE, AL.LONGITUDINE, 
           COUNT (AL.ID_ALLEVAMENTO) AS NUM_ALLEV
      FROM DB_UTE UT,
           DB_ALLEVAMENTO AL,
           DB_TIPO_SPECIE_ANIMALE SA
     WHERE UT.ID_AZIENDA = P_ID_AZIENDA
       AND UT.DATA_FINE_ATTIVITA IS NULL
       AND UT.ID_UTE = AL.ID_UTE
       AND AL.DATA_FINE IS NULL
       AND AL.ID_SPECIE_ANIMALE = SA.ID_SPECIE_ANIMALE
  GROUP BY AL.CODICE_AZIENDA_ZOOTECNICA,
           AL.ID_UTE,
           SA.DESCRIZIONE,
           SA.ID_SPECIE_ANIMALE,
           AL.CODICE_FISCALE_PROPRIETARIO,
           AL.CODICE_FISCALE_DETENTORE,
           AL.LATITUDINE, AL.LONGITUDINE 
    HAVING
     COUNT (AL.ID_ALLEVAMENTO) > 1;


BEGIN

    FOR recAllevamentoDoppio IN curAllevamentoDoppio LOOP

        vMessaggioAnomalia := 'L''allevamento ' || recAllevamentoDoppio.DESCRIZIONE || ', CODICE AZIENDA ZOOTECNICA : ' || NVL(recAllevamentoDoppio.CODICE_AZIENDA_ZOOTECNICA,'N.P.') || ', DETENTORE :  ' || recAllevamentoDoppio.CODICE_FISCALE_DETENTORE || ', PROPRIETARIO : ' || recAllevamentoDoppio.CODICE_FISCALE_PROPRIETARIO || ' risulta censito : ' || recAllevamentoDoppio.NUM_ALLEV || ' volte in anagrafica';

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vMessaggioAnomalia, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        INSERT INTO DB_ESITO_CONTROLLO_ALLEVAMENTO
            (
            ID_ESITO_CONTROLLO_ALLEVAMENTO,
            ID_ALLEVAMENTO,
            ID_CONTROLLO,
            BLOCCANTE,
            DESCRIZIONE
            )
        SELECT SEQ_DB_ESITO_CONTROLLO_ALLEV.nextval,
               ID_ALLEVAMENTO,
               P_ID_CONTROLLO,
               P_BLOCCANTE,
               vMessaggioAnomalia
          FROM DB_ALLEVAMENTO
         WHERE ID_UTE = recAllevamentoDoppio.ID_UTE
           AND NVL(CODICE_AZIENDA_ZOOTECNICA,'N.P.') = NVL(recAllevamentoDoppio.CODICE_AZIENDA_ZOOTECNICA,'N.P.')
           AND ID_SPECIE_ANIMALE = recAllevamentoDoppio.ID_SPECIE_ANIMALE
           AND CODICE_FISCALE_PROPRIETARIO = recAllevamentoDoppio.CODICE_FISCALE_PROPRIETARIO
           AND CODICE_FISCALE_DETENTORE = recAllevamentoDoppio.CODICE_FISCALE_DETENTORE;

    END LOOP;

    RETURN TRUE;

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE ALLEVAMENTO_DUPLICATO: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END ALLEVAMENTO_DUPLICATO;


-- 419 (ALL20)
-- controlla se l'allevamento presente in anagrafe
-- per il cuaa e' presente in BDN con stessa specie (o specie BDN compatibile)
FUNCTION ALLEVAMENTO_ASSENTE_IN_BDN  ( P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                       P_CUAA         IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                                       P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR       IN OUT VARCHAR2)    RETURN BOOLEAN IS
    CURSOR curAllevamentoNonInBDN IS
    SELECT AL.*,
           SA.DESCRIZIONE
      FROM DB_UTE UT,
           DB_ALLEVAMENTO AL,
           DB_TIPO_SPECIE_ANIMALE SA
     WHERE UT.ID_AZIENDA = P_ID_AZIENDA
       AND UT.DATA_FINE_ATTIVITA IS NULL
       AND UT.ID_UTE = AL.ID_UTE
       AND AL.DATA_FINE IS NULL
       AND AL.ID_SPECIE_ANIMALE = SA.ID_SPECIE_ANIMALE
       AND SA.FLAG_MODIFICA_COD_AZ_ZOO = 'N'
       AND NOT EXISTS (SELECT ALS.ID_ALLEVAMENTI_SIAN
                         FROM DB_ALLEVAMENTI_SIAN ALS,
                              DB_R_SPECIE_AN_SIAN_SIAP SASS
                        WHERE UT.ID_AZIENDA = P_ID_AZIENDA
                          AND UT.DATA_FINE_ATTIVITA IS NULL
                          AND UT.ID_UTE = AL.ID_UTE
                          AND AL.DATA_FINE IS NULL
                          AND AL.ID_SPECIE_ANIMALE = SA.ID_SPECIE_ANIMALE
                          AND ALS.CUAA = P_CUAA
                          AND ALS.FLAG_PRESENZA_SIAN = 'S'
                          AND ALS.CODICE_SPECIE = SASS.CODICE_SPECIE
                          AND SASS.ID_SPECIE_ANIMALE = SA.ID_SPECIE_ANIMALE
                          AND SASS.FLAG_RELAZIONE_ATTIVA = 'S'
                          AND ALS.CODICE_AZIENDA = AL.CODICE_AZIENDA_ZOOTECNICA);

    vMessaggioAnomalia DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

BEGIN

    FOR recAllevamentoNonInBDN IN curAllevamentoNonInBDN LOOP

        vMessaggioAnomalia := 'Allevamento ' || recAllevamentoNonInBDN.DESCRIZIONE || ' : ' || recAllevamentoNonInBDN.CODICE_AZIENDA_ZOOTECNICA || ' non presente in BDN per il CUAA indicato';

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vMessaggioAnomalia, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_ANOMALIA_ALLEVAMENTO (P_ID_CONTROLLO, vMessaggioAnomalia, P_BLOCCANTE, recAllevamentoNonInBDN.ID_ALLEVAMENTO, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

    END LOOP;

    RETURN TRUE;

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE ALLEVAMENTO_ASSENTE_IN_BDN: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END ALLEVAMENTO_ASSENTE_IN_BDN;


FUNCTION ACQUISIZIONE_CES_DICHIARATA (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                 P_MSGERR       IN OUT VARCHAR2,
                                                P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS
/*
    - COMUNICAZIONE 10/R -

    Per ogni tipologia di effluente zootecnico
    acquisito dall'Azienda dichiarata verifica se esiste la cessione

*/
-- 905
S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_CES                   NUMBER;

CURSOR CUR_ACQ      IS     SELECT  ACQ.ID_EFFLUENTE, ACQ.ID_AZIENDA,
                                EFF.DESCRIZIONE, NVL(TE.CODICE_FISCALE,'ASSENTE') CAA,
                                AZ.DENOMINAZIONE, AZ.CUAA
                        FROM    DB_UTE                    UT,
                                          DB_COMUNICAZIONE_10R COM,
                                DB_EFFLUENTE_CES_ACQ_10R ACQ,
                                DB_TIPO_CAUSALE_EFFLUENTE CAU,
                                DB_TIPO_EFFLUENTE EFF,
                                DB_DELEGA DE,
                                          DB_INTERMEDIARIO TE,
                                DB_ANAGRAFICA_AZIENDA AZ
                        WHERE    UT.ID_AZIENDA= P_ID_AZIENDA
                                AND     UT.ID_UTE    = COM.ID_UTE
                                AND     UT.DATA_FINE_ATTIVITA    IS NULL
                                AND     COM.DATA_FINE_VALIDITA IS NULL
                                AND     ACQ.ID_CAUSALE_EFFLUENTE=CAU.ID_CAUSALE_EFFLUENTE
                                AND     CAU.ID_CAUSALE_EFFLUENTE=2
                                AND     ACQ.ID_AZIENDA IS NOT NULL
                                AND     EFF.ID_EFFLUENTE=ACQ.ID_EFFLUENTE
                                AND     DE.ID_AZIENDA(+)=ACQ.ID_AZIENDA
                                AND     DE.DATA_FINE IS NULL
                                AND     DE.ID_PROCEDIMENTO(+)=7
                                AND     DE.ID_INTERMEDIARIO=TE.ID_INTERMEDIARIO(+)
                                AND     AZ.ID_AZIENDA(+)=ACQ.ID_AZIENDA
                                AND     AZ.DATA_FINE_VALIDITA IS NULL
                                AND     ACQ.ID_COMUNICAZIONE_10R=COM.ID_COMUNICAZIONE_10R
                                GROUP BY ACQ.ID_EFFLUENTE, ACQ.ID_AZIENDA, EFF.DESCRIZIONE,TE.CODICE_FISCALE,AZ.DENOMINAZIONE,AZ.CUAA;

BEGIN

    S_DESCRIZIONE := NULL;

    FOR REC_ACQ IN  CUR_ACQ LOOP

        SELECT COUNT(*)
          INTO N_CES
          FROM DB_DICHIARAZIONE_CONSISTENZA DC,
               DB_ANAGRAFICA_AZIENDA AA,
               DB_AZIENDA A,
               DB_COMUNICAZIONE_10R CO,
               DB_EFFLUENTE_CES_ACQ_10R CS
         WHERE A.ID_AZIENDA = AA.ID_AZIENDA
           AND AA.ID_AZIENDA = DC.ID_AZIENDA
           AND AA.DATA_FINE_VALIDITA IS NULL
           AND AA.DATA_CESSAZIONE IS NULL
           AND A.ID_AZIENDA = REC_ACQ.ID_AZIENDA
           AND DC.ID_MOTIVO_DICHIARAZIONE <> 7
           AND CO.DATA_INIZIO_VALIDITA < DC.DATA_INSERIMENTO_DICHIARAZIONE
           AND NVL(CO.DATA_FINE_VALIDITA,TO_DATE ('31/12/9999', 'DD/MM/YYYY')) > DC.DATA_INSERIMENTO_DICHIARAZIONE
           AND CO.ID_COMUNICAZIONE_10R = CS.ID_COMUNICAZIONE_10R
           AND CS.ID_CAUSALE_EFFLUENTE = 1
           AND CS.ID_EFFLUENTE = REC_ACQ.ID_EFFLUENTE
           AND DC.ID_AZIENDA <> P_ID_AZIENDA
           AND CS.ID_AZIENDA = P_ID_AZIENDA
           AND DC.DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DCX.DATA_INSERIMENTO_DICHIARAZIONE)
                                                      FROM DB_DICHIARAZIONE_CONSISTENZA    DCX,
                                                           DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                     WHERE DCX.ID_AZIENDA = DC.ID_AZIENDA
                                                       AND DCX.ANNO = TO_CHAR(SYSDATE,'YYYY') 
                                                       AND DCX.ID_MOTIVO_DICHIARAZIONE <> 7
                                                       AND TI.ID_MOTIVO_DICHIARAZIONE = DCX.ID_MOTIVO_DICHIARAZIONE
                                                       AND TI.TIPO_DICHIARAZIONE != 'C');

        IF N_CES=0 THEN

            S_DESCRIZIONE := 'L''effluente zootecnico acquisito ' || REC_ACQ.DESCRIZIONE || ', non trova un riscontro come cessione nell''Azienda dichiarata: ' || REC_ACQ.CUAA || ' - ' || REC_ACQ.DENOMINAZIONE || '(CAA:' || REC_ACQ.CAA || ')';

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
            END IF;
        END IF;

    END LOOP;

    RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE ACQUISIZIONE_CES_DICHIARATA: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END ACQUISIZIONE_CES_DICHIARATA;


FUNCTION ACQUISIZIONE_CES_QTA (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                 P_MSGERR       IN OUT VARCHAR2,
                                                P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS
/*
    - COMUNICAZIONE 10/R -

    Per ogni tipologia di effluente zootecnico
    acquisito dall'Azienda dichiarata verifica se esiste la cessione in
    quantità coerente con l'acquisizione
--906
*/

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_CES                   NUMBER;
QTA_CES                 NUMBER;

CURSOR CUR_ACQ      IS     SELECT  ACQ.ID_EFFLUENTE, ACQ.ID_AZIENDA,
                                EFF.DESCRIZIONE, NVL(TE.CODICE_FISCALE,'ASSENTE') CAA,
                                AZ.DENOMINAZIONE, AZ.CUAA, ACQ.QUANTITA
                        FROM    DB_UTE                    UT,
                                          DB_COMUNICAZIONE_10R COM,
                                DB_EFFLUENTE_CES_ACQ_10R ACQ,
                                DB_TIPO_CAUSALE_EFFLUENTE CAU,
                                DB_TIPO_EFFLUENTE EFF,
                                DB_DELEGA DE, DB_INTERMEDIARIO TE,
                                DB_ANAGRAFICA_AZIENDA AZ
                                WHERE    UT.ID_AZIENDA= P_ID_AZIENDA
                                AND     UT.ID_UTE    = COM.ID_UTE
                                AND     UT.DATA_FINE_ATTIVITA    IS NULL
                                AND     COM.DATA_FINE_VALIDITA IS NULL
                                AND     ACQ.ID_CAUSALE_EFFLUENTE=CAU.ID_CAUSALE_EFFLUENTE
                                AND     CAU.ID_CAUSALE_EFFLUENTE=2
                                AND     ACQ.ID_AZIENDA IS NOT NULL
                                AND     EFF.ID_EFFLUENTE=ACQ.ID_EFFLUENTE
                                AND     DE.ID_AZIENDA(+)=ACQ.ID_AZIENDA
                                AND     DE.DATA_FINE IS NULL
                                AND     DE.ID_PROCEDIMENTO(+)=7
                                AND     DE.ID_INTERMEDIARIO=TE.ID_INTERMEDIARIO(+)
                                AND     AZ.ID_AZIENDA(+)=ACQ.ID_AZIENDA
                                AND     AZ.DATA_FINE_VALIDITA IS NULL
                                AND     ACQ.ID_COMUNICAZIONE_10R=COM.ID_COMUNICAZIONE_10R
                                GROUP BY ACQ.ID_EFFLUENTE, ACQ.ID_AZIENDA, EFF.DESCRIZIONE,TE.CODICE_FISCALE,AZ.DENOMINAZIONE,AZ.CUAA,ACQ.QUANTITA;
BEGIN

    S_DESCRIZIONE := NULL;

    FOR REC_ACQ IN  CUR_ACQ LOOP

        BEGIN
            SELECT SUM(NVL(CS.QUANTITA,0)), COUNT(*)
              INTO QTA_CES, N_CES
              FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                   DB_ANAGRAFICA_AZIENDA AA,
                   DB_AZIENDA A,
                   DB_COMUNICAZIONE_10R CO,
                   DB_EFFLUENTE_CES_ACQ_10R CS
             WHERE A.ID_AZIENDA = AA.ID_AZIENDA
               AND AA.ID_AZIENDA = DC.ID_AZIENDA
               AND AA.DATA_FINE_VALIDITA IS NULL
               AND AA.DATA_CESSAZIONE IS NULL
               AND A.ID_AZIENDA = REC_ACQ.ID_AZIENDA
               AND DC.ID_MOTIVO_DICHIARAZIONE <> 7
               AND CO.DATA_INIZIO_VALIDITA < DC.DATA_INSERIMENTO_DICHIARAZIONE
               AND NVL(CO.DATA_FINE_VALIDITA,TO_DATE ('31/12/9999', 'DD/MM/YYYY')) > DC.DATA_INSERIMENTO_DICHIARAZIONE
               AND CO.ID_COMUNICAZIONE_10R=CS.ID_COMUNICAZIONE_10R
               AND CS.ID_CAUSALE_EFFLUENTE = 1
               AND CS.ID_EFFLUENTE = REC_ACQ.ID_EFFLUENTE
               AND DC.ID_AZIENDA <> P_ID_AZIENDA
               AND CS.ID_AZIENDA = P_ID_AZIENDA
               AND DC.DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DCX.DATA_INSERIMENTO_DICHIARAZIONE)
                                                          FROM DB_DICHIARAZIONE_CONSISTENZA    DCX,
                                                               DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                         WHERE DCX.ID_AZIENDA = DC.ID_AZIENDA
                                                           AND DCX.ANNO = TO_CHAR(SYSDATE,'YYYY') 
                                                           AND DCX.ID_MOTIVO_DICHIARAZIONE <> 7
                                                           AND TI.ID_MOTIVO_DICHIARAZIONE = DCX.ID_MOTIVO_DICHIARAZIONE
                                                           AND TI.TIPO_DICHIARAZIONE != 'C');
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
            N_CES:=0;
        END;

        IF N_CES>0 AND QTA_CES < REC_ACQ.QUANTITA THEN

            S_DESCRIZIONE := 'L''effluente zootecnico ' || REC_ACQ.DESCRIZIONE || ', acquisito in q.tà ' || TRIM(TO_CHAR(NVL(REC_ACQ.QUANTITA,0),'999G990D9')) || '(m3) risulta maggiore di quello ceduto in qtà ' || TRIM(TO_CHAR(NVL(QTA_CES,0),'999G990D9')) || '(m3) dall''azienda dichiarata:' || REC_ACQ.CUAA || ' - ' || REC_ACQ.DENOMINAZIONE || '(CAA:' || REC_ACQ.CAA || ')';

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
            END IF;
        END IF;

    END LOOP;

    RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE ACQUISIZIONE_CES_QTA: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END ACQUISIZIONE_CES_QTA;


FUNCTION CESSIONE_ACQ_DICHIARATA (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                 P_MSGERR       IN OUT VARCHAR2,
                                                P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS
/*
    - COMUNICAZIONE 10/R -

    Per ogni tipologia di effluente zootecnico
    ceduto dall'Azienda dichiarata verifica se esiste l'acquisizione
-- 907
*/

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_CES                   NUMBER;

CURSOR CUR_ACQ      IS     SELECT  ACQ.ID_EFFLUENTE, ACQ.ID_AZIENDA,
                                EFF.DESCRIZIONE, NVL(TE.CODICE_FISCALE,'ASSENTE') CAA,
                                AZ.DENOMINAZIONE, AZ.CUAA
                        FROM    DB_UTE                    UT,
                                          DB_COMUNICAZIONE_10R COM,
                                DB_EFFLUENTE_CES_ACQ_10R ACQ,
                                DB_TIPO_CAUSALE_EFFLUENTE CAU,
                                DB_TIPO_EFFLUENTE EFF,
                                DB_DELEGA DE, DB_INTERMEDIARIO TE,
                                DB_ANAGRAFICA_AZIENDA AZ
                                WHERE    UT.ID_AZIENDA= P_ID_AZIENDA
                                AND     UT.ID_UTE    = COM.ID_UTE
                                AND     UT.DATA_FINE_ATTIVITA    IS NULL
                                AND     COM.DATA_FINE_VALIDITA IS NULL
                                AND     ACQ.ID_CAUSALE_EFFLUENTE=CAU.ID_CAUSALE_EFFLUENTE
                                AND     CAU.ID_CAUSALE_EFFLUENTE=1
                                AND     ACQ.ID_AZIENDA IS NOT NULL
                                AND     EFF.ID_EFFLUENTE=ACQ.ID_EFFLUENTE
                                AND     DE.ID_AZIENDA(+)=ACQ.ID_AZIENDA
                                AND     DE.DATA_FINE IS NULL
                                AND     DE.ID_PROCEDIMENTO(+)=7
                                AND     DE.ID_INTERMEDIARIO=TE.ID_INTERMEDIARIO(+)
                                AND     AZ.ID_AZIENDA(+)=ACQ.ID_AZIENDA
                                AND     AZ.DATA_FINE_VALIDITA IS NULL
                                AND     ACQ.ID_COMUNICAZIONE_10R=COM.ID_COMUNICAZIONE_10R
                                GROUP BY ACQ.ID_EFFLUENTE, ACQ.ID_AZIENDA, EFF.DESCRIZIONE,TE.CODICE_FISCALE,AZ.DENOMINAZIONE,AZ.CUAA;

BEGIN

    S_DESCRIZIONE := NULL;

    FOR REC_ACQ IN  CUR_ACQ LOOP

        SELECT COUNT(*)
          INTO N_CES
          FROM DB_DICHIARAZIONE_CONSISTENZA DC,
               DB_ANAGRAFICA_AZIENDA AA,
               DB_AZIENDA A,
               DB_COMUNICAZIONE_10R CO,
               DB_EFFLUENTE_CES_ACQ_10R CS
         WHERE A.ID_AZIENDA = AA.ID_AZIENDA
           AND AA.ID_AZIENDA = DC.ID_AZIENDA
           AND AA.DATA_FINE_VALIDITA IS NULL
           AND AA.DATA_CESSAZIONE IS NULL
           AND A.ID_AZIENDA = REC_ACQ.ID_AZIENDA
           AND DC.ID_MOTIVO_DICHIARAZIONE <> 7
           AND CO.DATA_INIZIO_VALIDITA < DC.DATA_INSERIMENTO_DICHIARAZIONE
           AND NVL(CO.DATA_FINE_VALIDITA,TO_DATE ('31/12/9999', 'DD/MM/YYYY')) > DC.DATA_INSERIMENTO_DICHIARAZIONE
           AND CO.ID_COMUNICAZIONE_10R = CS.ID_COMUNICAZIONE_10R
           AND CS.ID_CAUSALE_EFFLUENTE=2
           AND CS.ID_EFFLUENTE=REC_ACQ.ID_EFFLUENTE
           AND DC.ID_AZIENDA <> P_ID_AZIENDA
           AND CS.ID_AZIENDA = P_ID_AZIENDA
           AND DC.DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DCX.DATA_INSERIMENTO_DICHIARAZIONE)
                                                      FROM DB_DICHIARAZIONE_CONSISTENZA    DCX,
                                                           DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                     WHERE DCX.ID_AZIENDA = DC.ID_AZIENDA
                                                       AND DCX.ID_MOTIVO_DICHIARAZIONE <> 7
                                                       AND DCX.ANNO = TO_CHAR(SYSDATE,'YYYY') 
                                                       AND TI.ID_MOTIVO_DICHIARAZIONE = DCX.ID_MOTIVO_DICHIARAZIONE
                                                       AND TI.TIPO_DICHIARAZIONE != 'C');

        IF N_CES=0 THEN

            S_DESCRIZIONE := 'L''effluente zootecnico ceduto ' || REC_ACQ.DESCRIZIONE || ', non trova un riscontro come acquisizione nell''Azienda dichiarata: ' || REC_ACQ.CUAA || ' - ' || REC_ACQ.DENOMINAZIONE || '(CAA:' || REC_ACQ.CAA || ')';

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
            END IF;
        END IF;

    END LOOP;

    RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE CESSIONE_ACQ_DICHIARATA: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END CESSIONE_ACQ_DICHIARATA;


FUNCTION CESSIONE_ACQ_QTA (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                 P_MSGERR       IN OUT VARCHAR2,
                                                P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS
/*
    - COMUNICAZIONE 10/R -

    Per ogni tipologia di effluente zootecnico
    ceduto dall'Azienda dichiarata verifica se esiste l'acquisizione in
    quantità coerente con la cessione
     -- 908
*/

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_CES                   NUMBER;
QTA_CES                 NUMBER;

CURSOR CUR_ACQ      IS     SELECT  ACQ.ID_EFFLUENTE, ACQ.ID_AZIENDA,
                                EFF.DESCRIZIONE, NVL(TE.CODICE_FISCALE,'ASSENTE') CAA,
                                AZ.DENOMINAZIONE, AZ.CUAA, ACQ.QUANTITA
                        FROM    DB_UTE                    UT,
                                          DB_COMUNICAZIONE_10R COM,
                                DB_EFFLUENTE_CES_ACQ_10R ACQ,
                                DB_TIPO_CAUSALE_EFFLUENTE CAU,
                                DB_TIPO_EFFLUENTE EFF,
                                DB_DELEGA DE, DB_INTERMEDIARIO TE,
                                DB_ANAGRAFICA_AZIENDA AZ
                                WHERE    UT.ID_AZIENDA= P_ID_AZIENDA
                                AND     UT.ID_UTE    = COM.ID_UTE
                                AND     UT.DATA_FINE_ATTIVITA    IS NULL
                                AND     COM.DATA_FINE_VALIDITA IS NULL
                                AND     ACQ.ID_CAUSALE_EFFLUENTE=CAU.ID_CAUSALE_EFFLUENTE
                                AND     CAU.ID_CAUSALE_EFFLUENTE=1
                                AND     ACQ.ID_AZIENDA IS NOT NULL
                                AND     EFF.ID_EFFLUENTE=ACQ.ID_EFFLUENTE
                                AND     DE.ID_AZIENDA(+)=ACQ.ID_AZIENDA
                                AND     DE.DATA_FINE IS NULL
                                AND     DE.ID_PROCEDIMENTO(+)=7
                                AND     DE.ID_INTERMEDIARIO=TE.ID_INTERMEDIARIO(+)
                                AND     AZ.ID_AZIENDA(+)=ACQ.ID_AZIENDA
                                AND     AZ.DATA_FINE_VALIDITA IS NULL
                                AND     ACQ.ID_COMUNICAZIONE_10R=COM.ID_COMUNICAZIONE_10R
                        GROUP BY ACQ.ID_EFFLUENTE, ACQ.ID_AZIENDA, EFF.DESCRIZIONE,TE.CODICE_FISCALE,AZ.DENOMINAZIONE,AZ.CUAA,ACQ.QUANTITA;
BEGIN

    S_DESCRIZIONE := NULL;

    FOR REC_ACQ IN  CUR_ACQ LOOP

        BEGIN
            SELECT SUM(NVL(CS.QUANTITA,0)), COUNT(*)
              INTO QTA_CES, N_CES
              FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                   DB_ANAGRAFICA_AZIENDA AA,
                   DB_AZIENDA A,
                   DB_COMUNICAZIONE_10R CO,
                   DB_EFFLUENTE_CES_ACQ_10R CS
             WHERE A.ID_AZIENDA = AA.ID_AZIENDA
               AND AA.ID_AZIENDA = DC.ID_AZIENDA
               AND AA.DATA_FINE_VALIDITA IS NULL
               AND AA.DATA_CESSAZIONE IS NULL
               AND A.ID_AZIENDA = REC_ACQ.ID_AZIENDA
               AND DC.ID_MOTIVO_DICHIARAZIONE <> 7
               AND CO.DATA_INIZIO_VALIDITA < DC.DATA_INSERIMENTO_DICHIARAZIONE
               AND NVL(CO.DATA_FINE_VALIDITA,TO_DATE ('31/12/9999', 'DD/MM/YYYY')) > DC.DATA_INSERIMENTO_DICHIARAZIONE
               AND CO.ID_COMUNICAZIONE_10R = CS.ID_COMUNICAZIONE_10R
               AND CS.ID_CAUSALE_EFFLUENTE= 2
               AND CS.ID_EFFLUENTE=REC_ACQ.ID_EFFLUENTE
               AND DC.ID_AZIENDA <> P_ID_AZIENDA
               AND CS.ID_AZIENDA = P_ID_AZIENDA
               AND DC.DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DCX.DATA_INSERIMENTO_DICHIARAZIONE)
                                                          FROM DB_DICHIARAZIONE_CONSISTENZA    DCX,
                                                               DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                         WHERE DCX.ID_AZIENDA = DC.ID_AZIENDA
                                                           AND DCX.ANNO = TO_CHAR(SYSDATE,'YYYY') 
                                                           AND DCX.ID_MOTIVO_DICHIARAZIONE <> 7
                                                           AND TI.ID_MOTIVO_DICHIARAZIONE = DCX.ID_MOTIVO_DICHIARAZIONE
                                                           AND TI.TIPO_DICHIARAZIONE != 'C');
            EXCEPTION
        WHEN NO_DATA_FOUND THEN
            N_CES:=0;
        END;

        IF N_CES>0 AND QTA_CES > REC_ACQ.QUANTITA THEN

            S_DESCRIZIONE := 'L''effluente zootecnico ' || REC_ACQ.DESCRIZIONE || ', ceduto in q.tà ' || TRIM(TO_CHAR(NVL(REC_ACQ.QUANTITA,0),'999G990D9')) || '(m3) risulta minore di quello acquisito in qtà ' || TRIM(TO_CHAR(NVL(QTA_CES,0),'999G990D9')) || '(m3) dall''azienda dichiarata:' || REC_ACQ.CUAA || ' - ' || REC_ACQ.DENOMINAZIONE || '(CAA:' || REC_ACQ.CAA || ')';

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
            END IF;
        END IF;

    END LOOP;

    RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE CESSIONE_ACQ_QTA: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END CESSIONE_ACQ_QTA;


-- 909
FUNCTION CESSIONE_QTA_PRODOTTA (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                            P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                            P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                             P_MSGERR       IN OUT VARCHAR2,
                                            P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS
/*
    - COMUNICAZIONE 10/R -

    Per ogni tipologia di effluente zootecnico
    ceduto dall'Azienda dichiarata verifica se esiste l'acquisizione in
    quantità coerente con la cessione

*/

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_CES                   NUMBER;
QTA_CES                 NUMBER;
nSum1                            NUMBER;
nSum2                            NUMBER;

nIdEffluente                DB_EFFLUENTE_CES_ACQ_10R.id_effluente%TYPE;
vDescEffluente                DB_TIPO_EFFLUENTE.descrizione%TYPE;
nQuantita                    NUMBER;


CURSOR CUR_UTE IS SELECT     UT.ID_UTE,
                                    CM.DESCOM    DESC_COMUNE,
                                    PR.SIGLA_PROVINCIA    SIGLA,
                                    UT.INDIRIZZO
                        FROM     DB_UTE UT,
                                COMUNE CM,
                                PROVINCIA PR,
                                REGIONE    RG
                        WHERE UT.ID_AZIENDA                 = P_ID_AZIENDA
                        AND    UT.DATA_FINE_ATTIVITA     IS NULL
                        AND    UT.COMUNE                    = CM.ISTAT_COMUNE
                        AND   CM.ISTAT_PROVINCIA         = PR.ISTAT_PROVINCIA
                        AND   PR.ID_REGIONE                 = RG.ID_REGIONE;

/* MS 25/09/2014 il cursore cambia drasticamente
se uno deve fare ste seghe mentali per reperire i dati
e' probabile che ci sia qualche grosso problema nella progettazione
della base dati */
CURSOR CUR_ACQ(pUte IN NUMBER)    IS
WITH APP AS (
    SELECT ACQ.ID_EFFLUENTE,
           EFF.DESCRIZIONE,
           PRO.VOLUME_POST_TRATTAMENTO
      FROM DB_COMUNICAZIONE_10R COM,
           DB_EFFLUENTE_CES_ACQ_10R ACQ,
           DB_TIPO_CAUSALE_EFFLUENTE CAU,
           DB_TIPO_EFFLUENTE EFF,
           DB_EFFLUENTE_10R PRO
     WHERE COM.ID_UTE  = pUte
       AND COM.DATA_FINE_VALIDITA IS NULL
       AND ACQ.ID_CAUSALE_EFFLUENTE=CAU.ID_CAUSALE_EFFLUENTE
       AND CAU.ID_CAUSALE_EFFLUENTE=1
       AND ACQ.ID_AZIENDA IS NOT NULL
       AND EFF.ID_EFFLUENTE=ACQ.ID_EFFLUENTE
       AND PRO.ID_COMUNICAZIONE_10R=COM.ID_COMUNICAZIONE_10R
       AND PRO.ID_EFFLUENTE=ACQ.ID_EFFLUENTE
       AND COM.ID_COMUNICAZIONE_10R=ACQ.ID_COMUNICAZIONE_10R
  GROUP BY ACQ.ID_EFFLUENTE,  EFF.DESCRIZIONE,PRO.VOLUME_POST_TRATTAMENTO),
    ALTRA_APP AS (
    SELECT P.ID_EFFLUENTE,
           P.DESCRIZIONE,
           P.VOLUME_POST_TRATTAMENTO,
           EFC.ID_AZIENDA,
           MAX(EFC.QUANTITA) AS TOT_QUANTITA
      FROM APP P,
           DB_EFFLUENTE_CES_ACQ_10R EFC,
           DB_COMUNICAZIONE_10R R2
     WHERE EFC.ID_EFFLUENTE = P.ID_EFFLUENTE
       AND R2.ID_UTE =  pUte
       AND R2.DATA_FINE_VALIDITA IS NULL
       AND R2.ID_COMUNICAZIONE_10R= EFC.ID_COMUNICAZIONE_10R
  GROUP BY P.ID_EFFLUENTE, P.DESCRIZIONE, P.VOLUME_POST_TRATTAMENTO, EFC.ID_AZIENDA)
 SELECT PA.ID_EFFLUENTE, PA.DESCRIZIONE, PA.VOLUME_POST_TRATTAMENTO, SUM(PA.TOT_QUANTITA) AS QUANTITA
   FROM ALTRA_APP PA
  GROUP BY PA.ID_EFFLUENTE, PA.DESCRIZIONE, PA.VOLUME_POST_TRATTAMENTO;

/*
CURSOR CUR_ACQ(pUte IN NUMBER)    IS
                                SELECT  ACQ.ID_EFFLUENTE, EFF.DESCRIZIONE, SUM(ACQ.QUANTITA) QUANTITA, PRO.VOLUME_POST_TRATTAMENTO
                        FROM    DB_COMUNICAZIONE_10R COM,
                                DB_EFFLUENTE_CES_ACQ_10R ACQ,
                                DB_TIPO_CAUSALE_EFFLUENTE CAU,
                                DB_TIPO_EFFLUENTE EFF,
                                DB_EFFLUENTE_10R PRO
                                WHERE    COM.ID_UTE                = pUte
                                AND     COM.DATA_FINE_VALIDITA IS NULL
                                AND     ACQ.ID_CAUSALE_EFFLUENTE=CAU.ID_CAUSALE_EFFLUENTE
                                AND     CAU.ID_CAUSALE_EFFLUENTE=1
                                AND     ACQ.ID_AZIENDA IS NOT NULL
                                AND     EFF.ID_EFFLUENTE=ACQ.ID_EFFLUENTE
                                AND     PRO.ID_COMUNICAZIONE_10R=COM.ID_COMUNICAZIONE_10R
                                AND     PRO.ID_EFFLUENTE=ACQ.ID_EFFLUENTE
                                AND     COM.ID_COMUNICAZIONE_10R=ACQ.ID_COMUNICAZIONE_10R
                                GROUP BY ACQ.ID_EFFLUENTE, EFF.DESCRIZIONE,PRO.VOLUME_POST_TRATTAMENTO;
*/

BEGIN

    S_DESCRIZIONE := NULL;

    FOR REC_UTE IN CUR_UTE LOOP

        FOR REC_ACQ IN  CUR_ACQ(REC_UTE.ID_UTE) LOOP
--           IF REC_ACQ.ID_EFFLUENTE != 19 THEN
              IF REC_ACQ.QUANTITA>REC_ACQ.VOLUME_POST_TRATTAMENTO THEN

                 S_DESCRIZIONE := 'Nell'' Unita'' Produttiva '||REC_UTE.DESC_COMUNE||' ('||REC_UTE.SIGLA||') '||REC_UTE.INDIRIZZO||', l''effluente zootecnico ' || REC_ACQ.DESCRIZIONE || ', ceduto in q.tà ' || TRIM(TO_CHAR(NVL(REC_ACQ.QUANTITA,0),'999G990D9')) || '(m3) risulta superiore alla q.tà  prodotta dall''azienda ' || TRIM(TO_CHAR(NVL(REC_ACQ.VOLUME_POST_TRATTAMENTO,0),'999G990D9')) || '(m3)';

                IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                    END IF;
                END IF;
        END LOOP;

        /* MS 25/09/2014
        -- gestione particolare dell'ID_EFFLUENTE 19 probabilmente era da togliere
        -- anni fa quando si e' commentato l'IF nel cursore di cui sopra
        -- ma chi lo sa ???!!!!!!!!
        BEGIN
            SELECT   ACQ.ID_EFFLUENTE,
                        EFF.DESCRIZIONE,
                        SUM(NVL(ACQ.QUANTITA,0)) QUANTITA
            INTO         nIdEffluente,vDescEffluente,nQuantita
          FROM        DB_COMUNICAZIONE_10R COM,
                       DB_EFFLUENTE_CES_ACQ_10R ACQ,
                        DB_TIPO_CAUSALE_EFFLUENTE CAU,
                        DB_TIPO_EFFLUENTE EFF
            WHERE    COM.ID_UTE                = REC_UTE.ID_UTE
            AND     COM.DATA_FINE_VALIDITA IS NULL
            AND     COM.ID_COMUNICAZIONE_10R=ACQ.ID_COMUNICAZIONE_10R
            AND     ACQ.ID_CAUSALE_EFFLUENTE=CAU.ID_CAUSALE_EFFLUENTE
            AND     CAU.ID_CAUSALE_EFFLUENTE=1
            AND     ACQ.ID_AZIENDA IS NOT NULL
            AND     EFF.ID_EFFLUENTE            =ACQ.ID_EFFLUENTE
            AND     EFF.ID_EFFLUENTE            =19;
            --GROUP BY ACQ.ID_EFFLUENTE, EFF.DESCRIZIONE;


            SELECT NVL(NVL(VOLUME_PIOGGE,0) + NVL(VOLUME_REFLUO_AZIENDA,0) + NVL(ACQUE_LAVAGGIO,0),0) INTO nSum1
            FROM DB_COMUNICAZIONE_10R COM
            WHERE    COM.ID_UTE        = REC_UTE.ID_UTE
            AND     COM.DATA_FINE_VALIDITA IS NULL;


            SELECT NVL(SUM(NVL(VOLUME_REFLUO,0)),0) INTO nSum2
            FROM  DB_ACQUA_EXTRA_10R   ACQ,
                    DB_COMUNICAZIONE_10R COM
            WHERE    COM.ID_UTE        = REC_UTE.ID_UTE
            AND     COM.DATA_FINE_VALIDITA IS NULL
            AND  ACQ.ID_COMUNICAZIONE_10R = COM.ID_COMUNICAZIONE_10R;

            IF nQuantita > (nSum1 + nSum2) THEN
               S_DESCRIZIONE := 'Nell'' Unita'' Produttiva '||REC_UTE.DESC_COMUNE||' ('||REC_UTE.SIGLA||') '||REC_UTE.INDIRIZZO||', l''effluente ' || vDescEffluente || ', ceduto in q.tà ' || TRIM(TO_CHAR(NVL(nQuantita,0),'999G990D9'))|| '(m3) risulta superiore alla q.tà  prodotta dall''azienda ' || TRIM(TO_CHAR(NVL((nSum1 + nSum2),0),'999G990D9')) || '(m3)';

               IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                  P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
              END IF;

            END IF;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                NULL;
        END ;
       */
    END LOOP;

    RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE CESSIONE_QTA_PRODOTTA: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END CESSIONE_QTA_PRODOTTA;




FUNCTION SUPERFICIE_PREVISTA_SPECIE ( P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                      P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                      P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                      P_MSGERR       IN OUT VARCHAR2,
                                      P_CODERR       IN OUT VARCHAR2)    RETURN BOOLEAN IS


-- COMUNICAZIONE 10/R -
--  indica la superficie lettiera permanente solo per le specie animali che lo prevedono
-- 409

    CURSOR CUR_ALL IS
    SELECT SP.DESCRIZIONE,
           AL.ID_ALLEVAMENTO
      FROM DB_UTE UT,
           DB_ALLEVAMENTO AL,
           DB_TIPO_SPECIE_ANIMALE SP
     WHERE UT.ID_AZIENDA = P_ID_AZIENDA
       AND UT.DATA_FINE_ATTIVITA IS NULL
       AND AL.DATA_FINE IS NULL
       AND AL.ID_UTE = UT.ID_UTE
       AND SP.ID_SPECIE_ANIMALE = AL.ID_SPECIE_ANIMALE
       AND SP.ALT_LETTIERA_PERMANENTE_MIN + SP.ALT_LETTIERA_PERMANENTE_MAX = 0
       AND NVL (Al.SUPERFICIE_LETTIERA_PERMANENTE, 0) > 0;

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
BEGIN

    FOR REC_ALL IN CUR_ALL LOOP

        S_DESCRIZIONE := 'Per la specie ' || REC_ALL.DESCRIZIONE || ' non e'' prevista la superficie lettiera permanente.';

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_ANOMALIA_ALLEVAMENTO (P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, REC_ALL.ID_ALLEVAMENTO, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;


    END LOOP;

     RETURN(TRUE);
EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE SUPERFICIE_PREVISTA_SPECIE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);


END SUPERFICIE_PREVISTA_SPECIE;


FUNCTION RICETTIVITA_AZOTO_TERRENI_UTE (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                        P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                        P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                         P_MSGERR       IN OUT VARCHAR2,
                                                        P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS

/*

    910
    Verifica per ogni ute piemontese che la q.tà di azoto aziendale prodotto
    dall'azienda al netto delle cessioni e acquisizioni sia inferiore alla
    ricettività massima di azoto disponibile sui terreni dell'ute interessata.
*/

CURSOR CUR_UTE IS SELECT     COM.ID_COMUNICAZIONE_10R,
                                    COM.DATA_RICALCOLO,
                                    COM.ID_UTE,
                                    COM.DATA_AGGIORNAMENTO,
                                    COM.TOTALE_AZOTO_AZIENDALE,
--                                    COM.TOTALE_AZOTO,
                                    COM.AZOTO_CONDUZIONE_ZVN,
                                    COM.AZOTO_ASSERVIMENTO_ZVN,
                                    COM.AZOTO_CONDUZIONE_NO_ZVN,
                                    COM.AZOTO_ASSERVIMENTO_NO_ZVN,
                                    CM.DESCOM    DESC_COMUNE,
                                    PR.SIGLA_PROVINCIA    SIGLA,
                                    UT.INDIRIZZO
                        FROM     DB_COMUNICAZIONE_10R COM,
                                DB_UTE UT,
                                COMUNE CM,
                                PROVINCIA PR
                        WHERE ut.ID_AZIENDA                 = P_ID_AZIENDA
                        AND    UT.ID_UTE                    = COM.ID_UTE
                        AND    UT.COMUNE                    = CM.ISTAT_COMUNE
                        AND   CM.ISTAT_PROVINCIA         = PR.ISTAT_PROVINCIA
                        AND   PR.ID_REGIONE = '01' 
                        AND    COM.DATA_FINE_VALIDITA     IS NULL
                        AND    UT.DATA_FINE_ATTIVITA     IS NULL;


S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

--RecComunicazione10r DB_COMUNICAZIONE_10R%ROWTYPE;

nQuantitaAzotoAcq        NUMBER;
nQuantitaAzotoCeduto    NUMBER;
nTotAzoto                NUMBER;
nMaxRicetTerr            NUMBER;

ERR_AZOTO        EXCEPTION;
BEGIN

    S_DESCRIZIONE := NULL;
    nTotAzoto         := 0;
    nMaxRicetTerr    := 0;


--        SELECT * INTO RecComunicazione10r FROM DB_COMUNICAZIONE_10R     WHERE ID_AZIENDA = P_ID_AZIENDA     AND    DATA_FINE_VALIDITA IS NULL;

    FOR  RecComunicazione10r IN CUR_UTE LOOP

            SELECT NVL(SUM(NVL(QUANTITA_AZOTO_DICHIARATO,0)),0) -- NVL(SUM(NVL(QUANTITA_AZOTO,0)),0)
            INTO nQuantitaAzotoAcq
            FROM  DB_EFFLUENTE_CES_ACQ_10R EF,
                    DB_TIPO_EFFLUENTE        TI
            WHERE EF.ID_COMUNICAZIONE_10R        = RecComunicazione10r.ID_COMUNICAZIONE_10R
            AND    EF.ID_CAUSALE_EFFLUENTE        = 2
            AND    TI.ID_EFFLUENTE                 = EF.ID_EFFLUENTE
            AND    TI.DATA_FINE_VALIDITA         IS NULL;


            SELECT NVL(SUM(NVL(QUANTITA_AZOTO_DICHIARATO,0)),0) -- NVL(SUM(NVL(QUANTITA_AZOTO,0)),0)
            INTO nQuantitaAzotoCeduto
            FROM  DB_EFFLUENTE_CES_ACQ_10R EF,
                    DB_TIPO_EFFLUENTE        TI
            WHERE EF.ID_COMUNICAZIONE_10R        = RecComunicazione10r.ID_COMUNICAZIONE_10R
            AND    EF.ID_CAUSALE_EFFLUENTE        = 1
            AND    TI.ID_EFFLUENTE                 = EF.ID_EFFLUENTE
            AND    TI.DATA_FINE_VALIDITA         IS NULL;

            nTotAzoto :=   (ROUND(RecComunicazione10r.TOTALE_AZOTO_AZIENDALE) + ROUND(nQuantitaAzotoAcq) - ROUND(nQuantitaAzotoCeduto));
--            nTotAzoto :=   (ROUND(RecComunicazione10r.TOTALE_AZOTO) + ROUND(nQuantitaAzotoAcq) - ROUND(nQuantitaAzotoCeduto));

            nMaxRicetTerr    :=  (ROUND(RecComunicazione10r.AZOTO_CONDUZIONE_ZVN) + ROUND(RecComunicazione10r.AZOTO_ASSERVIMENTO_ZVN) + ROUND(RecComunicazione10r.AZOTO_CONDUZIONE_NO_ZVN) + ROUND(RecComunicazione10r.AZOTO_ASSERVIMENTO_NO_ZVN));

        IF NOT nTotAzoto <= nMaxRicetTerr THEN

           S_DESCRIZIONE := 'Nell'' Unita'' Produttiva '||RecComunicazione10r.DESC_COMUNE||' ('||RecComunicazione10r.SIGLA||') '||RecComunicazione10r.INDIRIZZO||', l''azoto aziendale prodotto al netto delle cessioni/acquisizioni di altre aziende e'' '||nTotAzoto||' kg ,superiore alla massima ricettività di azoto disponibile sui terreni dell''azienda '||nMaxRicetTerr||' kg';
            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
            END IF;
        END IF;
    END LOOP;
    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE RICETTIVITA_AZOTO_TERRENI_UTE: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END RICETTIVITA_AZOTO_TERRENI_UTE;




FUNCTION STOC_INSUFFICIENTE_UTE     (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                 P_MSGERR       IN OUT VARCHAR2,
                                                P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS


-- 911
--Verifica che  per ogni ute piemontese il volume dello stoccaggio disponibile per i reflui-
--volume stoccaggio necessario sia maggiore o uguale a 0

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

CURSOR CUR_UTE IS SELECT     COM.ID_COMUNICAZIONE_10R,
                                    COM.DATA_RICALCOLO,
                                    COM.ID_UTE,
                                    COM.DATA_AGGIORNAMENTO,
                                    COM.STOC_DISP_PALABILE_VOL,
                                    COM.STOC_DISP_NONPALABILE_VOL,
                                    COM.VOLUME_REFLUO_AZIENDA,
                                    COM.VOLUME_PIOGGE,
                                    COM.ACQUE_LAVAGGIO,
                                    COM.STOC_ACQUE_NEC_VOL,
                                    CM.DESCOM    DESC_COMUNE,
                                    PR.SIGLA_PROVINCIA    SIGLA,
                                    UT.INDIRIZZO
                        FROM     DB_COMUNICAZIONE_10R COM,
                                DB_UTE UT,
                                COMUNE CM,
                                PROVINCIA PR
                        WHERE ut.ID_AZIENDA                 = P_ID_AZIENDA
                        AND    UT.ID_UTE                    = COM.ID_UTE
                        AND    UT.COMUNE                    = CM.ISTAT_COMUNE
                        AND CM.ISTAT_PROVINCIA         = PR.ISTAT_PROVINCIA
                        AND PR.ID_REGIONE = '01' 
                        AND    COM.DATA_FINE_VALIDITA     IS NULL
                        AND    UT.DATA_FINE_ATTIVITA     IS NULL;


--RecComunicazione10r DB_COMUNICAZIONE_10R%ROWTYPE;

nStoc_1                    NUMBER;
nStoc_2                    NUMBER;
nStoc_3                     NUMBER;
nStoc_4                     NUMBER;
nStoc_5                     NUMBER;
nStoc_6                     NUMBER;
nStocNec                    NUMBER;
nVolumeRefluoExtra    NUMBER;

ERR_AZOTO                EXCEPTION;

BEGIN

    S_DESCRIZIONE := NULL;
    nStoc_1 := 0;
    nStoc_2 := 0;
    nStocNec:= 0;
    nStoc_3 := 0;
    nStoc_4 := 0;
    nStoc_5 := 0;
    nStoc_6 := 0;
        FOR  RecComunicazione10r IN CUR_UTE LOOP
        -- primo controllo
            nStoc_1   := ROUND(RecComunicazione10r.STOC_DISP_PALABILE_VOL);-- + ROUND(RecComunicazione10r.STOC_DISP_NONPALABILE_VOL);

            SELECT NVL(SUM(NVL(EFF.STOC_NECESSARIO_VOL,0)),0) INTO nStocNec
            FROM     DB_EFFLUENTE_10R        EFF,
                    DB_TIPO_EFFLUENTE        TIP
            WHERE EFF.ID_COMUNICAZIONE_10R        = RecComunicazione10r.ID_COMUNICAZIONE_10R
            AND    TIP.ID_EFFLUENTE                =    EFF.ID_EFFLUENTE
            AND    TIP.FLAG_PALABILE = 'S';

            nStoc_2 :=  nStocNec;

            IF nStoc_1 - nStoc_2  < 0 THEN
                S_DESCRIZIONE := 'Nell'' Unita'' Produttiva '||RecComunicazione10r.DESC_COMUNE||' ('||RecComunicazione10r.SIGLA||') '||RecComunicazione10r.INDIRIZZO||', lo stoccaggio disponibile per i reflui palabili prodotti '||ROUND(nStoc_1,1)||' m3 ,risulta insufficiente rispetto a quello necessario '||ROUND(nStoc_2,1)||' m3.';

                IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                    RAISE ERR_AZOTO;
                END IF;

            END IF;


        -- secondo controllo
            nStoc_3   := ROUND(RecComunicazione10r.STOC_DISP_NONPALABILE_VOL);

            SELECT NVL(SUM(NVL(EFF.STOC_NECESSARIO_VOL,0)),0) + NVL(RecComunicazione10r.STOC_ACQUE_NEC_VOL,0) INTO nStocNec
            FROM     DB_EFFLUENTE_10R        EFF,
                    DB_TIPO_EFFLUENTE        TIP
            WHERE EFF.ID_COMUNICAZIONE_10R        = RecComunicazione10r.ID_COMUNICAZIONE_10R
            AND    TIP.ID_EFFLUENTE                =    EFF.ID_EFFLUENTE
            AND    TIP.FLAG_PALABILE = 'N';


            nStoc_4 := nStocNec;

            IF nStoc_3 - nStoc_4  < 0 THEN
                S_DESCRIZIONE := 'Nell'' Unita'' Produttiva '||RecComunicazione10r.DESC_COMUNE||' ('||RecComunicazione10r.SIGLA||') '||RecComunicazione10r.INDIRIZZO||', lo stoccaggio disponibile per i reflui non palabili prodotti '||ROUND(nStoc_3,1)||' m3 ,risulta insufficiente rispetto a quello necessario '||ROUND(nStoc_4,1)||' m3.';

                IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                    RAISE ERR_AZOTO;
                END IF;

            END IF;

            -- terzo controllo
            nStoc_5   := ROUND(RecComunicazione10r.STOC_DISP_PALABILE_VOL) + ROUND(RecComunicazione10r.STOC_DISP_NONPALABILE_VOL);

            SELECT NVL(SUM(NVL(STOC_NECESSARIO_VOL,0)),0) +  NVL(RecComunicazione10r.STOC_ACQUE_NEC_VOL,0) INTO nStocNec
            FROM DB_EFFLUENTE_10R
            WHERE ID_COMUNICAZIONE_10R        = RecComunicazione10r.ID_COMUNICAZIONE_10R;

            nStoc_6 := nStocNec;

            IF nStoc_5 - nStoc_6  < 0 THEN
                S_DESCRIZIONE := 'Nell'' Unita'' Produttiva '||RecComunicazione10r.DESC_COMUNE||' ('||RecComunicazione10r.SIGLA||') '||RecComunicazione10r.INDIRIZZO||', lo stoccaggio disponibile per i reflui prodotti '||ROUND(nStoc_5,1)||' m3 ,risulta insufficiente rispetto a quello necessario '||ROUND(nStoc_6,1)||' m3.';

                IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                    RAISE ERR_AZOTO;
                END IF;

            END IF;
        END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN ERR_AZOTO    THEN
        RETURN (FALSE);

    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE STOC_INSUFFICIENTE_UTE: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END STOC_INSUFFICIENTE_UTE;



FUNCTION SUPERFICIE_AGRONOMIC_SAU_UTE     (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                        P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                        P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                         P_MSGERR       IN OUT VARCHAR2,
                                                        P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS

/*
    912
    [10R05] Verifica per ogni ute piemontese che la somma degli usi del suolo idonei
    alla spandibilità per conduzioni non asservimento +  la somma degli usi del suolo
    idonei alla spandibilità per conduzioni non asservimento dichiarate nelle ultime
    d.c. di altre aziende le cui particelle ricadono in conduzione asservimento sul
    piano in lavorazione sia maggiore delle superfici agronomiche + le superfici
    condotte in asservimento.*/

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

CURSOR CUR_UTE IS SELECT    UT.ID_UTE,
                                    CM.DESCOM    DESC_COMUNE,
                                    PR.SIGLA_PROVINCIA    SIGLA,
                                    UT.INDIRIZZO
                        FROM         DB_UTE UT,
                                    COMUNE CM,
                                    PROVINCIA PR
                        WHERE ut.ID_AZIENDA                 = P_ID_AZIENDA
                        AND    UT.COMUNE                    = CM.ISTAT_COMUNE
                        AND   CM.ISTAT_PROVINCIA         = PR.ISTAT_PROVINCIA
                        AND   PR.ID_REGIONE = '01' 
                        AND    UT.DATA_FINE_ATTIVITA     IS NULL;

--nSupSpandibile                NUMBER;
nSupAgronomica                NUMBER;
nSupCondottaAsservita    NUMBER;
nSupSpandimento         NUMBER;
nTotSupTmp1                    NUMBER;
nTotSupTmp2                    NUMBER;
nTotSau                        NUMBER;

vCodErr            VARCHAR2(100);
vDesErr            VARCHAR2(100);

ERR_AZOTO        EXCEPTION;
BEGIN

    S_DESCRIZIONE := NULL;


    /*
        Calcolo la superfice agronomica dichiarata
        Come somma delle superfice agronomica per conduzioni diverse da asservimento
        e superfice condotta per conduzioni asservimento
     */

    FOR  RecComunicazione10r IN CUR_UTE LOOP

        BEGIN
            SELECT NVL(SUM(NVL(SUPERFICIE_UTILIZZATA,0)),0)
            INTO nTotSupTmp1
            FROM  DB_UTE UT,
                    DB_CONDUZIONE_PARTICELLA CO,
                    DB_UTILIZZO_PARTICELLA   UT,
                    DB_TIPO_UTILIZZO             TI
            WHERE UT.ID_UTE = RecComunicazione10r.ID_UTE
            AND    CO.ID_UTE                             =     UT.ID_UTE
            AND    CO.DATA_FINE_CONDUZIONE         IS NULL
            AND    ID_TITOLO_POSSESSO                 != 5
            AND    UT.ID_CONDUZIONE_PARTICELLA    = CO.ID_CONDUZIONE_PARTICELLA
            AND    UT.ID_UTILIZZO                        = TI.ID_UTILIZZO
            AND    TI.FLAG_USO_AGRONOMICO            = 'S';
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                nTotSupTmp1 := 0;
        END;


        BEGIN

            SELECT NVL(SUM(NVL(SUPERFICIE_UTILIZZATA,0)),0)
            INTO nTotSupTmp2
          FROM      DB_CONDUZIONE_DICHIARATA CD,
                        DB_DICHIARAZIONE_CONSISTENZA DC,
                        DB_ANAGRAFICA_AZIENDA AA,
                        DB_UTILIZZO_DICHIARATO   UT,
                        DB_TIPO_UTILIZZO             TI
            WHERE CD.CODICE_FOTOGRAFIA_TERRENI             = DC.CODICE_FOTOGRAFIA_TERRENI
            AND    AA.ID_AZIENDA                                 = DC.ID_AZIENDA
            AND     AA.DATA_FINE_VALIDITA                     IS NULL
            AND     AA.DATA_CESSAZIONE                         IS NULL
            AND    AA.ID_AZIENDA                                 <> P_ID_AZIENDA
            AND    DC.ID_MOTIVO_DICHIARAZIONE             <> 7
            AND    DC.DATA_INSERIMENTO_DICHIARAZIONE    = (    SELECT MAX(DCX.DATA_INSERIMENTO_DICHIARAZIONE)
                                                                            FROM     DB_DICHIARAZIONE_CONSISTENZA    DCX,
                                                                                    DB_TIPO_MOTIVO_DICHIARAZIONE     TI
                                                                        WHERE DCX.ID_AZIENDA = DC.ID_AZIENDA
                                                                       AND   DCX.ID_MOTIVO_DICHIARAZIONE <> 7
                                                                            AND    TI.ID_MOTIVO_DICHIARAZIONE = DCX.ID_MOTIVO_DICHIARAZIONE
                                                                            AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                                                        )
            AND    ID_TITOLO_POSSESSO                         != 5
            AND     UT.ID_CONDUZIONE_DICHIARATA            =    CD.ID_CONDUZIONE_DICHIARATA
            AND    UT.ID_UTILIZZO                                =     TI.ID_UTILIZZO
            AND    TI.FLAG_USO_AGRONOMICO                    = 'S'
            AND CD.ID_PARTICELLA IN (    SELECT DISTINCT ID_PARTICELLA
                                                FROM      DB_UTE UT,
                                                          DB_CONDUZIONE_PARTICELLA CO
                                                WHERE UT.ID_UTE                   = RecComunicazione10r.ID_UTE
                                                AND    UT.DATA_FINE_ATTIVITA     IS NULL
                                                AND    CO.ID_UTE                     = UT.ID_UTE
                                                AND    CO.DATA_FINE_CONDUZIONE IS NULL
                                                AND    ID_TITOLO_POSSESSO         = 5
                                            );


        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                nTotSupTmp2 := 0;
        END;

        nTotSau := (nTotSupTmp1 + nTotSupTmp2);


        BEGIN
            SELECT NVL(SUM(NVL(CO.SUPERFICIE_AGRONOMICA,0)),0)
            INTO nSupAgronomica
            FROM      DB_CONDUZIONE_PARTICELLA CO
            WHERE     CO.ID_UTE                     = RecComunicazione10r.ID_UTE
            AND    CO.DATA_FINE_CONDUZIONE IS NULL
            AND    ID_TITOLO_POSSESSO         != 5;
        EXCEPTION
             WHEN NO_DATA_FOUND THEN
                  nSupAgronomica:=0;
        END;


       BEGIN

        SELECT NVL(SUM(NVL(SUPERFICIE_CONDOTTA,0)),0)
            INTO nSupCondottaAsservita
            FROM      DB_UTE UT,
                      DB_CONDUZIONE_PARTICELLA CO
            WHERE UT.ID_UTE                   = RecComunicazione10r.ID_UTE
            AND    CO.ID_UTE                     = UT.ID_UTE
            AND    CO.DATA_FINE_CONDUZIONE IS NULL
            AND    ID_TITOLO_POSSESSO         = 5
            AND    ID_PARTICELLA        IN    (        SELECT ID_PARTICELLA
                                                      FROM      DB_CONDUZIONE_DICHIARATA CD,
                                                                    DB_DICHIARAZIONE_CONSISTENZA DC,
                                                                    DB_ANAGRAFICA_AZIENDA AA
                                                        WHERE CD.CODICE_FOTOGRAFIA_TERRENI             = DC.CODICE_FOTOGRAFIA_TERRENI
                                                        AND    AA.ID_AZIENDA                                 = DC.ID_AZIENDA
                                                        AND     AA.DATA_FINE_VALIDITA                     IS NULL
                                                        AND     AA.DATA_CESSAZIONE                         IS NULL
                                                        AND    AA.ID_AZIENDA                                 <> P_ID_AZIENDA
                                                        AND    DC.ID_MOTIVO_DICHIARAZIONE             <> 7
                                                        AND    DC.DATA_INSERIMENTO_DICHIARAZIONE    =  (    SELECT MAX(DCX.DATA_INSERIMENTO_DICHIARAZIONE)
                                                                                                                        FROM     DB_DICHIARAZIONE_CONSISTENZA    DCX,
                                                                                                                                DB_TIPO_MOTIVO_DICHIARAZIONE     TI
                                                                                                                    WHERE DCX.ID_AZIENDA = DC.ID_AZIENDA
                                                                                                                   AND   DCX.ID_MOTIVO_DICHIARAZIONE <> 7
                                                                                                                        AND    TI.ID_MOTIVO_DICHIARAZIONE = DCX.ID_MOTIVO_DICHIARAZIONE
                                                                                                                        AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                                                                                                    )
                                                        AND    ID_TITOLO_POSSESSO                         != 5
                                                        AND CD.ID_PARTICELLA IN (    SELECT DISTINCT ID_PARTICELLA
                                                                                            FROM      DB_UTE UT,
                                                                                                      DB_CONDUZIONE_PARTICELLA CO
                                                                                            WHERE UT.ID_UTE                   = RecComunicazione10r.ID_UTE
                                                                                            AND    CO.ID_UTE                     = UT.ID_UTE
                                                                                            AND    CO.DATA_FINE_CONDUZIONE IS NULL
                                                                                            AND    ID_TITOLO_POSSESSO         = 5
                                                                                        )
                                                        );



        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                nSupCondottaAsservita := 0;
        END;

        nSupSpandimento:=nSupAgronomica + nSupCondottaAsservita;



        IF    nTotSau  >= nSupSpandimento THEN
            NULL;
        ELSE
            S_DESCRIZIONE := 'Nell'' Unita'' Produttiva '||RecComunicazione10r.DESC_COMUNE||' ('||RecComunicazione10r.SIGLA||') '||RecComunicazione10r.INDIRIZZO||', le  superfici relative agli usi del suolo, congruenti con la SAU, legate alle particelle presenti sul piano in lavorazione dell ''azienda ('|| TRIM(TO_CHAR(NVL(nTotSau,0),'999G990D9999'))||' ha) , sono inferiori alla superficie ad uso agronomico dichiarata per le stesse particelle presenti sul piano in lavorazione dell''azienda';

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
            END IF;

        END IF;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE SUPERFICIE_AGRONOMIC_SAU_UTE: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END SUPERFICIE_AGRONOMIC_SAU_UTE;



FUNCTION NOTE_EFFLUENTI_NULL        (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                 P_MSGERR       IN OUT VARCHAR2,
                                                P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS

/*
    914
    [10R15] Verifica, per ogni comunicazione 10/r legate alle UTE, che siano specificate
    le NOTE del riepilogo reflui nel caso in cui l'utente ha dichiarato un volume/azoto
    diverso dal rispettivo calcolato.*/

    CURSOR CUR_UTE IS SELECT     DISTINCT COM.ID_UTE,
                                                    CM.DESCOM    DESC_COMUNE,
                                                    PR.SIGLA_PROVINCIA    SIGLA,
                                                    UT.INDIRIZZO
                            FROM     DB_COMUNICAZIONE_10R COM,
                                    DB_EFFLUENTE_10R        EFF,
                                    DB_UTE UT,
                                    COMUNE CM,
                                    PROVINCIA PR,
                                    REGIONE    RG
                            WHERE ut.ID_AZIENDA                 = P_ID_AZIENDA
                            AND    UT.ID_UTE                    = COM.ID_UTE
                            AND    UT.COMUNE                    = CM.ISTAT_COMUNE
                            AND   CM.ISTAT_PROVINCIA         = PR.ISTAT_PROVINCIA
                            AND   PR.ID_REGIONE                 = RG.ID_REGIONE
                            AND    COM.DATA_FINE_VALIDITA     IS NULL
                            AND    UT.DATA_FINE_ATTIVITA     IS NULL
                            AND TRIM(COM.NOTE) IS NULL 
                            AND    EFF.ID_COMUNICAZIONE_10R        = COM.ID_COMUNICAZIONE_10R
                            AND    (VOLUME_POST_TRATTAMENTO  != VOLUME_POST_DICHIARATO OR AZOTO_POST_TRATTAMENTO    != AZOTO_POST_DICHIARATO);

nNoteNull NUMBER;
S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

BEGIN
    S_DESCRIZIONE    :=  NULL;

    FOR  RecComunicazione10r IN CUR_UTE LOOP

        S_DESCRIZIONE := 'Nell'' Unita'' Produttiva '||RecComunicazione10r.DESC_COMUNE||' ('||RecComunicazione10r.SIGLA||') '||RecComunicazione10r.INDIRIZZO||' l''utente ha variato il volume/azoto calcolato senza specificarne il motivo nelle relative note.';
            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
            END IF;
    END LOOP;
    RETURN (TRUE);
EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE NOTE_EFFLUENTI_NULL: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END NOTE_EFFLUENTI_NULL;

---------------------------------------------------------------------------------------
-- FINE CONTROLLI DICHIARAZIONE 10 R
---------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------
-- INIZIO CONTROLLI ELENCO SOCI
---------------------------------------------------------------------------------------
FUNCTION CONTROLLA_SOCI_DOPPI (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                               P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                               P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                               P_MSGERR       IN OUT VARCHAR2,
                               P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

    -- cursore che mi indica le aziende che risultano
    -- più di una volta come socie di quella corrente
    CURSOR curAziendeSocieDoppie IS
    SELECT AC.ID_AZIENDA_ASSOCIATA,
           AZ.CUAA,
           COUNT(*) AS NUM_VOLTE
      FROM DB_AZIENDA_COLLEGATA AC,
           DB_ANAGRAFICA_AZIENDA AZ
     WHERE AC.ID_AZIENDA = P_ID_AZIENDA
       AND AC.DATA_FINE_VALIDITA IS NULL
       AND AC.ID_AZIENDA_ASSOCIATA IS NOT NULL
       AND AC.ID_AZIENDA_ASSOCIATA = AZ.ID_AZIENDA
       AND AZ.DATA_FINE_VALIDITA IS NULL
  GROUP BY AC.ID_AZIENDA_ASSOCIATA,
           AZ.CUAA
  HAVING COUNT(*) > 1;

    -- cursore che mi indica i soggetti che risultano
    -- più di una volta come soci dell'aziendacorrente
    CURSOR curSoggettiSociDoppi IS
    SELECT SA.CUAA,
           COUNT(*) AS NUM_VOLTE
      FROM DB_AZIENDA_COLLEGATA AC,
           DB_SOGGETTO_ASSOCIATO SA
     WHERE AC.ID_AZIENDA = P_ID_AZIENDA
       AND AC.ID_SOGGETTO_ASSOCIATO IS NOT NULL
       AND AC.DATA_FINE_VALIDITA IS NULL
       AND AC.ID_SOGGETTO_ASSOCIATO = SA.ID_SOGGETTO_ASSOCIATO
  GROUP BY SA.CUAA
  HAVING COUNT(*) > 1;

  vMessaggio    DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

BEGIN

    vMessaggio := NULL;
    -- scorro le aziende censite in anagrafe che risultano doppi e le segnalo su apposita tabella
    FOR recAziendeSocieDoppie IN curAziendeSocieDoppie LOOP
        vMessaggio := 'Il socio identificato col cuaa : ' || recAziendeSocieDoppie.CUAA || ' risulta ' || recAziendeSocieDoppie.NUM_VOLTE || ' volte come socio dell''azienda';
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vMessaggio, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
    END LOOP;

    vMessaggio := NULL;
    -- scorro i soci censiti in anagrafe che risultano doppi e le segnalo su apposita tabella
    FOR recSoggettiSociDoppi IN curSoggettiSociDoppi LOOP
        vMessaggio := 'Il socio identificato col cuaa : ' || recSoggettiSociDoppi.CUAA || ' risulta ' || recSoggettiSociDoppi.NUM_VOLTE || ' volte come socio dell''azienda';
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vMessaggio, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'CONTROLLA_SOCI_DOPPI: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END CONTROLLA_SOCI_DOPPI;

---------------------------------------------------------------------------------------
-- FINE CONTROLLI ELENCO SOCI
---------------------------------------------------------------------------------------



-----------------------------------------------------------------------------------------
FUNCTION PRESENZA_USO_SUOLO_ASSERVIM (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                     P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                    P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                     P_MSGERR       IN OUT VARCHAR2,
                                                    P_CODERR           IN OUT VARCHAR2)    RETURN BOOLEAN IS


CURSOR CUR_P IS SELECT     D.SEZIONE                         SEZ,
                                D.FOGLIO                         FOGLIO,
                                D.PARTICELLA                     PART,
                                D.SUBALTERNO                     SUB,
                                 E.DESCOM                         COMU,
                                A.ID_CONDUZIONE_PARTICELLA ID_CONDUZIONE_PARTICELLA
    FROM     DB_CONDUZIONE_PARTICELLA A,
            DB_UTE B,
            DB_PARTICELLA K,
            DB_UTILIZZO_PARTICELLA X,
            DB_STORICO_PARTICELLA D,
            COMUNE E
    WHERE ID_AZIENDA                            =    P_ID_AZIENDA
    AND     A.ID_UTE                                =    B.ID_UTE
    AND     A.DATA_FINE_CONDUZIONE             IS NULL
    AND    B.DATA_FINE_ATTIVITA             IS NULL
    AND    A.ID_TITOLO_POSSESSO                = 5
    AND    X.ID_CONDUZIONE_PARTICELLA     = A.ID_CONDUZIONE_PARTICELLA
    AND     D.DATA_FINE_VALIDITA             IS NULL
    AND     A.ID_PARTICELLA                     = D.ID_PARTICELLA
    AND    D.ID_PARTICELLA                     = K.ID_PARTICELLA
   AND     E.ISTAT_COMUNE                     = D.COMUNE
     GROUP BY  D.SEZIONE , D.FOGLIO , D.PARTICELLA , D.SUBALTERNO ,    E.DESCOM, A.ID_CONDUZIONE_PARTICELLA;

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

BEGIN
    S_DESCRIZIONE := NULL;

    FOR REC_P IN CUR_P LOOP

--    S_DESCRIZIONE :=     '['||REC_P.COMU||' Sez:'||REC_P.SEZ||' Fgl:' ||REC_P.FOGLIO||
--                               ' Part:'||REC_P.PART||' Sub:'||REC_P.SUB||'] Impossibile inserire usi del suolo su conduzioni in asservimento';

        S_DESCRIZIONE :=     '['||REC_P.COMU;

        IF REC_P.SEZ IS NOT NULL THEN
            S_DESCRIZIONE := S_DESCRIZIONE||' Sez:'||REC_P.SEZ;
        END IF;

        S_DESCRIZIONE := S_DESCRIZIONE||' Fgl:' ||REC_P.FOGLIO||' Part:'||REC_P.PART;

        IF REC_P.SUB IS NOT NULL THEN
            S_DESCRIZIONE := S_DESCRIZIONE||' Sub:'||REC_P.SUB;
        END IF;

        S_DESCRIZIONE := S_DESCRIZIONE||'] Impossibile inserire usi del suolo su conduzioni in asservimento';


        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE,  REC_P.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
         END IF;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE PRESENZA_USO_SUOLO_ASSERVIM: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);

END PRESENZA_USO_SUOLO_ASSERVIM;


FUNCTION PRESENZA_TERRENI (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                 P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                 P_MSGERR       IN OUT VARCHAR2,
                                P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_NUMERO             NUMBER;

BEGIN
     S_DESCRIZIONE := NULL;
    SELECT COUNT(*)
    INTO  S_NUMERO
    FROM DB_CONDUZIONE_PARTICELLA A, DB_UTE B
    WHERE ID_AZIENDA=P_ID_AZIENDA AND A.ID_UTE=B.ID_UTE
    AND A.DATA_FINE_CONDUZIONE IS NULL;

    S_DESCRIZIONE := 'Non sono stati dichiarati TERRENI';

    IF S_NUMERO = 0 THEN
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
             P_BLOCCANTE, NULL, NULL,P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
        END IF;
    END IF;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE PRESENZA_TERRENI: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END PRESENZA_TERRENI;

FUNCTION PRESENZA_ALLEVAMENTI (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                 P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                 P_MSGERR       IN OUT VARCHAR2,
                                P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_NUMERO             NUMBER;

BEGIN
     S_DESCRIZIONE := NULL;
    SELECT COUNT(*)
    INTO  S_NUMERO
    FROM DB_ALLEVAMENTO A, DB_UTE B
    WHERE B.ID_AZIENDA=P_ID_AZIENDA AND A.ID_UTE=B.ID_UTE
    AND A.DATA_FINE IS NULL;

    S_DESCRIZIONE := 'Non sono stati dichiarati ALLEVAMENTI';

    IF S_NUMERO = 0 THEN
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
             P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
        END IF;
    END IF;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE PRESENZA_ALLEVAMENTI: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END PRESENZA_ALLEVAMENTI;

/* verifica che non esistano allevamenti attivi legati ad UTE cessate */
FUNCTION ALLEVAMENTI_SU_UTE_SCADUTE (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                      P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                     P_BLOCCANTE    IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                      P_MSGERR       IN OUT VARCHAR2,
                                     P_CODERR        IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_NUMERO             NUMBER;

BEGIN

    SELECT COUNT(B.ID_ALLEVAMENTO)
    INTO  S_NUMERO
    FROM DB_UTE A, DB_ALLEVAMENTO B
    WHERE A.ID_AZIENDA=P_ID_AZIENDA
    AND B.DATA_FINE IS NULL
    AND A.ID_UTE=B.ID_UTE
    AND A.DATA_FINE_ATTIVITA IS NOT NULL;

    IF S_NUMERO > 0 THEN
        S_DESCRIZIONE := 'Esistono allevamenti attivi legati ad UTE cessate';
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
             P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
        END IF;
    END IF;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE ALLEVAMENTI_SU_UTE_SCADUTE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END ALLEVAMENTI_SU_UTE_SCADUTE;

-- ALL02
FUNCTION CONTROLLA_CODICE_ALLEVAMENTO (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                 P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                 P_MSGERR       IN OUT VARCHAR2,
                                P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS
CURSOR C_ALLEVAMENTO IS
     SELECT A.ID_ALLEVAMENTO, C.DESCRIZIONE, a.CODICE_AZIENDA_ZOOTECNICA, a.ISTAT_COMUNE, a.ID_ASL,
            D.SIGLA_PROVINCIA, c.FLAG_OBBLIGO_ASL,C.FLAG_CONTROLLO_COMUNE  
     FROM     DB_ALLEVAMENTO A, DB_UTE B, DB_TIPO_SPECIE_ANIMALE C, PROVINCIA D
     WHERE  A.DATA_FINE IS NULL AND A.ID_UTE = B.ID_UTE
       AND  B.ID_AZIENDA = P_ID_AZIENDA
       AND A.ID_SPECIE_ANIMALE = C.ID_SPECIE_ANIMALE
       AND  B.DATA_FINE_ATTIVITA IS NULL
       AND SUBSTR(A.ISTAT_COMUNE,1,3) =D.ISTAT_PROVINCIA(+);

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_NUMERO                 NUMBER;
BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_ALLEVAMENTO IN C_ALLEVAMENTO LOOP
       IF rec_allevamento.flag_obbligo_asl= 'S' THEN
           IF REC_ALLEVAMENTO.CODICE_AZIENDA_ZOOTECNICA IS NULL OR REC_ALLEVAMENTO.id_asl IS NULL THEN

              S_DESCRIZIONE :=  REC_ALLEVAMENTO.descrizione||': Codice allevamento zootecnico o ASL di competenza non valorizzato' ;
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;

              IF NOT SCRIVI_ANOMALIA_ALLEVAMENTO (P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, REC_ALLEVAMENTO.ID_ALLEVAMENTO, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;

           ELSE
                 IF SUBSTR(REC_ALLEVAMENTO.CODICE_AZIENDA_ZOOTECNICA,1,3) <> SUBSTR(REC_ALLEVAMENTO.istat_comune,4,3) AND
                    REC_ALLEVAMENTO.FLAG_CONTROLLO_COMUNE = 'S'  THEN 
                      S_DESCRIZIONE :=  REC_ALLEVAMENTO.descrizione||': Codice allevamento zootecnico ERRATO' ;
                      IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                         RETURN (FALSE);
                      END IF;

                      IF NOT SCRIVI_ANOMALIA_ALLEVAMENTO (P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, REC_ALLEVAMENTO.ID_ALLEVAMENTO, P_MSGERR, P_CODERR) THEN
                         RETURN (FALSE);
                      END IF;


                 ELSIF SUBSTR(REC_ALLEVAMENTO.CODICE_AZIENDA_ZOOTECNICA,4,2) <> REC_ALLEVAMENTO.SIGLA_PROVINCIA AND
                    REC_ALLEVAMENTO.FLAG_CONTROLLO_COMUNE = 'S' THEN 
                      S_DESCRIZIONE :=  REC_ALLEVAMENTO.descrizione||': Codice allevamento zootecnico ERRATO' ;
                      IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                         RETURN (FALSE);
                      END IF;

                      IF NOT SCRIVI_ANOMALIA_ALLEVAMENTO (P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, REC_ALLEVAMENTO.ID_ALLEVAMENTO, P_MSGERR, P_CODERR) THEN
                         RETURN (FALSE);
                      END IF;


                 ELSE
                     -- gli ultimi 3 caratteri devono essere per forza dei numeri
                     -- quindi il codice ascii deve essere tra 48 e 57
                     IF ASCII(SUBSTR(REC_ALLEVAMENTO.CODICE_AZIENDA_ZOOTECNICA,6,1)) NOT BETWEEN 48 AND 57 OR
                        ASCII(SUBSTR(REC_ALLEVAMENTO.CODICE_AZIENDA_ZOOTECNICA,7,1)) NOT BETWEEN 48 AND 57 OR
                        ASCII(SUBSTR(REC_ALLEVAMENTO.CODICE_AZIENDA_ZOOTECNICA,8,1)) NOT BETWEEN 48 AND 57 THEN

                        S_DESCRIZIONE :=  REC_ALLEVAMENTO.descrizione||': Codice allevamento zootecnico ERRATO' ;
                        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                           RETURN (FALSE);
                        END IF;

                       IF NOT SCRIVI_ANOMALIA_ALLEVAMENTO (P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, REC_ALLEVAMENTO.ID_ALLEVAMENTO, P_MSGERR, P_CODERR) THEN
                          RETURN (FALSE);
                       END IF;

                     END IF;
                 END IF;
           END IF;
        END IF;
     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_CODICE_ALLEVAMENTO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLA_CODICE_ALLEVAMENTO;

FUNCTION CONTROLLA_CONSIST_ALLEVAMENTO (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                        P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                        P_MSGERR       IN OUT VARCHAR2,
                                        P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS
    CURSOR C_ALLEVAMENTO IS
    SELECT A.ID_ALLEVAMENTO,
           C.DESCRIZIONE,
           A.CODICE_AZIENDA_ZOOTECNICA
      FROM DB_ALLEVAMENTO A,
           DB_UTE B,
           DB_TIPO_SPECIE_ANIMALE C
     WHERE A.DATA_FINE IS NULL
       AND A.ID_UTE = B.ID_UTE
       AND B.ID_AZIENDA = P_ID_AZIENDA
       AND A.ID_SPECIE_ANIMALE = C.ID_SPECIE_ANIMALE
       AND B.DATA_FINE_ATTIVITA IS NULL
       AND NOT EXISTS (SELECT CA.ID_CATEGORIE_ALLEVAMENTO
                         FROM DB_CATEGORIE_ALLEVAMENTO CA
                        WHERE CA.ID_ALLEVAMENTO = A.ID_ALLEVAMENTO); 


    S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    S_NUMERO                 NUMBER;
BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_ALLEVAMENTO IN C_ALLEVAMENTO LOOP
         S_DESCRIZIONE :=  'Per l''allevamento con codice azienda zootecnica: ' || REC_ALLEVAMENTO.CODICE_AZIENDA_ZOOTECNICA || ' (' || REC_ALLEVAMENTO.descrizione||') non è stata indicata la consistenza zootecnica';

         IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
         END IF;

         IF NOT SCRIVI_ANOMALIA_ALLEVAMENTO (P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, REC_ALLEVAMENTO.ID_ALLEVAMENTO, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
         END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_CONSISTENZA_ALLEVAMENTO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLA_CONSIST_ALLEVAMENTO;

FUNCTION ALLEVAMENTI_SENZA_PESO (P_ID_AZIENDA   IN    DB_AZIENDA.ID_AZIENDA%TYPE,
                                 P_ID_CONTROLLO IN    DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                 P_BLOCCANTE    IN    DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                 P_MSGERR       IN OUT VARCHAR2,
                                 P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

/*
    CURSOR C_ALLEVAMENTI IS
    SELECT A.CODICE_AZIENDA_ZOOTECNICA, TSA.DESCRIZIONE DESC_SPECIE
      FROM DB_UTE U,
           DB_ALLEVAMENTO A,
           DB_CATEGORIE_ALLEVAMENTO CA,
           DB_TIPO_CATEGORIA_ANIMALE TCA,
           DB_TIPO_SPECIE_ANIMALE TSA
     WHERE U.ID_AZIENDA=P_ID_AZIENDA
       AND A.DATA_FINE IS NULL
       AND U.ID_UTE=A.ID_UTE
        AND U.DATA_FINE_ATTIVITA IS NULL
        AND CA.ID_ALLEVAMENTO = A.ID_ALLEVAMENTO
        AND CA.ID_CATEGORIA_ANIMALE = TCA.ID_CATEGORIA_ANIMALE
        AND TCA.ID_SPECIE_ANIMALE = TSA.ID_SPECIE_ANIMALE
        AND (CA.QUANTITA > 0 OR CA.QUANTITA_PROPRIETA > 0)
        AND NVL(CA.PESO_VIVO_UNITARIO,0) = 0
        AND TCA.PESO_VIVO_MEDIO > 0
   GROUP BY A.CODICE_AZIENDA_ZOOTECNICA, TSA.DESCRIZIONE;
*/

    CURSOR C_ALLEVAMENTI IS
    SELECT A.ID_ALLEVAMENTO,
           A.CODICE_AZIENDA_ZOOTECNICA,
           TSA.DESCRIZIONE DESC_SPECIE
      FROM DB_UTE U,
           DB_ALLEVAMENTO A,
           DB_TIPO_SPECIE_ANIMALE TSA
     WHERE U.ID_AZIENDA = P_ID_AZIENDA
       AND A.DATA_FINE IS NULL
       AND U.ID_UTE = A.ID_UTE
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND A.ID_SPECIE_ANIMALE = TSA.ID_SPECIE_ANIMALE
       AND EXISTS (SELECT CA.ID_CATEGORIE_ALLEVAMENTO
                     FROM DB_CATEGORIE_ALLEVAMENTO CA,
                          DB_TIPO_CATEGORIA_ANIMALE TCA
                    WHERE CA.ID_ALLEVAMENTO = A.ID_ALLEVAMENTO
                      AND CA.ID_CATEGORIA_ANIMALE = TCA.ID_CATEGORIA_ANIMALE
                      AND (CA.QUANTITA > 0 OR CA.QUANTITA_PROPRIETA > 0) 
                      AND NVL(CA.PESO_VIVO_UNITARIO,0) = 0
                      AND TCA.PESO_VIVO_MEDIO > 0 );



S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

BEGIN

    FOR REC_ALLEVAMENTI IN C_ALLEVAMENTI LOOP
        S_DESCRIZIONE := 'Per l''allevamento con codice azienda zootecnica: ' || REC_ALLEVAMENTI.CODICE_AZIENDA_ZOOTECNICA || ' (' || REC_ALLEVAMENTI.DESC_SPECIE||') non è stata indicato il peso vivo medio unitario per tutte le categorie animali';
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
             P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_ANOMALIA_ALLEVAMENTO (P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, REC_ALLEVAMENTI.ID_ALLEVAMENTO, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

    END LOOP;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE ALLEVAMENTI_SENZA_PESO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END ALLEVAMENTI_SENZA_PESO;

FUNCTION ALLEVAMENTI_PESO_ERRATO (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                  P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                  P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                  P_MSGERR       IN OUT VARCHAR2,
                                  P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

/* MS 26/09/2014
-- cambia il cursore
CURSOR C_ALLEVAMENTI IS
    SELECT A.CODICE_AZIENDA_ZOOTECNICA, TSA.DESCRIZIONE DESC_SPECIE
    FROM DB_UTE U, DB_ALLEVAMENTO A, DB_CATEGORIE_ALLEVAMENTO CA, DB_TIPO_CATEGORIA_ANIMALE TCA,
         DB_TIPO_SPECIE_ANIMALE TSA
    WHERE U.ID_AZIENDA=P_ID_AZIENDA
    AND A.DATA_FINE IS NULL
    AND U.ID_UTE=A.ID_UTE
    AND U.DATA_FINE_ATTIVITA IS NULL
    AND CA.ID_ALLEVAMENTO = A.ID_ALLEVAMENTO
    AND CA.ID_CATEGORIA_ANIMALE = TCA.ID_CATEGORIA_ANIMALE
    AND (CA.QUANTITA > 0 OR CA.QUANTITA_PROPRIETA > 0) 
    AND TCA.ID_SPECIE_ANIMALE = TSA.ID_SPECIE_ANIMALE
    AND NVL(CA.PESO_VIVO_UNITARIO,0) NOT BETWEEN NVL(TCA.PESO_VIVO_MIN,0) AND NVL(TCA.PESO_VIVO_MAX,0)
    GROUP BY A.CODICE_AZIENDA_ZOOTECNICA, TSA.DESCRIZIONE;
*/


    CURSOR C_ALLEVAMENTI IS
    SELECT A.ID_ALLEVAMENTO,
           A.CODICE_AZIENDA_ZOOTECNICA,
           TSA.DESCRIZIONE DESC_SPECIE
      FROM DB_UTE U,
           DB_ALLEVAMENTO A,
           DB_TIPO_SPECIE_ANIMALE TSA
     WHERE U.ID_AZIENDA = P_ID_AZIENDA
       AND A.DATA_FINE IS NULL
       AND U.ID_UTE = A.ID_UTE
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND A.ID_SPECIE_ANIMALE = TSA.ID_SPECIE_ANIMALE
       AND EXISTS (SELECT CA.ID_CATEGORIE_ALLEVAMENTO
                     FROM DB_CATEGORIE_ALLEVAMENTO CA,
                          DB_TIPO_CATEGORIA_ANIMALE TCA
                    WHERE CA.ID_ALLEVAMENTO = A.ID_ALLEVAMENTO
                      AND CA.ID_CATEGORIA_ANIMALE = TCA.ID_CATEGORIA_ANIMALE
                      AND (CA.QUANTITA > 0 OR
                           CA.QUANTITA_PROPRIETA > 0)   
                      AND NVL (CA.PESO_VIVO_UNITARIO, 0) NOT BETWEEN NVL (TCA.PESO_VIVO_MIN,0) AND NVL (TCA.PESO_VIVO_MAX,0));


    S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

BEGIN

    FOR REC_ALLEVAMENTI IN C_ALLEVAMENTI LOOP
        S_DESCRIZIONE := 'Per l''allevamento con codice azienda zootecnica: ' || REC_ALLEVAMENTI.CODICE_AZIENDA_ZOOTECNICA || ' (' || REC_ALLEVAMENTI.DESC_SPECIE||') è stata indicato il peso vivo medio unitario errato';
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
             P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_ANOMALIA_ALLEVAMENTO (P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, REC_ALLEVAMENTI.ID_ALLEVAMENTO, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;


    END LOOP;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE ALLEVAMENTI_PESO_ERRATO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END ALLEVAMENTI_PESO_ERRATO;

FUNCTION PRESENZA_FABBRICATI (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                 P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                 P_MSGERR       IN OUT VARCHAR2,
                                P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_NUMERO             NUMBER;

BEGIN
     S_DESCRIZIONE := NULL;
    SELECT COUNT(*)
    INTO  S_NUMERO
    FROM DB_FABBRICATO A, DB_UTE B
    WHERE B.ID_AZIENDA=P_ID_AZIENDA AND A.ID_UTE=B.ID_UTE
    AND A.DATA_FINE_VALIDITA IS NULL;

    S_DESCRIZIONE := 'Non sono stati dichiarati FABBRICATI';

    IF S_NUMERO = 0 THEN
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
             P_BLOCCANTE, NULL, NULL,P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
        END IF;
    END IF;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE PRESENZA_FABBRICATI: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END PRESENZA_FABBRICATI;

/* verifica che non esistano fabbricati validi legati ad UTE cessate */
FUNCTION FABBRICATI_SU_UTE_SCADUTE (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                      P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                     P_BLOCCANTE    IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                      P_MSGERR       IN OUT VARCHAR2,
                                     P_CODERR        IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_NUMERO             NUMBER;

BEGIN

    SELECT COUNT(C.ID_FABBRICATO)
    INTO  S_NUMERO
    FROM DB_UTE A, DB_FABBRICATO C
    WHERE A.ID_AZIENDA=P_ID_AZIENDA
    AND C.DATA_FINE_VALIDITA IS NULL
    AND A.ID_UTE=C.ID_UTE
    AND A.DATA_FINE_ATTIVITA IS NOT NULL;

    IF S_NUMERO > 0 THEN
        S_DESCRIZIONE := 'Esistono fabbricati validi legati ad UTE cessate';
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
             P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
        END IF;
    END IF;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE FABBRICATI_SU_UTE_SCADUTE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END FABBRICATI_SU_UTE_SCADUTE;

FUNCTION FABBRICATO_SENZA_PARTICELLE (P_ID_AZIENDA IN       DB_AZIENDA.ID_AZIENDA%TYPE,
                                    P_ID_CONTROLLO IN       DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                    P_BLOCCANTE       IN       DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                    P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

/*
        Escludo le strutture di stoccaggio
*/

CURSOR C_FABBRICATO IS
     SELECT A.DENOMINAZIONE, C.DESCRIZIONE
     FROM     DB_FABBRICATO A, DB_UTE B, DB_TIPO_TIPOLOGIA_FABBRICATO C
     WHERE  ID_FABBRICATO NOT IN (SELECT ID_FABBRICATO FROM DB_FABBRICATO_PARTICELLA WHERE DATA_FINE_VALIDITA IS NULL)
       AND  A.DATA_FINE_VALIDITA IS NULL AND A.ID_UTE = B.ID_UTE
       AND  B.ID_AZIENDA = P_ID_AZIENDA
       AND  A.ID_TIPOLOGIA_FABBRICATO = C.ID_TIPOLOGIA_FABBRICATO
       AND  C.FLAG_PER_STOCCAGGIO<>'S';

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_FABBRICATO IN C_FABBRICATO LOOP
          S_DESCRIZIONE := 'Non sono state indicate le particelle per il fabbricato ' || REC_FABBRICATO.DENOMINAZIONE || ' ' ||REC_FABBRICATO.DESCRIZIONE;
          IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;
     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE FABBRICATO_SENZA_PARTICELLE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END FABBRICATO_SENZA_PARTICELLE;

FUNCTION PRESENZA_MANODOPERA (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                 P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                 P_MSGERR       IN OUT VARCHAR2,
                                P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_NUMERO             NUMBER;

BEGIN
     S_DESCRIZIONE := NULL;
    SELECT COUNT(*)
    INTO  S_NUMERO
    FROM DB_MANODOPERA A
    WHERE A.ID_AZIENDA=P_ID_AZIENDA
    AND A.DATA_FINE_VALIDITA IS NULL;

    S_DESCRIZIONE := 'Non è presente la dichiarazione della MANODOPERA';

    IF S_NUMERO = 0 THEN
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
             P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
        END IF;
    END IF;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE PRESENZA_MANODOPERA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END PRESENZA_MANODOPERA;

FUNCTION COERENZA_TIPO_FG (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                           P_ID_FORMA_GIURIDICA   IN      DB_ANAGRAFICA_AZIENDA.ID_FORMA_GIURIDICA%TYPE,
                           P_ID_TIPOLOGIA_AZIENDA   IN      DB_ANAGRAFICA_AZIENDA.ID_TIPOLOGIA_AZIENDA%TYPE,
                           P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                            P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                             P_MSGERR       IN OUT VARCHAR2,
                            P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_NUMERO             NUMBER;

BEGIN
     S_DESCRIZIONE := NULL;
    SELECT COUNT(*)
    INTO  S_NUMERO
    FROM DB_TIPO_FG_TIPOLOGIA
    WHERE ID_FORMA_GIURIDICA=P_ID_FORMA_GIURIDICA
    AND ID_TIPOLOGIA_AZIENDA=P_ID_TIPOLOGIA_AZIENDA;

    S_DESCRIZIONE := 'Tipo di azienda incoerente con la forma giuridica';

    IF S_NUMERO = 0 THEN
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
             P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
        END IF;
    END IF;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE COERENZA_TIPO_FG: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END COERENZA_TIPO_FG;

FUNCTION CONTROLLO_RUOLO (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                           P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                            P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                             P_MSGERR       IN OUT VARCHAR2,
                            P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_NUMERO             NUMBER;

BEGIN
     S_DESCRIZIONE := NULL;
    SELECT COUNT(*)
    INTO  S_NUMERO
    FROM DB_CONTITOLARE
    WHERE ID_AZIENDA=P_ID_AZIENDA
    AND data_fine_ruolo IS NULL AND id_ruolo=99;

    S_DESCRIZIONE := 'Sono presenti soggetti senza ruolo specificato';

    IF S_NUMERO > 0 THEN
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
             P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
        END IF;
    END IF;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLO_RUOLO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLO_RUOLO;

-- prelevata una data da DB_PARAMETRO per l'ID_PARAMETRO SRPU
-- controlla se ci sono state variazioni di titolari / deleghe
-- successive alla stessa ppure se l'azienda è stata creata dopo
-- la stessa ed in tal caso genera apposita anomalia
FUNCTION CONTROLLO_FERMO_OROLOGI (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                  P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                  P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                  P_MSGERR       IN OUT VARCHAR2,
                                  P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS
    dDataApp        DATE;
    dDataAzienda    DATE;
    S_DESCRIZIONE   DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    nCont           INTEGER:=0;
BEGIN
    -- prendo la data di appoggio per la quale effettuare i conteggi da DB_PARAMETRO
    BEGIN
        dDataApp := TO_DATE(SelectValoreParametro(kvIdParamDtFermoOrologi), 'DD/MM/YYYY');
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             -- se non c'è non eseguo il controllo
             dDataApp := NULL;
    END;

    S_DESCRIZIONE := 'Impossibile procedere con la validazione. Riprovare scegliendo una diversa motivazione di dichiarazione di consistenza';
    -- se la data è valorizzata
    IF dDataApp IS NOT NULL THEN
        -- conto se ci sono contitolari con data_inizio_ruolo maggiore di quella di appoggio
        SELECT COUNT(ID_CONTITOLARE)
          INTO nCont
          FROM DB_CONTITOLARE
         WHERE ID_AZIENDA = P_ID_AZIENDA
           AND DATA_INIZIO_RUOLO > dDataApp;
        -- se non ce ne sono conto se ci sono deleghe con data_inizio maggiore di quella di appoggio
        IF nCont = 0 THEN
           SELECT COUNT(ID_DELEGA)
             INTO nCont
             FROM DB_DELEGA
            WHERE ID_AZIENDA = P_ID_AZIENDA
              AND DATA_INIZIO > dDataApp;
        END IF;

        -- se non ce ne sono controllo se l'azienda è stata creata dopo la data di appoggio
        IF nCont = 0 THEN
           SELECT MIN(DATA_INIZIO_VALIDITA)
             INTO dDataAzienda
             FROM DB_ANAGRAFICA_AZIENDA
            WHERE ID_AZIENDA = P_ID_AZIENDA;

           IF dDataAzienda > dDataApp THEN
              nCont := 1;
           END IF;
        END IF;

        -- se una di queste select da un numero di record maggiore di zero ho anomalia e la segnalo
        IF nCont > 0 THEN
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;
    END IF;

    RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLO_FERMO_OROLOGI: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLO_FERMO_OROLOGI;


-- controllo se l'utente iride passato in input al package
-- ha dei conflitti di interesse con l'azienda per la quale sono eseguiti i controlli
-- AKA VAL04
FUNCTION UTENTE_BIRBONE (P_ID_AZIENDA       IN DB_AZIENDA.ID_AZIENDA%TYPE,
                         P_CUAA             IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                         P_ID_UTENTE_LOGIN  IN PAPUA_V_UTENTE_LOGIN.ID_UTENTE_LOGIN%TYPE, 
                         P_ID_CONTROLLO     IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                         P_BLOCCANTE        IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                         P_MSGERR       IN OUT VARCHAR2,
                         P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

  nNumConflitti  INTEGER:=0;
  nSoggAz        SIMPLE_INTEGER := 0;
BEGIN

  SELECT COUNT(UIC.ID_UTENTE_IN_CONFLITTO)
  INTO   nNumConflitti
  FROM   DB_UTENTE_IN_CONFLITTO UIC,PAPUA_V_UTENTE_LOGIN UL 
  WHERE  UL.ID_UTENTE_LOGIN             = P_ID_UTENTE_LOGIN
  AND    UL.CODICE_FISCALE_UTENTE_LOGIN = UIC.CODICE_FISCALE_UTENTE
  AND    UIC.CUAA_AZIENDA               = P_CUAA
  AND    UIC.DATA_FINE_CONFLITTO        IS NULL;

  SELECT COUNT(*)
  INTO   nSoggAz
  FROM   PAPUA_V_UTENTE_LOGIN UL,DB_CONTITOLARE C,DB_PERSONA_FISICA PF
  WHERE  UL.ID_UTENTE_LOGIN  = P_ID_UTENTE_LOGIN
  AND    C.ID_AZIENDA        = P_ID_AZIENDA
  AND    C.ID_SOGGETTO       = PF.ID_SOGGETTO
  AND    PF.CODICE_FISCALE   = UL.CODICE_FISCALE_UTENTE_LOGIN
  AND    C.DATA_FINE_RUOLO   IS NULL;

  IF nNumConflitti > 0 OR nSoggAz > 0 THEN
    IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO,
                                'Impossibile procedere alla validazione del fascicolo in quanto e'' presente un conflitto di interessi',P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
      RETURN FALSE;
    END IF;
  END IF;

  RETURN TRUE;

EXCEPTION
  WHEN OTHERS THEN
    p_MsgErr := 'ERRORE UTENTE_BIRBONE: ' || SQLERRM;
    p_CodErr := SQLCODE;
    RETURN FALSE;
END UTENTE_BIRBONE;


FUNCTION RESPONSABILE_BIRBONE (P_ID_AZIENDA       IN DB_AZIENDA.ID_AZIENDA%TYPE,
                               P_CUAA             IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                               P_ID_UTENTE_LOGIN  IN PAPUA_V_UTENTE_LOGIN.ID_UTENTE_LOGIN%TYPE, 
                               P_ID_CONTROLLO     IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                               P_BLOCCANTE        IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                               P_MSGERR       IN OUT VARCHAR2,
                               P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

    nNumConflitti INTEGER:=0;
BEGIN

    SELECT COUNT(RI.ID_RESPONSABILE_INTERMEDIARIO)
      INTO nNumConflitti
      FROM PAPUA_V_UTENTE_LOGIN UL, 
           DB_RESPONSABILE_INTERMEDIARIO RI,
           DB_INTERMEDIARIO I
     WHERE UL.ID_UTENTE_LOGIN = P_ID_UTENTE_LOGIN
       AND UL.CODICE_FISCALE_UTENTE_LOGIN = RI.CF_RESPONSABILE
       AND RI.DATA_FINE IS NULL
       AND RI.ID_PROCEDIMENTO = knIdTipoProcedimentoSMRGAA
       AND RI.ID_INTERMEDIARIO = I.ID_INTERMEDIARIO
       AND I.CODICE_FISCALE = UL.CODICE_ENTE;

    IF nNumConflitti > 0 THEN
       IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, 'Impossibile procedere alla validazione del fascicolo in quanto il soggetto che sta validando corrisponde al responsabile del procedimento : non e'' rispettata la separazione delle funzioni',P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
          RETURN (FALSE);
       END IF;
    END IF;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
         p_MsgErr   := 'ERRORE RESPONSABILE_BIRBONE: ' || SQLERRM;
         p_CodErr   := SQLCODE;
         RETURN (FALSE);
END RESPONSABILE_BIRBONE;


FUNCTION UNIVOCITA_CUAA (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                         P_CUAA            IN     DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                         P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                        P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                        P_SCRIVI_POSITIVI IN BOOLEAN,
                        P_FASE              IN DB_TIPO_CONTROLLO_FASE.FASE%TYPE,
                         P_MSGERR       IN OUT VARCHAR2,
                        P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_NUMERO             NUMBER;
VAR_BLOCCANTE       DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE:=P_BLOCCANTE;

BEGIN
     S_DESCRIZIONE := NULL;
    SELECT COUNT(*)
    INTO  S_NUMERO
    FROM DB_ANAGRAFICA_AZIENDA
    WHERE CUAA=p_cuaa
    AND DATA_FINE_VALIDITA IS NULL
    AND DATA_CESSAZIONE IS NULL
    AND ID_AZIENDA<>p_id_azienda;


    IF var_tipo_azienda<>1 AND var_tipo_azienda<>2 AND var_tipo_azienda<>3 THEN
       var_bloccante:='N';
    END IF;
    IF var_flag_provvisoria = 'S' AND p_fase<> costanteFaseInsediamento THEN
       var_bloccante:='N';
    END IF;

    IF S_NUMERO > 0 THEN
       S_DESCRIZIONE := 'Sono presenti altre aziende attive in archivio con il medesimo CUAA';

       IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
             VAR_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
       END IF;
    ELSE
       S_DESCRIZIONE := 'Il CUAA dichiarato è univoco in archivio';
       IF p_scrivi_positivi THEN
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                 'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
           END IF;
       END IF;
    END IF;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE UNIVOCITA_CUAA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END UNIVOCITA_CUAA;

FUNCTION UNIVOCITA_PIVA (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                         P_PIVA            IN     DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                         P_ID_CONTROLLO  IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                        P_BLOCCANTE        IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                        P_SCRIVI_POSITIVI IN BOOLEAN,
                        P_FASE              IN DB_TIPO_CONTROLLO_FASE.FASE%TYPE,
                         P_MSGERR        IN OUT VARCHAR2,
                        P_CODERR        IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_NUMERO             NUMBER;
VAR_BLOCCANTE       DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE:=P_BLOCCANTE;

BEGIN
     S_DESCRIZIONE := NULL;
    SELECT COUNT(*)
    INTO  S_NUMERO
    FROM DB_ANAGRAFICA_AZIENDA
    WHERE PARTITA_IVA=p_piva
    AND DATA_FINE_VALIDITA IS NULL
    AND DATA_CESSAZIONE IS NULL
    AND ID_AZIENDA <> p_id_azienda;

    IF var_tipo_azienda<>1 AND var_tipo_azienda<>2 AND var_tipo_azienda<>3 THEN
       var_bloccante:='N';
    END IF;
    IF var_flag_provvisoria = 'S' AND p_fase<> costanteFaseInsediamento THEN
       var_bloccante:='N';
    END IF;

    IF S_NUMERO > 0 THEN
       S_DESCRIZIONE := 'Sono presenti altre aziende attive in archivio con la medesima partita iva';
       IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
             VAR_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
       END IF;
    ELSE
        S_DESCRIZIONE := 'Partita iva dichiarata univoca in archivio';
        IF p_scrivi_positivi THEN
            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                 'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
           END IF;
       END IF;
    END IF;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE UNIVOCITA_PIVA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END UNIVOCITA_PIVA;

FUNCTION UNIVOCITA_RAPPLEG (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                         P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                        P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                        P_SCRIVI_POSITIVI IN BOOLEAN,
                        P_FASE              IN DB_TIPO_CONTROLLO_FASE.FASE%TYPE,
                         P_MSGERR       IN OUT VARCHAR2,
                        P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_NUMERO             NUMBER;
VAR_NOMINATIVO      VARCHAR2(200);
VAR_ID_SOGGETTO     DB_PERSONA_FISICA.Id_soggetto%TYPE;
VAR_BLOCCANTE       DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE:=P_BLOCCANTE;

BEGIN
    S_DESCRIZIONE := NULL;

    --PRENDO IL CF DEL RAPP LEGALE
    SELECT  a.ID_SOGGETTO, cognome ||' '|| nome
    INTO   VAR_ID_SOGGETTO, VAR_NOMINATIVO
    FROM DB_CONTITOLARE a, DB_PERSONA_FISICA b
    WHERE a.id_ruolo=1
    AND a.data_fine_ruolo IS NULL
    AND a.ID_AZIENDA=p_id_azienda
    AND b.id_soggetto=a.id_soggetto;

    SELECT COUNT(*)
      INTO S_NUMERO
      FROM DB_CONTITOLARE A,
           DB_ANAGRAFICA_AZIENDA B
     WHERE A.ID_SOGGETTO = VAR_ID_SOGGETTO
       AND A.ID_RUOLO=1
       AND A.DATA_FINE_RUOLO IS NULL
       AND A.ID_AZIENDA <> P_ID_AZIENDA
       AND A.ID_AZIENDA = B.ID_AZIENDA
       AND B.DATA_CESSAZIONE IS NULL
       AND B.DATA_FINE_VALIDITA IS NULL
       AND EXISTS (SELECT AA.ID_AZIENDA_AAEP
                     FROM DB_AZIENDA_AAEP AA
                    WHERE AA.CUAA = B.CUAA
                      AND AA.FLAG_PRESENTE_IN_AAEP = 'S'
                      AND AA.DATA_CESSAZIONE IS NULL); 

    IF S_NUMERO > 0 THEN
       S_DESCRIZIONE := VAR_NOMINATIVO||' risulta essere rappresentante legale di altre aziende';

       IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
             VAR_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
       END IF;
    ELSE
       S_DESCRIZIONE := VAR_NOMINATIVO||'  non risulta essere rappresentante legale di altre aziende';
       IF P_SCRIVI_POSITIVI THEN
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                 'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
           END IF;
       END IF;
   END IF;

   RETURN (TRUE);

EXCEPTION
    WHEN TOO_MANY_ROWS THEN
        S_DESCRIZIONE := 'Non è stato possibile verificare l''univocità del rappresentante legale su altre aziende';
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                 'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
        ELSE
            RETURN (TRUE);
        END IF;
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE UNIVOCITA_RAPPLEG: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END UNIVOCITA_RAPPLEG;

FUNCTION CONTROLLA_UNIVOCITA_UTE (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                            P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                           P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                            P_MSGERR       IN OUT VARCHAR2,
                           P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_NOME_COMUNE            COMUNE.DESCOM%TYPE;
S_ISTAT                    COMUNE.ISTAT_COMUNE%TYPE;
S_NUMERO                    NUMBER;

BEGIN
    S_DESCRIZIONE := '';
    BEGIN

    SELECT COMUNE, B.DESCOM, COUNT(*)
    INTO S_ISTAT, S_NOME_COMUNE, S_NUMERO
    FROM DB_UTE A, COMUNE B
    WHERE ID_AZIENDA=P_ID_AZIENDA AND A.COMUNE=B.ISTAT_COMUNE
    AND a.data_fine_attivita IS NULL
    GROUP BY COMUNE, B.DESCOM
    HAVING COUNT(*) >1;

    S_DESCRIZIONE := 'Sono state dichiarate '||s_numero||' unità produttive nel comune di '||S_NOME_COMUNE;

    IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
         P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
         RETURN (FALSE);
    END IF;

   EXCEPTION
      WHEN NO_DATA_FOUND THEN
         RETURN (TRUE);

      WHEN TOO_MANY_ROWS THEN
         S_DESCRIZIONE := 'Sono state dichiarate più unità produttive nello stesso comune';
         IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
             P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
         END IF;
   END;
   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_UNIVOCITA_UTE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLA_UNIVOCITA_UTE;

FUNCTION AZIENDA_CEDENTE (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                         P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                        P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                         P_MSGERR       IN OUT VARCHAR2,
                        P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_NUMERO             NUMBER;
var_id_azienda        DB_ANAGRAFICA_AZIENDA.id_azienda%TYPE;
var_cuaa            DB_ANAGRAFICA_AZIENDA.cuaa%TYPE;
var_denominazione    DB_ANAGRAFICA_AZIENDA.denominazione%TYPE;
var_id_fg            DB_ANAGRAFICA_AZIENDA.id_forma_giuridica%TYPE;
var_data_cessazione DB_ANAGRAFICA_AZIENDA.data_cessazione%TYPE;

BEGIN
    S_DESCRIZIONE := NULL;

        SELECT ID_AZIENDA_PROVENIENZA, CUAA, DENOMINAZIONE, ID_FORMA_GIURIDICA, DATA_CESSAZIONE
        INTO  var_id_azienda, var_cuaa, var_denominazione, var_id_fg, var_data_cessazione
        FROM DB_AZIENDA A, DB_ANAGRAFICA_AZIENDA B
        WHERE A.ID_AZIENDA = p_id_azienda
        AND A.ID_azienda_provenienza=B.ID_AZIENDA
        AND B.DATA_FINE_VALIDITA IS NULL;

        IF var_data_cessazione IS NOT NULL THEN
           S_DESCRIZIONE := 'Azienda cedente '|| var_cuaa||' - '|| var_denominazione ||' dichiarata cessata il '||TO_CHAR(var_data_cessazione,'dd/mm/yyyy');
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                 'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
           END IF;
        ELSIF var_id_fg=52 THEN
           S_DESCRIZIONE := 'Azienda cedente '|| var_cuaa||' - '|| var_denominazione ||' dichiarata come persona che non esercita più attività di impresa.';
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                 'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
           END IF;
        ELSE
           S_DESCRIZIONE := 'Azienda cedente '|| var_cuaa||' - '|| var_denominazione ||' risulta ancora attiva in archivio.';
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                 P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
           END IF;
        END IF;



    RETURN (TRUE);

EXCEPTION
    WHEN NO_DATA_FOUND THEN
        S_DESCRIZIONE := 'Nessun''azienda di provenienza';
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                 'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
           END IF;
        RETURN (TRUE);
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE AZIENDA_CEDENTE: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END AZIENDA_CEDENTE;

FUNCTION CONTROLLA_INSEDIAMENTO_GIOVANI (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                            P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                           P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                           p_AZIENDA_giovane IN OUT BOOLEAN,
                            P_MSGERR       IN OUT VARCHAR2,
                           P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
sFlagProvvisoria        DB_AZIENDA.FLAG_AZIENDA_PROVVISORIA%TYPE;
n_giovani                NUMBER;

BEGIN
     P_AZIENDA_GIOVANE := FALSE;

    /* Verifico il FlagAziendaProvvisorio sull'azienda */
    SELECT FLAG_AZIENDA_PROVVISORIA
    INTO sFlagProvvisoria
    FROM SMRGAA.DB_AZIENDA
    WHERE ID_AZIENDA=P_ID_AZIENDA;

    IF sFlagProvvisoria = 'S' THEN
       S_DESCRIZIONE := 'L''azienda risulta in fase di costituzione per insediamento giovani';
       P_AZIENDA_GIOVANE := TRUE;
       IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;
       RETURN TRUE;
    ELSE
        SELECT COUNT(*) INTO n_giovani
        FROM SMRGAA.DB_CONTITOLARE
        WHERE ID_AZIENDA=P_ID_AZIENDA AND ID_RUOLO = 10 AND DATA_FINE_RUOLO IS NULL;

        IF n_giovani > 0 THEN
            S_DESCRIZIONE := 'E'' stato dichiarato un soggetto legato all''azienda di tipo giovane insediante';
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
           END IF;
        END IF;
    END IF;
    RETURN TRUE;

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_INSEDIAMENTO_GIOVANI: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);

END CONTROLLA_INSEDIAMENTO_GIOVANI;

FUNCTION CONTROLLA_CONTENZIOSO (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                 P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                 P_MSGERR       IN OUT VARCHAR2,
                                P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS
CURSOR C_CONTENZIOSO IS
     SELECT D.SEZIONE SEZ, D.FOGLIO FOGLIO, D.PARTICELLA PART, D.SUBALTERNO SUB ,
             E.DESCOM COMU, B.DATA_CESSAZIONE DATA_CESSAZIONE, D.ID_STORICO_PARTICELLA, A.ID_CONDUZIONE_PARTICELLA
     FROM DB_CONDUZIONE_PARTICELLA A, DB_PARTICELLA B,
           DB_UTE C, DB_STORICO_PARTICELLA D, COMUNE E
     WHERE A.ID_PARTICELLA = B.ID_PARTICELLA
       AND C.ID_UTE = A.ID_UTE
       AND C.ID_AZIENDA = P_ID_AZIENDA
       AND B.ID_PARTICELLA = D.ID_PARTICELLA
       AND D.DATA_FINE_VALIDITA IS NULL
       AND B.DATA_CESSAZIONE IS NOT NULL
       AND E.ISTAT_COMUNE = D.COMUNE
       AND A.DATA_FINE_CONDUZIONE IS NULL
     GROUP BY  D.SEZIONE , D.FOGLIO , D.PARTICELLA , D.SUBALTERNO  ,
             E.DESCOM , B.DATA_CESSAZIONE, D.ID_STORICO_PARTICELLA, A.ID_CONDUZIONE_PARTICELLA;

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
s_sezione            VARCHAR2(20);
s_sub                VARCHAR2(20);
BEGIN

     S_DESCRIZIONE := NULL;

     FOR REC_CONTENZIOSO IN C_CONTENZIOSO LOOP
         SELECT DECODE(REC_CONTENZIOSO.SEZ, NULL, '', ' Sz: '|| REC_CONTENZIOSO.SEZ) INTO S_SEZIONE FROM DUAL;
        SELECT DECODE(REC_CONTENZIOSO.SUB, NULL, '', ' Sub: '|| REC_CONTENZIOSO.SUB) INTO s_sub FROM dual;
           S_DESCRIZIONE := '[' || REC_CONTENZIOSO.COMU || s_sezione ||
                        ' Fgl:' || REC_CONTENZIOSO.FOGLIO ||' Part:'||REC_CONTENZIOSO.PART ||
                     s_sub || '] è stata CESSATA il ' || TO_CHAR(REC_CONTENZIOSO.DATA_CESSAZIONE,'DD/MM/YYYY');

         IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE,
               REC_CONTENZIOSO.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
         END IF;

         IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE,
                    REC_CONTENZIOSO.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
         END IF;
     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_CONTENZIOSO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLA_CONTENZIOSO;

-- Per ciascuna conduzione attiva sul piano in lavorazione all'azienda controlla se
-- la somma della superficie utilizzata è maggiore della superficie grafica (al netto dell'applicazione della percentuale_possesso)
-- e la somma della superficie utilizzata è maggiore della superficie catastale (al netto dell'applicazione della percentuale_possesso)
-- se sono vere entrambe le condizione segnala apposita anomalia
FUNCTION SUPERO_USO (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                     P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                     P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                     P_MSGERR       IN OUT VARCHAR2,
                     P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

    CURSOR curConduzioneInSupero IS
    SELECT SP.ID_STORICO_PARTICELLA,
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           SP.SUP_CATASTALE,
           SP.SUPERFICIE_GRAFICA,
           C.DESCOM,
           CP.ID_CONDUZIONE_PARTICELLA,
           CP.PERCENTUALE_POSSESSO,
           SUM(UC.SUPERFICIE_UTILIZZATA) AS TOT_UTILIZZATA
      FROM DB_STORICO_PARTICELLA SP,
           DB_CONDUZIONE_PARTICELLA CP,
           DB_UTILIZZO_PARTICELLA UC,
           DB_UTE U,
           COMUNE C,
           DB_FOGLIO FO 
     WHERE U.ID_AZIENDA = P_ID_AZIENDA
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND U.ID_UTE = CP.ID_UTE
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_TITOLO_POSSESSO <> 5 -- asservimento
       AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
       AND CP.ID_CONDUZIONE_PARTICELLA = UC.ID_CONDUZIONE_PARTICELLA
       AND SP.DATA_FINE_VALIDITA IS NULL
       AND SP.COMUNE = C.ISTAT_COMUNE
       AND SP.PARTICELLA IS NOT NULL 
       AND SP.COMUNE = FO.COMUNE (+)
       AND SP.FOGLIO = FO.FOGLIO (+)
       AND NVL(SP.SEZIONE,'#') = NVL(FO.SEZIONE (+),'#')
       AND SP.SUP_CATASTALE > 0
       AND SP.SUPERFICIE_GRAFICA = 0
       --AND NVL(FO.FLAG_STABILIZZAZIONE,-1) <> 0 
  GROUP BY SP.ID_STORICO_PARTICELLA,
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           SP.SUP_CATASTALE,
           SP.SUPERFICIE_GRAFICA,
           C.DESCOM,
           CP.ID_CONDUZIONE_PARTICELLA,
           CP.PERCENTUALE_POSSESSO
   HAVING SUM(UC.SUPERFICIE_UTILIZZATA) > ROUND((SP.SUP_CATASTALE *  CP.PERCENTUALE_POSSESSO) / 100,4)
      AND SUM(UC.SUPERFICIE_UTILIZZATA) > ROUND((SP.SUPERFICIE_GRAFICA *  CP.PERCENTUALE_POSSESSO) / 100,4); 

    vDescAnomalia   DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
BEGIN

    FOR recConduzioneInSupero IN curConduzioneInSupero LOOP

         vDescAnomalia := '[' || recConduzioneInSupero.DESCOM || ' Sez : ' || NVL(recConduzioneInSupero.SEZIONE,'N.P.') ||' Fgl:' || recConduzioneInSupero.FOGLIO ||
                     ' Part:' || recConduzioneInSupero.PARTICELLA || ' Sub : ' || NVL(recConduzioneInSupero.SUBALTERNO,'N.P.') ||
                     '] la Sup.utilizzata: ' ||  TRIM(TO_CHAR(recConduzioneInSupero.TOT_UTILIZZATA,'999G990D9999')) ||
                     ' e'' maggiore delle superfici grafica e catastale ' || TRIM(TO_CHAR(recConduzioneInSupero.SUPERFICIE_GRAFICA,'999G990D9999')) || ' - ' || TRIM(TO_CHAR(recConduzioneInSupero.SUP_CATASTALE,'999G990D9999')) ||
                     ' al netto dell''applicazione della percentuale di possesso del ' || TO_CHAR(recConduzioneInSupero.PERCENTUALE_POSSESSO,'990D99') || '%';

         IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA,P_ID_CONTROLLO, vDescAnomalia,
                                     P_BLOCCANTE, recConduzioneInSupero.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
            RETURN FALSE;
         END IF;

         IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA,P_ID_CONTROLLO,vDescAnomalia,
                                                P_BLOCCANTE,recConduzioneInSupero.ID_CONDUZIONE_PARTICELLA,P_MSGERR,P_CODERR) THEN
            RETURN FALSE;
         END IF;
    END LOOP;

    RETURN TRUE;

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE SUPERO_USO: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END SUPERO_USO;

-- Per ciascuna particella attiva sul piano in lavorazione all'azienda controlla se
-- la somma della superficie utilizzata è maggiore della superficie grafica
FUNCTION SUPERO_SUP_GRAFICA (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                             P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                             P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                             P_MSGERR       IN OUT VARCHAR2,
                             P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

    CURSOR curParticellaInSupero IS
    SELECT SP.ID_STORICO_PARTICELLA,
           SP.ID_PARTICELLA,
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           SP.SUPERFICIE_GRAFICA,
           C.DESCOM,
           CP.PERCENTUALE_POSSESSO, 
           CP.ID_CONDUZIONE_PARTICELLA, 
           SUM(UC.SUPERFICIE_UTILIZZATA) AS TOT_UTILIZZATA
      FROM DB_STORICO_PARTICELLA SP,
           DB_CONDUZIONE_PARTICELLA CP,
           DB_UTILIZZO_PARTICELLA UC,
           DB_UTE U,
           COMUNE C,
           DB_FOGLIO FO
     WHERE U.ID_AZIENDA = P_ID_AZIENDA
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND U.ID_UTE = CP.ID_UTE
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_TITOLO_POSSESSO <> 5 -- asservimento
       AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
       AND CP.ID_CONDUZIONE_PARTICELLA = UC.ID_CONDUZIONE_PARTICELLA
       AND SP.DATA_FINE_VALIDITA IS NULL
       AND SP.COMUNE = C.ISTAT_COMUNE
       AND SP.PARTICELLA IS NOT NULL 
       AND SP.COMUNE = FO.COMUNE (+)
       AND SP.FOGLIO = FO.FOGLIO (+)
       AND NVL(SP.SEZIONE,'#') = NVL(FO.SEZIONE (+),'#')
       AND SP.SUPERFICIE_GRAFICA > 0
--       AND NVL(FO.FLAG_STABILIZZAZIONE,-1) = 0 
       AND NOT EXISTS (SELECT ID_ESITO_CONTROLLO_PARTICELLA
                         FROM DB_ESITO_CONTROLLO_PARTICELLA
                        WHERE ID_CONTROLLO IN (knIdControlloP25,knIdControlloP30)
                          AND ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA)
  GROUP BY SP.ID_STORICO_PARTICELLA,
           SP.ID_PARTICELLA,
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           SP.SUPERFICIE_GRAFICA,
           CP.ID_CONDUZIONE_PARTICELLA, 
           CP.PERCENTUALE_POSSESSO, 
           C.DESCOM
   HAVING SUM(UC.SUPERFICIE_UTILIZZATA) > ROUND((SP.SUPERFICIE_GRAFICA *  CP.PERCENTUALE_POSSESSO) / 100,4);


    vDescAnomalia   DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
BEGIN

    FOR recParticellaInSupero IN curParticellaInSupero LOOP

         vDescAnomalia := '[' || recParticellaInSupero.DESCOM || ' Sez : ' || NVL(recParticellaInSupero.SEZIONE,'N.P.') ||' Fgl:' || recParticellaInSupero.FOGLIO ||
                     ' Part:' || recParticellaInSupero.PARTICELLA || ' Sub : ' || NVL(recParticellaInSupero.SUBALTERNO,'N.P.') ||
                     '] la Sup.utilizzata: ' ||  TRIM(TO_CHAR(recParticellaInSupero.TOT_UTILIZZATA,'999G990D9999')) ||
                     ' e'' maggiore delle superficie grafica ' || TRIM(TO_CHAR(recParticellaInSupero.SUPERFICIE_GRAFICA,'999G990D9999')) ||
                     ' al netto dell''applicazione della percentuale di possesso del ' || TO_CHAR(recParticellaInSupero.PERCENTUALE_POSSESSO,'990D99') || '%';

         IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA,P_ID_CONTROLLO, vDescAnomalia,
                                     P_BLOCCANTE, recParticellaInSupero.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
            RETURN FALSE;
         END IF;

         IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA,P_ID_CONTROLLO,vDescAnomalia,
                                                P_BLOCCANTE,recParticellaInSupero.ID_CONDUZIONE_PARTICELLA,P_MSGERR,P_CODERR) THEN
            RETURN FALSE;
         END IF;

    END LOOP;

    RETURN TRUE;

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE SUPERO_SUP_GRAFICA: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END SUPERO_SUP_GRAFICA ;

FUNCTION CONTROLLA_SUPERO (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                    P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                   P_BLOCCANTE          IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                    P_MSGERR       IN OUT VARCHAR2,
                                   P_CODERR                IN OUT VARCHAR2) RETURN BOOLEAN IS

N_ID_PARTICELLA                  DB_PARTICELLA.ID_PARTICELLA%TYPE;

/* cursore che cicle su tutte le conduzioni attive della mia azienda */
CURSOR C_CONDUZIONI IS
    SELECT A.ID_PARTICELLA, NVL(SUM(B.SUPERFICIE_CONDOTTA),0) TOT_SUP_COND, A.SUP_CATASTALE, A.ID_STORICO_PARTICELLA,
    E.DESCOM, SEZIONE, FOGLIO, PARTICELLA, SUBALTERNO
    FROM DB_STORICO_PARTICELLA a, DB_CONDUZIONE_PARTICELLA b, DB_UTE c, COMUNE E
    WHERE a.id_particella = b.id_particella
      AND A.DATA_FINE_VALIDITA IS NULL
      AND c.id_ute = b.id_ute
      AND c.data_fine_attivita IS NULL
      AND c.id_azienda = P_ID_AZIENDA
--      AND b.ID_TITOLO_POSSESSO<>5
      AND b.ID_TITOLO_POSSESSO  NOT IN (5,6)
      AND B.DATA_FINE_CONDUZIONE IS NULL
      AND A.COMUNE = E.ISTAT_COMUNE
      AND A.PARTICELLA IS NOT NULL 
    GROUP BY A.ID_PARTICELLA, A.SUP_CATASTALE, A.ID_STORICO_PARTICELLA, E.DESCOM, SEZIONE, FOGLIO, PARTICELLA, SUBALTERNO;

CURSOR C_ALTRE_CONDUZIONI (pIdParticella IN DB_CONDUZIONE_DICHIARATA.ID_PARTICELLA%TYPE) IS
    SELECT /*+rule*/ NVL(SUM(E.SUPERFICIE_CONDOTTA),0) TOT_SUP_COND
    FROM DB_DICHIARAZIONE_CONSISTENZA d, DB_CONDUZIONE_DICHIARATA e,
         DB_ANAGRAFICA_AZIENDA F, DB_AZIENDA G
    WHERE E.ID_PARTICELLA=pIdParticella
      AND D.id_azienda <> P_ID_AZIENDA
      AND D.CODICE_FOTOGRAFIA_TERRENI = E.CODICE_FOTOGRAFIA_TERRENI
--      AND E.DATA_FINE_CONDUZIONE IS NULL
      AND D.ID_AZIENDA = G.ID_AZIENDA
      AND D.ID_AZIENDA = F.ID_AZIENDA
      AND F.DATA_FINE_VALIDITA IS NULL
--      AND e.ID_TITOLO_POSSESSO<>5
      AND e.ID_TITOLO_POSSESSO  NOT IN (5,6)
      AND (G.FLAG_AZIENDA_PROVVISORIA IS NULL OR G.FLAG_AZIENDA_PROVVISORIA = 'N')
      AND F.DATA_CESSAZIONE IS NULL
      AND D.ID_MOTIVO_DICHIARAZIONE <> 7
      AND d.DATA_INSERIMENTO_DICHIARAZIONE = (    SELECT MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
                                                                  FROM     DB_DICHIARAZIONE_CONSISTENZA DC,
                                                                        DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                                     WHERE DC.id_azienda = d.id_azienda
                                                                AND     (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DC.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                                                AND     DC.ID_MOTIVO_DICHIARAZIONE <> 7
                                                                AND    TI.ID_MOTIVO_DICHIARAZIONE = DC.ID_MOTIVO_DICHIARAZIONE
                                                                AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                            );
/*
CURSOR C_ALTRE_CONDUZIONI IS
    SELECT NVL(SUM(E.SUPERFICIE_CONDOTTA),0) TOT_SUP_COND
    FROM DB_DICHIARAZIONE_CONSISTENZA d, DB_CONDUZIONE_DICHIARATA e,
         DB_ANAGRAFICA_AZIENDA F, DB_AZIENDA G
    WHERE E.ID_PARTICELLA=N_ID_PARTICELLA
      AND D.id_azienda <> P_ID_AZIENDA
      AND D.CODICE_FOTOGRAFIA_TERRENI = E.CODICE_FOTOGRAFIA_TERRENI
--      AND E.DATA_FINE_CONDUZIONE IS NULL
      AND D.ID_AZIENDA = G.ID_AZIENDA
      AND D.ID_AZIENDA = F.ID_AZIENDA
      AND F.DATA_FINE_VALIDITA IS NULL
--      AND e.ID_TITOLO_POSSESSO<>5
      AND e.ID_TITOLO_POSSESSO  NOT IN (5,6)
      AND (G.FLAG_AZIENDA_PROVVISORIA IS NULL OR G.FLAG_AZIENDA_PROVVISORIA = 'N')
      AND F.DATA_CESSAZIONE IS NULL
      AND D.ID_MOTIVO_DICHIARAZIONE <> 7
      AND d.DATA_INSERIMENTO_DICHIARAZIONE = (    SELECT MAX(DATA_INSERIMENTO_DICHIARAZIONE)
                                                                  FROM     DB_DICHIARAZIONE_CONSISTENZA DC,
                                                                        DB_ANAGRAFICA_AZIENDA AA,
                                                                        DB_AZIENDA AZ,
                                                                        DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                                     WHERE AA.id_azienda = d.id_azienda
                                                                AND     (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                                                AND     AA.ID_AZIENDA = DC.ID_AZIENDA
                                                                AND     AA.DATA_FINE_VALIDITA IS NULL
                                                                AND     AA.DATA_CESSAZIONE IS NULL
                                                                AND     AA.ID_AZIENDA <> P_ID_AZIENDA
                                                                AND     AZ.ID_AZIENDA = AA.ID_AZIENDA
                                                                AND     AA.DATA_CESSAZIONE IS NULL
                                                                AND     NVL(AZ.FLAG_AZIENDA_PROVVISORIA,'N') = 'N'
                                                                AND     DC.ID_MOTIVO_DICHIARAZIONE <> 7
                                                                AND    TI.ID_MOTIVO_DICHIARAZIONE = DC.ID_MOTIVO_DICHIARAZIONE
                                                                AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                            );
*/

      /* 
      and d.ID_DICHIARAZIONE_CONSISTENZA = (select max(ID_DICHIARAZIONE_CONSISTENZA)
                                              from db_dichiarazione_consistenza DC, DB_ANAGRAFICA_AZIENDA AA, DB_AZIENDA AZ
                                                 where AA.id_azienda = d.id_azienda
                                               AND AA.ID_AZIENDA = DC.ID_AZIENDA
                                               AND AA.DATA_FINE_VALIDITA IS NULL
                                               AND AA.DATA_CESSAZIONE IS NULL
                                                   AND AA.ID_AZIENDA <> P_ID_AZIENDA
                                               AND AZ.ID_AZIENDA = AA.ID_AZIENDA
                                               AND AA.DATA_CESSAZIONE IS NULL
                                               AND NVL(AZ.FLAG_AZIENDA_PROVVISORIA,'N') = 'N'
                                               AND DC.ID_MOTIVO_DICHIARAZIONE <> 7);    */

CURSOR C_AZI_SUPERO IS
   SELECT C.CUAA, C.DENOMINAZIONE, A.SUPERFICIE_CONDOTTA, F.CODICE_FISCALE AS CAA, b.id_azienda
FROM DB_CONDUZIONE_DICHIARATA A, DB_DICHIARAZIONE_CONSISTENZA B, DB_ANAGRAFICA_AZIENDA C, DB_AZIENDA D, DB_DELEGA E, DB_INTERMEDIARIO F
WHERE A.ID_PARTICELLA = N_ID_PARTICELLA
  AND A.CODICE_FOTOGRAFIA_TERRENI = B.CODICE_FOTOGRAFIA_TERRENI
  AND C.ID_AZIENDA = B.ID_AZIENDA
  AND C.DATA_FINE_VALIDITA IS NULL
  AND C.DATA_CESSAZIONE IS NULL
  AND D.ID_AZIENDA = C.ID_AZIENDA
  AND E.ID_AZIENDA(+) = D.ID_AZIENDA
  AND E.DATA_FINE IS NULL
--  AND a.ID_TITOLO_POSSESSO<>5
  AND a.ID_TITOLO_POSSESSO  NOT IN (5,6)
  AND E.ID_PROCEDIMENTO = 7
  AND E.ID_AZIENDA IS NOT NULL
  AND F.ID_INTERMEDIARIO = E.ID_INTERMEDIARIO
  AND B.DATA_INSERIMENTO_DICHIARAZIONE = (    SELECT MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
                                                            FROM     DB_DICHIARAZIONE_CONSISTENZA DC,
                                                                    DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                            WHERE id_azienda = b.id_azienda
                                                            AND     (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DC.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                                            AND     DC.ID_MOTIVO_DICHIARAZIONE <> 7
                                                            AND    TI.ID_MOTIVO_DICHIARAZIONE = DC.ID_MOTIVO_DICHIARAZIONE
                                                            AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                                        )
  /*  
  AND B.ID_DICHIARAZIONE_CONSISTENZA = (select max(ID_DICHIARAZIONE_CONSISTENZA)
                                          from db_dichiarazione_consistenza
                                        where id_azienda = b.id_azienda
                                          AND ID_MOTIVO_DICHIARAZIONE <> 7)*/
UNION
SELECT C.CUAA, C.DENOMINAZIONE, A.SUPERFICIE_CONDOTTA, 'ASSENTE' AS CAA, b.id_azienda
FROM DB_CONDUZIONE_DICHIARATA A, DB_DICHIARAZIONE_CONSISTENZA B, DB_ANAGRAFICA_AZIENDA C, DB_AZIENDA D
WHERE A.ID_PARTICELLA = N_ID_PARTICELLA
  AND A.CODICE_FOTOGRAFIA_TERRENI = B.CODICE_FOTOGRAFIA_TERRENI
  AND C.ID_AZIENDA = B.ID_AZIENDA
  AND C.DATA_FINE_VALIDITA IS NULL
  AND C.DATA_CESSAZIONE IS NULL
  AND D.ID_AZIENDA = C.ID_AZIENDA
--  AND a.ID_TITOLO_POSSESSO <>5
  AND a.ID_TITOLO_POSSESSO  NOT IN (5,6)
  AND B.DATA_INSERIMENTO_DICHIARAZIONE = (    SELECT MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
                                                              FROM     DB_DICHIARAZIONE_CONSISTENZA DC,
                                                                    DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                            WHERE id_azienda = b.id_azienda
                                                            AND     (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DC.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                                            AND     DC.ID_MOTIVO_DICHIARAZIONE <> 7
                                                            AND    TI.ID_MOTIVO_DICHIARAZIONE = DC.ID_MOTIVO_DICHIARAZIONE
                                                            AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                                        )
  /*  
  AND B.ID_DICHIARAZIONE_CONSISTENZA = (select max(ID_DICHIARAZIONE_CONSISTENZA)
                                          from db_dichiarazione_consistenza
                                        where id_azienda = b.id_azienda
                                        and ID_MOTIVO_DICHIARAZIONE <> 7)*/
  AND NOT EXISTS (SELECT ID_AZIENDA FROM DB_DELEGA WHERE ID_AZIENDA = D.ID_AZIENDA AND DATA_FINE IS NULL AND ID_PROCEDIMENTO = 7) ;

CURSOR C_CONDUZIONI_ATTIVE IS
        SELECT ID_CONDUZIONE_PARTICELLA
        FROM DB_CONDUZIONE_PARTICELLA A, DB_UTE B
        WHERE A.DATA_FINE_CONDUZIONE IS NULL
        AND     A.ID_PARTICELLA         =     N_ID_PARTICELLA
        AND    B.DATA_FINE_ATTIVITA IS NULL
        AND     B.ID_UTE                 =     A.ID_UTE
        AND     B.ID_AZIENDA             =     P_ID_AZIENDA;

S_DESCRIZIONE                DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_DESC_AZIENDE                DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_DETENTORE_FASCICOLO    DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_CUAA                        DB_ANAGRAFICA_AZIENDA.CUAA%TYPE;
S_DENOMINAZIONE            DB_ANAGRAFICA_AZIENDA.DENOMINAZIONE%TYPE;
N_TOTALE_SUP_CONDOTTA    DB_CONDUZIONE_PARTICELLA.SUPERFICIE_CONDOTTA%TYPE;
var_differenza NUMBER(20,4);

N_LUNGHEZZA_DENOM NUMBER;
var_denominazione VARCHAR2(3000);

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_CONDUZIONI IN C_CONDUZIONI LOOP
         N_ID_PARTICELLA  := REC_CONDUZIONI.ID_PARTICELLA;
        FOR REC_ALTRE_CONDUZIONI IN C_ALTRE_CONDUZIONI (N_ID_PARTICELLA)LOOP
            IF REC_CONDUZIONI.SUP_CATASTALE < REC_CONDUZIONI.TOT_SUP_COND + REC_ALTRE_CONDUZIONI.TOT_SUP_COND THEN

                S_DESC_AZIENDE     := NULL;
                --N_TOTALE_SUP_CONDOTTA := REC_CONDUZIONI.SUP_TOTALE;
                IF REC_CONDUZIONI.SEZIONE IS NULL THEN
                   IF REC_CONDUZIONI.SUBALTERNO IS NULL THEN
                         S_DESCRIZIONE := '[' || REC_CONDUZIONI.DESCOM ||' Fgl:' || REC_CONDUZIONI.FOGLIO ||
                       ' Part:' || REC_CONDUZIONI.PARTICELLA || '] Sup.cat.: '||
                       TRIM(TO_CHAR(NVL(REC_CONDUZIONI.SUP_CATASTALE,0),'999G990D9999')) || ' (ha). ';
                   ELSE
                         S_DESCRIZIONE := '[' || REC_CONDUZIONI.DESCOM ||' Fgl:' || REC_CONDUZIONI.FOGLIO ||
                          ' Part:' || REC_CONDUZIONI.PARTICELLA || ' Sub:' || REC_CONDUZIONI.SUBALTERNO ||
                        '] Sup.cat.: '|| TRIM(TO_CHAR(NVL(REC_CONDUZIONI.SUP_CATASTALE,0),'999G990D9999')) || ' (ha). ';
                   END IF;
                ELSE
                   IF REC_CONDUZIONI.SUBALTERNO IS NULL THEN
                         S_DESCRIZIONE := '[' || REC_CONDUZIONI.DESCOM || ' Sz:' || REC_CONDUZIONI.SEZIONE ||
                        ' Fgl:' || REC_CONDUZIONI.FOGLIO ||' Part:' || REC_CONDUZIONI.PARTICELLA ||
                        '] Sup.cat.: '|| TRIM(TO_CHAR(NVL(REC_CONDUZIONI.SUP_CATASTALE,0),'999G990D9999')) || ' (ha). ';
                   ELSE
                         S_DESCRIZIONE := '[' || REC_CONDUZIONI.DESCOM ||' Sz:' || REC_CONDUZIONI.SEZIONE ||
                          ' Fgl:' || REC_CONDUZIONI.FOGLIO ||' Part:' || REC_CONDUZIONI.PARTICELLA ||
                        ' Sub:' || REC_CONDUZIONI.SUBALTERNO || '] Sup.cat.: '||
                        TRIM(TO_CHAR(NVL(REC_CONDUZIONI.SUP_CATASTALE,0),'999G990D9999')) || ' (ha). ';
                   END IF;
                END IF;
                FOR REC_AZI_SUPERO IN C_AZI_SUPERO LOOP
                      N_LUNGHEZZA_DENOM := LENGTH(REC_AZI_SUPERO.DENOMINAZIONE);
                      IF  LENGTH(REC_AZI_SUPERO.DENOMINAZIONE) > 50 THEN
                          VAR_DENOMINAZIONE :=  SUBSTR(REC_AZI_SUPERO.DENOMINAZIONE,1,50);
                      ELSE
                            VAR_DENOMINAZIONE :=  REC_AZI_SUPERO.DENOMINAZIONE;
                      END IF;
                      S_DETENTORE_FASCICOLO :='(CAA: '||REC_AZI_SUPERO.CAA||')';
                      IF REC_AZI_SUPERO.ID_AZIENDA <> P_ID_AZIENDA THEN
                          -- SOMMO LE SUPERFICI CONDOTTE DELLE AZIENDE ATTIVE CHE HANNO DICHIARATO QUELLA PARTICELLA
                          S_DESC_AZIENDE := S_DESC_AZIENDE     || ' Azienda: '||  REC_AZI_SUPERO.CUAA||'-'||VAR_DENOMINAZIONE ||
                                                S_DETENTORE_FASCICOLO
                                              ||' conduce '||TRIM(TO_CHAR(NVL(REC_AZI_SUPERO.SUPERFICIE_CONDOTTA,0),'999G990D9999')) ||' ha. ';
                      ELSE
                          S_DESC_AZIENDE := S_DESC_AZIENDE     || ' Azienda: '||  REC_AZI_SUPERO.CUAA||'-'||VAR_DENOMINAZIONE ||
                                                S_DETENTORE_FASCICOLO ||' conduce '||TRIM(TO_CHAR(NVL(REC_CONDUZIONI.TOT_SUP_COND,0),'999G990D9999')) ||' ha. ';

                      END IF;
                END LOOP;

                S_DESCRIZIONE := S_DESCRIZIONE || ' ' ||S_DESC_AZIENDE;
                IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, p_bloccante,
                          REC_CONDUZIONI.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
                END IF;

                FOR REC_CONDUZIONI_ATTIVE IN C_CONDUZIONI_ATTIVE LOOP
                    IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, p_bloccante,
                              REC_CONDUZIONI_ATTIVE.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                       RETURN (FALSE);
                    END IF;
                END LOOP;
            END IF;
        END LOOP;
     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_SUPERO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLA_SUPERO;

-- Verifica per ogni particella in conduzione all'azienda che la percentuale di possesso
-- totale della particella non sfori il 100% (considerando eventualmente anche le altre aziende
-- se la particella è condivisa)
FUNCTION SUPERO_PERCENTUALE_FASCICOLI  (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                        P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                        P_MSGERR       IN OUT VARCHAR2,
                                        P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

N_ID_PARTICELLA                  DB_PARTICELLA.ID_PARTICELLA%TYPE;

/* cursore che cicle su tutte le conduzioni attive della mia azienda */
    CURSOR C_CONDUZIONI IS
    SELECT A.ID_PARTICELLA, SUM(B.PERCENTUALE_POSSESSO) AS PERC_AZIENDA, A.ID_STORICO_PARTICELLA, E.DESCOM, SEZIONE, FOGLIO, PARTICELLA, SUBALTERNO
      FROM DB_STORICO_PARTICELLA a, DB_CONDUZIONE_PARTICELLA b, DB_UTE c, COMUNE E
    WHERE a.id_particella = b.id_particella
      AND A.DATA_FINE_VALIDITA IS NULL
      AND c.id_ute = b.id_ute
      AND c.data_fine_attivita IS NULL
      AND c.id_azienda = P_ID_AZIENDA
      AND b.ID_TITOLO_POSSESSO  NOT IN (5,6)
      AND B.DATA_FINE_CONDUZIONE IS NULL
      AND A.COMUNE = E.ISTAT_COMUNE
    GROUP BY A.ID_PARTICELLA, A.ID_STORICO_PARTICELLA, E.DESCOM, SEZIONE, FOGLIO, PARTICELLA, SUBALTERNO;

CURSOR C_AZI_SUPERO IS
   SELECT C.CUAA, C.DENOMINAZIONE, A.PERCENTUALE_POSSESSO, F.CODICE_FISCALE AS CAA, b.id_azienda
FROM DB_CONDUZIONE_DICHIARATA A, DB_DICHIARAZIONE_CONSISTENZA B, DB_ANAGRAFICA_AZIENDA C, DB_AZIENDA D, DB_DELEGA E, DB_INTERMEDIARIO F
WHERE A.ID_PARTICELLA = N_ID_PARTICELLA
  AND A.CODICE_FOTOGRAFIA_TERRENI = B.CODICE_FOTOGRAFIA_TERRENI
  AND C.ID_AZIENDA = B.ID_AZIENDA
  AND B.ID_AZIENDA <> P_ID_AZIENDA
  AND C.DATA_FINE_VALIDITA IS NULL
  AND C.DATA_CESSAZIONE IS NULL
  AND D.ID_AZIENDA = C.ID_AZIENDA
  AND E.ID_AZIENDA(+) = D.ID_AZIENDA
  AND E.DATA_FINE IS NULL
--  AND a.ID_TITOLO_POSSESSO<>5
  AND a.ID_TITOLO_POSSESSO  NOT IN (5,6)
  AND E.ID_PROCEDIMENTO = 7
  AND E.ID_AZIENDA IS NOT NULL
  AND F.ID_INTERMEDIARIO = E.ID_INTERMEDIARIO
  AND B.DATA_INSERIMENTO_DICHIARAZIONE = (    SELECT MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
                                                            FROM     DB_DICHIARAZIONE_CONSISTENZA DC,
                                                                    DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                            WHERE id_azienda = b.id_azienda
                                                            AND     (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DC.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                                            AND     DC.ID_MOTIVO_DICHIARAZIONE <> 7
                                                            AND    TI.ID_MOTIVO_DICHIARAZIONE = DC.ID_MOTIVO_DICHIARAZIONE
                                                            AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                                        )
UNION
SELECT C.CUAA, C.DENOMINAZIONE, A.PERCENTUALE_POSSESSO, 'ASSENTE' AS CAA, b.id_azienda
FROM DB_CONDUZIONE_DICHIARATA A, DB_DICHIARAZIONE_CONSISTENZA B, DB_ANAGRAFICA_AZIENDA C, DB_AZIENDA D
WHERE A.ID_PARTICELLA = N_ID_PARTICELLA
  AND B.ID_AZIENDA <> P_ID_AZIENDA
  AND A.CODICE_FOTOGRAFIA_TERRENI = B.CODICE_FOTOGRAFIA_TERRENI
  AND C.ID_AZIENDA = B.ID_AZIENDA
  AND C.DATA_FINE_VALIDITA IS NULL
  AND C.DATA_CESSAZIONE IS NULL
  AND D.ID_AZIENDA = C.ID_AZIENDA
--  AND a.ID_TITOLO_POSSESSO <>5
  AND a.ID_TITOLO_POSSESSO  NOT IN (5,6)
  AND B.DATA_INSERIMENTO_DICHIARAZIONE = (    SELECT MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
                                                              FROM     DB_DICHIARAZIONE_CONSISTENZA DC,
                                                                    DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                            WHERE id_azienda = b.id_azienda
                                                            AND     (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DC.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                                            AND     DC.ID_MOTIVO_DICHIARAZIONE <> 7
                                                            AND    TI.ID_MOTIVO_DICHIARAZIONE = DC.ID_MOTIVO_DICHIARAZIONE
                                                            AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                                        )
  AND NOT EXISTS (SELECT ID_AZIENDA FROM DB_DELEGA WHERE ID_AZIENDA = D.ID_AZIENDA AND DATA_FINE IS NULL AND ID_PROCEDIMENTO = 7) ;

CURSOR C_CONDUZIONI_ATTIVE IS
        SELECT ID_CONDUZIONE_PARTICELLA
        FROM DB_CONDUZIONE_PARTICELLA A, DB_UTE B
        WHERE A.DATA_FINE_CONDUZIONE IS NULL
        AND     A.ID_PARTICELLA         =     N_ID_PARTICELLA
        AND    B.DATA_FINE_ATTIVITA IS NULL
        AND     B.ID_UTE                 =     A.ID_UTE
        AND     B.ID_AZIENDA             =     P_ID_AZIENDA;

vDescAnomalia         DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_DESC_AZIENDE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_DETENTORE_FASCICOLO DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_CUAA                DB_ANAGRAFICA_AZIENDA.CUAA%TYPE;
S_DENOMINAZIONE       DB_ANAGRAFICA_AZIENDA.DENOMINAZIONE%TYPE;
N_TOTALE_SUP_CONDOTTA DB_CONDUZIONE_PARTICELLA.SUPERFICIE_CONDOTTA%TYPE;
var_differenza        NUMBER(20,4);

N_LUNGHEZZA_DENOM     NUMBER;
var_denominazione     VARCHAR2(3000);
nTotPercAltreAziende  NUMBER(10,2); 

BEGIN
    vDescAnomalia := NULL;

    FOR REC_CONDUZIONI IN C_CONDUZIONI LOOP
        N_ID_PARTICELLA  := REC_CONDUZIONI.ID_PARTICELLA;
        vDescAnomalia := NULL;


        SELECT /*+rule*/ NVL(SUM(E.PERCENTUALE_POSSESSO),0)
          INTO nTotPercAltreAziende
          FROM DB_DICHIARAZIONE_CONSISTENZA d,
               DB_CONDUZIONE_DICHIARATA e,
               DB_ANAGRAFICA_AZIENDA F, DB_AZIENDA G
         WHERE E.ID_PARTICELLA = N_ID_PARTICELLA
           AND D.id_azienda <> P_ID_AZIENDA
           AND D.CODICE_FOTOGRAFIA_TERRENI = E.CODICE_FOTOGRAFIA_TERRENI
           AND D.ID_AZIENDA = G.ID_AZIENDA
           AND D.ID_AZIENDA = F.ID_AZIENDA
           AND F.DATA_FINE_VALIDITA IS NULL
           AND E.ID_TITOLO_POSSESSO  NOT IN (5,6)
           AND (G.FLAG_AZIENDA_PROVVISORIA IS NULL OR G.FLAG_AZIENDA_PROVVISORIA = 'N')
           AND F.DATA_CESSAZIONE IS NULL
           AND D.ID_MOTIVO_DICHIARAZIONE <> 7
           AND D.DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
                                                     FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                                                          DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                    WHERE DC.ID_AZIENDA = D.ID_AZIENDA
                                                      AND (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DC.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                                      AND DC.ID_MOTIVO_DICHIARAZIONE <> 7
                                                      AND TI.ID_MOTIVO_DICHIARAZIONE = DC.ID_MOTIVO_DICHIARAZIONE
                                                      AND TI.TIPO_DICHIARAZIONE != 'C');


        IF REC_CONDUZIONI.PERC_AZIENDA +
           nTotPercAltreAziende > 100 THEN

             AccodaMessaggio (vDescAnomalia,
                              '[' || REC_CONDUZIONI.DESCOM || ' Sez : ' || NVL(REC_CONDUZIONI.SEZIONE,'N.P.') ||' Fgl:' || REC_CONDUZIONI.FOGLIO ||
                               ' Part:' || REC_CONDUZIONI.PARTICELLA || ' Sub : ' || NVL(REC_CONDUZIONI.SUBALTERNO,'N.P.') ||
                               '] - supero percentuale conduzione tra fascicoli , percentuale condotta azienda : ' || TRIM(TO_CHAR(REC_CONDUZIONI.PERC_AZIENDA,'990D99'))); 


             IF nTotPercAltreAziende > 0 THEN
                AccodaMessaggio (vDescAnomalia , ' Altre aziende :');

                FOR REC_AZI_SUPERO IN C_AZI_SUPERO LOOP
                    N_LUNGHEZZA_DENOM := LENGTH(REC_AZI_SUPERO.DENOMINAZIONE);
                    IF LENGTH(REC_AZI_SUPERO.DENOMINAZIONE) > 50 THEN
                       VAR_DENOMINAZIONE :=  SUBSTR(REC_AZI_SUPERO.DENOMINAZIONE,1,50);
                    ELSE
                       VAR_DENOMINAZIONE :=  REC_AZI_SUPERO.DENOMINAZIONE;
                    END IF;
                    S_DETENTORE_FASCICOLO :='(CAA: '||REC_AZI_SUPERO.CAA||')';
                    IF REC_AZI_SUPERO.ID_AZIENDA <> P_ID_AZIENDA THEN
                       -- SOMMO LE SUPERFICI CONDOTTE DELLE AZIENDE ATTIVE CHE HANNO DICHIARATO QUELLA PARTICELLA
                       AccodaMessaggio (vDescAnomalia ,' Azienda: '||  REC_AZI_SUPERO.CUAA||'-'||VAR_DENOMINAZIONE ||
                                        S_DETENTORE_FASCICOLO ||' percentuale condotta : '||TRIM(TO_CHAR(NVL(REC_AZI_SUPERO.PERCENTUALE_POSSESSO,0),'990D99')));
                    ELSE
                       AccodaMessaggio (vDescAnomalia , ' Azienda: '||  REC_AZI_SUPERO.CUAA||'-'||VAR_DENOMINAZIONE ||
                                        S_DETENTORE_FASCICOLO ||' percentuale condotta : '||TRIM(TO_CHAR(NVL(REC_AZI_SUPERO.PERCENTUALE_POSSESSO,0),'990D99')));

                    END IF;
                END LOOP;

            END IF;


            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia, p_bloccante,
                                        REC_CONDUZIONI.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;

            FOR REC_CONDUZIONI_ATTIVE IN C_CONDUZIONI_ATTIVE LOOP
                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia, p_bloccante,
                                                       REC_CONDUZIONI_ATTIVE.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                   RETURN (FALSE);
                END IF;
            END LOOP;
        END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE SUPERO_PERCENTUALE_FASCICOLI : ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END SUPERO_PERCENTUALE_FASCICOLI;


-- Verifica per ogni particella in conduzione all'azienda con annessa unità vitata
-- che la percentuale di possesso totale della particella non sfori il 100%
--(considerando eventualmente anche le altre aziende se la particella è condivisa)
FUNCTION SUPERO_PERC_FASCICOLI_VITICOLI  (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                          P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                          P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                          P_MSGERR       IN OUT VARCHAR2,
                                          P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

N_ID_PARTICELLA                  DB_PARTICELLA.ID_PARTICELLA%TYPE;

    /* cursore che cicle su tutte le conduzioni attive della mia azienda
       che hanno associata almeno un U.V. attiva */
    CURSOR C_CONDUZIONI IS
    SELECT A.ID_PARTICELLA, SUM(B.PERCENTUALE_POSSESSO) AS PERC_AZIENDA, A.ID_STORICO_PARTICELLA, E.DESCOM, SEZIONE, FOGLIO, PARTICELLA, SUBALTERNO
      FROM DB_STORICO_PARTICELLA a, DB_CONDUZIONE_PARTICELLA b, DB_UTE c, COMUNE E
    WHERE a.id_particella = b.id_particella
      AND A.DATA_FINE_VALIDITA IS NULL
      AND c.id_ute = b.id_ute
      AND c.data_fine_attivita IS NULL
      AND c.id_azienda = P_ID_AZIENDA
      AND b.ID_TITOLO_POSSESSO  NOT IN (5,6)
      AND B.DATA_FINE_CONDUZIONE IS NULL
      AND A.COMUNE = E.ISTAT_COMUNE
      AND EXISTS (SELECT SUA.ID_STORICO_UNITA_ARBOREA
                    FROM DB_STORICO_UNITA_ARBOREA SUA
                   WHERE SUA.ID_AZIENDA = P_ID_AZIENDA
                     AND SUA.ID_PARTICELLA = B.ID_PARTICELLA
                     AND SUA.DATA_FINE_VALIDITA IS NULL)
    GROUP BY A.ID_PARTICELLA, A.ID_STORICO_PARTICELLA, E.DESCOM, SEZIONE, FOGLIO, PARTICELLA, SUBALTERNO;

CURSOR C_AZI_SUPERO IS
   SELECT C.CUAA, C.DENOMINAZIONE, A.PERCENTUALE_POSSESSO, F.CODICE_FISCALE AS CAA, b.id_azienda
FROM DB_CONDUZIONE_DICHIARATA A, DB_DICHIARAZIONE_CONSISTENZA B, DB_ANAGRAFICA_AZIENDA C, DB_AZIENDA D, DB_DELEGA E, DB_INTERMEDIARIO F
WHERE A.ID_PARTICELLA = N_ID_PARTICELLA
  AND A.CODICE_FOTOGRAFIA_TERRENI = B.CODICE_FOTOGRAFIA_TERRENI
  AND C.ID_AZIENDA = B.ID_AZIENDA
  AND B.ID_AZIENDA <> P_ID_AZIENDA
  AND C.DATA_FINE_VALIDITA IS NULL
  AND C.DATA_CESSAZIONE IS NULL
  AND D.ID_AZIENDA = C.ID_AZIENDA
  AND E.ID_AZIENDA(+) = D.ID_AZIENDA
  AND E.DATA_FINE IS NULL
--  AND a.ID_TITOLO_POSSESSO<>5
  AND a.ID_TITOLO_POSSESSO  NOT IN (5,6)
  AND E.ID_PROCEDIMENTO = 7
  AND E.ID_AZIENDA IS NOT NULL
  AND F.ID_INTERMEDIARIO = E.ID_INTERMEDIARIO
  AND B.DATA_INSERIMENTO_DICHIARAZIONE = (    SELECT MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
                                                            FROM     DB_DICHIARAZIONE_CONSISTENZA DC,
                                                                    DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                            WHERE id_azienda = b.id_azienda
                                                            AND     (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DC.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                                            AND     DC.ID_MOTIVO_DICHIARAZIONE <> 7
                                                            AND    TI.ID_MOTIVO_DICHIARAZIONE = DC.ID_MOTIVO_DICHIARAZIONE
                                                            AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                                        )
UNION
SELECT C.CUAA, C.DENOMINAZIONE, A.PERCENTUALE_POSSESSO, 'ASSENTE' AS CAA, b.id_azienda
FROM DB_CONDUZIONE_DICHIARATA A, DB_DICHIARAZIONE_CONSISTENZA B, DB_ANAGRAFICA_AZIENDA C, DB_AZIENDA D
WHERE A.ID_PARTICELLA = N_ID_PARTICELLA
  AND B.ID_AZIENDA <> P_ID_AZIENDA
  AND A.CODICE_FOTOGRAFIA_TERRENI = B.CODICE_FOTOGRAFIA_TERRENI
  AND C.ID_AZIENDA = B.ID_AZIENDA
  AND C.DATA_FINE_VALIDITA IS NULL
  AND C.DATA_CESSAZIONE IS NULL
  AND D.ID_AZIENDA = C.ID_AZIENDA
--  AND a.ID_TITOLO_POSSESSO <>5
  AND a.ID_TITOLO_POSSESSO  NOT IN (5,6)
  AND B.DATA_INSERIMENTO_DICHIARAZIONE = (    SELECT MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
                                                              FROM     DB_DICHIARAZIONE_CONSISTENZA DC,
                                                                    DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                            WHERE id_azienda = b.id_azienda
                                                            AND     (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DC.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                                            AND     DC.ID_MOTIVO_DICHIARAZIONE <> 7
                                                            AND    TI.ID_MOTIVO_DICHIARAZIONE = DC.ID_MOTIVO_DICHIARAZIONE
                                                            AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                                        )
  AND NOT EXISTS (SELECT ID_AZIENDA FROM DB_DELEGA WHERE ID_AZIENDA = D.ID_AZIENDA AND DATA_FINE IS NULL AND ID_PROCEDIMENTO = 7) ;

CURSOR C_CONDUZIONI_ATTIVE IS
        SELECT ID_CONDUZIONE_PARTICELLA
        FROM DB_CONDUZIONE_PARTICELLA A, DB_UTE B
        WHERE A.DATA_FINE_CONDUZIONE IS NULL
        AND     A.ID_PARTICELLA         =     N_ID_PARTICELLA
        AND    B.DATA_FINE_ATTIVITA IS NULL
        AND     B.ID_UTE                 =     A.ID_UTE
        AND     B.ID_AZIENDA             =     P_ID_AZIENDA;

vDescAnomalia         DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_DESC_AZIENDE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_DETENTORE_FASCICOLO DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_CUAA                DB_ANAGRAFICA_AZIENDA.CUAA%TYPE;
S_DENOMINAZIONE       DB_ANAGRAFICA_AZIENDA.DENOMINAZIONE%TYPE;
N_TOTALE_SUP_CONDOTTA DB_CONDUZIONE_PARTICELLA.SUPERFICIE_CONDOTTA%TYPE;
var_differenza        NUMBER(20,4);

N_LUNGHEZZA_DENOM     NUMBER;
var_denominazione     VARCHAR2(3000);
nTotPercAltreAziende  NUMBER(10,2); 

BEGIN
    vDescAnomalia := NULL;

    FOR REC_CONDUZIONI IN C_CONDUZIONI LOOP
        N_ID_PARTICELLA  := REC_CONDUZIONI.ID_PARTICELLA;

        SELECT /*+rule*/ NVL(SUM(E.PERCENTUALE_POSSESSO),0)
          INTO nTotPercAltreAziende
          FROM DB_DICHIARAZIONE_CONSISTENZA d,
               DB_CONDUZIONE_DICHIARATA e,
               DB_ANAGRAFICA_AZIENDA F, DB_AZIENDA G
         WHERE E.ID_PARTICELLA = N_ID_PARTICELLA
           AND D.id_azienda <> P_ID_AZIENDA
           AND D.CODICE_FOTOGRAFIA_TERRENI = E.CODICE_FOTOGRAFIA_TERRENI
           AND D.ID_AZIENDA = G.ID_AZIENDA
           AND D.ID_AZIENDA = F.ID_AZIENDA
           AND F.DATA_FINE_VALIDITA IS NULL
           AND E.ID_TITOLO_POSSESSO  NOT IN (5,6)
           AND (G.FLAG_AZIENDA_PROVVISORIA IS NULL OR G.FLAG_AZIENDA_PROVVISORIA = 'N')
           AND F.DATA_CESSAZIONE IS NULL
           AND D.ID_MOTIVO_DICHIARAZIONE <> 7
           AND D.DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
                                                     FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                                                          DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                    WHERE DC.ID_AZIENDA = D.ID_AZIENDA
                                                      AND (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DC.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                                      AND DC.ID_MOTIVO_DICHIARAZIONE <> 7
                                                      AND TI.ID_MOTIVO_DICHIARAZIONE = DC.ID_MOTIVO_DICHIARAZIONE
                                                      AND TI.TIPO_DICHIARAZIONE != 'C');


        IF REC_CONDUZIONI.PERC_AZIENDA +
           nTotPercAltreAziende > 100 THEN

             vDescAnomalia := '[' || REC_CONDUZIONI.DESCOM || ' Sez : ' || NVL(REC_CONDUZIONI.SEZIONE,'N.P.') ||' Fgl:' || REC_CONDUZIONI.FOGLIO ||
                               ' Part:' || REC_CONDUZIONI.PARTICELLA || ' Sub : ' || NVL(REC_CONDUZIONI.SUBALTERNO,'N.P.') ||
                               '] - supero percentuale conduzione tra fascicoli , percentuale condotta azienda : ' || TRIM(TO_CHAR(REC_CONDUZIONI.PERC_AZIENDA,'990D99')); 


             IF nTotPercAltreAziende > 0 THEN
                vDescAnomalia := vDescAnomalia || ' Altre aziende :';
                FOR REC_AZI_SUPERO IN C_AZI_SUPERO LOOP
                    N_LUNGHEZZA_DENOM := LENGTH(REC_AZI_SUPERO.DENOMINAZIONE);
                    IF LENGTH(REC_AZI_SUPERO.DENOMINAZIONE) > 50 THEN
                       VAR_DENOMINAZIONE :=  SUBSTR(REC_AZI_SUPERO.DENOMINAZIONE,1,50);
                    ELSE
                       VAR_DENOMINAZIONE :=  REC_AZI_SUPERO.DENOMINAZIONE;
                    END IF;
                    S_DETENTORE_FASCICOLO :='(CAA: '||REC_AZI_SUPERO.CAA||')';
                    IF REC_AZI_SUPERO.ID_AZIENDA <> P_ID_AZIENDA THEN
                       -- SOMMO LE SUPERFICI CONDOTTE DELLE AZIENDE ATTIVE CHE HANNO DICHIARATO QUELLA PARTICELLA
                       vDescAnomalia := vDescAnomalia || ' Azienda: '||  REC_AZI_SUPERO.CUAA||'-'||VAR_DENOMINAZIONE ||
                                        S_DETENTORE_FASCICOLO ||' percentuale condotta : '||TRIM(TO_CHAR(NVL(REC_AZI_SUPERO.PERCENTUALE_POSSESSO,0),'990D99'));
                    ELSE
                       vDescAnomalia := vDescAnomalia     || ' Azienda: '||  REC_AZI_SUPERO.CUAA||'-'||VAR_DENOMINAZIONE ||
                                        S_DETENTORE_FASCICOLO ||' percentuale condotta : '||TRIM(TO_CHAR(NVL(REC_AZI_SUPERO.PERCENTUALE_POSSESSO,0),'990D99'));

                    END IF;
                END LOOP;
            END IF;

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia, p_bloccante,
                                        REC_CONDUZIONI.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;

            FOR REC_CONDUZIONI_ATTIVE IN C_CONDUZIONI_ATTIVE LOOP
                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia, p_bloccante,
                                                       REC_CONDUZIONI_ATTIVE.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                   RETURN (FALSE);
                END IF;
            END LOOP;
        END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE SUPERO_PERC_FASCICOLI_VITICOLI : ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END SUPERO_PERC_FASCICOLI_VITICOLI;


-- Verifica per ogni particella in conduzione all'azienda che la superficie utilizzata totale
-- sommata all'eventuale superficie utilizzata totale di altre aziende, se la particella è condivisa,
-- non superi la massima tra la superficie catastale e quella grafica
FUNCTION SUPERO_TRA_AZIENDE  (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                              P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                              P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                              P_MSGERR       IN OUT VARCHAR2,
                              P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

N_ID_PARTICELLA                  DB_PARTICELLA.ID_PARTICELLA%TYPE;

    /* cursore che cicle su tutte le particelle attive della mia azienda sommando la superficie
    utilizzata ed estraendo la massima tra la superficie grafica e la superficie catastale */
    CURSOR curParticelleAzienda IS
    SELECT A.ID_PARTICELLA, A.ID_STORICO_PARTICELLA, E.DESCOM, SEZIONE, FOGLIO, PARTICELLA, SUBALTERNO,
           SUM(UP.SUPERFICIE_UTILIZZATA) AS TOT_UTILIZZATA,
           GREATEST(MAX(A.SUP_CATASTALE),MAX(A.SUPERFICIE_GRAFICA)) AS SUP_MASSIMA
      FROM DB_STORICO_PARTICELLA a, DB_CONDUZIONE_PARTICELLA b, DB_UTE c, COMUNE E,
           DB_UTILIZZO_PARTICELLA UP
    WHERE a.id_particella = b.id_particella
      AND A.DATA_FINE_VALIDITA IS NULL
      AND c.id_ute = b.id_ute
      AND c.data_fine_attivita IS NULL
      AND c.id_azienda = P_ID_AZIENDA
      AND b.ID_TITOLO_POSSESSO  NOT IN (5,6)
      AND B.DATA_FINE_CONDUZIONE IS NULL
      AND A.COMUNE = E.ISTAT_COMUNE
      AND A.PARTICELLA IS NOT NULL 
      AND B.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
    GROUP BY A.ID_PARTICELLA, A.ID_STORICO_PARTICELLA, E.DESCOM, SEZIONE, FOGLIO, PARTICELLA, SUBALTERNO;

-- cursore che mi estrae le altre aziende che conducono
-- la particella in questione sia che abbiano la delega (1 select in union che senza 2 select in union)
CURSOR C_AZI_SUPERO IS
   SELECT C.CUAA, C.DENOMINAZIONE, F.CODICE_FISCALE AS CAA
FROM DB_CONDUZIONE_DICHIARATA A, DB_DICHIARAZIONE_CONSISTENZA B, DB_ANAGRAFICA_AZIENDA C, DB_AZIENDA D, DB_DELEGA E, DB_INTERMEDIARIO F
WHERE A.ID_PARTICELLA = N_ID_PARTICELLA
  AND A.CODICE_FOTOGRAFIA_TERRENI = B.CODICE_FOTOGRAFIA_TERRENI
  AND C.ID_AZIENDA = B.ID_AZIENDA
  AND B.ID_AZIENDA <> P_ID_AZIENDA
  AND C.DATA_FINE_VALIDITA IS NULL
  AND C.DATA_CESSAZIONE IS NULL
  AND D.ID_AZIENDA = C.ID_AZIENDA
  AND E.ID_AZIENDA(+) = D.ID_AZIENDA
  AND E.DATA_FINE IS NULL
--  AND a.ID_TITOLO_POSSESSO<>5
  AND a.ID_TITOLO_POSSESSO  NOT IN (5,6)
  AND E.ID_PROCEDIMENTO = 7
  AND E.ID_AZIENDA IS NOT NULL
  AND F.ID_INTERMEDIARIO = E.ID_INTERMEDIARIO
  AND B.DATA_INSERIMENTO_DICHIARAZIONE = (    SELECT MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
                                                            FROM     DB_DICHIARAZIONE_CONSISTENZA DC,
                                                                    DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                            WHERE id_azienda = b.id_azienda
                                                            AND     (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DC.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                                            AND     DC.ID_MOTIVO_DICHIARAZIONE <> 7
                                                            AND    TI.ID_MOTIVO_DICHIARAZIONE = DC.ID_MOTIVO_DICHIARAZIONE
                                                            AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                                        )
UNION
SELECT C.CUAA, C.DENOMINAZIONE, 'ASSENTE' AS CAA
FROM DB_CONDUZIONE_DICHIARATA A, DB_DICHIARAZIONE_CONSISTENZA B, DB_ANAGRAFICA_AZIENDA C, DB_AZIENDA D
WHERE A.ID_PARTICELLA = N_ID_PARTICELLA
  AND B.ID_AZIENDA <> P_ID_AZIENDA
  AND A.CODICE_FOTOGRAFIA_TERRENI = B.CODICE_FOTOGRAFIA_TERRENI
  AND C.ID_AZIENDA = B.ID_AZIENDA
  AND C.DATA_FINE_VALIDITA IS NULL
  AND C.DATA_CESSAZIONE IS NULL
  AND D.ID_AZIENDA = C.ID_AZIENDA
--  AND a.ID_TITOLO_POSSESSO <>5
  AND a.ID_TITOLO_POSSESSO  NOT IN (5,6)
  AND B.DATA_INSERIMENTO_DICHIARAZIONE = (    SELECT MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
                                                              FROM     DB_DICHIARAZIONE_CONSISTENZA DC,
                                                                    DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                            WHERE id_azienda = b.id_azienda
                                                            AND     (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DC.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                                            AND     DC.ID_MOTIVO_DICHIARAZIONE <> 7
                                                            AND    TI.ID_MOTIVO_DICHIARAZIONE = DC.ID_MOTIVO_DICHIARAZIONE
                                                            AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                                        )
  AND NOT EXISTS (SELECT ID_AZIENDA FROM DB_DELEGA WHERE ID_AZIENDA = D.ID_AZIENDA AND DATA_FINE IS NULL AND ID_PROCEDIMENTO = 7) ;

CURSOR C_CONDUZIONI_ATTIVE IS
        SELECT ID_CONDUZIONE_PARTICELLA
        FROM DB_CONDUZIONE_PARTICELLA A, DB_UTE B
        WHERE A.DATA_FINE_CONDUZIONE IS NULL
        AND     A.ID_PARTICELLA         =     N_ID_PARTICELLA
        AND    B.DATA_FINE_ATTIVITA IS NULL
        AND     B.ID_UTE                 =     A.ID_UTE
        AND     B.ID_AZIENDA             =     P_ID_AZIENDA;

vDescAnomalia         DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_DESC_AZIENDE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_DETENTORE_FASCICOLO DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_CUAA                DB_ANAGRAFICA_AZIENDA.CUAA%TYPE;
S_DENOMINAZIONE       DB_ANAGRAFICA_AZIENDA.DENOMINAZIONE%TYPE;
N_TOTALE_SUP_CONDOTTA DB_CONDUZIONE_PARTICELLA.SUPERFICIE_CONDOTTA%TYPE;
var_differenza        NUMBER(20,4);

N_LUNGHEZZA_DENOM     NUMBER;
var_denominazione     VARCHAR2(3000);
nTotUtilAltreAziende  DB_UTILIZZO_DICHIARATO.SUPERFICIE_UTILIZZATA%TYPE;

BEGIN
    vDescAnomalia := NULL;

    FOR recParticelleAzienda IN curParticelleAzienda LOOP
        N_ID_PARTICELLA  := recParticelleAzienda.ID_PARTICELLA;

        SELECT NVL(SUM(UD.SUPERFICIE_UTILIZZATA),0)
          INTO nTotUtilAltreAziende
          FROM DB_DICHIARAZIONE_CONSISTENZA d,
               DB_CONDUZIONE_DICHIARATA E,
               DB_UTILIZZO_DICHIARATO UD,
               DB_ANAGRAFICA_AZIENDA F,
               DB_AZIENDA G
         WHERE E.ID_PARTICELLA = N_ID_PARTICELLA
           AND D.id_azienda <> P_ID_AZIENDA
           AND D.CODICE_FOTOGRAFIA_TERRENI = E.CODICE_FOTOGRAFIA_TERRENI
           AND D.ID_AZIENDA = G.ID_AZIENDA
           AND D.ID_AZIENDA = F.ID_AZIENDA
           AND F.DATA_FINE_VALIDITA IS NULL
           AND E.ID_TITOLO_POSSESSO  NOT IN (5,6)
           AND UD.ID_CONDUZIONE_DICHIARATA = E.ID_CONDUZIONE_DICHIARATA
           AND (G.FLAG_AZIENDA_PROVVISORIA IS NULL OR G.FLAG_AZIENDA_PROVVISORIA = 'N')
           AND F.DATA_CESSAZIONE IS NULL
           AND D.ID_MOTIVO_DICHIARAZIONE <> 7
           AND D.DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
                                                     FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                                                          DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                    WHERE DC.ID_AZIENDA = D.ID_AZIENDA
                                                      AND (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DC.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                                      AND DC.ID_MOTIVO_DICHIARAZIONE <> 7
                                                      AND TI.ID_MOTIVO_DICHIARAZIONE = DC.ID_MOTIVO_DICHIARAZIONE
                                                      AND TI.TIPO_DICHIARAZIONE != 'C');


        IF recParticelleAzienda.TOT_UTILIZZATA + nTotUtilAltreAziende > recParticelleAzienda.SUP_MASSIMA THEN

             vDescAnomalia := '[' || recParticelleAzienda.DESCOM || ' Sez : ' || NVL(recParticelleAzienda.SEZIONE,'N.P.') ||' Fgl:' || recParticelleAzienda.FOGLIO ||
                               ' Part:' || recParticelleAzienda.PARTICELLA || ' Sub : ' || NVL(recParticelleAzienda.SUBALTERNO,'N.P.') ||
                               '] - la superficie dichiarata : ' || TRIM(TO_CHAR(recParticelleAzienda.TOT_UTILIZZATA,'999G990D9999')) ||
                               ' sommata alla superficie dichiarata delle altre aziende : ' || TRIM(TO_CHAR(nTotUtilAltreAziende,'999G990D9999')) ||
                               ' supera la massima tra la superficie grafica e la superficie catastale : ' || TRIM(TO_CHAR(recParticelleAzienda.SUP_MASSIMA,'999G990D9999'));


             IF nTotUtilAltreAziende > 0 THEN
                vDescAnomalia := vDescAnomalia || ' Altre aziende :';
                FOR REC_AZI_SUPERO IN C_AZI_SUPERO LOOP
                    N_LUNGHEZZA_DENOM := LENGTH(REC_AZI_SUPERO.DENOMINAZIONE);
                    IF LENGTH(REC_AZI_SUPERO.DENOMINAZIONE) > 50 THEN
                       VAR_DENOMINAZIONE :=  SUBSTR(REC_AZI_SUPERO.DENOMINAZIONE,1,50);
                    ELSE
                       VAR_DENOMINAZIONE :=  REC_AZI_SUPERO.DENOMINAZIONE;
                    END IF;
                    S_DETENTORE_FASCICOLO :='(CAA: '||REC_AZI_SUPERO.CAA||')';
                    vDescAnomalia := vDescAnomalia || ' Azienda: '||  REC_AZI_SUPERO.CUAA||'-'||VAR_DENOMINAZIONE || S_DETENTORE_FASCICOLO;
                END LOOP;
            END IF;

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia, p_bloccante,
                                        recParticelleAzienda.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;

            FOR REC_CONDUZIONI_ATTIVE IN C_CONDUZIONI_ATTIVE LOOP
                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia, p_bloccante,
                                                       REC_CONDUZIONI_ATTIVE.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                   RETURN (FALSE);
                END IF;
            END LOOP;
        END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE SUPERO_TRA_AZIENDE : ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END SUPERO_TRA_AZIENDE;

-- Verifica per ogni particella in conduzione all'azienda , avente almeno un'unità vitata associata,
-- che la superficie utilizzata totale sommata all'eventuale superficie utilizzata
-- totale di altre aziende, se la particella è condivisa, non superi la massima tra la superficie catastale
-- e quella grafica
FUNCTION SUPERO_TRA_AZIENDE_VITICOLE  (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                              P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                              P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                              P_MSGERR       IN OUT VARCHAR2,
                              P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

N_ID_PARTICELLA                  DB_PARTICELLA.ID_PARTICELLA%TYPE;

    /* cursore che cicle su tutte le particelle attive della mia azienda, che hanno almeno
       una unità vitata atttiva, sommando la superficie utilizzata ed
       estraendo la massima tra la superficie grafica e la superficie catastale */
    CURSOR curParticelleAzienda IS
    SELECT A.ID_PARTICELLA, A.ID_STORICO_PARTICELLA, E.DESCOM, SEZIONE, FOGLIO, PARTICELLA, SUBALTERNO,
           SUM(UP.SUPERFICIE_UTILIZZATA) AS TOT_UTILIZZATA,
           GREATEST(MAX(A.SUP_CATASTALE),MAX(A.SUPERFICIE_GRAFICA)) AS SUP_MASSIMA
      FROM DB_STORICO_PARTICELLA a, DB_CONDUZIONE_PARTICELLA b, DB_UTE c, COMUNE E,
           DB_UTILIZZO_PARTICELLA UP
    WHERE a.id_particella = b.id_particella
      AND A.DATA_FINE_VALIDITA IS NULL
      AND c.id_ute = b.id_ute
      AND c.data_fine_attivita IS NULL
      AND c.id_azienda = P_ID_AZIENDA
      AND b.ID_TITOLO_POSSESSO  NOT IN (5,6)
      AND B.DATA_FINE_CONDUZIONE IS NULL
      AND A.COMUNE = E.ISTAT_COMUNE
      AND A.PARTICELLA IS NOT NULL 
      AND B.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
      AND EXISTS (SELECT SUA.ID_STORICO_UNITA_ARBOREA
                    FROM DB_STORICO_UNITA_ARBOREA SUA
                   WHERE SUA.ID_AZIENDA = P_ID_AZIENDA
                     AND SUA.ID_PARTICELLA = B.ID_PARTICELLA
                     AND SUA.DATA_FINE_VALIDITA IS NULL)
    GROUP BY A.ID_PARTICELLA, A.ID_STORICO_PARTICELLA, E.DESCOM, SEZIONE, FOGLIO, PARTICELLA, SUBALTERNO;

-- cursore che mi estrae le altre aziende che conducono
-- la particella in questione sia che abbiano la delega (1 select in union che senza 2 select in union)
CURSOR C_AZI_SUPERO IS
   SELECT C.CUAA, C.DENOMINAZIONE, F.CODICE_FISCALE AS CAA
FROM DB_CONDUZIONE_DICHIARATA A, DB_DICHIARAZIONE_CONSISTENZA B, DB_ANAGRAFICA_AZIENDA C, DB_AZIENDA D, DB_DELEGA E, DB_INTERMEDIARIO F
WHERE A.ID_PARTICELLA = N_ID_PARTICELLA
  AND A.CODICE_FOTOGRAFIA_TERRENI = B.CODICE_FOTOGRAFIA_TERRENI
  AND C.ID_AZIENDA = B.ID_AZIENDA
  AND B.ID_AZIENDA <> P_ID_AZIENDA
  AND C.DATA_FINE_VALIDITA IS NULL
  AND C.DATA_CESSAZIONE IS NULL
  AND D.ID_AZIENDA = C.ID_AZIENDA
  AND E.ID_AZIENDA(+) = D.ID_AZIENDA
  AND E.DATA_FINE IS NULL
--  AND a.ID_TITOLO_POSSESSO<>5
  AND a.ID_TITOLO_POSSESSO  NOT IN (5,6)
  AND E.ID_PROCEDIMENTO = 7
  AND E.ID_AZIENDA IS NOT NULL
  AND F.ID_INTERMEDIARIO = E.ID_INTERMEDIARIO
  AND B.DATA_INSERIMENTO_DICHIARAZIONE = (    SELECT MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
                                                            FROM     DB_DICHIARAZIONE_CONSISTENZA DC,
                                                                    DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                            WHERE id_azienda = b.id_azienda
                                                            AND     (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DC.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                                            AND     DC.ID_MOTIVO_DICHIARAZIONE <> 7
                                                            AND    TI.ID_MOTIVO_DICHIARAZIONE = DC.ID_MOTIVO_DICHIARAZIONE
                                                            AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                                        )
UNION
SELECT C.CUAA, C.DENOMINAZIONE, 'ASSENTE' AS CAA
FROM DB_CONDUZIONE_DICHIARATA A, DB_DICHIARAZIONE_CONSISTENZA B, DB_ANAGRAFICA_AZIENDA C, DB_AZIENDA D
WHERE A.ID_PARTICELLA = N_ID_PARTICELLA
  AND B.ID_AZIENDA <> P_ID_AZIENDA
  AND A.CODICE_FOTOGRAFIA_TERRENI = B.CODICE_FOTOGRAFIA_TERRENI
  AND C.ID_AZIENDA = B.ID_AZIENDA
  AND C.DATA_FINE_VALIDITA IS NULL
  AND C.DATA_CESSAZIONE IS NULL
  AND D.ID_AZIENDA = C.ID_AZIENDA
--  AND a.ID_TITOLO_POSSESSO <>5
  AND a.ID_TITOLO_POSSESSO  NOT IN (5,6)
  AND B.DATA_INSERIMENTO_DICHIARAZIONE = (    SELECT MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
                                                              FROM     DB_DICHIARAZIONE_CONSISTENZA DC,
                                                                    DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                            WHERE id_azienda = b.id_azienda
                                                            AND     (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DC.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                                            AND     DC.ID_MOTIVO_DICHIARAZIONE <> 7
                                                            AND    TI.ID_MOTIVO_DICHIARAZIONE = DC.ID_MOTIVO_DICHIARAZIONE
                                                            AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                                        )
  AND NOT EXISTS (SELECT ID_AZIENDA FROM DB_DELEGA WHERE ID_AZIENDA = D.ID_AZIENDA AND DATA_FINE IS NULL AND ID_PROCEDIMENTO = 7) ;

CURSOR C_CONDUZIONI_ATTIVE IS
        SELECT ID_CONDUZIONE_PARTICELLA
        FROM DB_CONDUZIONE_PARTICELLA A, DB_UTE B
        WHERE A.DATA_FINE_CONDUZIONE IS NULL
        AND     A.ID_PARTICELLA         =     N_ID_PARTICELLA
        AND    B.DATA_FINE_ATTIVITA IS NULL
        AND     B.ID_UTE                 =     A.ID_UTE
        AND     B.ID_AZIENDA             =     P_ID_AZIENDA;

vDescAnomalia         DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_DESC_AZIENDE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_DETENTORE_FASCICOLO DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_CUAA                DB_ANAGRAFICA_AZIENDA.CUAA%TYPE;
S_DENOMINAZIONE       DB_ANAGRAFICA_AZIENDA.DENOMINAZIONE%TYPE;
N_TOTALE_SUP_CONDOTTA DB_CONDUZIONE_PARTICELLA.SUPERFICIE_CONDOTTA%TYPE;
var_differenza        NUMBER(20,4);

N_LUNGHEZZA_DENOM     NUMBER;
var_denominazione     VARCHAR2(3000);
nTotUtilAltreAziende  DB_UTILIZZO_DICHIARATO.SUPERFICIE_UTILIZZATA%TYPE;

BEGIN
    vDescAnomalia := NULL;

    FOR recParticelleAzienda IN curParticelleAzienda LOOP
        N_ID_PARTICELLA  := recParticelleAzienda.ID_PARTICELLA;

        SELECT NVL(SUM(UD.SUPERFICIE_UTILIZZATA),0)
          INTO nTotUtilAltreAziende
          FROM DB_DICHIARAZIONE_CONSISTENZA d,
               DB_CONDUZIONE_DICHIARATA E,
               DB_UTILIZZO_DICHIARATO UD,
               DB_ANAGRAFICA_AZIENDA F,
               DB_AZIENDA G
         WHERE E.ID_PARTICELLA = N_ID_PARTICELLA
           AND D.id_azienda <> P_ID_AZIENDA
           AND D.CODICE_FOTOGRAFIA_TERRENI = E.CODICE_FOTOGRAFIA_TERRENI
           AND D.ID_AZIENDA = G.ID_AZIENDA
           AND D.ID_AZIENDA = F.ID_AZIENDA
           AND F.DATA_FINE_VALIDITA IS NULL
           AND E.ID_TITOLO_POSSESSO  NOT IN (5,6)
           AND UD.ID_CONDUZIONE_DICHIARATA = E.ID_CONDUZIONE_DICHIARATA
           AND (G.FLAG_AZIENDA_PROVVISORIA IS NULL OR G.FLAG_AZIENDA_PROVVISORIA = 'N')
           AND F.DATA_CESSAZIONE IS NULL
           AND D.ID_MOTIVO_DICHIARAZIONE <> 7
           AND D.DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
                                                     FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                                                          DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                    WHERE DC.ID_AZIENDA = D.ID_AZIENDA
                                                      AND (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DC.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                                      AND DC.ID_MOTIVO_DICHIARAZIONE <> 7
                                                      AND TI.ID_MOTIVO_DICHIARAZIONE = DC.ID_MOTIVO_DICHIARAZIONE
                                                      AND TI.TIPO_DICHIARAZIONE != 'C');


        IF recParticelleAzienda.TOT_UTILIZZATA + nTotUtilAltreAziende > recParticelleAzienda.SUP_MASSIMA THEN

             vDescAnomalia := '[' || recParticelleAzienda.DESCOM || ' Sez : ' || NVL(recParticelleAzienda.SEZIONE,'N.P.') ||' Fgl:' || recParticelleAzienda.FOGLIO ||
                               ' Part:' || recParticelleAzienda.PARTICELLA || ' Sub : ' || NVL(recParticelleAzienda.SUBALTERNO,'N.P.') ||
                               '] - la superficie dichiarata : ' || TRIM(TO_CHAR(recParticelleAzienda.TOT_UTILIZZATA,'999G990D9999')) ||
                               ' sommata alla superficie dichiarata delle altre aziende : ' || TRIM(TO_CHAR(nTotUtilAltreAziende,'999G990D9999')) ||
                               ' supera la massima tra la superficie grafica e la superficie catastale : ' || TRIM(TO_CHAR(recParticelleAzienda.SUP_MASSIMA,'999G990D9999'));


             IF nTotUtilAltreAziende > 0 THEN
                vDescAnomalia := vDescAnomalia || ' Altre aziende :';
                FOR REC_AZI_SUPERO IN C_AZI_SUPERO LOOP
                    N_LUNGHEZZA_DENOM := LENGTH(REC_AZI_SUPERO.DENOMINAZIONE);
                    IF LENGTH(REC_AZI_SUPERO.DENOMINAZIONE) > 50 THEN
                       VAR_DENOMINAZIONE :=  SUBSTR(REC_AZI_SUPERO.DENOMINAZIONE,1,50);
                    ELSE
                       VAR_DENOMINAZIONE :=  REC_AZI_SUPERO.DENOMINAZIONE;
                    END IF;
                    S_DETENTORE_FASCICOLO :='(CAA: '||REC_AZI_SUPERO.CAA||')';
                    vDescAnomalia := vDescAnomalia || ' Azienda: '||  REC_AZI_SUPERO.CUAA||'-'||VAR_DENOMINAZIONE || S_DETENTORE_FASCICOLO;
                END LOOP;
            END IF;

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia, p_bloccante,
                                        recParticelleAzienda.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;

            FOR REC_CONDUZIONI_ATTIVE IN C_CONDUZIONI_ATTIVE LOOP
                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia, p_bloccante,
                                                       REC_CONDUZIONI_ATTIVE.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                   RETURN (FALSE);
                END IF;
            END LOOP;
        END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE SUPERO_TRA_AZIENDE_VITICOLE : ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END SUPERO_TRA_AZIENDE_VITICOLE;


FUNCTION CONTROLLA_SUPERO_CATASTALE (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                            P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                           P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                            P_MSGERR       IN OUT VARCHAR2,
                           P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
var_differenza NUMBER(20,4);
N_ID_PARTICELLA      DB_PARTICELLA.ID_PARTICELLA%TYPE;

     CURSOR C_CONDUZIONI IS
     SELECT SP.ID_PARTICELLA,
            SP.ID_STORICO_PARTICELLA,
            C.DESCOM,
            SP.SEZIONE,
            SP.FOGLIO,
             SP.PARTICELLA,
            SP.SUBALTERNO,
            SP.SUP_CATASTALE,
            SUM(SUPERFICIE_CONDOTTA) AS SUPERFICIE_CONDOTTA_AZ
       FROM DB_STORICO_PARTICELLA SP,
            DB_CONDUZIONE_PARTICELLA D,
            DB_UTE U,
            COMUNE C
      WHERE D.ID_UTE = U.ID_UTE
        AND U.ID_AZIENDA = P_ID_AZIENDA
        AND U.DATA_FINE_ATTIVITA IS NULL 
        AND SP.DATA_FINE_VALIDITA IS NULL
        AND D.DATA_FINE_CONDUZIONE IS NULL
        AND SP.ID_PARTICELLA = D.ID_PARTICELLA
        AND SP.PARTICELLA IS NOT NULL 
        AND SP.COMUNE=C.ISTAT_COMUNE
   GROUP BY SP.ID_PARTICELLA, SP.ID_STORICO_PARTICELLA, C.DESCOM, SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA, SP.SUBALTERNO, SP.SUP_CATASTALE
   HAVING SUM(NVL(SUPERFICIE_CONDOTTA,0)) > SP.SUP_CATASTALE;

    -- prendo le conduzioni attive della particella
    -- e spalmo l'anomalia (tolto il vecchio cursore totalmente idiota)
    CURSOR C_CONDUZIONI_ATTIVE (pIdParticella IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA A, DB_UTE B
     WHERE A.DATA_FINE_CONDUZIONE IS NULL
       AND A.ID_UTE = B.ID_UTE
       AND B.ID_AZIENDA = P_ID_AZIENDA
       AND B.DATA_FINE_ATTIVITA IS NULL
       AND A.ID_PARTICELLA = pIdParticella;


BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_CONDUZIONI IN C_CONDUZIONI LOOP
        var_differenza := NVL(REC_CONDUZIONI.SUPERFICIE_CONDOTTA_az,0) - NVL(REC_CONDUZIONI.SUP_CATASTALE,0);
            IF REC_CONDUZIONI.SEZIONE IS NULL THEN
               IF REC_CONDUZIONI.SUBALTERNO IS NULL THEN
                      S_DESCRIZIONE := '[' || REC_CONDUZIONI.DESCOM ||' Fgl:' ||
                              REC_CONDUZIONI.FOGLIO ||' Part:' || REC_CONDUZIONI.PARTICELLA ||
                              '] La superficie condotta dichiarata supera la superficie catastale di '||
                              TRIM(TO_CHAR(var_differenza,'999G990D9999')) || ' ha';
               ELSE
                      S_DESCRIZIONE := '[' || REC_CONDUZIONI.DESCOM ||' Fgl:' ||
                              REC_CONDUZIONI.FOGLIO ||' Part:' || REC_CONDUZIONI.PARTICELLA ||
                              ' Sub:' || REC_CONDUZIONI.SUBALTERNO ||
                              '] La superficie condotta dichiarata supera la superficie catastale di '||
                              TRIM(TO_CHAR(var_differenza,'999G990D9999')) || ' ha';
               END IF;
            ELSE
               IF REC_CONDUZIONI.SUBALTERNO IS NULL THEN
                      S_DESCRIZIONE := '[' || REC_CONDUZIONI.DESCOM || ' Sz:' || REC_CONDUZIONI.SEZIONE ||
                                ' Fgl:' || REC_CONDUZIONI.FOGLIO ||' Part:' || REC_CONDUZIONI.PARTICELLA ||
                              '] La superficie condotta dichiarata supera la superficie catastale di '||
                              TRIM(TO_CHAR(var_differenza,'999G990D9999')) || ' ha';
               ELSE
                      S_DESCRIZIONE := '[' || REC_CONDUZIONI.DESCOM || ' Sz:' || REC_CONDUZIONI.SEZIONE ||
                                ' Fgl:' || REC_CONDUZIONI.FOGLIO ||' Part:' || REC_CONDUZIONI.PARTICELLA ||
                              ' Sub:' || REC_CONDUZIONI.SUBALTERNO ||
                              '] La superficie condotta dichiarata supera la superficie catastale di '||
                              TRIM(TO_CHAR(var_differenza,'999G990D9999')) || ' ha';
               END IF;
            END IF;

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                     p_bloccante, REC_CONDUZIONI.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
            END IF;

            FOR REC_CONDUZIONI_ATTIVE IN C_CONDUZIONI_ATTIVE (REC_CONDUZIONI.ID_PARTICELLA) LOOP
                s_descrizione := 'La superficie condotta dichiarata supera la superficie catastale';
                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA(P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                    p_bloccante, REC_CONDUZIONI_ATTIVE.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
                END IF;
            END LOOP;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_SUPERO_CATASTALE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLA_SUPERO_CATASTALE;

FUNCTION USO_DEL_SUOLO_MANCANTE (P_ID_AZIENDA      IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                 P_ID_CONTROLLO  IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                 P_BLOCCANTE     IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                 P_MSGERR          IN OUT VARCHAR2,
                                    P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE         DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_TOT_SUP_CONDOTTA   DB_CONDUZIONE_PARTICELLA.SUPERFICIE_CONDOTTA%TYPE;
N_TOT_SUP_UTILIZZATA DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;

CURSOR C_USO_MANCANTE IS
     SELECT A.ID_CONDUZIONE_PARTICELLA, E.DESCOM, C.SEZIONE, C.FOGLIO, C.PARTICELLA, C.SUBALTERNO,
             A.SUPERFICIE_CONDOTTA, c.ID_STORICO_PARTICELLA, SUM (NVL(D.SUPERFICIE_UTILIZZATA,0)) SUP_UTILIZZATA
     FROM DB_CONDUZIONE_PARTICELLA A, DB_UTE B, DB_STORICO_PARTICELLA C, DB_UTILIZZO_PARTICELLA D,
           COMUNE E
     WHERE A.DATA_FINE_CONDUZIONE IS NULL
       AND B.ID_UTE = A.ID_UTE
       AND B.ID_AZIENDA = P_ID_AZIENDA
       AND C.ID_PARTICELLA = A.ID_PARTICELLA
       AND C.DATA_FINE_VALIDITA IS NULL
       AND A.ID_CONDUZIONE_PARTICELLA = D.ID_CONDUZIONE_PARTICELLA(+)
       AND E.ISTAT_COMUNE = C.COMUNE
       AND a.ID_TITOLO_POSSESSO<>5
     GROUP BY A.ID_CONDUZIONE_PARTICELLA, E.DESCOM, C.SEZIONE, C.FOGLIO, C.PARTICELLA, C.SUBALTERNO,
                  A.SUPERFICIE_CONDOTTA, c.ID_STORICO_PARTICELLA
     HAVING A.SUPERFICIE_CONDOTTA <> SUM (NVL(D.SUPERFICIE_UTILIZZATA,0));

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_USO_MANCANTE IN C_USO_MANCANTE LOOP
        -- e la tabella DB_CONDUZIONE_PARTICELLA non è in outer join mentre la SUP_UTILIZZATA
        -- presa da DB_UTILIZZO_PARTICELLA (che è in outer join e quindi potrebbe essere a null)
        -- è già estratta con l'NVL nella select del cursore.
        -- Inoltre aggiunta la condizione per segnalare l'anomalia anche quando la superficie
        -- utilizzata è zero
         IF (REC_USO_MANCANTE.SUP_UTILIZZATA = 0) OR
           (REC_USO_MANCANTE.SUPERFICIE_CONDOTTA > REC_USO_MANCANTE.SUP_UTILIZZATA AND
            REC_USO_MANCANTE.SUPERFICIE_CONDOTTA - REC_USO_MANCANTE.SUP_UTILIZZATA > 0.01) THEN
             IF REC_USO_MANCANTE.SEZIONE IS NULL THEN
               IF REC_USO_MANCANTE.SUBALTERNO IS NULL THEN
                     S_DESCRIZIONE := '[' || REC_USO_MANCANTE.DESCOM ||' Fgl:' || REC_USO_MANCANTE.FOGLIO ||
                  ' Part:' || REC_USO_MANCANTE.PARTICELLA ||
                  '] Sup. cond.:' || TO_CHAR(NVL(REC_USO_MANCANTE.SUPERFICIE_CONDOTTA,0),'999G990D9999') ||
                  '(ha), Sup.util.:'|| TO_CHAR(NVL(REC_USO_MANCANTE.SUP_UTILIZZATA,0),'999G990D9999') ||
                  '(ha). destinazione produttiva non specificata per ' ||
                    TO_CHAR(NVL(REC_USO_MANCANTE.SUPERFICIE_CONDOTTA,0) - NVL(REC_USO_MANCANTE.SUP_UTILIZZATA,0),'999G990D9999')
                  || '(ha)';
               ELSE
                     S_DESCRIZIONE := '[' || REC_USO_MANCANTE.DESCOM ||' Fgl:' || REC_USO_MANCANTE.FOGLIO ||
                  ' Part:' || REC_USO_MANCANTE.PARTICELLA || ' Sub:' || REC_USO_MANCANTE.SUBALTERNO ||
                  '] Sup. cond.:' || TO_CHAR(NVL(REC_USO_MANCANTE.SUPERFICIE_CONDOTTA,0),'999G990D9999') ||
                  '(ha), Sup.util.:'|| TO_CHAR(NVL(REC_USO_MANCANTE.SUP_UTILIZZATA,0),'999G990D9999') ||
                  '(ha). destinazione produttiva non specificata per ' ||
                  TO_CHAR(NVL(REC_USO_MANCANTE.SUPERFICIE_CONDOTTA,0) - NVL(REC_USO_MANCANTE.SUP_UTILIZZATA,0),'999G990D9999')
                 || '(ha)';
               END IF;
            ELSE
               IF REC_USO_MANCANTE.SUBALTERNO IS NULL THEN
                     S_DESCRIZIONE := '[' || REC_USO_MANCANTE.DESCOM || ' Sz:' ||REC_USO_MANCANTE.SEZIONE ||
                  ' Fgl:' || REC_USO_MANCANTE.FOGLIO || ' Part:' || REC_USO_MANCANTE.PARTICELLA ||
                  '] Sup. cond.:' || TO_CHAR(NVL(REC_USO_MANCANTE.SUPERFICIE_CONDOTTA,0),'999G990D9999') ||
                  '(ha), Sup.util.:'|| TO_CHAR(NVL(REC_USO_MANCANTE.SUP_UTILIZZATA,0),'999G990D9999') ||
                  '(ha). destinazione produttiva non specificata per ' ||
                  TO_CHAR(NVL(REC_USO_MANCANTE.SUPERFICIE_CONDOTTA,0) - NVL(REC_USO_MANCANTE.SUP_UTILIZZATA,0),'999G990D9999')
                 || '(ha)';
               ELSE
                     S_DESCRIZIONE := '[' || REC_USO_MANCANTE.DESCOM ||' Sz:' ||REC_USO_MANCANTE.SEZIONE ||
                  ' Fgl:' || REC_USO_MANCANTE.FOGLIO ||' Part:' || REC_USO_MANCANTE.PARTICELLA || ' Sub:' || REC_USO_MANCANTE.SUBALTERNO ||
                  '] Sup. cond.:' || TO_CHAR(NVL(REC_USO_MANCANTE.SUPERFICIE_CONDOTTA,0),'999G990D9999') ||
                  '(ha), Sup.util.:'|| TO_CHAR(NVL(REC_USO_MANCANTE.SUP_UTILIZZATA,0),'999G990D9999') ||
                  '(ha). destinazione produttiva non specificata per ' ||
                  TO_CHAR(NVL(REC_USO_MANCANTE.SUPERFICIE_CONDOTTA,0) - NVL(REC_USO_MANCANTE.SUP_UTILIZZATA,0),'999G990D9999')
                 || '(ha)';
               END IF;
            END IF;
            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                        P_BLOCCANTE, REC_USO_MANCANTE.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;

            IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, p_bloccante,
                      REC_USO_MANCANTE.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
        END IF;
     END LOOP;

/*
      --- TOTALE DELLA SUPERFICIE CONDOTTA PER L'AZIENDA IN ESAME
     SELECT SUM(SUPERFICIE_CONDOTTA)
     INTO    N_TOT_SUP_CONDOTTA
     FROM DB_UTE A, DB_CONDUZIONE_PARTICELLA B
     WHERE A.ID_UTE = B.ID_UTE
       AND A.ID_AZIENDA = P_ID_AZIENDA
       AND B.DATA_FINE_CONDUZIONE IS NULL; -- VERIFICARE

     --- TOTALE DELLA SUPERFICIE UTILIZZATA PER L'AZIENDA IN ESAME
     SELECT SUM(SUPERFICIE_UTILIZZATA)
     INTO    N_TOT_SUP_UTILIZZATA
     FROM DB_UTE A, DB_CONDUZIONE_PARTICELLA B, DB_UTILIZZO_PARTICELLA C
     WHERE A.ID_UTE = B.ID_UTE
       AND A.ID_AZIENDA = P_ID_AZIENDA
       AND C.ID_CONDUZIONE_PARTICELLA = B.ID_CONDUZIONE_PARTICELLA
       AND C.ANNO = P_ANNO_RIF
       AND B.DATA_FINE_CONDUZIONE IS NULL; -- VERIFICARE


     IF (NVL(N_TOT_SUP_CONDOTTA,0) - NVL(N_TOT_SUP_UTILIZZATA,0)) > 0 THEN
          S_DESCRIZIONE := 'Uso del suolo non specificato per ' ||
         TRIM(TO_CHAR(NVL(N_TOT_SUP_CONDOTTA,0) - NVL(N_TOT_SUP_UTILIZZATA,0),'999G990D9999')) ||
         ' (ha) in conduzione all''azienda';

          IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;

     END IF;
*/
     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE USO_DEL_SUOLO_MANCANTE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END USO_DEL_SUOLO_MANCANTE;


-- Per ciascuna conduzione attiva sul piano in lavorazione all'azienda controlla se
-- la somma della superficie utilizzata è minore della minore tra la superficie grafica
-- e la superficie catastale escludendo quelle a zero (al netto dell'applicazione della percentuale_possesso)
FUNCTION USO_DEL_SUOLO_NON_SPECIFICATO (P_ID_AZIENDA    IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                        P_ID_CONTROLLO  IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        P_BLOCCANTE     IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                        P_MSGERR        IN OUT VARCHAR2,
                                        P_CODERR        IN OUT VARCHAR2) RETURN BOOLEAN IS

    CURSOR curConduzioneInSupero IS
    SELECT SP.ID_STORICO_PARTICELLA,
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           SP.SUP_CATASTALE,
           SP.SUPERFICIE_GRAFICA,
           /*CASE WHEN FO.FLAG_STABILIZZAZIONE = 0 THEN 
              DECODE(SP.SUPERFICIE_GRAFICA,0,SP.SUP_CATASTALE, SP.SUPERFICIE_GRAFICA)
           ELSE
              LEAST(DECODE(SP.SUPERFICIE_GRAFICA,0,SP.SUP_CATASTALE,SP.SUPERFICIE_GRAFICA),
                    DECODE(SP.SUP_CATASTALE,0,SP.SUPERFICIE_GRAFICA,SP.SUP_CATASTALE))
           END AS SUP_MINORE,*/
           DECODE(SP.SUPERFICIE_GRAFICA,0,SP.SUP_CATASTALE, SP.SUPERFICIE_GRAFICA) SUP_MINORE,
           C.DESCOM,
           CP.ID_CONDUZIONE_PARTICELLA,
           CP.PERCENTUALE_POSSESSO,
           SUM(UC.SUPERFICIE_UTILIZZATA) AS TOT_UTILIZZATA
      FROM DB_STORICO_PARTICELLA SP,
           DB_CONDUZIONE_PARTICELLA CP,
           DB_UTILIZZO_PARTICELLA UC,
           DB_UTE U,
           COMUNE C,
           DB_FOGLIO FO 
     WHERE U.ID_AZIENDA = P_ID_AZIENDA
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND U.ID_UTE = CP.ID_UTE
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_TITOLO_POSSESSO <> 5 -- asservimento
       AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
       AND CP.ID_CONDUZIONE_PARTICELLA = UC.ID_CONDUZIONE_PARTICELLA
       AND SP.DATA_FINE_VALIDITA IS NULL
       AND SP.COMUNE = FO.COMUNE (+)
       AND SP.FOGLIO = FO.FOGLIO (+)
       AND NVL(SP.SEZIONE,'#') = NVL(FO.SEZIONE (+),'#')
       AND SP.COMUNE = C.ISTAT_COMUNE
       AND SP.PARTICELLA IS NOT NULL 
  GROUP BY SP.ID_STORICO_PARTICELLA,
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           --FO.FLAG_STABILIZZAZIONE, 
           SP.PARTICELLA,
           SP.SUBALTERNO,
           SP.SUP_CATASTALE,
           SP.SUPERFICIE_GRAFICA,
           C.DESCOM,
           CP.ID_CONDUZIONE_PARTICELLA,
           CP.PERCENTUALE_POSSESSO
  HAVING DECODE(SP.SUPERFICIE_GRAFICA,0,SP.SUP_CATASTALE, SP.SUPERFICIE_GRAFICA) != 0
 and TRUNC(SUM(UC.SUPERFICIE_UTILIZZATA),2) <
 TRUNC(DECODE(SP.SUPERFICIE_GRAFICA,0,SP.SUP_CATASTALE, SP.SUPERFICIE_GRAFICA) * CP.PERCENTUALE_POSSESSO / 100,2);
   /*HAVING TRUNC(SUM(UC.SUPERFICIE_UTILIZZATA),2) <
          TRUNC(CASE WHEN FO.FLAG_STABILIZZAZIONE = 0 THEN -- se foglio stabilitazzato
                    DECODE(SP.SUPERFICIE_GRAFICA,0,SP.SUP_CATASTALE, SP.SUPERFICIE_GRAFICA)
                ELSE
                    LEAST(DECODE(SP.SUPERFICIE_GRAFICA,0,SP.SUP_CATASTALE,SP.SUPERFICIE_GRAFICA),
                          DECODE(SP.SUP_CATASTALE,0,SP.SUPERFICIE_GRAFICA,SP.SUP_CATASTALE))
                END * CP.PERCENTUALE_POSSESSO / 100,2); */


    vDescAnomalia   DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    nSuoloMancante  DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
BEGIN

     FOR recConduzioneInSupero IN curConduzioneInSupero LOOP

         nSuoloMancante := (recConduzioneInSupero.SUP_MINORE * recConduzioneInSupero.PERCENTUALE_POSSESSO) / 100 -
                            recConduzioneInSupero.TOT_UTILIZZATA;

         vDescAnomalia := '[' || recConduzioneInSupero.DESCOM || ' Sez : ' || NVL(recConduzioneInSupero.SEZIONE,'N.P.') ||' Fgl:' || recConduzioneInSupero.FOGLIO ||
                     ' Part:' || recConduzioneInSupero.PARTICELLA || ' Sub : ' || NVL(recConduzioneInSupero.SUBALTERNO,'N.P.') ||
                     '] la Sup.utilizzata: ' ||  TRIM(TO_CHAR(recConduzioneInSupero.TOT_UTILIZZATA,'999G990D9999')) ||
                     ' ha uso del suolo non specificato per ' || TRIM(TO_CHAR(nSuoloMancante,'999G990D9999')) || ' ha';

         IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,
                                     P_BLOCCANTE, recConduzioneInSupero.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
         END IF;

         IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,
                                                P_BLOCCANTE, recConduzioneInSupero.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
         END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE USO_DEL_SUOLO_NON_SPECIFICATO: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END USO_DEL_SUOLO_NON_SPECIFICATO;

-- controlla se ci sono conduzioni non in asservimento / conferimento
-- senza usi del suolo
FUNCTION USO_DEL_SUOLO_NON_ESISTENTE (P_ID_AZIENDA    IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                      P_ID_CONTROLLO  IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                      P_BLOCCANTE     IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                      P_MSGERR        IN OUT VARCHAR2,
                                      P_CODERR        IN OUT VARCHAR2) RETURN BOOLEAN IS

    CURSOR curConduzioneSenzaUso IS
    SELECT SP.ID_STORICO_PARTICELLA,
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           C.DESCOM,
           CP.ID_CONDUZIONE_PARTICELLA,
           CP.PERCENTUALE_POSSESSO
      FROM DB_STORICO_PARTICELLA SP,
           DB_CONDUZIONE_PARTICELLA CP,
           DB_UTE U,
           COMUNE C
     WHERE U.ID_AZIENDA = P_ID_AZIENDA
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND U.ID_UTE = CP.ID_UTE
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_TITOLO_POSSESSO NOT IN (5,6) -- asservimento / conferimento
       AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
       AND SP.DATA_FINE_VALIDITA IS NULL
       AND SP.COMUNE = C.ISTAT_COMUNE
       AND SP.PARTICELLA IS NOT NULL
       AND NOT EXISTS(SELECT UP.ID_UTILIZZO_PARTICELLA
                        FROM DB_UTILIZZO_PARTICELLA UP
                       WHERE UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
                         AND UP.SUPERFICIE_UTILIZZATA > 0);

    vDescAnomalia   DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
BEGIN

     FOR recConduzioneSenzaUso IN curConduzioneSenzaUso LOOP


         vDescAnomalia := '[' || recConduzioneSenzaUso.DESCOM || ' Sez : ' || NVL(recConduzioneSenzaUso.SEZIONE,'N.P.') ||' Fgl:' || recConduzioneSenzaUso.FOGLIO ||
                     ' Part:' || recConduzioneSenzaUso.PARTICELLA || ' Sub : ' || NVL(recConduzioneSenzaUso.SUBALTERNO,'N.P.') ||
                     '] condotta al : ' || TO_CHAR(recConduzioneSenzaUso.PERCENTUALE_POSSESSO,'990D99') || ' non ha usi del suolo specificati';


         IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,
                                     P_BLOCCANTE, recConduzioneSenzaUso.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
         END IF;

         IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,
                                                P_BLOCCANTE, recConduzioneSenzaUso.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
         END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE USO_DEL_SUOLO_NON_ESISTENTE: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END USO_DEL_SUOLO_NON_ESISTENTE;



FUNCTION USO_DEL_SUOLO_NON_VALIDO (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                   P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                   P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                   P_MSGERR       IN OUT VARCHAR2,
                                   P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

CURSOR C_USO_NON_VALIDO IS
     SELECT D.DESCRIZIONE , D.ANNO_FINE_VALIDITA, B.ID_CONDUZIONE_PARTICELLA, F.DESCOM,
             E.SEZIONE, E.FOGLIO, E.PARTICELLA, E.SUBALTERNO, E.ID_STORICO_PARTICELLA
     FROM DB_UTE A, DB_CONDUZIONE_PARTICELLA B, DB_UTILIZZO_PARTICELLA C, DB_TIPO_UTILIZZO D,
           DB_STORICO_PARTICELLA E, COMUNE F, DB_TIPO_CASO_PARTICOLARE CP
     WHERE A.ID_AZIENDA = P_ID_AZIENDA
       AND A.ID_UTE = B.ID_UTE
       AND B.ID_CONDUZIONE_PARTICELLA = C.ID_CONDUZIONE_PARTICELLA
       AND B.DATA_FINE_CONDUZIONE IS NULL
       AND D.ID_UTILIZZO = C.ID_UTILIZZO
       AND D.ANNO_FINE_VALIDITA IS NOT NULL
       AND E.ID_PARTICELLA = B.ID_PARTICELLA
       AND E.DATA_FINE_VALIDITA IS NULL
       AND F.ISTAT_COMUNE = E.COMUNE
       AND NVL(E.ID_CASO_PARTICOLARE,99) = CP.ID_CASO_PARTICOLARE
       AND CP.EFFETTUA_CONTROLLI_GIS = 'S' 
  GROUP BY D.DESCRIZIONE , D.ANNO_FINE_VALIDITA, B.ID_CONDUZIONE_PARTICELLA, F.DESCOM,
            E.SEZIONE, E.FOGLIO, E.PARTICELLA, E.SUBALTERNO, E.ID_STORICO_PARTICELLA;

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_USO_NON_VALIDO IN C_USO_NON_VALIDO LOOP
          IF REC_USO_NON_VALIDO.SEZIONE IS NULL THEN
             IF REC_USO_NON_VALIDO.SUBALTERNO IS NULL THEN
               S_DESCRIZIONE := '[' || REC_USO_NON_VALIDO.DESCOM || ' Fgl:' || REC_USO_NON_VALIDO.FOGLIO ||
                                ' Part:'||REC_USO_NON_VALIDO.PARTICELLA || '] La destinazione produttiva ' ||
                             REC_USO_NON_VALIDO.DESCRIZIONE ||' non e'' piu'' valida';
            ELSE
               S_DESCRIZIONE := '[' || REC_USO_NON_VALIDO.DESCOM || ' Fgl:' || REC_USO_NON_VALIDO.FOGLIO ||
                                ' Part:'||REC_USO_NON_VALIDO.PARTICELLA || ' Sub:' ||  REC_USO_NON_VALIDO.SUBALTERNO
                             || '] La destinazione produttiva ' || REC_USO_NON_VALIDO.DESCRIZIONE ||' non e'' piu'' valida';
            END IF;
         ELSE
             IF REC_USO_NON_VALIDO.SUBALTERNO IS NULL THEN
               S_DESCRIZIONE := '[' || REC_USO_NON_VALIDO.DESCOM || ' Sz:' || REC_USO_NON_VALIDO.SEZIONE ||
                                ' Fgl:' || REC_USO_NON_VALIDO.FOGLIO ||' Part:'||REC_USO_NON_VALIDO.PARTICELLA ||
                             '] La destinazione produttiva ' || REC_USO_NON_VALIDO.DESCRIZIONE ||' non e'' piu'' valida';
            ELSE
               S_DESCRIZIONE := '[' || REC_USO_NON_VALIDO.DESCOM || ' Sz:' || REC_USO_NON_VALIDO.SEZIONE ||
                                ' Fgl:' || REC_USO_NON_VALIDO.FOGLIO ||' Part:'||REC_USO_NON_VALIDO.PARTICELLA ||
                             ' Sub:' ||  REC_USO_NON_VALIDO.SUBALTERNO || '] La destinazione produttiva ' ||
                             REC_USO_NON_VALIDO.DESCRIZIONE ||' non e'' piu'' valida';
            END IF;
         END IF;

          IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, REC_USO_NON_VALIDO.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;

          IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, REC_USO_NON_VALIDO.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE USO_DEL_SUOLO_NON_VALIDO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END USO_DEL_SUOLO_NON_VALIDO;

-- Verifica che le particelle con utilizzi a frutta a guscio
-- abbiano le informazioni specifiche della frutta a guscio valorizzate
FUNCTION VERIFICA_INFORMAZIONI_FAG (P_ID_AZIENDA    IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                    P_ID_CONTROLLO  IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                    P_BLOCCANTE     IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                    P_MSGERR        IN OUT VARCHAR2,
                                    P_CODERR        IN OUT VARCHAR2) RETURN BOOLEAN IS

    CURSOR curConduzioneConFagIncompleta IS
    SELECT SP.ID_STORICO_PARTICELLA,
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           C.DESCOM,
           CP.ID_CONDUZIONE_PARTICELLA
      FROM DB_STORICO_PARTICELLA SP,
           DB_CONDUZIONE_PARTICELLA CP,
           DB_UTE U,
           COMUNE C
     WHERE U.ID_AZIENDA = P_ID_AZIENDA
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND U.ID_UTE = CP.ID_UTE
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_TITOLO_POSSESSO NOT IN (5,6) -- asservimento / conferimento
       AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
       AND SP.DATA_FINE_VALIDITA IS NULL
       AND SP.COMUNE = C.ISTAT_COMUNE
       AND SP.PARTICELLA IS NOT NULL
       AND EXISTS(SELECT UP.ID_UTILIZZO_PARTICELLA
                    FROM DB_UTILIZZO_PARTICELLA UP,DB_R_CATALOGO_MATRICE CM
                   WHERE UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
                     AND CM.ID_CATALOGO_MATRICE = UP.ID_CATALOGO_MATRICE 
                     AND CM.FLAG_FRUTTA_GUSCIO = 'S' 
                     AND (UP.ID_IMPIANTO IS NULL OR
                          UP.ANNO_IMPIANTO IS NULL OR
                          UP.SESTO_SU_FILE IS NULL OR
                          UP.SESTO_TRA_FILE IS NULL OR
                          UP.NUMERO_PIANTE_CEPPI IS NULL))
  ORDER BY SP.ID_STORICO_PARTICELLA;

    nIdStoricoParticella  DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE:=-1;
    vDescAnomalia         DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
BEGIN

     FOR recConduzioneConFagIncompleta IN curConduzioneConFagIncompleta LOOP

         vDescAnomalia := '[' || recConduzioneConFagIncompleta.DESCOM || ' Sez : ' || NVL(recConduzioneConFagIncompleta.SEZIONE,'N.P.') ||' Fgl:' || recConduzioneConFagIncompleta.FOGLIO ||
                     ' Part:' || recConduzioneConFagIncompleta.PARTICELLA || ' Sub : ' || NVL(recConduzioneConFagIncompleta.SUBALTERNO,'N.P.') ||
                     '] non sono stati dichiarati tutti i dati relativi alla frutta a guscio';


         IF nIdStoricoParticella <> recConduzioneConFagIncompleta.ID_STORICO_PARTICELLA THEN
            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,
                                        P_BLOCCANTE, recConduzioneConFagIncompleta.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
         END IF;

         IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,
                                                P_BLOCCANTE, recConduzioneConFagIncompleta.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
         END IF;

         nIdStoricoParticella := recConduzioneConFagIncompleta.ID_STORICO_PARTICELLA;

     END LOOP;

     RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE VERIFICA_INFORMAZIONI_FAG: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END VERIFICA_INFORMAZIONI_FAG;



-- 219
FUNCTION MACRO_USO_INCONGRUENTE (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                           P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                           P_BLOCCANTE          IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                           P_MSGERR       IN OUT VARCHAR2,
                                           P_CODERR         IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
s_sezione            VARCHAR2(20);
s_sub                VARCHAR2(20);

CURSOR C_MACRO_USO_INCONGRUENTE IS
    SELECT     G.DESCRIZIONE,
                G.CODICE ,
                B.ID_CONDUZIONE_PARTICELLA,
                F.DESCOM,
                E.SEZIONE,
                E.FOGLIO,
                E.PARTICELLA,
                E.SUBALTERNO,
                E.ID_STORICO_PARTICELLA
    FROM    DB_UTE A,
            DB_CONDUZIONE_PARTICELLA B,
            DB_UTILIZZO_PARTICELLA C,
            DB_TIPO_MACRO_USO_VARIETA D,
            DB_STORICO_PARTICELLA E,
            COMUNE F,
            DB_TIPO_MACRO_USO G,DB_R_CATALOGO_MATRICE CM
    WHERE A.ID_AZIENDA                     =    P_ID_AZIENDA
    AND     A.ID_UTE                         =     B.ID_UTE
    AND     A.DATA_FINE_ATTIVITA         IS NULL
    AND     B.ID_CONDUZIONE_PARTICELLA =     C.ID_CONDUZIONE_PARTICELLA
    AND     B.DATA_FINE_CONDUZIONE         IS NULL
    AND     CM.ID_CATALOGO_MATRICE  = C.ID_CATALOGO_MATRICE 
    AND     C.ID_CATALOGO_MATRICE   = D.ID_CATALOGO_MATRICE 
    AND     G.ID_MACRO_USO                    =     D.ID_MACRO_USO
    AND     G.codice                         NOT IN     (    SELECT VALORE_STRINGA
                                                                FROM DB_TIPO_CONTROLLO_PARAMETRO
                                                                WHERE ID_CONTROLLO=219
                                                                  AND SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE) 
                                                            )
    AND     D.data_fine_validita         IS NULL
    AND     E.ID_PARTICELLA                 =     B.ID_PARTICELLA
    AND     E.DATA_FINE_VALIDITA         IS NULL
    AND     F.ISTAT_COMUNE                 =     E.COMUNE
    AND     b.ID_TITOLO_POSSESSO            <>    5
    AND     e.id_caso_particolare        =    3
    GROUP BY G.DESCRIZIONE, G.CODICE, B.ID_CONDUZIONE_PARTICELLA, F.DESCOM,E.SEZIONE, E.FOGLIO, E.PARTICELLA, E.SUBALTERNO, E.ID_STORICO_PARTICELLA;

    vDescMac DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
BEGIN
     S_DESCRIZIONE := NULL;
        vDescMac := NULL;
        FOR rec_d IN  (     SELECT G.DESCRIZIONE
                                FROM     DB_TIPO_CONTROLLO_PARAMETRO P,
                                      DB_TIPO_MACRO_USO G
                                WHERE P.ID_CONTROLLO=219
                                AND SYSDATE BETWEEN P.DATA_INIZIO_VALIDITA AND NVL(P.DATA_FINE_VALIDITA,SYSDATE) 
                                AND    G.codice = p.VALORE_STRINGA
                                ORDER BY G.DESCRIZIONE ) LOOP
            vDescMac := vDescMac||rec_d.DESCRIZIONE||',';
        END LOOP;
        vDescMac := RTRIM(vDescMac,',');

     FOR REC_VARIETA_NON_VALIDA IN C_MACRO_USO_INCONGRUENTE LOOP

          SELECT DECODE(REC_VARIETA_NON_VALIDA.SEZIONE, NULL, '', ' Sz: '|| REC_VARIETA_NON_VALIDA.SEZIONE)
        INTO S_SEZIONE FROM DUAL;

        SELECT DECODE(REC_VARIETA_NON_VALIDA.subalterno, NULL, '', ' Sub: '|| REC_VARIETA_NON_VALIDA.SUBALTERNO)
        INTO s_sub FROM dual;

         S_DESCRIZIONE := '[' || REC_VARIETA_NON_VALIDA.DESCOM || S_SEZIONE ||' Fgl:' || REC_VARIETA_NON_VALIDA.FOGLIO ||
                                ' Part:'||REC_VARIETA_NON_VALIDA.PARTICELLA || s_sub ||'] Il macro uso del suolo ' ||
                                  REC_VARIETA_NON_VALIDA.DESCRIZIONE|| ' non è previsto per il caso paticolare Uso civico. I macro usi possibili sono : '||vDescMac||'.';

          IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, REC_VARIETA_NON_VALIDA.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;

          IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, REC_VARIETA_NON_VALIDA.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE MACRO_USO_INCONGRUENTE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END MACRO_USO_INCONGRUENTE;

-- 220
FUNCTION USO_VITE_AUTOCONSUMO     (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                           P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                           P_BLOCCANTE          IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                           P_MSGERR       IN OUT VARCHAR2,
                                          P_CODERR             IN OUT VARCHAR2) RETURN BOOLEAN IS



CURSOR CUR_VITI IS
SELECT     SUM(C.SUPERFICIE_UTILIZZATA) SUP,
            F.DESCOM,
            E.SEZIONE,
            E.FOGLIO,
            E.PARTICELLA,
            E.SUBALTERNO,
             d.descrizione,
            E.ID_STORICO_PARTICELLA,
            E.ID_PARTICELLA
     FROM DB_UTE A,
            DB_CONDUZIONE_PARTICELLA B,
            DB_UTILIZZO_PARTICELLA C,
            DB_TIPO_UTILIZZO d,
               DB_STORICO_PARTICELLA E,
            COMUNE F
     WHERE     A.ID_AZIENDA                     =     P_ID_AZIENDA
        AND     A.DATA_FINE_ATTIVITA         IS NULL
       AND     A.ID_UTE                         =     B.ID_UTE
       AND     B.ID_CONDUZIONE_PARTICELLA =     C.ID_CONDUZIONE_PARTICELLA
       AND     B.DATA_FINE_CONDUZIONE         IS NULL
       AND     D.ID_UTILIZZO                     =     C.ID_UTILIZZO
        AND    D.CODICE                         =     '161'
        AND    D.ANNO_FINE_VALIDITA            IS NULL
       AND     E.ID_PARTICELLA = B.ID_PARTICELLA
       AND     E.DATA_FINE_VALIDITA IS NULL
       AND     F.ISTAT_COMUNE = E.COMUNE
         GROUP BY F.DESCOM,    E.SEZIONE, E.FOGLIO, E.PARTICELLA, E.SUBALTERNO, d.descrizione, E.ID_STORICO_PARTICELLA,E.ID_PARTICELLA;


    CURSOR C_CONDUZIONI_ATTIVE (parIdParticella IN NUMBER) IS
     SELECT ID_CONDUZIONE_PARTICELLA
     FROM DB_CONDUZIONE_PARTICELLA A, DB_UTE B
     WHERE A.DATA_FINE_CONDUZIONE IS NULL
       AND A.ID_PARTICELLA = parIdParticella
       AND B.ID_UTE = A.ID_UTE
        AND B.DATA_FINE_ATTIVITA         IS NULL
       AND B.ID_AZIENDA = P_ID_AZIENDA;


S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
s_sezione            VARCHAR2(20);
s_sub                    VARCHAR2(20);
nValLmite            NUMBER;

BEGIN

    nValLmite := 0.1000;

    FOR REC_VITI IN CUR_VITI LOOP

        IF REC_VITI.SUP >= nValLmite THEN

              SELECT DECODE(REC_VITI.SEZIONE, NULL, '', ' Sz: '|| REC_VITI.SEZIONE) INTO S_SEZIONE FROM DUAL;

            SELECT DECODE(REC_VITI.subalterno, NULL, '', ' Sub: '|| REC_VITI.SUBALTERNO) INTO s_sub FROM dual;

             S_DESCRIZIONE := '[' || REC_VITI.DESCOM || S_SEZIONE ||' Fgl:' || REC_VITI.FOGLIO ||
                                ' Part:'||REC_VITI.PARTICELLA || s_sub ||'] La superficie utilizzata ' ||
                                  TO_CHAR(NVL(REC_VITI.SUP,0),'999G990D9999') || ' ha, per l''uso del suolo '  || REC_VITI.DESCRIZIONE ||', e'' maggiore o uguale a '||TO_CHAR(NVL(nValLmite,0),'999G990D9999')||' ha.';

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                  P_BLOCCANTE, REC_VITI.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
              END IF;

            FOR REC_CONDUZIONI_ATTIVE IN C_CONDUZIONI_ATTIVE(REC_VITI.ID_PARTICELLA) LOOP
                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, p_bloccante,
                     REC_CONDUZIONI_ATTIVE.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                      RETURN (FALSE);
                END IF;
            END LOOP;

        END IF;
    END LOOP;


 RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE USO_VITE_AUTOCONSUMO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);


END USO_VITE_AUTOCONSUMO;


---------------------------------------------------------------------------------
-- 221
FUNCTION CONFERIMENTO_DA_SOCI     (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                           P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                           P_BLOCCANTE          IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                           P_MSGERR       IN OUT VARCHAR2,
                                          P_CODERR             IN OUT VARCHAR2) RETURN BOOLEAN IS


CURSOR CUR_PAR IS SELECT TBL1.* FROM
            (
            SELECT C.ID_PARTICELLA, C.ID_STORICO_PARTICELLA, C.SEZIONE, D.ISTAT_COMUNE,D.DESCOM, C.FOGLIO, C.PARTICELLA, C.SUBALTERNO
            FROM   DB_UTE A,
                   DB_CONDUZIONE_PARTICELLA B,
                   DB_STORICO_PARTICELLA C,
                   COMUNE D
            WHERE A.DATA_FINE_ATTIVITA         IS NULL
                  AND A.ID_AZIENDA                =    P_ID_AZIENDA
                  AND A.ID_UTE                    =    B.ID_UTE
                  AND B.DATA_FINE_CONDUZIONE IS NULL
                  AND B.ID_TITOLO_POSSESSO    =    6
                  AND B.ID_PARTICELLA            =    C.ID_PARTICELLA
                  AND C.DATA_FINE_VALIDITA     IS NULL
                  AND C.COMUNE                    =    D.ISTAT_COMUNE
            GROUP BY C.ID_PARTICELLA, C.ID_STORICO_PARTICELLA, C.SEZIONE, D.ISTAT_COMUNE,D.DESCOM, C.FOGLIO, C.PARTICELLA, C.SUBALTERNO
            ) TBL1
            WHERE NOT EXISTS
            (    SELECT C.ID_PARTICELLA                                                                -- Considero tutte le dichiarazioni
                FROM DB_DICHIARAZIONE_CONSISTENZA A,                                                 -- di consistenza dei soci
                     DB_TIPO_MOTIVO_DICHIARAZIONE B,
                     DB_CONDUZIONE_DICHIARATA C
                WHERE A.ID_MOTIVO_DICHIARAZIONE        =            B.ID_MOTIVO_DICHIARAZIONE
                 AND     A.ID_MOTIVO_DICHIARAZIONE        !=            7
                 AND     B.TIPO_DICHIARAZIONE                !=            'C'
                 AND   (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= A.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                 AND     A.CODICE_FOTOGRAFIA_TERRENI    =            C.CODICE_FOTOGRAFIA_TERRENI
                 AND     A.ID_AZIENDA IN (    SELECT  D.ID_AZIENDA_ASSOCIATA
                                                FROM DB_AZIENDA_COLLEGATA D  -- Questi sono i soci presenti sul piano lavorazione all'azienda
                                         WHERE ID_AZIENDA                =     P_ID_AZIENDA
                                         AND     D.DATA_FINE_VALIDITA IS NULL
                                         AND     (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= D.DATA_INIZIO_VALIDITA OR nAnnoCampagna IS NULL)                                     )                                                            -- Per le correttive il sistema considera i soci attivi all'anno della correttiva.
                AND C.ID_PARTICELLA                        =            TBL1.ID_PARTICELLA                                           -- Verifico se un socio
                AND C.ID_TITOLO_POSSESSO                 NOT IN     (5,6)                                            -- ha dichiarato la medesima particella
                );



CURSOR CUR_COND    (pIdParticella IN NUMBER )    IS
                                SELECT ID_CONDUZIONE_PARTICELLA
                                FROM     DB_CONDUZIONE_PARTICELLA A,
                                        DB_UTE B
                                WHERE A.DATA_FINE_CONDUZIONE     IS NULL
                                AND     A.ID_PARTICELLA             =     pIdParticella
                                AND    B.DATA_FINE_ATTIVITA     IS NULL
                                AND     B.ID_UTE                     =     A.ID_UTE
                                AND     B.ID_AZIENDA                 =     P_ID_AZIENDA
                                AND   A.ID_TITOLO_POSSESSO        =    6;


S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
s_sezione            VARCHAR2(20);
s_sub                    VARCHAR2(20);
vSoci                    VARCHAR2(50);


BEGIN


    SELECT NVL(B.LABEL_ELENCO_ASSOCIATI ,'''Elenco soci') INTO  vSoci
    FROM DB_AZIENDA a,
         DB_TIPO_FORMA_ASSOCIATA b
    WHERE A.ID_TIPO_FORMA_ASSOCIATA    =    B.ID_TIPO_FORMA_ASSOCIATA(+)
    AND A.ID_AZIENDA                        =    P_ID_AZIENDA;


    FOR REC_P IN CUR_PAR LOOP
          SELECT DECODE(REC_P.SEZIONE, NULL, '', ' Sz: '|| REC_P.SEZIONE) INTO S_SEZIONE FROM DUAL;

        SELECT DECODE(REC_P.subalterno, NULL, '', ' Sub: '|| REC_P.SUBALTERNO) INTO s_sub FROM dual;

         S_DESCRIZIONE := '[' || REC_P.DESCOM || S_SEZIONE ||' Fgl:' || REC_P.FOGLIO ||
                                ' Part:'||REC_P.PARTICELLA || s_sub ||'] La particella conferita non è in conduzione ad alcuna azienda dell'||vSoci;


        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
              P_BLOCCANTE, REC_P.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
          END IF;

        FOR REC_C IN CUR_COND(REC_P.ID_PARTICELLA ) LOOP
            IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, p_bloccante,
                 REC_C.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                  RETURN (FALSE);
            END IF;
        END LOOP;
    END LOOP;

    RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONFERIMENTO_DA_SOCI: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);


END CONFERIMENTO_DA_SOCI;


----------------
-- 222

FUNCTION CONFERIMENTO_ULTIMA_DC_DA_SOCI     (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                           P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                           P_BLOCCANTE          IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                           P_MSGERR       IN OUT VARCHAR2,
                                                          P_CODERR             IN OUT VARCHAR2) RETURN BOOLEAN IS

CURSOR CUR_UD IS
            SELECT TBL1.* FROM
            (    SELECT C.ID_PARTICELLA, C.ID_STORICO_PARTICELLA, C.SEZIONE, D.ISTAT_COMUNE,D.DESCOM, C.FOGLIO, C.PARTICELLA, C.SUBALTERNO
                FROM   DB_UTE A,
                       DB_CONDUZIONE_PARTICELLA B,
                       DB_STORICO_PARTICELLA C,
                       COMUNE D
                WHERE A.DATA_FINE_ATTIVITA         IS NULL
                      AND A.ID_AZIENDA                =    P_ID_AZIENDA
                      AND A.ID_UTE                    =    B.ID_UTE
                      AND B.DATA_FINE_CONDUZIONE IS NULL
                      AND B.ID_TITOLO_POSSESSO    =    6
                      AND B.ID_PARTICELLA            =    C.ID_PARTICELLA
                      AND C.DATA_FINE_VALIDITA     IS NULL
                      AND C.COMUNE                    =    D.ISTAT_COMUNE
                        GROUP BY C.ID_PARTICELLA, C.ID_STORICO_PARTICELLA, C.SEZIONE, D.ISTAT_COMUNE,D.DESCOM, C.FOGLIO, C.PARTICELLA, C.SUBALTERNO
            ) TBL1
            WHERE NOT EXISTS
            (
                SELECT C.ID_PARTICELLA                                                                -- Considero per ogni socio solamente l'ultima dichiarazione
                FROM DB_DICHIARAZIONE_CONSISTENZA A ,                                                 -- di consistenza
                     DB_CONDUZIONE_DICHIARATA C
                WHERE A.CODICE_FOTOGRAFIA_TERRENI=C.CODICE_FOTOGRAFIA_TERRENI
              AND A.DATA_INSERIMENTO_DICHIARAZIONE     =    (    SELECT MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
                                                                FROM       DB_DICHIARAZIONE_CONSISTENZA DC,
                                                                          DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                              WHERE DC.id_azienda = A.id_azienda
                                                            AND   (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DC.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                                            AND   DC.ID_MOTIVO_DICHIARAZIONE <> 7
                                                            AND   TI.ID_MOTIVO_DICHIARAZIONE = DC.ID_MOTIVO_DICHIARAZIONE
                                                            AND   TI.TIPO_DICHIARAZIONE    != 'C'
                                                          )
                 AND A.ID_AZIENDA IN (    SELECT  D.ID_AZIENDA_ASSOCIATA
                                            FROM DB_AZIENDA_COLLEGATA D  -- Questi sono i soci presenti sul piano
                                    WHERE D.ID_AZIENDA= P_ID_AZIENDA            -- in lavorazione all'azienda
                                     AND D.DATA_FINE_VALIDITA IS NULL
                                     AND (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= D.DATA_INIZIO_VALIDITA OR nAnnoCampagna IS NULL)
                                        )
                  AND C.ID_PARTICELLA=TBL1.ID_PARTICELLA                                           -- Verifico se un socio
                 AND C.ID_TITOLO_POSSESSO NOT IN (5,6)                                            -- ha dichiarato la medesima particella
            );                                                                                     -- con titolo di possesso diverso da asservimento, conferimento;

CURSOR CUR_COND    (pIdParticella IN NUMBER )    IS
                                SELECT ID_CONDUZIONE_PARTICELLA
                                FROM     DB_CONDUZIONE_PARTICELLA A,
                                        DB_UTE B
                                WHERE A.DATA_FINE_CONDUZIONE     IS NULL
                                AND     A.ID_PARTICELLA             =     pIdParticella
                                AND    B.DATA_FINE_ATTIVITA     IS NULL
                                AND     B.ID_UTE                     =     A.ID_UTE
                                AND     B.ID_AZIENDA                 =     P_ID_AZIENDA
                                AND   A.ID_TITOLO_POSSESSO        =    6;

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
s_sezione            VARCHAR2(20);
s_sub                    VARCHAR2(20);
nValLmite            NUMBER;
vSoci                    VARCHAR2(50);

BEGIN

    SELECT NVL(B.LABEL_ELENCO_ASSOCIATI ,'''Elenco soci') INTO  vSoci
    FROM DB_AZIENDA a,
         DB_TIPO_FORMA_ASSOCIATA b
    WHERE A.ID_TIPO_FORMA_ASSOCIATA    =    B.ID_TIPO_FORMA_ASSOCIATA(+)
    AND A.ID_AZIENDA                        =    P_ID_AZIENDA;


    FOR REC_P IN CUR_UD LOOP
          SELECT DECODE(REC_P.SEZIONE, NULL, '', ' Sz: '|| REC_P.SEZIONE) INTO S_SEZIONE FROM DUAL;

        SELECT DECODE(REC_P.subalterno, NULL, '', ' Sub: '|| REC_P.SUBALTERNO) INTO s_sub FROM dual;

         S_DESCRIZIONE := '[' || REC_P.DESCOM || S_SEZIONE ||' Fgl:' || REC_P.FOGLIO ||
                                ' Part:'||REC_P.PARTICELLA || s_sub ||'] La particella conferita non è stata dichiarata nell''ultima validazione delle aziende dell'||vSoci;


        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
              P_BLOCCANTE, REC_P.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
          END IF;

        FOR REC_C IN CUR_COND(REC_P.ID_PARTICELLA ) LOOP
            IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, p_bloccante,
                 REC_C.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                  RETURN (FALSE);
            END IF;
        END LOOP;
    END LOOP;



 RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONFERIMENTO_ULTIMA_DC_DA_SOCI: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);


END CONFERIMENTO_ULTIMA_DC_DA_SOCI;




----------------
-- 223

FUNCTION SUPERO_CONFERIMENTO     (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                           P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                           P_BLOCCANTE          IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                           P_MSGERR       IN OUT VARCHAR2,
                                           P_CODERR             IN OUT VARCHAR2) RETURN BOOLEAN IS


CURSOR CUR_PART IS
        SELECT     C.ID_PARTICELLA, C.ID_STORICO_PARTICELLA, C.SEZIONE, D.ISTAT_COMUNE,D.DESCOM, C.FOGLIO, C.PARTICELLA, C.SUBALTERNO, NVL(SUM(B.SUPERFICIE_CONDOTTA),0) SUP
        FROM       DB_UTE A,
                    DB_CONDUZIONE_PARTICELLA B,
                    DB_STORICO_PARTICELLA C,
                    COMUNE D
        WHERE A.DATA_FINE_ATTIVITA IS NULL
        AND A.ID_AZIENDA                =    P_ID_AZIENDA
        AND A.ID_UTE                    =    B.ID_UTE
        AND B.DATA_FINE_CONDUZIONE IS NULL
        AND B.ID_TITOLO_POSSESSO    =    6
        AND B.ID_PARTICELLA            =    C.ID_PARTICELLA
        AND C.DATA_FINE_VALIDITA     IS NULL
        AND C.COMUNE                    =    D.ISTAT_COMUNE
        GROUP BY C.ID_PARTICELLA, C.ID_STORICO_PARTICELLA, C.SEZIONE, D.ISTAT_COMUNE,D.DESCOM, C.FOGLIO, C.PARTICELLA, C.SUBALTERNO;

CURSOR CUR_COND    (pIdParticella IN NUMBER )    IS
                                SELECT ID_CONDUZIONE_PARTICELLA
                                FROM     DB_CONDUZIONE_PARTICELLA A,
                                        DB_UTE B
                                WHERE A.DATA_FINE_CONDUZIONE     IS NULL
                                AND     A.ID_PARTICELLA             =     pIdParticella
                                AND    B.DATA_FINE_ATTIVITA     IS NULL
                                AND     B.ID_UTE                     =     A.ID_UTE
                                AND     B.ID_AZIENDA                 =     P_ID_AZIENDA
                                AND   A.ID_TITOLO_POSSESSO        =    6;

                                                                             -- con titolo di possesso diverso da asservimento, conferimento
S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
s_sezione            VARCHAR2(20);
s_sub                    VARCHAR2(20);
nValLmite            NUMBER;
 nSupCond            NUMBER;
vSoci                    VARCHAR2(50);

BEGIN

    SELECT NVL(B.LABEL_ELENCO_ASSOCIATI ,'''Elenco soci') INTO  vSoci
    FROM DB_AZIENDA a,
         DB_TIPO_FORMA_ASSOCIATA b
    WHERE A.ID_TIPO_FORMA_ASSOCIATA    =    B.ID_TIPO_FORMA_ASSOCIATA(+)
    AND A.ID_AZIENDA                        =    P_ID_AZIENDA;



    FOR REC_PP IN  CUR_PART LOOP

        SELECT NVL(SUM(c.superficie_condotta),0)    INTO nSupCond                                                 -- Considero le ultime dichiarazioni
        FROM DB_DICHIARAZIONE_CONSISTENZA A ,                                                 -- di consistenza dei soci
             DB_CONDUZIONE_DICHIARATA C
        WHERE A.CODICE_FOTOGRAFIA_TERRENI=C.CODICE_FOTOGRAFIA_TERRENI
       AND A.DATA_INSERIMENTO_DICHIARAZIONE =    (SELECT MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
                                               FROM   DB_DICHIARAZIONE_CONSISTENZA DC,
                                                       DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                               WHERE DC.id_azienda                     =     A.id_azienda
                                               AND   (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DC.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                               AND   DC.ID_MOTIVO_DICHIARAZIONE     <> 7
                                               AND   TI.ID_MOTIVO_DICHIARAZIONE     =     DC.ID_MOTIVO_DICHIARAZIONE
                                               AND   TI.TIPO_DICHIARAZIONE            != 'C'
                                              )
             AND A.ID_AZIENDA IN (    SELECT  D.ID_AZIENDA_ASSOCIATA
                                            FROM DB_AZIENDA_COLLEGATA D  -- Questi sono i soci presenti sul piano in lavorazione all'azienda
                                   WHERE D.ID_AZIENDA            =    P_ID_AZIENDA
                                     AND D.DATA_FINE_VALIDITA     IS NULL
                                     AND (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= D.DATA_INIZIO_VALIDITA OR nAnnoCampagna IS NULL)
                                         )
             AND C.ID_PARTICELLA        =    REC_PP.ID_PARTICELLA                                                          -- CONSIDERO I SOCI CHE
             AND C.ID_TITOLO_POSSESSO NOT IN (5,6);                                           -- hanno dichiarato la medesima particella

        IF REC_PP.SUP > nSupCond THEN

            SELECT DECODE(REC_PP.SEZIONE, NULL, '', ' Sz: '||REC_PP.SEZIONE) INTO S_SEZIONE FROM DUAL;

            SELECT DECODE(REC_PP.subalterno, NULL, '', ' Sub: '|| REC_PP.SUBALTERNO) INTO s_sub FROM dual;

             S_DESCRIZIONE := '[' || REC_PP.DESCOM || S_SEZIONE ||' Fgl:' || REC_PP.FOGLIO ||
                                ' Part:'||REC_PP.PARTICELLA || s_sub ||'] La superficie conferita di '||TO_CHAR(REC_PP.SUP,'999G990D9999') ||' (ha) è superiore a quella presente nell''ultima validazione '||TO_CHAR(nSupCond,'999G990D9999') ||' (ha) delle aziende dell'||vSoci;


            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                                                  P_BLOCCANTE, REC_PP.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
              END IF;

            FOR REC_C IN CUR_COND(REC_PP.ID_PARTICELLA ) LOOP
                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, p_bloccante,
                     REC_C.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                      RETURN (FALSE);
                END IF;
            END LOOP;

        END IF;
    END LOOP;

 RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE SUPERO_CONFERIMENTO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);


END SUPERO_CONFERIMENTO;



----------------
-- 224

FUNCTION VARIETA_CONFERITA     (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                       P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE          IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR             IN OUT VARCHAR2) RETURN BOOLEAN IS


CURSOR CUR_PART IS    SELECT     C.ID_PARTICELLA,
                                        C.ID_STORICO_PARTICELLA,
                                        E.ID_UTILIZZO,
                                        E.ID_VARIETA,
                                        D.ISTAT_COMUNE,
                                        C.SEZIONE,
                                        D.DESCOM,
                                       C.FOGLIO,
                                        C.PARTICELLA,
                                        C.SUBALTERNO,
                                        F.CODICE,
                                        F.DESCRIZIONE            DESC_UTIL,
                                        G.CODICE_VARIETA        CODICE_VARIETA,
                                        G.DESCRIZIONE            DES_VAR
                            FROM   DB_UTE                             A,
                                   DB_CONDUZIONE_PARTICELLA     B,
                                   DB_STORICO_PARTICELLA         C,
                                   COMUNE                             D,
                                   DB_UTILIZZO_PARTICELLA     E,
                                   DB_TIPO_UTILIZZO             F,
                                   DB_TIPO_VARIETA                 G,DB_R_CATALOGO_MATRICE CM
                            WHERE A.DATA_FINE_ATTIVITA                 IS NULL
                                  AND A.ID_AZIENDA                        =    P_ID_AZIENDA
                                  AND A.ID_UTE                            =    B.ID_UTE
                                  AND B.DATA_FINE_CONDUZIONE         IS NULL
                                  AND B.ID_TITOLO_POSSESSO            =    6
                                  AND B.ID_PARTICELLA                    =    C.ID_PARTICELLA
                                  AND C.DATA_FINE_VALIDITA             IS NULL
                                  AND C.COMUNE                            =    D.ISTAT_COMUNE
                                  AND B.ID_CONDUZIONE_PARTICELLA    =    E.ID_CONDUZIONE_PARTICELLA(+)
                                  AND E.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE(+) 
                                  AND CM.ID_UTILIZZO                        =    F.ID_UTILIZZO(+) 
                                  AND CM.ID_VARIETA                        =    G.ID_VARIETA(+); 
--                            GROUP BY C.ID_PARTICELLA, C.ID_STORICO_PARTICELLA, C.SEZIONE, D.ISTAT_COMUNE,D.DESCOM, C.FOGLIO, C.PARTICELLA, C.SUBALTERNO, E.ID_UTILIZZO, E.ID_VARIETA, F.CODICE, F.DESCRIZIONE, G.CODICE_VARIETA, G.DESCRIZIONE;



CURSOR CUR_COND    (pIdParticella IN NUMBER )    IS
                                SELECT ID_CONDUZIONE_PARTICELLA
                                FROM     DB_CONDUZIONE_PARTICELLA A,
                                        DB_UTE B
                                WHERE A.DATA_FINE_CONDUZIONE     IS NULL
                                AND     A.ID_PARTICELLA             =     pIdParticella
                                AND    B.DATA_FINE_ATTIVITA     IS NULL
                                AND     B.ID_UTE                     =     A.ID_UTE
                                AND     B.ID_AZIENDA                 =     P_ID_AZIENDA
                                AND   A.ID_TITOLO_POSSESSO        =    6;

                                                                                     -- con titolo di possesso diverso da asservimento, conferimento



S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
s_sezione            VARCHAR2(20);
s_sub                    VARCHAR2(20);
nValLmite            NUMBER;
nSupCond                NUMBER;
vSoci                    VARCHAR2(50);
nCountP                NUMBER;

BEGIN

    SELECT NVL(B.LABEL_ELENCO_ASSOCIATI ,'''Elenco soci') INTO  vSoci
    FROM DB_AZIENDA a,
         DB_TIPO_FORMA_ASSOCIATA b
    WHERE A.ID_TIPO_FORMA_ASSOCIATA    =    B.ID_TIPO_FORMA_ASSOCIATA(+)
    AND A.ID_AZIENDA                        =    P_ID_AZIENDA;



    FOR REC_PP IN  CUR_PART LOOP

        SELECT COUNT(*) INTO nCountP                                                            -- Considero le ultime dichiarazioni
        FROM     DB_DICHIARAZIONE_CONSISTENZA A ,                                                 -- di consistenza dei soci
                 DB_CONDUZIONE_DICHIARATA C,
                 DB_UTILIZZO_DICHIARATO D
        WHERE A.CODICE_FOTOGRAFIA_TERRENI=C.CODICE_FOTOGRAFIA_TERRENI
      AND C.ID_CONDUZIONE_DICHIARATA=D.ID_CONDUZIONE_DICHIARATA(+)
         AND A.DATA_INSERIMENTO_DICHIARAZIONE =(    SELECT MAX(DC.DATA_INSERIMENTO_DICHIARAZIONE)
                                                    FROM   DB_DICHIARAZIONE_CONSISTENZA DC,
                                                         DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                 WHERE DC.id_azienda                         =     A.id_azienda
                                                 AND   (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= DC.DATA_INSERIMENTO_DICHIARAZIONE OR nAnnoCampagna IS NULL)
                                                 AND   DC.ID_MOTIVO_DICHIARAZIONE     <> 7
                                                 AND   TI.ID_MOTIVO_DICHIARAZIONE     =     DC.ID_MOTIVO_DICHIARAZIONE
                                                 AND   TI.TIPO_DICHIARAZIONE            != 'C'
                                             )
         AND A.ID_AZIENDA IN (    SELECT  D.ID_AZIENDA_ASSOCIATA
                                        FROM DB_AZIENDA_COLLEGATA D  -- Questi sono i soci presenti sul piano
                                 WHERE  D.ID_AZIENDA            =    P_ID_AZIENDA                                                       -- in lavorazione all'azienda
                                 AND D.DATA_FINE_VALIDITA     IS NULL
                                 AND (TO_DATE('31/12/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= D.DATA_INIZIO_VALIDITA OR nAnnoCampagna IS NULL)
                                    )
         AND C.ID_PARTICELLA            =            REC_PP.ID_PARTICELLA                                                          -- CONSIDERO I SOCI CHE
         AND C.ID_TITOLO_POSSESSO     NOT IN     (5,6)                                           -- hanno dichiarato la medesima particella
         AND NVL(D.ID_UTILIZZO,-1)    =            NVL(REC_PP.ID_UTILIZZO,-1)                                         -- Utilizzo della particella da ricercare
         AND NVL(D.ID_VARIETA,-1)    =            NVL(REC_PP.ID_VARIETA,-1);
                                          -- Varieta della particella da ricercare

        IF nCountP  = 0  THEN

            SELECT DECODE(REC_PP.SEZIONE, NULL, '', ' Sz: '||REC_PP.SEZIONE) INTO S_SEZIONE FROM DUAL;

            SELECT DECODE(REC_PP.subalterno, NULL, '', ' Sub: '|| REC_PP.SUBALTERNO) INTO s_sub FROM dual;

             S_DESCRIZIONE := '[' || REC_PP.DESCOM || S_SEZIONE ||' Fgl:' || REC_PP.FOGLIO ||
                                ' Part:'||REC_PP.PARTICELLA || s_sub ||'] L''uso del suolo ['||REC_PP.CODICE_VARIETA||'] '||REC_PP.DES_VAR||' non trova riscontro nell''ultima validazione delle aziende dell'||vSoci;


            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                                                  P_BLOCCANTE, REC_PP.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
              END IF;

            FOR REC_C IN CUR_COND(REC_PP.ID_PARTICELLA ) LOOP
                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, p_bloccante,
                     REC_C.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                      RETURN (FALSE);
                END IF;
            END LOOP;

        END IF;
    END LOOP;

 RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE VARIETA_CONFERITA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);


END VARIETA_CONFERITA;

-- 617
FUNCTION VALIDITA_TIPOLOGIA_VINI (P_ID_AZIENDA       IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                               P_ID_CONTROLLO     IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                               P_BLOCCANTE          IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                               P_MSGERR           IN OUT VARCHAR2,
                                               P_CODERR               IN OUT VARCHAR2) RETURN BOOLEAN IS

v_descrizione_errore            VARCHAR2(1000);

s_sezione                        VARCHAR2(20);
s_sub                                VARCHAR2(20);

nIdConduzioneParticellaOld        DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
nIdStoricoUnitaArboreaOld        DB_STORICO_UNITA_ARBOREA.ID_STORICO_UNITA_ARBOREA%TYPE;

CURSOR CUR_VIT IS SELECT     PA.ID_CONDUZIONE_PARTICELLA,
                                    AR.ID_STORICO_UNITA_ARBOREA,
                                    ID_STORICO_PARTICELLA,
                                    SEZIONE,
                                    SUBALTERNO,
                                    FOGLIO,
                                    DESCOM,
                                    PARTICELLA,
                                    PROGR_UNAR,
                                    DESCRIZIONE
                        FROM     DB_STORICO_UNITA_ARBOREA     AR,
                                DB_TIPO_TIPOLOGIA_VINO         VI,
                                DB_CONDUZIONE_PARTICELLA    PA,
                                DB_UTE                            UT,
                                DB_STORICO_PARTICELLA        ST,
                                COMUNE                            CO
                        WHERE AR.ID_AZIENDA                =     P_ID_AZIENDA
                        AND    AR.DATA_FINE_VALIDITA     IS NULL
                        AND    AR.ID_TIPOLOGIA_UNAR        =    2
                        AND    AR.ID_TIPOLOGIA_VINO     =     VI.ID_TIPOLOGIA_VINO
                        AND    VI.DATA_FINE_VALIDITA     IS NOT NULL
                        AND    PA.ID_PARTICELLA            =    AR.ID_PARTICELLA
                        AND    PA.DATA_FINE_CONDUZIONE IS NULL
                        AND    UT.ID_UTE                    =    PA.ID_UTE
                        AND    UT.DATA_FINE_ATTIVITA     IS NULL
                        AND    UT.ID_AZIENDA                =     P_ID_AZIENDA
                        AND    ST.ID_PARTICELLA            =    AR.ID_PARTICELLA
                        AND    ST.DATA_FINE_VALIDITA    IS NULL
                        AND    CO.ISTAT_COMUNE            = ST.COMUNE;

BEGIN

nIdConduzioneParticellaOld        := 0;
nIdStoricoUnitaArboreaOld        := 0;

    FOR REC_V IN CUR_VIT LOOP

        SELECT DECODE(REC_V.SEZIONE, NULL, '', ' Sz: '|| REC_V.SEZIONE)
        INTO s_sezione
        FROM DUAL;

        SELECT DECODE(REC_V.SUBALTERNO, NULL, '', ' Sub: '|| REC_V.SUBALTERNO)
        INTO s_sub
        FROM DUAL;


        IF nIdConduzioneParticellaOld = 0 THEN
            v_descrizione_errore := '['||REC_V.DESCOM||s_sezione||' Fgl:'||REC_V.FOGLIO||' Part:'||REC_V.PARTICELLA||s_sub||' Progr: '||REC_V.PROGR_UNAR||'].';
            v_descrizione_errore    := v_descrizione_errore||'La tipologia di vino '||REC_V.DESCRIZIONE||', dichiarata nei dati di iscrizione albo risulta non piu'' valida.';

             IF NOT SCRIVI_SEGNALAZIONE (    P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                                                       P_BLOCCANTE, REC_V.ID_STORICO_PARTICELLA, REC_V.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
             END IF;

        END IF;

        IF nIdConduzioneParticellaOld        != REC_V.ID_CONDUZIONE_PARTICELLA    THEN

            v_descrizione_errore := '['||REC_V.DESCOM||s_sezione||' Fgl:'||REC_V.FOGLIO||' Part:'||REC_V.PARTICELLA||s_sub||' Progr: '||REC_V.PROGR_UNAR||'].';
            v_descrizione_errore := v_descrizione_errore||' La tipologia di vino '||REC_V.DESCRIZIONE||', dichiarata nei dati di iscrizione albo, risulta non piu'' valida.';

            IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                                                                P_BLOCCANTE, REC_V.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
            END IF;

        END IF;


        IF nIdStoricoUnitaArboreaOld        != REC_V.ID_STORICO_UNITA_ARBOREA    THEN

            v_descrizione_errore := '['||REC_V.DESCOM||s_sezione||' Fgl:'||REC_V.FOGLIO||' Part:'||REC_V.PARTICELLA||s_sub||' Progr: '||REC_V.PROGR_UNAR||'].';
             v_descrizione_errore := v_descrizione_errore||' La tipologia di vino '||REC_V.DESCRIZIONE||', dichiarata nei dati di iscrizione albo risulta non piu'' valida.';

            IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                                                         P_BLOCCANTE, REC_V.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
             END IF;

        END IF;

        nIdConduzioneParticellaOld        := REC_V.ID_CONDUZIONE_PARTICELLA;
        nIdStoricoUnitaArboreaOld        := REC_V.ID_STORICO_UNITA_ARBOREA;

    END LOOP;

    RETURN TRUE;

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'VALIDITA_TIPOLOGIA_VINI: ' || SQLERRM;
       p_CodErr   := SQLCODE;
        RETURN FALSE;
END VALIDITA_TIPOLOGIA_VINI;

-- 618
FUNCTION DATI_UV_ERRATI (P_ID_AZIENDA       IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                   P_ID_CONTROLLO     IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                   P_BLOCCANTE          IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                   P_MSGERR           IN OUT VARCHAR2,
                                   P_CODERR               IN OUT VARCHAR2) RETURN BOOLEAN IS


    -- suddiviso il cursore in tre parti
    -- 1 select per UV senza DATA_IMPIANTO e DATA_SOVRAINNESTO valorizzate
    -- 2 select per UV con DATA_IMPIANTO valorizzata e DATA_SOVRAINNESTO non valorizzata e DATA_IMPIANTO non congruente con ANNO_PRIMA_PRODUZIONE
    -- 3 select per UV con DATA_IMPIANTO valorizzata e DATA_SOVRAINNESTO valorizzata e DATA_SOVRAINNESTO non congruente con ANNO_PRIMA_PRODUZIONE
    CURSOR CUR_UV IS
    SELECT AR.ID_STORICO_UNITA_ARBOREA,
           AR.ID_PARTICELLA,
           ST.ID_STORICO_PARTICELLA,
           ST.SEZIONE,
           ST.SUBALTERNO,
           ST.FOGLIO,
           CO.DESCOM,
           ST.PARTICELLA,
           AR.PROGR_UNAR,
           NVL(TO_CHAR(DATA_IMPIANTO,'YYYY'),0) AS ANNO_IMPIANTO,
           NVL(AR.ANNO_PRIMA_PRODUZIONE,0) ANNO_PRIMA_PRODUZIONE,
           CASE WHEN TO_CHAR(DATA_IMPIANTO,'MM') <= knMeseLuglio
           THEN 2
           ELSE 3
           END AS ANNO_OFFSET
      FROM DB_STORICO_UNITA_ARBOREA AR,
           DB_STORICO_PARTICELLA ST,
           COMUNE CO
     WHERE AR.ID_AZIENDA = P_ID_AZIENDA
       AND AR.DATA_FINE_VALIDITA IS NULL
       AND AR.ID_TIPOLOGIA_UNAR = 2
       AND AR.DATA_IMPIANTO IS NULL
       AND AR.DATA_SOVRAINNESTO IS NULL
       AND ST.ID_PARTICELLA = AR.ID_PARTICELLA
       AND ST.DATA_FINE_VALIDITA IS NULL
       AND CO.ISTAT_COMUNE = ST.COMUNE /* MS 25/08/2010 re inserita la parte relativa al filtro x conduzione attiva */
       AND EXISTS (SELECT CP.ID_CONDUZIONE_PARTICELLA
                     FROM DB_CONDUZIONE_PARTICELLA CP,
                          DB_UTE U
                    WHERE CP.DATA_FINE_CONDUZIONE IS NULL
                      AND CP.ID_TITOLO_POSSESSO NOT IN (5,6)
                      AND CP.ID_UTE = U.ID_UTE
                      AND U.ID_AZIENDA = P_ID_AZIENDA
                      AND U.DATA_FINE_ATTIVITA IS NULL
                      AND CP.ID_PARTICELLA = AR.ID_PARTICELLA)

    UNION ALL

    SELECT AR.ID_STORICO_UNITA_ARBOREA,
           AR.ID_PARTICELLA,
           ST.ID_STORICO_PARTICELLA,
           ST.SEZIONE,
           ST.SUBALTERNO,
           ST.FOGLIO,
           CO.DESCOM,
           ST.PARTICELLA,
           AR.PROGR_UNAR,
           NVL(TO_CHAR(DATA_IMPIANTO,'YYYY'),0) AS ANNO_IMPIANTO,
           NVL(AR.ANNO_PRIMA_PRODUZIONE,0) ANNO_PRIMA_PRODUZIONE,
           CASE WHEN TO_CHAR(DATA_IMPIANTO,'MM') <= knMeseLuglio
           THEN 2
           ELSE 3
           END AS ANNO_OFFSET
      FROM DB_STORICO_UNITA_ARBOREA AR,
           DB_STORICO_PARTICELLA ST,
           COMUNE CO
     WHERE AR.ID_AZIENDA = P_ID_AZIENDA
       AND AR.DATA_FINE_VALIDITA IS NULL
       AND AR.ID_TIPOLOGIA_UNAR = 2
       AND AR.DATA_IMPIANTO IS NOT NULL
       AND AR.DATA_SOVRAINNESTO IS NULL
       AND ((TO_CHAR(DATA_IMPIANTO,'MM') <= knMeseLuglio AND 
                 NVL(AR.ANNO_PRIMA_PRODUZIONE,0) < NVL(TO_CHAR(AR.DATA_IMPIANTO,'YYYY'),0) + 2) OR
            (TO_CHAR(DATA_IMPIANTO,'MM') > knMeseLuglio AND
                 NVL(AR.ANNO_PRIMA_PRODUZIONE,0) < NVL(TO_CHAR(AR.DATA_IMPIANTO,'YYYY'),0)+ 3))
       AND ST.ID_PARTICELLA = AR.ID_PARTICELLA
       AND ST.DATA_FINE_VALIDITA IS NULL
       AND CO.ISTAT_COMUNE = ST.COMUNE /* MS 25/08/2010 re inserita la parte relativa al filtro x conduzione attiva */
       AND EXISTS (SELECT CP.ID_CONDUZIONE_PARTICELLA
                     FROM DB_CONDUZIONE_PARTICELLA CP,
                          DB_UTE U
                    WHERE CP.DATA_FINE_CONDUZIONE IS NULL
                      AND CP.ID_TITOLO_POSSESSO NOT IN (5,6)
                      AND CP.ID_UTE = U.ID_UTE
                      AND U.ID_AZIENDA = P_ID_AZIENDA
                      AND U.DATA_FINE_ATTIVITA IS NULL
                      AND CP.ID_PARTICELLA = AR.ID_PARTICELLA)
    UNION ALL
    SELECT AR.ID_STORICO_UNITA_ARBOREA,
           AR.ID_PARTICELLA,
           ST.ID_STORICO_PARTICELLA,
           ST.SEZIONE,
           ST.SUBALTERNO,
           ST.FOGLIO,
           CO.DESCOM,
           ST.PARTICELLA,
           AR.PROGR_UNAR,
           NVL(TO_CHAR(DATA_SOVRAINNESTO,'YYYY'),0) AS ANNO_IMPIANTO,
           NVL(AR.ANNO_PRIMA_PRODUZIONE,0) ANNO_PRIMA_PRODUZIONE,
           CASE WHEN TO_CHAR(DATA_SOVRAINNESTO,'MM') <= knMeseLuglio
           THEN 1
           ELSE 2
           END AS ANNO_OFFSET
      FROM DB_STORICO_UNITA_ARBOREA AR,
           DB_STORICO_PARTICELLA ST,
           COMUNE CO
     WHERE AR.ID_AZIENDA = P_ID_AZIENDA
       AND AR.DATA_FINE_VALIDITA IS NULL
       AND AR.ID_TIPOLOGIA_UNAR = 2
       AND AR.DATA_SOVRAINNESTO IS NOT NULL
       AND ((TO_CHAR(DATA_SOVRAINNESTO,'MM') <= knMeseLuglio AND 
                 NVL(AR.ANNO_PRIMA_PRODUZIONE,0) < NVL(TO_CHAR(AR.DATA_SOVRAINNESTO,'YYYY'),0) + 1) OR
            (TO_CHAR(DATA_SOVRAINNESTO,'MM') > knMeseLuglio AND
                 NVL(AR.ANNO_PRIMA_PRODUZIONE,0) < NVL(TO_CHAR(AR.DATA_SOVRAINNESTO,'YYYY'),0)+ 2))
       AND ST.ID_PARTICELLA = AR.ID_PARTICELLA
       AND ST.DATA_FINE_VALIDITA IS NULL
       AND CO.ISTAT_COMUNE = ST.COMUNE /* MS 25/08/2010 re inserita la parte relativa al filtro x conduzione attiva */
       AND EXISTS (SELECT CP.ID_CONDUZIONE_PARTICELLA
                     FROM DB_CONDUZIONE_PARTICELLA CP,
                          DB_UTE U
                    WHERE CP.DATA_FINE_CONDUZIONE IS NULL
                      AND CP.ID_TITOLO_POSSESSO NOT IN (5,6)
                      AND CP.ID_UTE = U.ID_UTE
                      AND U.ID_AZIENDA = P_ID_AZIENDA
                      AND U.DATA_FINE_ATTIVITA IS NULL
                      AND CP.ID_PARTICELLA = AR.ID_PARTICELLA)
  ORDER BY DESCOM, SEZIONE, FOGLIO, PARTICELLA, SUBALTERNO, PROGR_UNAR;

    CURSOR curConduzioniParticella(pIdParticella IN DB_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT CP.ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA CP, DB_UTE U
     WHERE CP.ID_PARTICELLA = pIdParticella
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_UTE = U.ID_UTE
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND U.id_azienda = P_ID_AZIENDA
       AND cp.ID_TITOLO_POSSESSO NOT IN (5,6);


v_descrizione_errore    VARCHAR2(1000);
vMessaggio              VARCHAR2(500);
s_sezione                VARCHAR2(20);
s_sub                    VARCHAR2(20);

BEGIN

    FOR REC_V IN CUR_UV LOOP

        -- se anno impianto minore di 1900 dove apposita anomalia
        IF NVL(REC_V.ANNO_IMPIANTO,0) < 1900 THEN
           vMessaggio := ' L''anno impianto '||REC_V.ANNO_IMPIANTO|| ' dell''unità vitata, deve essere maggiore o uguale a 1900.';
        ELSE
           -- altrimenti sono nel caso in cui l'anno di prima produzione non coincide con l'anno impianto + 2 o 3 anni di offset a seconda del mese di impianto
           vMessaggio := ' L''anno prima produzione : ' || REC_V.ANNO_PRIMA_PRODUZIONE || ' dell''unità vitata dev''essere uguale o successivo al : ' || TO_CHAR(REC_V.ANNO_IMPIANTO + REC_V.ANNO_OFFSET);
        END IF;


        SELECT DECODE(REC_V.SEZIONE, NULL, '', ' Sz: '|| REC_V.SEZIONE)
        INTO s_sezione
        FROM DUAL;

        SELECT DECODE(REC_V.SUBALTERNO, NULL, '', ' Sub: '|| REC_V.SUBALTERNO)
        INTO s_sub
        FROM DUAL;

        v_descrizione_errore := '['||REC_V.DESCOM||s_sezione||' Fgl:'||REC_V.FOGLIO||' Part:'||REC_V.PARTICELLA||s_sub||' Progr: '||REC_V.PROGR_UNAR||'].';
        v_descrizione_errore := v_descrizione_errore || vMessaggio;

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                                    P_BLOCCANTE, REC_V.ID_STORICO_PARTICELLA, REC_V.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        FOR recConduzioniParticella IN curConduzioniParticella(REC_V.ID_PARTICELLA) LOOP
            IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                                                   P_BLOCCANTE, recConduzioniParticella.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
        END LOOP;

        IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                                         P_BLOCCANTE, REC_V.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;

    END LOOP;

    RETURN TRUE;

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'DATI_UV_ERRATI: ' || SQLERRM;
           p_CodErr   := SQLCODE;
        RETURN FALSE;
END DATI_UV_ERRATI;




-- Aggiunto verifica se gli ATECO secondari sono attivi con AtecoSec
FUNCTION CONTROLLO_CODICE_ATECO  (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                P_BLOCCANTE          IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                P_MSGERR       IN OUT VARCHAR2,
                                                P_CODERR               IN OUT VARCHAR2) RETURN BOOLEAN IS

v_descrizione_errore            VARCHAR2(1000);
nAteco                          NUMBER;
nAtecoSec                       NUMBER;   
EXC_CALCOLO_INE    EXCEPTION;
BEGIN
    SELECT COUNT(*) INTO nAteco
    FROM     DB_ANAGRAFICA_AZIENDA    ANA,
            DB_TIPO_ATTIVITA_ATECO    ATE
    WHERE ANA.ID_AZIENDA             = P_ID_AZIENDA
    AND      ANA.DATA_FINE_VALIDITA    IS NULL
    AND    ATE.ID_ATTIVITA_ATECO    = ANA.ID_ATTIVITA_ATECO
    AND    ATE.DATA_FINE_VALIDITA    IS NOT NULL
    AND    ( TO_DATE('01/01/'||NVL(nAnnoCampagna,'1940'),'DD/MM/YYYY') NOT BETWEEN ATE.data_inizio_validita AND NVL(ATE.data_fine_validita,SYSDATE)
            OR nAnnoCampagna IS NULL
            );

    SELECT COUNT(*)
      INTO nAtecoSec
    FROM   DB_ANAGRAFICA_AZIENDA    ANA,
           DB_AZIENDA_ATECO_SEC     AAS,DB_TIPO_ATTIVITA_ATECO    ATE
    WHERE  ANA.ID_AZIENDA           =P_ID_AZIENDA
    AND    ANA.DATA_FINE_VALIDITA   IS NULL
    AND    AAS.ID_AZIENDA    = ANA.ID_AZIENDA
    AND    AAS.ID_ATTIVITA_ATECO    = ATE.ID_ATTIVITA_ATECO
    AND    AAS.DATA_FINE_VALIDITA   IS  NULL
    AND    ATE.DATA_FINE_VALIDITA    IS NOT NULL
    AND    (
           TO_DATE('01/01/'||NVL(nAnnoCampagna,'1940'),'DD/MM/YYYY') NOT BETWEEN AAS.data_inizio_validita AND NVL(AAS.data_fine_validita,SYSDATE)
               OR nAnnoCampagna IS NULL
           );

    IF nAteco > 0 THEN  
        v_descrizione_errore        := 'Il codice attività ATECO dell''azienda non è più attivo.';

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                    P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
        END IF;

    ELSIF nAtecoSec > 0 THEN
         v_descrizione_errore        := 'Il codice attività ATECO secondario dell''azienda non è più attivo.';
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                    P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
        END IF;

    END IF;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'CONTROLLO_CODICE_ATECO: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN FALSE;
END  CONTROLLO_CODICE_ATECO;

-- Aggiunto verifica che i codice attivita ATECO secondari utilizzati nelle
-- rispettive UTE attive dell'azienda siano attivi.
FUNCTION CONTROLLO_CODICE_ATECO_UTE  (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                    P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                    P_BLOCCANTE          IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                    P_MSGERR       IN OUT VARCHAR2,
                                                    P_CODERR               IN OUT VARCHAR2) RETURN BOOLEAN IS


v_descrizione_errore            VARCHAR2(1000);

EXC_CALCOLO_INE    EXCEPTION;

BEGIN

    FOR REC_U IN  (    SELECT DESCOM, 'ATECO' TIPO_ATE
                            FROM    DB_UTE                  UTE,
                                    DB_TIPO_ATTIVITA_ATECO  ATE,
                                    COMUNE                  COM
                            WHERE UTE.ID_AZIENDA             =     P_ID_AZIENDA
                            AND      UTE.DATA_FINE_ATTIVITA    IS NULL
                            AND    ATE.ID_ATTIVITA_ATECO    =     UTE.ID_ATTIVITA_ATECO
                            AND    COM.ISTAT_COMUNE            =    UTE.COMUNE
                            AND    ATE.DATA_FINE_VALIDITA    IS NOT NULL
                            AND    COM.FLAG_ESTINTO            =     'N'
                            AND    ( TO_DATE('01/01/'||NVL(nAnnoCampagna,'1940'),'DD/MM/YYYY') NOT BETWEEN ATE.data_inizio_validita AND NVL(ATE.data_fine_validita,SYSDATE)
                                        OR nAnnoCampagna IS NULL
                                    )
                        UNION
                        SELECT DESCOM, 'ATECO_SEC' TIPO_ATE
                            FROM    DB_UTE                        UTE,
                                    DB_UTE_ATECO_SECONDARI        UAS,
                                    DB_TIPO_ATTIVITA_ATECO        ATE,
                                    COMUNE                        COM
                            WHERE UTE.ID_AZIENDA            =     P_ID_AZIENDA
                              AND UTE.DATA_FINE_ATTIVITA IS NULL
                              AND UAS.ID_UTE               =      UTE.ID_UTE
                              AND COM.ISTAT_COMUNE         =      UTE.COMUNE
                              AND ATE.ID_ATTIVITA_ATECO    =      UAS.ID_ATTIVITA_ATECO
                              AND ATE.DATA_FINE_VALIDITA    IS NOT NULL
                              AND UAS.DATA_FINE_VALIDITA   IS NULL
                              AND COM.FLAG_ESTINTO         =     'N'
                              AND  ( TO_DATE('01/01/'||NVL(nAnnoCampagna,'1940'),'DD/MM/YYYY') NOT BETWEEN ATE.data_inizio_validita AND NVL(ATE.data_fine_validita,SYSDATE)
                                          OR nAnnoCampagna IS NULL
                                   )
                ) LOOP
                    IF REC_U.TIPO_ATE ='ATECO' THEN
                    v_descrizione_errore        := 'Nell''unita'' produttiva nel comune di '||REC_U.DESCOM||' il codice attivita'' ATECO non e'' piu'' attivo.';
                    ELSIF  REC_U.TIPO_ATE ='ATECO_SEC' THEN
                    v_descrizione_errore        := 'Nell''unita'' produttiva nel comune di '||REC_U.DESCOM||' il codice attivita'' ATECO Secondario non e'' piu'' attivo.';
                    END IF;

                    IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                            P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                            RETURN (FALSE);
                    END IF;

                END LOOP;
    RETURN TRUE;

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'CONTROLLO_CODICE_ATECO_UTE: ' || SQLERRM;
       p_CodErr   := SQLCODE;
        RETURN FALSE;

END  CONTROLLO_CODICE_ATECO_UTE;


---------------------------------------------
-- 118
FUNCTION DATI_ANAGRAFICI_SOGGETTO  (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                    P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                    P_BLOCCANTE          IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                    P_MSGERR       IN OUT VARCHAR2,
                                                    P_CODERR               IN OUT VARCHAR2) RETURN BOOLEAN IS


CURSOR CUR_SOGG IS    SELECT COGNOME, NOME, SESSO, NASCITA_DATA, NASCITA_COMUNE,MIN (B.ID_RUOLO) ID_RUOLO
                            FROM     DB_PERSONA_FISICA a,
                                    DB_CONTITOLARE b
                          WHERE A.ID_SOGGETTO         =     B.ID_SOGGETTO
                           AND     B.ID_RUOLO             != 1
                          AND     B.ID_AZIENDA         =     P_ID_AZIENDA
                          AND     B.DATA_FINE_RUOLO IS NULL
                            GROUP BY COGNOME, NOME, SESSO, NASCITA_DATA, NASCITA_COMUNE;

v_descrizione_errore            VARCHAR2(1000);
vDesRuolo                        DB_TIPO_RUOLO.descrizione%TYPE;
ERR_DATI                             EXCEPTION;

BEGIN
    FOR REC_S IN CUR_SOGG LOOP

        SELECT descrizione
        INTO vDesRuolo
        FROM DB_TIPO_RUOLO
        WHERE id_ruolo = REC_S.id_ruolo;



       IF TRIM(REC_S.COGNOME) IS NULL THEN
            v_descrizione_errore   := 'Il Cognome del '||vDesRuolo||' '||NVL(REC_S.COGNOME,' ')||' '||NVL(REC_S.NOME,' ')||' non e'' valorizzato o non valido';
          RAISE ERR_DATI;
        END IF;
       IF TRIM(REC_S.NOME) IS NULL THEN
            v_descrizione_errore   := 'Il Nome del '||vDesRuolo||' '||NVL(REC_S.COGNOME,' ')||' '||NVL(REC_S.NOME,' ')||' non e'' valorizzato o non valido';
          RAISE ERR_DATI;
        END IF;
       IF TRIM(REC_S.SESSO) IS NULL OR TRIM(REC_S.SESSO) NOT IN ('M', 'F') THEN
            v_descrizione_errore   := 'Il Sesso del '||vDesRuolo||' '||NVL(REC_S.COGNOME,' ')||' '||NVL(REC_S.NOME,' ')||' non e'' valorizzato o non valido';
          RAISE ERR_DATI;
        END IF;
       IF (TRIM(REC_S.NASCITA_DATA) IS NULL OR REC_S.NASCITA_DATA > TRUNC(SYSDATE)) THEN
            v_descrizione_errore   := 'La Data di nascita del '||vDesRuolo||' '||NVL(REC_S.COGNOME,' ')||' '||NVL(REC_S.NOME,' ')||' non e'' valorizzato o non valido';
          RAISE ERR_DATI;
        END IF;
       IF TRIM(REC_S.NASCITA_COMUNE) IS NULL OR NOT Pack_Controlli.FNCCONTROLLACOMUNE(TRIM(REC_S.NASCITA_COMUNE)) THEN
            v_descrizione_errore   := 'Il Comune di Nascita del '||vDesRuolo||' '||NVL(REC_S.COGNOME,' ')||' '||NVL(REC_S.NOME,' ')||' non e'' valorizzato o non valido';
          RAISE ERR_DATI;
        END IF;

    END LOOP;

    RETURN TRUE;

EXCEPTION
   WHEN ERR_DATI THEN
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
            P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;
        RETURN TRUE;
    WHEN OTHERS THEN
        p_MsgErr   := 'DATI_ANAGRAFICI_SOGGETTO: ' || SQLERRM;
       p_CodErr   := SQLCODE;
        RETURN FALSE;

END  DATI_ANAGRAFICI_SOGGETTO;

--------------------------------------------
-- 119
FUNCTION CODICE_FISCALE_SOGGETTO      (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                    P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                    P_BLOCCANTE          IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                    P_MSGERR       IN OUT VARCHAR2,
                                                    P_CODERR               IN OUT VARCHAR2) RETURN BOOLEAN IS


CURSOR CUR_SOGG IS    SELECT COGNOME, NOME, SESSO, NASCITA_DATA, NASCITA_COMUNE,CODICE_FISCALE,MIN (B.ID_RUOLO) ID_RUOLO
                            FROM     DB_PERSONA_FISICA a,
                                    DB_CONTITOLARE b,
                                    DB_TIPO_RUOLO r
                          WHERE A.ID_SOGGETTO         =     B.ID_SOGGETTO
                           AND     B.ID_RUOLO             != 1
                          AND     B.ID_AZIENDA         =     P_ID_AZIENDA
                          AND     B.DATA_FINE_RUOLO IS NULL
                            AND    B.id_ruolo            = R.id_ruolo
                            GROUP BY COGNOME, NOME, SESSO, NASCITA_DATA, NASCITA_COMUNE, CODICE_FISCALE;

v_descrizione_errore            VARCHAR2(1000);
ERR_DATI                             EXCEPTION;
vDesRuolo                        DB_TIPO_RUOLO.descrizione%TYPE;

BEGIN
    FOR REC_S IN CUR_SOGG LOOP


        SELECT descrizione
        INTO vDesRuolo
        FROM DB_TIPO_RUOLO
        WHERE id_ruolo = REC_S.id_ruolo;


       IF trim(REC_S.CODICE_FISCALE) IS NULL
        OR    NOT Pack_Controlli.fncCodiceFiscale( trim(REC_S.CODICE_FISCALE), REC_S.COGNOME, REC_S.NOME,  REC_S.NASCITA_COMUNE,REC_S.NASCITA_DATA, REC_S.SESSO)
        OR NOT Pack_Controlli.fncCheckDigit( trim(REC_S.CODICE_FISCALE)) THEN
            v_descrizione_errore   := 'Cod Fiscale del '||vDesRuolo||' '||NVL(REC_S.COGNOME,' ')||' '||NVL(REC_S.NOME,' ')||' non e'' valorizzato o non valido';
            RAISE ERR_DATI;
         END IF;

    END LOOP;

    RETURN TRUE;

EXCEPTION
   WHEN ERR_DATI THEN
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
            P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;
        RETURN TRUE;
    WHEN OTHERS THEN
        p_MsgErr   := 'CODICE_FISCALE_SOGGETTO: ' || SQLERRM;
       p_CodErr   := SQLCODE;
        RETURN FALSE;

END  CODICE_FISCALE_SOGGETTO;

---------------------------------------------
--120
FUNCTION RESIDENZA_SOGGETTO          (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                    P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                    P_BLOCCANTE          IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                    P_MSGERR       IN OUT VARCHAR2,
                                                    P_CODERR               IN OUT VARCHAR2) RETURN BOOLEAN IS


CURSOR CUR_SOGG IS    SELECT COGNOME,NOME,RES_INDIRIZZO, RES_CAP, RES_COMUNE, RES_CITTA_ESTERO,MIN (B.ID_RUOLO) ID_RUOLO
                            FROM     DB_PERSONA_FISICA a,
                                    DB_CONTITOLARE b,
                                    DB_TIPO_RUOLO r
                          WHERE A.ID_SOGGETTO         =     B.ID_SOGGETTO
                           AND     B.ID_RUOLO             != 1
                          AND     B.ID_AZIENDA         =     P_ID_AZIENDA
                          AND     B.DATA_FINE_RUOLO IS NULL
                            AND    B.id_ruolo            = R.id_ruolo
                            GROUP BY COGNOME,NOME,RES_INDIRIZZO, RES_CAP, RES_COMUNE, RES_CITTA_ESTERO;

v_descrizione_errore            VARCHAR2(1000);
ERR_DATI                             EXCEPTION;
bFlagEstero                     COMUNE.FLAG_ESTERO%TYPE;
vDesRuolo                        DB_TIPO_RUOLO.descrizione%TYPE;
BEGIN

    FOR REC_S IN CUR_SOGG LOOP


        SELECT descrizione
        INTO vDesRuolo
        FROM DB_TIPO_RUOLO
        WHERE id_ruolo = REC_S.id_ruolo;


        IF trim(REC_S.RES_COMUNE) IS NULL THEN
            v_descrizione_errore   := 'Comune di Residenza del '||vDesRuolo||' '||NVL(REC_S.COGNOME,' ')||' '||NVL(REC_S.NOME,' ')||' non e'' valorizzato o non valido';
            RAISE ERR_DATI;
        END IF;

        IF trim(REC_S.RES_INDIRIZZO) IS NULL THEN
            v_descrizione_errore   := 'Indirizzo di Residenza del '||vDesRuolo||' '||NVL(REC_S.COGNOME,' ')||' '||NVL(REC_S.NOME,' ')||' non e'' valorizzato o non valido';
            RAISE ERR_DATI;
        END IF;

        -- Verifica se si tratta di uno stato estero
        SELECT flag_estero
        INTO bFlagEstero
        FROM COMUNE WHERE istat_comune = REC_S.RES_COMUNE;

      -- Nel caso di residenza all'estero, controlla la validazione della città
      --
        IF bFlagEstero = 'S' THEN

           IF trim(REC_S.RES_CITTA_ESTERO) IS NULL THEN
                v_descrizione_errore   := 'La Citta'' Estera di Residenza del '||vDesRuolo||' '||NVL(REC_S.COGNOME,' ')||' '||NVL(REC_S.NOME,' ')||' non e'' valorizzato o non valido';
                RAISE ERR_DATI;
             END IF;

          ELSE
          -- Nel caso di residenza in Italia, controlla la validazione del CAP
          --
           IF trim(REC_S.RES_CAP) IS NULL THEN
                v_descrizione_errore   := 'Il CAP di Residenza del '||vDesRuolo||' '||NVL(REC_S.COGNOME,' ')||' '||NVL(REC_S.NOME,' ')||' non e'' valorizzato o non valido';
                RAISE ERR_DATI;
             END IF;
        END IF;

    END LOOP;

    RETURN TRUE;

EXCEPTION
   WHEN ERR_DATI THEN
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
            P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;
        RETURN TRUE;
    WHEN OTHERS THEN
        p_MsgErr   := 'RESIDENZA_SOGGETTO: ' || SQLERRM;
       p_CodErr   := SQLCODE;
        RETURN FALSE;

END  RESIDENZA_SOGGETTO;

----------------------------------------------------------------------------


FUNCTION CONTROLLA_PARTICELLE_DOPPIE (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                   P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                   P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                   P_MSGERR       IN OUT VARCHAR2,
                                   P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
s_sezione            VARCHAR2(20);
s_sub            VARCHAR2(20);

CURSOR C_PARTICELLE_DOPPIE IS
     SELECT CP.ID_CONDUZIONE_PARTICELLA, SP.ID_STORICO_PARTICELLA,
             C.DESCOM, SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA, SP.SUBALTERNO, COUNT(*)
     FROM DB_UTE U, DB_CONDUZIONE_PARTICELLA CP, DB_STORICO_PARTICELLA SP, COMUNE C
     WHERE U.ID_AZIENDA = P_ID_AZIENDA
       AND U.ID_UTE = CP.ID_UTE
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND SP.ID_PARTICELLA = CP.ID_PARTICELLA
       AND SP.DATA_FINE_VALIDITA IS NULL
       AND SP.COMUNE = C.ISTAT_COMUNE
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND EXISTS (SELECT sp2.COMUNE, SP2.SEZIONE, SP2.FOGLIO, SP2.PARTICELLA, SP2.SUBALTERNO, COUNT(*)
                    FROM DB_STORICO_PARTICELLA SP2
                    WHERE SP2.COMUNE = SP.COMUNE
                    AND NVL(SP2.SEZIONE,'-') = NVL(SP.SEZIONE,'-')
                    AND SP2.FOGLIO = SP.FOGLIO
                    AND SP2.PARTICELLA = SP.PARTICELLA
                    AND NVL(SP2.SUBALTERNO,'-') = NVL(SP.SUBALTERNO,'-')
                    AND SP2.DATA_FINE_VALIDITA IS NULL
                    GROUP BY sp2.COMUNE, SP2.SEZIONE, SP2.FOGLIO, SP2.PARTICELLA, SP2.SUBALTERNO
                    HAVING COUNT(*) > 1)
     GROUP BY CP.ID_CONDUZIONE_PARTICELLA, SP.ID_STORICO_PARTICELLA,
                  C.DESCOM, SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA, SP.SUBALTERNO;

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_PARTICELLE_DOPPIE IN C_PARTICELLE_DOPPIE LOOP
         SELECT DECODE(REC_PARTICELLE_DOPPIE.SEZIONE, NULL, '', ' Sz: '|| REC_PARTICELLE_DOPPIE.SEZIONE)
        INTO S_SEZIONE FROM DUAL;
        SELECT DECODE(REC_PARTICELLE_DOPPIE.subalterno, NULL, '', ' Sub: '|| REC_PARTICELLE_DOPPIE.SUBALTERNO)
        INTO S_SUB FROM DUAL;

          S_DESCRIZIONE := '[' || REC_PARTICELLE_DOPPIE.DESCOM || s_sezione || ' Fgl:' ||
                        REC_PARTICELLE_DOPPIE.FOGLIO ||' Part:' || REC_PARTICELLE_DOPPIE.PARTICELLA ||s_sub||
                       ' Particella doppia in archivio. Contattare l''assistenza tecnica';

          IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE,
                    REC_PARTICELLE_DOPPIE.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;

          IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, p_id_controllo, S_DESCRIZIONE,
                 p_bloccante, REC_PARTICELLE_DOPPIE.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_PARTICELLE_DOPPIE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLA_PARTICELLE_DOPPIE;

FUNCTION CONTROLLA_PRESENZA_AGEA (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                 P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                 P_MSGERR       IN OUT VARCHAR2,
                                P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS
-- 208
-- deve avere almeno un utilizzo
-- con il controllo catasto abilitato
  CURSOR C_PART IS
  SELECT SP.COMUNE,
         C.DESCOM,
         SP.SEZIONE,
         SP.FOGLIO,
         SP.PARTICELLA,
         SP.SUBALTERNO,
         SP.ID_STORICO_PARTICELLA,
         CP.ID_CONDUZIONE_PARTICELLA
    FROM DB_CONDUZIONE_PARTICELLA CP, DB_STORICO_PARTICELLA SP, DB_UTE u, COMUNE c
   WHERE CP.ID_UTE= u.ID_UTE
     AND U.ID_AZIENDA=P_ID_AZIENDA
     AND CP.DATA_FINE_CONDUZIONE IS NULL
     AND CP.ID_PARTICELLA=SP.ID_PARTICELLA
     AND SP.DATA_FINE_VALIDITA IS NULL
     AND SP.COMUNE=C.ISTAT_COMUNE
     AND SUBSTR(SP.COMUNE,1,3) IN ('001','002','003','004','005','006','103','096')
     AND NVL(SP.ID_CASO_PARTICOLARE,99) IN (5,99)
     AND EXISTS (SELECT UP.ID_UTILIZZO_PARTICELLA
                   FROM DB_UTILIZZO_PARTICELLA UP,
                        DB_TIPO_UTILIZZO TU
                  WHERE CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
                    AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
                    AND TU.CONTROLLO_CATASTO = 'S');


S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_CONT NUMBER;
D_DATA_SOPPRESSIONE DATE;
s_sezione            VARCHAR2(20);
s_sub                VARCHAR2(20);

C_COMUNE_C            COMUNE.ISTAT_COMUNE%TYPE;
S_SEZIONE_C            SMRGAA.DB_STORICO_PARTICELLA.SEZIONE%TYPE;

FLAG_RET            BOOLEAN;

BEGIN
     S_DESCRIZIONE := NULL;

     FOR R_PART IN C_PART LOOP
        N_CONT := 1;
        C_COMUNE_C:=R_PART.COMUNE;
        S_SEZIONE_C:=R_PART.SEZIONE;
        /* transcodico */
        FLAG_RET:=TRANSCOD(C_COMUNE_C,S_SEZIONE_C);
         BEGIN
            SELECT NVL(DATA_SOPPRESSIONE,TO_DATE('31/12/9999','DD/MM/YYYY'))
            INTO D_DATA_SOPPRESSIONE
            FROM SMRGAA.DB_PARTICELLA_CERTIFICATA PC
            WHERE C_COMUNE_C       = PC.COMUNE
            AND NVL(S_SEZIONE_C,'-')       = NVL(PC.SEZIONE,'-')
            AND R_PART.foGLIO               = PC.FOGLIO
            AND R_PART.PARTICELLA           = PC.PARTICELLA
            AND NVL(R_PART.SUBALTERNO,'-') = NVL(PC.SUBALTERNO,'-')
            AND PC.ID_FONTE = knIdFonteCatasto 
            AND (PC.DATA_FINE_VALIDITA IS NULL OR nAnnoCampagna IS NOT NULL) 
            AND (TO_DATE('01/01/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= PC.DATA_INIZIO_VALIDITA
            AND  TO_DATE('01/01/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') <= NVL(PC.DATA_FINE_VALIDITA,SYSDATE)
                 OR nAnnoCampagna IS NULL);

        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                N_CONT := 0;
            WHEN OTHERS THEN
                p_MsgErr   := 'ERRORE REPERIMENTO PARTICELLA CATASTO CERTIFICATO: ' || SQLERRM;
                p_CodErr   := SQLCODE;
                RETURN (FALSE);
        END;
        SELECT DECODE(R_PART.SEZIONE, NULL, '', ' Sz: '|| R_PART.SEZIONE)
        INTO S_SEZIONE FROM DUAL;
        SELECT DECODE(R_PART.subalterno, NULL, '', ' Sub: '|| R_PART.SUBALTERNO)
        INTO s_sub FROM dual;
        S_DESCRIZIONE := '[' || R_PART.DESCOM || s_sezione ||
          ' Fgl:' || R_PART.foglio ||' Part:' || R_PART.particella||s_sub    || ']';
        IF N_CONT = 0 THEN /* la particella non è nel catasto AGEA */
             S_DESCRIZIONE := S_DESCRIZIONE ||' non risulta presente sul catasto di riferimento AGEA aggiornato all''anno campagna '||NVL(nAnnoCampagna,TO_CHAR(SYSDATE,'YYYY'));
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA,p_id_controllo, S_DESCRIZIONE,
                   p_bloccante, R_PART.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
           END IF;
           IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA,p_id_controllo, S_DESCRIZIONE,
                 p_bloccante, R_PART.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
           END IF;
        ELSE
           IF TO_CHAR(D_DATA_SOPPRESSIONE,'YYYYMMDD') < TO_CHAR(SYSDATE,'YYYYMMDD') THEN
--              S_DESCRIZIONE := S_DESCRIZIONE ||' è presente sul catasto di riferimento AGEA aggiornato al 31/10/2008, ma risulta SOPPRESSA';
                S_DESCRIZIONE := S_DESCRIZIONE ||' è presente sul catasto di riferimento AGEA aggiornato all''anno campagna '||NVL(nAnnoCampagna,TO_CHAR(SYSDATE,'YYYY'))||', ma risulta SOPPRESSA';
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA,p_id_controllo, S_DESCRIZIONE,
                       p_bloccante, R_PART.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
               END IF;
               IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA,p_id_controllo, S_DESCRIZIONE,
                     p_bloccante, R_PART.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
               END IF;
           END IF;
        END IF;
     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_PRESENZA_AGEA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLA_PRESENZA_AGEA;

FUNCTION CONTROLLA_SUPERFICIE_AGEA (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                 P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                 P_MSGERR       IN OUT VARCHAR2,
                                P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

     -- deve avere almeno un utilizzo
     -- con il controllo catasto abilitato
     CURSOR C_PART IS
     SELECT SP.COMUNE, c.DESCOM, SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA, SP.SUBALTERNO, SP.SUP_CATASTALE,
             SP.ID_STORICO_PARTICELLA, CP.ID_CONDUZIONE_PARTICELLA
        FROM DB_CONDUZIONE_PARTICELLA CP, DB_STORICO_PARTICELLA SP, DB_UTE u, COMUNE c
        WHERE CP.ID_UTE= u.ID_UTE
        AND U.ID_AZIENDA=P_ID_AZIENDA
        AND CP.DATA_FINE_CONDUZIONE IS NULL
        AND CP.ID_PARTICELLA=SP.ID_PARTICELLA
        AND SP.DATA_FINE_VALIDITA IS NULL
        AND SP.COMUNE=C.ISTAT_COMUNE
        AND SUBSTR(SP.COMUNE,1,3) IN ('001','002','003','004','005','006','103','096')
        AND NVL(SP.ID_CASO_PARTICOLARE,99) = 99 -- SOLO PARTICELLE SENZA CASO PARTICOLARE
        AND EXISTS (SELECT UP.ID_UTILIZZO_PARTICELLA
                      FROM DB_UTILIZZO_PARTICELLA UP,
                           DB_TIPO_UTILIZZO TU
                     WHERE CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
                       AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
                       AND TU.CONTROLLO_CATASTO = 'S');


S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_SUP_C_AGEA        NUMBER(10,4);
FLAG_FOUND            BOOLEAN;

C_COMUNE_C            COMUNE.ISTAT_COMUNE%TYPE;
S_SEZIONE_C            SMRGAA.DB_STORICO_PARTICELLA.SEZIONE%TYPE;

FLAG_RET            BOOLEAN;
s_sezione        VARCHAR2(20);
s_sub            VARCHAR2(20);

BEGIN
     S_DESCRIZIONE := NULL;

     FOR R_PART IN C_PART LOOP
        FLAG_FOUND:=TRUE;
        C_COMUNE_C:=R_PART.COMUNE;
        S_SEZIONE_C:=R_PART.SEZIONE;
        /* transcodico */
        FLAG_RET:=TRANSCOD(C_COMUNE_C,S_SEZIONE_C);
       /* recupero la sup.catastale dal tabellone agea */
         BEGIN
            SELECT PC.SUP_CATASTALE
            INTO N_SUP_C_AGEA
            FROM SMRGAA.DB_PARTICELLA_CERTIFICATA PC
            WHERE C_COMUNE_C            = PC.COMUNE
            AND NVL(S_SEZIONE_C,'-')    = NVL(PC.SEZIONE,'-')
            AND R_PART.FOGLIO            = PC.FOGLIO
            AND R_PART.PARTICELLA        = PC.PARTICELLA
            AND NVL(R_PART.SUBALTERNO,'-') = NVL(PC.SUBALTERNO,'-')
            AND PC.ID_FONTE = knIdFonteCatasto 
            AND (PC.DATA_FINE_VALIDITA IS NULL OR nAnnoCampagna IS NOT NULL) 
            AND (TO_DATE('01/01/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') >= PC.DATA_INIZIO_VALIDITA
            AND  TO_DATE('01/01/'||NVL(TO_CHAR(nAnnoCampagna),'1900'),'DD/MM/YYYY') <= NVL(PC.DATA_FINE_VALIDITA,SYSDATE)
                 OR nAnnoCampagna IS NULL);
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 /* non la trovo */
                 FLAG_FOUND:=FALSE;
        END;

        /* faccio il controllo solo se ho trovato il record sul tabellone */
        IF FLAG_FOUND THEN
            /* confronto le superfici */
            IF N_SUP_C_AGEA<>R_PART.SUP_CATASTALE THEN
                  SELECT DECODE(R_PART.SEZIONE, NULL, '', ' Sz: '|| R_PART.SEZIONE)
               INTO S_SEZIONE FROM DUAL;
               SELECT DECODE(R_PART.subalterno, NULL, '', ' Sub: '|| R_PART.SUBALTERNO)
               INTO s_sub FROM dual;
                 S_DESCRIZIONE := '[' || R_PART.DESCOM ||S_SEZIONE ||' Fgl:' || R_PART.FOGLIO ||
                 ' Part:' || R_PART.PARTICELLA || S_SUB ||
                 '] Sup.Cat.: ' ||  TO_CHAR(NVL(R_PART.SUP_CATASTALE,0),'999G990D9999')||
                 ' Sup. Cat. Agea: ' || TO_CHAR(NVL(N_SUP_C_AGEA,0),'999G990D9999')
                 || ' la superficie catastale dichiarata non coincide con quella quella presente sul catasto di riferimento AGEA valido per la campagna in corso'; 

              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA,P_id_controllo, S_DESCRIZIONE,
                   P_bloccante, R_PART.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
              IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA,P_id_controllo, S_DESCRIZIONE,
                   P_bloccante, R_PART.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_SUPERFICIE_AGEA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLA_SUPERFICIE_AGEA;

/* controllo che la somma della sup.util in db_utilizzo_particella non superi la precipua in db_particella_certificata */
FUNCTION CONTROLLA_ELEGGIBILITA(    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                    pVite          IN    VARCHAR2,
                                    P_PERC_P26     IN    NUMBER,
                                    P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                    P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                    P_MSGERR       IN OUT VARCHAR2,
                                    P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS


N_SUP_ELEGG_PIU5                    DB_UTILIZZO_PARTICELLA.superficie_utilizzata%TYPE;
--N_5_PER_100                            DB_UTILIZZO_PARTICELLA.superficie_utilizzata%TYPE;

/*   N.B.: DEVO TOGLIERE LE CONDUZIONI DALLA GROUP BY!!!!!!!!! */

    -- aggiunto parametro pVite e condizione di join con DB_TIPO_UTILIZZO
    CURSOR C_ELEGG IS
    SELECT A.COMUNE, G.DESCOM, A.SEZIONE, A.FOGLIO, A.PARTICELLA, A.SUBALTERNO, NVL(SUM(C.SUPERFICIE_UTILIZZATA),0) SUM_SUP_UTIL,  A.ID_STORICO_PARTICELLA, A.ID_PARTICELLA,X.ID_PARTICELLA_CERTIFICATA
      FROM DB_STORICO_PARTICELLA A,
           DB_CONDUZIONE_PARTICELLA B,
           DB_UTILIZZO_PARTICELLA C,
           DB_TIPO_UTILIZZO TU,
           DB_UTE F,
           COMUNE G,
           DB_PARTICELLA_CERTIFICATA X,
           DB_TIPO_CASO_PARTICOLARE CP
     WHERE A.DATA_FINE_VALIDITA IS NULL
       AND NVL(A.ID_CASO_PARTICOLARE,99) = CP.ID_CASO_PARTICOLARE
       AND CP.EFFETTUA_CONTROLLI_GIS = 'S' 
       AND A.ID_PARTICELLA = B.ID_PARTICELLA
       AND B.ID_CONDUZIONE_PARTICELLA =    C.ID_CONDUZIONE_PARTICELLA
       AND B.ID_TITOLO_POSSESSO <> 5 
       AND B.DATA_FINE_CONDUZIONE IS NULL
       AND B.ID_UTE = F.ID_UTE
       AND F.DATA_FINE_ATTIVITA IS NULL
       AND F.ID_AZIENDA = P_ID_AZIENDA
       AND A.COMUNE = G.ISTAT_COMUNE
       AND X.ID_PARTICELLA = A.ID_PARTICELLA 
       AND X.DATA_FINE_VALIDITA IS NULL
       AND TU.ID_UTILIZZO = C.ID_UTILIZZO
       AND ((pVite = 'S' AND TU.TIPO = 'V')  OR
            (pVite = 'N' AND TU.TIPO <> 'V')) 
       AND NOT EXISTS (SELECT ID_ESITO_CONTROLLO_PARTICELLA
                         FROM DB_ESITO_CONTROLLO_PARTICELLA
                        WHERE ID_CONTROLLO IN (knIdControlloP25,knIdControlloP30)
                          AND ID_CONDUZIONE_PARTICELLA = B.ID_CONDUZIONE_PARTICELLA) 
       AND NOT EXISTS (SELECT SUA.ID_STORICO_UNITA_ARBOREA 
                         FROM DB_STORICO_UNITA_ARBOREA SUA,  
                              DB_TIPO_CAUSALE_MODIFICA TCM 
                        WHERE SUA.ID_AZIENDA = P_ID_AZIENDA 
                          AND SUA.ID_PARTICELLA = A.ID_PARTICELLA
                          AND SUA.ID_CAUSALE_MODIFICA = TCM.ID_CAUSALE_MODIFICA
                          AND ESCLUDI_P26 = 'S'
                          AND SUA.DATA_FINE_VALIDITA IS NULL
                          AND SUA.DATA_CESSAZIONE IS NULL
                          AND DECODE(TCM.IMPIANTO, 'S',SUA.DATA_IMPIANTO, SUA.DATA_AGGIORNAMENTO) >=
                                (SELECT NVL(MAX(DATA_FOTOINTERPRETAZIONE), TO_DATE('01/01/1900','DD/MM/YYYY'))
                                   FROM DB_PARTICELLA_CERT_ELEG
                                  WHERE ID_PARTICELLA_CERTIFICATA = X.ID_PARTICELLA_CERTIFICATA
                                    AND ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                                           FROM DB_PARTICELLA_CERT_ELEG
                                                          WHERE ID_PARTICELLA_CERTIFICATA = X.ID_PARTICELLA_CERTIFICATA)))
    GROUP BY A.COMUNE, G.DESCOM, A.SEZIONE, A.FOGLIO, A.PARTICELLA, A.SUBALTERNO, A.ID_STORICO_PARTICELLA,A.ID_PARTICELLA, X.ID_PARTICELLA_CERTIFICATA;


    /* recupero le unità arboree attive */
    CURSOR curUnitaArborea (pIdParticella IN DB_STORICO_UNITA_ARBOREA.ID_PARTICELLA%TYPE) IS
    SELECT SUA.*
      FROM DB_STORICO_UNITA_ARBOREA SUA
     WHERE SUA.ID_AZIENDA = P_ID_AZIENDA
       AND SUA.DATA_FINE_VALIDITA IS NULL
       AND SUA.DATA_CESSAZIONE IS NULL
       AND SUA.ID_PARTICELLA = pIdParticella;

    /* recupero le conduzioni attive */
    CURSOR C_CONDUZIONI_ATTIVE (pIdParticella IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT B.ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA B,
           DB_UTE C
     WHERE C.ID_AZIENDA    = P_ID_AZIENDA
       AND C.DATA_FINE_ATTIVITA IS NULL
       AND C.ID_UTE = B.ID_UTE
       AND B.DATA_FINE_CONDUZIONE     IS NULL
       AND B.ID_TITOLO_POSSESSO <> 5 
       AND B.ID_PARTICELLA = pIdParticella;

    S_DESCRIZIONE                             DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

    C_COMUNE_C                            COMUNE.ISTAT_COMUNE%TYPE;
    S_SEZIONE_C                            DB_STORICO_PARTICELLA.SEZIONE%TYPE;
    s_sezione                            VARCHAR2(20);
    s_sub                                VARCHAR2(20);

BEGIN
    S_DESCRIZIONE := NULL;

    FOR R_ELEGG IN C_ELEGG LOOP
        IF R_ELEGG.ID_PARTICELLA_CERTIFICATA IS NOT NULL THEN
            IF NVL( PCK_SMRGAA_LIBRERIA.CALCOLA_P26_CON_TOLLERANZA
                                                   (P_ID_AZIENDA,
                                                    R_ELEGG.ID_PARTICELLA,
                                                    R_ELEGG.ID_PARTICELLA_CERTIFICATA,
                                                    P_PERC_P26),0) > 0 THEN

                  SELECT DECODE(R_ELEGG.SEZIONE, NULL, '', ' Sz: '|| R_ELEGG.SEZIONE)
               INTO S_SEZIONE FROM DUAL;
               SELECT DECODE(R_ELEGG.subalterno, NULL, '', ' Sub: '|| R_ELEGG.SUBALTERNO)
               INTO s_sub FROM dual;

                 S_DESCRIZIONE := '[' || R_ELEGG.DESCOM ||S_SEZIONE ||' Fgl:' || R_ELEGG.FOGLIO || ' Part:' || R_ELEGG.PARTICELLA || S_SUB ||
                                '] Sup.utilizzata: ' ||  TRIM(TO_CHAR(NVL(R_ELEGG.SUM_SUP_UTIL,0),'999G990D9999'))||
                                ' non congruente con la superficie eleggibile'; 

              IF pVite = 'S' THEN
                 FOR recUnitaArborea IN curUnitaArborea (R_ELEGG.ID_PARTICELLA) LOOP
                     IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA,P_id_controllo, S_DESCRIZIONE,
                                                 P_bloccante, R_ELEGG.ID_STORICO_PARTICELLA, recUnitaArborea.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                        RETURN (FALSE);
                     END IF;

                     IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,P_BLOCCANTE, recUnitaArborea.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                        RETURN (FALSE);
                     END IF;
                 END LOOP;
              ELSE
                 IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA,P_id_controllo, S_DESCRIZIONE,
                                             P_bloccante, R_ELEGG.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
                 END IF;
              END IF;

              /* ciclo sulle conduzioni attive */
              FOR REC_CONDUZIONI_ATTIVE IN C_CONDUZIONI_ATTIVE (R_ELEGG.ID_PARTICELLA) LOOP
                  IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA,P_id_controllo, S_DESCRIZIONE,
                       P_bloccante, REC_CONDUZIONI_ATTIVE.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
              END LOOP;
            END IF;
        END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_ELEGGIBILITA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLA_ELEGGIBILITA;



-- Uguale al controlla_eleggibilita_vite ma viene richiamata
-- una function che in caso di particelle miste (ovvero sia con utilizzi a vite che
-- non ) calcola la P26 solo per la parte di utilizzi a VITE
FUNCTION VERIFICA_ELEGGIBILITA_VITE(P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                     P_PERC_P26     IN NUMBER,
                                     P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                     P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                     P_MSGERR       IN OUT VARCHAR2,
                                     P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS


N_SUP_ELEGG_PIU5                    DB_UTILIZZO_PARTICELLA.superficie_utilizzata%TYPE;
--N_5_PER_100                            DB_UTILIZZO_PARTICELLA.superficie_utilizzata%TYPE;


    -- aggiunto parametro pVite e condizione di join con DB_TIPO_UTILIZZO
    CURSOR C_ELEGG IS
    SELECT A.COMUNE, G.DESCOM, A.SEZIONE, A.FOGLIO, A.PARTICELLA, A.SUBALTERNO, NVL(SUM(C.SUPERFICIE_UTILIZZATA),0) SUM_SUP_UTIL,  A.ID_STORICO_PARTICELLA, A.ID_PARTICELLA,X.ID_PARTICELLA_CERTIFICATA
      FROM DB_STORICO_PARTICELLA A,
           DB_CONDUZIONE_PARTICELLA B,
           DB_UTILIZZO_PARTICELLA C,
           DB_TIPO_UTILIZZO TU,
           DB_UTE F,
           COMUNE G,
           DB_PARTICELLA_CERTIFICATA X,
           DB_TIPO_CASO_PARTICOLARE CP
     WHERE A.DATA_FINE_VALIDITA IS NULL
       AND NVL(A.ID_CASO_PARTICOLARE,99) = CP.ID_CASO_PARTICOLARE
       AND CP.EFFETTUA_CONTROLLI_GIS = 'S' 
       AND A.ID_PARTICELLA = B.ID_PARTICELLA
       AND B.ID_CONDUZIONE_PARTICELLA =    C.ID_CONDUZIONE_PARTICELLA
       AND B.ID_TITOLO_POSSESSO <> 5 
       AND B.DATA_FINE_CONDUZIONE IS NULL
       AND B.ID_UTE = F.ID_UTE
       AND F.DATA_FINE_ATTIVITA IS NULL
       AND F.ID_AZIENDA = P_ID_AZIENDA
       AND A.COMUNE = G.ISTAT_COMUNE
       AND X.ID_PARTICELLA = A.ID_PARTICELLA 
       AND X.DATA_FINE_VALIDITA IS NULL
       AND TU.ID_UTILIZZO = C.ID_UTILIZZO
       AND TU.TIPO = 'V'
       AND NOT EXISTS (SELECT ID_ESITO_CONTROLLO_PARTICELLA
                         FROM DB_ESITO_CONTROLLO_PARTICELLA
                        WHERE ID_CONTROLLO IN (knIdControlloP25,knIdControlloP30)
                          AND ID_CONDUZIONE_PARTICELLA = B.ID_CONDUZIONE_PARTICELLA) 
       AND EXISTS (SELECT SUA.ID_STORICO_UNITA_ARBOREA
                     FROM DB_STORICO_UNITA_ARBOREA SUA
                    WHERE SUA.ID_AZIENDA = P_ID_AZIENDA
                      AND SUA.DATA_FINE_VALIDITA IS NULL
                      AND SUA.DATA_CESSAZIONE IS NULL
                      AND SUA.ID_PARTICELLA = B.ID_PARTICELLA)
                      -- rc capire come modificare la condizione di where
                      --AND PCK_SMRGAA_LIBRERIA.Uv_In_Tolleranza_Gis(P_ID_AZIENDA,SUA.ID_UNITA_ARBOREA) <> 0)
    GROUP BY A.COMUNE, G.DESCOM, A.SEZIONE, A.FOGLIO, A.PARTICELLA, A.SUBALTERNO, A.ID_STORICO_PARTICELLA,A.ID_PARTICELLA, X.ID_PARTICELLA_CERTIFICATA;

    /* recupero le unità arboree attive */
    CURSOR curUnitaArborea (pIdParticella IN DB_STORICO_UNITA_ARBOREA.ID_PARTICELLA%TYPE) IS
    SELECT SUA.*
      FROM DB_STORICO_UNITA_ARBOREA SUA
     WHERE SUA.ID_AZIENDA = P_ID_AZIENDA
       AND SUA.DATA_FINE_VALIDITA IS NULL
       AND SUA.DATA_CESSAZIONE IS NULL
       AND SUA.ID_PARTICELLA = pIdParticella;

    /* recupero le conduzioni attive */
    CURSOR C_CONDUZIONI_ATTIVE (pIdParticella IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT B.ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA B,
           DB_UTE C
     WHERE C.ID_AZIENDA = P_ID_AZIENDA
       AND C.DATA_FINE_ATTIVITA IS NULL
       AND C.ID_UTE = B.ID_UTE
       AND B.DATA_FINE_CONDUZIONE IS NULL
       AND B.ID_TITOLO_POSSESSO <> 5 
       AND B.ID_PARTICELLA = pIdParticella;

    S_DESCRIZIONE   DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    C_COMUNE_C      COMUNE.ISTAT_COMUNE%TYPE;
    S_SEZIONE_C     DB_STORICO_PARTICELLA.SEZIONE%TYPE;
    s_sezione       VARCHAR2(20);
    s_sub           VARCHAR2(20);

BEGIN
    S_DESCRIZIONE := NULL;

    FOR R_ELEGG IN C_ELEGG LOOP
        IF R_ELEGG.ID_PARTICELLA_CERTIFICATA IS NOT NULL THEN
            IF NVL( PCK_SMRGAA_LIBRERIA.CALCOLA_P26_UV_CON_TOLLERANZA
                                                   (P_ID_AZIENDA,
                                                    R_ELEGG.ID_PARTICELLA,
                                                    R_ELEGG.ID_PARTICELLA_CERTIFICATA,
                                                    P_PERC_P26),0) > 0 THEN

               SELECT DECODE(R_ELEGG.SEZIONE, NULL, '', ' Sz: '|| R_ELEGG.SEZIONE)
                 INTO S_SEZIONE FROM DUAL;
               SELECT DECODE(R_ELEGG.subalterno, NULL, '', ' Sub: '|| R_ELEGG.SUBALTERNO)
                 INTO s_sub FROM dual;

               S_DESCRIZIONE := '[' || R_ELEGG.DESCOM ||S_SEZIONE ||' Fgl:' || R_ELEGG.FOGLIO || ' Part:' || R_ELEGG.PARTICELLA || S_SUB ||
                                 '] Sup.utilizzata: ' ||  TRIM(TO_CHAR(NVL(R_ELEGG.SUM_SUP_UTIL,0),'999G990D9999'))||
                                 ' non congruente con la superficie eleggibile'; 

               /* ciclo sulle unar attive */
               FOR recUnitaArborea IN curUnitaArborea (R_ELEGG.ID_PARTICELLA) LOOP
                   IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA,P_id_controllo, S_DESCRIZIONE,
                                               P_bloccante, R_ELEGG.ID_STORICO_PARTICELLA, recUnitaArborea.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                      RETURN (FALSE);
                   END IF;

                   IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,P_BLOCCANTE, recUnitaArborea.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                      RETURN (FALSE);
                   END IF;
               END LOOP;

               /* ciclo sulle conduzioni attive */
               FOR REC_CONDUZIONI_ATTIVE IN C_CONDUZIONI_ATTIVE (R_ELEGG.ID_PARTICELLA) LOOP
                   IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA,P_id_controllo, S_DESCRIZIONE,
                                                          P_bloccante, REC_CONDUZIONI_ATTIVE.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                      RETURN (FALSE);
                   END IF;
               END LOOP;
            END IF;
        END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE VERIFICA_ELEGGIBILITA_VITE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END VERIFICA_ELEGGIBILITA_VITE;

-- controllo se le UV dell'azienda
-- che hanno altri vitigni non abbiano
-- la percentuale totale (varieta' principale + altre) che sfora il 100%
-- e che non ci siano altri vitigni con la stessa varieta'
-- 632
FUNCTION INDICAZIONE_ALTRI_VITIGNI_OK(P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                      P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                      P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                      P_MSGERR       IN OUT VARCHAR2,
                                      P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS


    CURSOR curUvConAltriVitigniAnomali IS
    WITH UV_COMPLETA AS
        (SELECT SUA.ID_VARIETA,
                SUA.PERCENTUALE_VARIETA,
               (SELECT NVL(SUM(AV.PERCENTUALE_VITIGNO),0)
                  FROM DB_ALTRO_VITIGNO AV
                 WHERE AV.ID_STORICO_UNITA_ARBOREA = SUA.ID_STORICO_UNITA_ARBOREA) AS PERC_ALTRI,
               (SELECT COUNT(AV.ID_ALTRO_VITIGNO)
                  FROM DB_ALTRO_VITIGNO AV
                 WHERE AV.ID_STORICO_UNITA_ARBOREA = SUA.ID_STORICO_UNITA_ARBOREA
                   AND AV.ID_VARIETA = SUA.ID_VARIETA) AS NUM_STESSA_VARIETA,
                SUA.ID_PARTICELLA,
                SUA.ID_STORICO_UNITA_ARBOREA,
                SUA.PROGR_UNAR
           FROM DB_STORICO_UNITA_ARBOREA SUA
          WHERE SUA.ID_AZIENDA = P_ID_AZIENDA
            AND SUA.DATA_CESSAZIONE IS NULL
            AND SUA.DATA_FINE_VALIDITA IS NULL)
         SELECT SP.COMUNE,
                C.DESCOM,
                SP.SEZIONE,
                SP.FOGLIO,
                SP.PARTICELLA,
                SP.SUBALTERNO,
                SP.ID_STORICO_PARTICELLA,
                SP.ID_PARTICELLA,
                UVC.ID_STORICO_UNITA_ARBOREA,
                UVC.PROGR_UNAR ,
                UVC.NUM_STESSA_VARIETA,
                UVC.PERCENTUALE_VARIETA,
                UVC.PERC_ALTRI
           FROM UV_COMPLETA UVC,
                DB_STORICO_PARTICELLA SP,
                COMUNE C
          WHERE UVC.ID_PARTICELLA = SP.ID_PARTICELLA
            AND SP.DATA_FINE_VALIDITA IS NULL
            AND SP.COMUNE = C.ISTAT_COMUNE
            AND (UVC.NUM_STESSA_VARIETA > 0 OR
                 UVC.PERCENTUALE_VARIETA + UVC.PERC_ALTRI <> 100);  
                 --UVC.PERCENTUALE_VARIETA + UVC.PERC_ALTRI > 100);


    /* recupero le conduzioni attive */
    CURSOR curConduzioniAttive (pIdParticella IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT B.ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA B,
           DB_UTE C
     WHERE C.ID_AZIENDA = P_ID_AZIENDA
       AND C.DATA_FINE_ATTIVITA IS NULL
       AND C.ID_UTE = B.ID_UTE
       AND B.DATA_FINE_CONDUZIONE IS NULL
       AND B.ID_PARTICELLA = pIdParticella;

    S_DESCRIZIONE    DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    S_SEZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    S_SUB            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;


BEGIN

     FOR recUvConAltriVitigniAnomali IN curUvConAltriVitigniAnomali LOOP

         SELECT DECODE(recUvConAltriVitigniAnomali.SEZIONE, NULL, '', ' Sz: '|| recUvConAltriVitigniAnomali.SEZIONE)
           INTO S_SEZIONE
           FROM DUAL;

         SELECT DECODE(recUvConAltriVitigniAnomali.SUBALTERNO, NULL, '', ' Sub: '|| recUvConAltriVitigniAnomali.SUBALTERNO)
           INTO S_SUB
           FROM DUAL;

         S_DESCRIZIONE := '[' || recUvConAltriVitigniAnomali.DESCOM || S_SEZIONE || ' Fgl:' ||
                                 recUvConAltriVitigniAnomali.FOGLIO || ' Part:' ||
                                 recUvConAltriVitigniAnomali.PARTICELLA || S_SUB || ' Progr Unar : ' ||
                                 recUvConAltriVitigniAnomali.PROGR_UNAR || ']';

         IF recUvConAltriVitigniAnomali.NUM_STESSA_VARIETA > 0 THEN
            S_DESCRIZIONE := S_DESCRIZIONE  || ' sono presenti altri vitigni con la stessa varieta'' del vitigno principale';
         ELSE
            S_DESCRIZIONE := S_DESCRIZIONE  || ' la somma delle percentuali del vitigno principale e degli altri vitigni e'' diversa dal 100% (' || TO_CHAR(recUvConAltriVitigniAnomali.PERCENTUALE_VARIETA) || '+' || TO_CHAR(recUvConAltriVitigniAnomali.PERC_ALTRI) || ')';
         END IF;

         IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA,P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, recUvConAltriVitigniAnomali.ID_STORICO_PARTICELLA, recUvConAltriVitigniAnomali.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
         END IF;

         IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,P_BLOCCANTE, recUvConAltriVitigniAnomali.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
         END IF;

         FOR recConduzioniAttive IN curConduzioniAttive (recUvConAltriVitigniAnomali.ID_PARTICELLA) LOOP
             IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA,P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, recConduzioniAttive.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
             END IF;
         END LOOP;

     END LOOP;

     RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE INDICAZIONE_ALTRI_VITIGNI_OK: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END INDICAZIONE_ALTRI_VITIGNI_OK;

-- Il controllo segnala tutte le unita' vitate
-- dell'azienda attive, non cessate che hanno la
-- percentuale di fallanza maggiore/uguale al 100%.
FUNCTION CONTROLLO_PERCENTUALE_FALLANZA (pIdAzienda   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                         pIdControllo IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                         pBloccante   IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                         P_MSGERR     IN OUT VARCHAR2,
                                         P_CODERR     IN OUT VARCHAR2) RETURN BOOLEAN IS



    nAnnoRif        DB_STORICO_UNITA_ARBOREA.ANNO_ISCRIZIONE_ALBO%TYPE;
    vDescAnomalia   DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

    CURSOR curUnitaVitata (pAnnoRif IN DB_STORICO_UNITA_ARBOREA.ANNO_ISCRIZIONE_ALBO%TYPE) IS
    SELECT C.DESCOM,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           SUA.PROGR_UNAR,
           TTV.DESCRIZIONE ,
           SUA.ID_STORICO_UNITA_ARBOREA,
           SUA.PERCENTUALE_FALLANZA,
           SP.ID_PARTICELLA,
           SP.ID_STORICO_PARTICELLA
      FROM DB_STORICO_UNITA_ARBOREA SUA,
           DB_TIPO_TIPOLOGIA_VINO TTV,
           DB_STORICO_PARTICELLA SP,
           COMUNE C,
           PROVINCIA P
     WHERE SUA.ID_AZIENDA = pIdAzienda
       AND SUA.DATA_FINE_VALIDITA IS NULL
       AND SUA.DATA_CESSAZIONE IS NULL
       AND SUA.ID_TIPOLOGIA_VINO = TTV.ID_TIPOLOGIA_VINO
       AND SUA.ID_PARTICELLA = SP.ID_PARTICELLA
       AND SP.DATA_FINE_VALIDITA IS NULL
       AND C.ISTAT_COMUNE = SP.COMUNE
       AND P.ISTAT_PROVINCIA = C.ISTAT_PROVINCIA
       --AND P.ID_REGIONE = '01' -- SOLO PIEMONTE
       AND SUA.PERCENTUALE_FALLANZA >= 100;


    CURSOR curConduzioniParticella (pIdParticella IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT CP.ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA CP,
           DB_UTE U
     WHERE CP.ID_PARTICELLA = pIdParticella
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_UTE = U.ID_UTE
       --AND CP.ID_TITOLO_POSSESSO NOT IN (5,6)
       AND U.ID_AZIENDA = pIdAzienda;

BEGIN

    -- tolto il vino dalla descrizione dell'anomalia ...
    FOR recUnitaVitata IN curUnitaVitata (nAnnoRif) LOOP

        vDescAnomalia :=  '[' || recUnitaVitata.DESCOM || ' Sez:'
                              || NVL(recUnitaVitata.SEZIONE,'N.V.') ||' Fgl:'
                              || recUnitaVitata.FOGLIO || ' Part:'
                              || recUnitaVitata.PARTICELLA || ' Sub:'
                              || NVL(recUnitaVitata.SUBALTERNO,'N.V') || ' Progr: '
                              || recUnitaVitata.PROGR_UNAR || '] ' /* vino  : ' || recUnitaVitata.DESCRIZIONE || */ || ' ha percentuale fallanza >= 100% (' || TO_CHAR(recUnitaVitata.PERCENTUALE_FALLANZA,'990D99') || ')';

        IF NOT SCRIVI_SEGNALAZIONE (pIdAzienda, pIdControllo, vDescAnomalia,pBloccante, recUnitaVitata.ID_STORICO_PARTICELLA, recUnitaVitata.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_UNAR (pIdAzienda, pIdControllo, vDescAnomalia,pBloccante, recUnitaVitata.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        FOR recConduzioniParticella IN curConduzioniParticella(recUnitaVitata.ID_PARTICELLA) LOOP
            IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (pIdAzienda, pIdControllo, vDescAnomalia,
                                                   pBloccante, recConduzioniParticella.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
        END LOOP;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
         p_MsgErr   := 'ERRORE CONTROLLO_PERCENTUALE_FALLANZA: ' || SQLERRM;
         p_CodErr   := SQLCODE;
         RETURN (FALSE);
END CONTROLLO_PERCENTUALE_FALLANZA;


-- 634
-- verifica che le particelle attive sul piano
-- in lavorazione che fanno parte del registro prati permamenti
-- e che non sono ad utilizzi prato permanente
-- abbiano l'apposito documento di regoga in caso contrario
-- da anomalia
FUNCTION MANTENIMENTO_PRATI_PERMANENTI (pIdAzienda   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                        pIdControllo IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        pBloccante   IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                        P_MSGERR     IN OUT VARCHAR2,
                                        P_CODERR     IN OUT VARCHAR2) RETURN BOOLEAN IS


    vDescAnomalia   DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

    CURSOR curConduzioniAttivaAPratoPerm IS
    SELECT --TAC.DEROGA_MANTENIMENTO_PRATI,
           C.DESCOM,
           C.ISTAT_COMUNE,
           SP.FOGLIO,
           SP.SEZIONE,
           SP.SUBALTERNO,
           SP.PARTICELLA,
           CP.ID_CONDUZIONE_PARTICELLA,
           SP.ID_STORICO_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA CP,
           DB_UTE UT,
           DB_STORICO_PARTICELLA SP,
           COMUNE C
           --DB_TIPO_AREA_C TAC
     WHERE UT.ID_AZIENDA = pIdAzienda
       AND UT.ID_UTE = CP.ID_UTE
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND UT.DATA_FINE_ATTIVITA IS NULL
       AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
       AND SP.DATA_FINE_VALIDITA IS NULL
       AND C.ISTAT_COMUNE = SP.COMUNE
       -- AND SP.ID_TIPO_AREA_C = TAC.ID_TIPO_AREA_C (+)
       -- AND NVL(TAC.DEROGA_MANTENIMENTO_PRATI,'S') = 'S' 
       AND EXISTS (SELECT ID_UTILIZZO_PARTICELLA
                     FROM DB_UTILIZZO_PARTICELLA UP,
                          DB_R_CATALOGO_MATRICE CM
                    WHERE CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
                      AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE
                      AND CM.FLAG_PRATO_PERMANENTE <> 'S') 
       AND EXISTS (SELECT EPM.ID_ESITO_PASCOLO_MAGRO
                     FROM DB_PARTICELLA_CERTIFICATA PC,
                          DB_ESITO_PASCOLO_MAGRO EPM
                    WHERE PC.ID_PARTICELLA = SP.ID_PARTICELLA
                      AND PC.DATA_FINE_VALIDITA IS NULL
                      AND PC.ID_PARTICELLA_CERTIFICATA = EPM.ID_PARTICELLA_CERTIFICATA
                      AND EPM.ID_FONTE = knIdFontePratoPermanente
                      AND EPM.DATA_FINE_VALIDITA IS NULL
                      )
       AND NOT EXISTS (SELECT DC.ID_DOCUMENTO_CONDUZIONE
                         FROM DB_DOCUMENTO D,
                              DB_DOCUMENTO_CONDUZIONE DC
                        WHERE D.EXT_ID_DOCUMENTO = knIdTipoDocDerogaMantenimPrati
                          AND D.ID_AZIENDA = pIdAzienda
                          AND D.ID_STATO_DOCUMENTO IS NULL
                          AND SYSDATE BETWEEN D.DATA_INIZIO_VALIDITA AND NVL(D.DATA_FINE_VALIDITA,SYSDATE)
                          AND D.ID_DOCUMENTO = DC.ID_DOCUMENTO
                          AND SYSDATE BETWEEN DC.DATA_INIZIO_VALIDITA AND NVL(DC.DATA_FINE_VALIDITA,SYSDATE)
                          AND DC.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA)
  ORDER BY SP.ID_STORICO_PARTICELLA;

    nIdStoricoParticella    DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE:=-1;


BEGIN

    FOR recConduzioniAttivaAPratoPerm IN curConduzioniAttivaAPratoPerm LOOP

        vDescAnomalia := 'Per la particella : ' ||
                      '[' || recConduzioniAttivaAPratoPerm.DESCOM || ' Sez : ' || NVL(recConduzioniAttivaAPratoPerm.SEZIONE,'N.P.') ||' Fgl:' || recConduzioniAttivaAPratoPerm.FOGLIO || ' Part:' || recConduzioniAttivaAPratoPerm.PARTICELLA || ' Sub : ' || NVL(recConduzioniAttivaAPratoPerm.SUBALTERNO,'N.P.') || ']' ||
                      ' non e'' rispettato il mantenimento dei prati permanenti';

        IF nIdStoricoParticella <> recConduzioniAttivaAPratoPerm.ID_STORICO_PARTICELLA THEN
            IF NOT SCRIVI_SEGNALAZIONE (pIdAzienda, pIdControllo, vDescAnomalia, pBloccante, recConduzioniAttivaAPratoPerm.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (pIdAzienda, pIdControllo, vDescAnomalia, pBloccante, recConduzioniAttivaAPratoPerm.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        nIdStoricoParticella := recConduzioniAttivaAPratoPerm.ID_STORICO_PARTICELLA;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
         p_MsgErr   := 'ERRORE MANTENIMENTO_PRATI_PERMANENTI: ' || SQLERRM;
         p_CodErr   := SQLCODE;
         RETURN (FALSE);
END MANTENIMENTO_PRATI_PERMANENTI;


-- 635
-- controllo che le particelle dichiarate
-- con titolo di possesso piccola particella montana
-- siano effettivamente montane e piccole (sotto i 5.000 mq di grafica o catastale)
FUNCTION PICCOLA_PARTICELLA_MONTANA (pIdAzienda   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                     pIdControllo IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                     pBloccante   IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                     P_MSGERR     IN OUT VARCHAR2,
                                     P_CODERR     IN OUT VARCHAR2) RETURN BOOLEAN IS


    CURSOR curPartFalsaPiccolaEMontana IS
    SELECT SP.ID_STORICO_PARTICELLA,
           SP.ID_PARTICELLA,
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           C.DESCOM,
           CP.ID_CONDUZIONE_PARTICELLA
      FROM DB_STORICO_PARTICELLA SP,
           DB_CONDUZIONE_PARTICELLA CP,
           DB_UTE U,
           COMUNE C,
           DB_FOGLIO FO,PROVINCIA PR 
     WHERE U.ID_AZIENDA = pIdAzienda
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND U.ID_UTE = CP.ID_UTE
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_TITOLO_POSSESSO = 9 -- piccola particella montana'
       AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
       AND SP.DATA_FINE_VALIDITA IS NULL
       AND SP.COMUNE = C.ISTAT_COMUNE
       AND SP.PARTICELLA IS NOT NULL
       AND C.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA 
       AND PR.ID_REGIONE = '01' 
       AND SP.COMUNE = FO.COMUNE (+)
       AND SP.FOGLIO = FO.FOGLIO (+)
       AND NVL(SP.SEZIONE,'#') = NVL(FO.SEZIONE (+),'#')
       AND (SP.ID_ZONA_ALTIMETRICA <> knIdZonaAltimetricaMontana OR
            FO.FLAG_STABILIZZAZIONE = 0 AND SP.SUPERFICIE_GRAFICA > 0.5 OR
            FO.FLAG_STABILIZZAZIONE <> 0 AND GREATEST(SP.SUPERFICIE_GRAFICA, SP.SUP_CATASTALE) > 0.5)
  ORDER BY SP.ID_STORICO_PARTICELLA;

    vDescAnomalia           DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    nIdStoricoParticella    DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE:=-1;

BEGIN

    FOR recPartFalsaPiccolaEMontana IN curPartFalsaPiccolaEMontana LOOP

        vDescAnomalia := '[' || recPartFalsaPiccolaEMontana.DESCOM || ' Sez : ' || NVL(recPartFalsaPiccolaEMontana.SEZIONE,'N.P.') ||' Fgl:' || recPartFalsaPiccolaEMontana.FOGLIO ||
                         ' Part:' || recPartFalsaPiccolaEMontana.PARTICELLA || ' Sub : ' || NVL(recPartFalsaPiccolaEMontana.SUBALTERNO,'N.P.') ||
                         ' la particella non soddisfa i requisiti previsti dall''allegato alla L.n. 116 del 11/08/2014, art.3, c.12 (particelle montane sotto i 0,5 ha)';



        IF nIdStoricoParticella <> recPartFalsaPiccolaEMontana.ID_STORICO_PARTICELLA THEN
           IF NOT SCRIVI_SEGNALAZIONE (pIdAzienda, pIdControllo, vDescAnomalia, pBloccante, recPartFalsaPiccolaEMontana.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (pIdAzienda, pIdControllo, vDescAnomalia, pBloccante, recPartFalsaPiccolaEMontana.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        nIdStoricoParticella := recPartFalsaPiccolaEMontana.ID_STORICO_PARTICELLA;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
         p_MsgErr   := 'ERRORE PICCOLA_PARTICELLA_MONTANA: ' || SQLERRM;
         p_CodErr   := SQLCODE;
         RETURN (FALSE);
END PICCOLA_PARTICELLA_MONTANA;

-- verifica che gli eventuali dettagli uso
-- (ulteriore dettaglio della varieta' di coltura)
-- specificati siano validi solo per validazioni non correttive
FUNCTION USO_NON_VALIDO (pIdAzienda   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                         pIdControllo IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                         pBloccante   IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                         P_MSGERR     IN OUT VARCHAR2,
                         P_CODERR     IN OUT VARCHAR2) RETURN BOOLEAN IS

     CURSOR curDettaglioUsoNonValido IS
     SELECT *
       FROM (
     SELECT SP.COMUNE,
            SP.SEZIONE,
            SP.FOGLIO,
            SP.PARTICELLA,
            SP.SUBALTERNO,
            SP.ID_STORICO_PARTICELLA,
            CP.ID_CONDUZIONE_PARTICELLA,
            C.DESCOM,
            TU.CODICE,
            TU.DESCRIZIONE,
            TV.CODICE_VARIETA,
            TV.DESCRIZIONE AS DESC_VARIETA,
            TDU.CODICE_DETTAGLIO_USO,
            TDU.DESCRIZIONE_DETTAGLIO_USO,
            TQU.CODICE_QUALITA_USO,
            TQU.DESCRIZIONE_QUALITA_USO,
            TD.CODICE_DESTINAZIONE,
            TD.DESCRIZIONE_DESTINAZIONE,
            'PRIMARIA' AS TIPO_COLTURA
       FROM DB_UTE UT,
            DB_CONDUZIONE_PARTICELLA CP,
            DB_UTILIZZO_PARTICELLA UP,
            DB_TIPO_UTILIZZO TU,
            DB_TIPO_VARIETA TV,
            DB_TIPO_DETTAGLIO_USO TDU,
            DB_STORICO_PARTICELLA SP,
            COMUNE C,
            DB_TIPO_CASO_PARTICOLARE TCP,DB_R_CATALOGO_MATRICE CM,DB_TIPO_QUALITA_USO TQU,
            DB_TIPO_DESTINAZIONE TD
      WHERE UT.ID_AZIENDA = pIdAzienda
        AND UT.ID_UTE = CP.ID_UTE
        AND UT.DATA_FINE_ATTIVITA IS NULL
        AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
        AND CP.DATA_FINE_CONDUZIONE IS NULL
        AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
        AND CM.ID_UTILIZZO = TU.ID_UTILIZZO 
        AND CM.ID_VARIETA = TV.ID_VARIETA 
        AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
        AND SP.DATA_FINE_VALIDITA IS NULL
        AND SP.COMUNE = C.ISTAT_COMUNE
        AND NVL(SP.ID_CASO_PARTICOLARE,99) = TCP.ID_CASO_PARTICOLARE
        AND TCP.EFFETTUA_CONTROLLI_GIS = 'S'
        AND CM.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO(+) 
        AND CM.DATA_FINE_VALIDITA IS NOT NULL
        AND CM.ID_TIPO_QUALITA_USO = TQU.ID_TIPO_QUALITA_USO(+)
        AND CM.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE(+)
      UNION ALL
     SELECT SP.COMUNE,
            SP.SEZIONE,
            SP.FOGLIO,
            SP.PARTICELLA,
            SP.SUBALTERNO,
            SP.ID_STORICO_PARTICELLA,
            CP.ID_CONDUZIONE_PARTICELLA,
            C.DESCOM,
            TU.CODICE,
            TU.DESCRIZIONE,
            TV.CODICE_VARIETA,
            TV.DESCRIZIONE AS DESC_VARIETA,
            TDU.CODICE_DETTAGLIO_USO,
            TDU.DESCRIZIONE_DETTAGLIO_USO,
            TQU.CODICE_QUALITA_USO,
            TQU.DESCRIZIONE_QUALITA_USO,
            TD.CODICE_DESTINAZIONE,
            TD.DESCRIZIONE_DESTINAZIONE,
            'SECONDARIA' AS TIPO_COLTURA
       FROM DB_UTE UT,
            DB_CONDUZIONE_PARTICELLA CP,
            DB_UTILIZZO_PARTICELLA UP,
            DB_TIPO_UTILIZZO TU,
            DB_TIPO_VARIETA TV,
            DB_TIPO_DETTAGLIO_USO TDU,
            DB_STORICO_PARTICELLA SP,
            COMUNE C,
            DB_TIPO_CASO_PARTICOLARE TCP,DB_R_CATALOGO_MATRICE CM,DB_TIPO_QUALITA_USO TQU,
            DB_TIPO_DESTINAZIONE TD
      WHERE UT.ID_AZIENDA = pIdAzienda
        AND UT.ID_UTE = CP.ID_UTE
        AND UT.DATA_FINE_ATTIVITA IS NULL
        AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
        AND CP.DATA_FINE_CONDUZIONE IS NULL
        AND UP.ID_CATALOGO_MATRICE_SECONDARIO = CM.ID_CATALOGO_MATRICE 
        AND CM.ID_UTILIZZO = TU.ID_UTILIZZO 
        AND CM.ID_VARIETA = TV.ID_VARIETA 
        AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
        AND SP.DATA_FINE_VALIDITA IS NULL
        AND SP.COMUNE = C.ISTAT_COMUNE
        AND NVL(SP.ID_CASO_PARTICOLARE,99) = TCP.ID_CASO_PARTICOLARE
        AND TCP.EFFETTUA_CONTROLLI_GIS = 'S'
        AND CM.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO(+) 
        AND CM.DATA_FINE_VALIDITA IS NOT NULL
        AND CM.ID_TIPO_QUALITA_USO = TQU.ID_TIPO_QUALITA_USO(+)
        AND CM.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE(+))
   ORDER BY ID_STORICO_PARTICELLA;


     CURSOR curDettaglioUsoNonSpecificato IS
     SELECT *
       FROM (
     SELECT SP.COMUNE,
            SP.SEZIONE,
            SP.FOGLIO,
            SP.PARTICELLA,
            SP.SUBALTERNO,
            SP.ID_STORICO_PARTICELLA,
            CP.ID_CONDUZIONE_PARTICELLA,
            C.DESCOM,
            TU.CODICE,
            TU.DESCRIZIONE,
            TV.CODICE_VARIETA,
            TV.DESCRIZIONE AS DESC_VARIETA,
            'PRIMARIA' AS TIPO_COLTURA
       FROM DB_UTE UT,
            DB_CONDUZIONE_PARTICELLA CP,
            DB_UTILIZZO_PARTICELLA UP,
            DB_TIPO_UTILIZZO TU,
            DB_TIPO_VARIETA TV,
            DB_STORICO_PARTICELLA SP,
            COMUNE C,
            DB_TIPO_CASO_PARTICOLARE TCP
      WHERE UT.ID_AZIENDA = pIdAzienda
        AND UT.ID_UTE = CP.ID_UTE
        AND UT.DATA_FINE_ATTIVITA IS NULL
        AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
        AND CP.DATA_FINE_CONDUZIONE IS NULL
        AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
        AND UP.ID_VARIETA = TV.ID_VARIETA
        AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
        AND SP.DATA_FINE_VALIDITA IS NULL
        AND SP.COMUNE = C.ISTAT_COMUNE
        AND NVL(SP.ID_CASO_PARTICOLARE,99) = TCP.ID_CASO_PARTICOLARE
        AND TCP.EFFETTUA_CONTROLLI_GIS = 'S'
        AND UP.ID_CATALOGO_MATRICE IS NULL 
      UNION ALL
     SELECT SP.COMUNE,
            SP.SEZIONE,
            SP.FOGLIO,
            SP.PARTICELLA,
            SP.SUBALTERNO,
            SP.ID_STORICO_PARTICELLA,
            CP.ID_CONDUZIONE_PARTICELLA,
            C.DESCOM,
            TU.CODICE,
            TU.DESCRIZIONE,
            TV.CODICE_VARIETA,
            TV.DESCRIZIONE AS DESC_VARIETA,
            'SECONDARIA' AS TIPO_COLTURA
       FROM DB_UTE UT,
            DB_CONDUZIONE_PARTICELLA CP,
            DB_UTILIZZO_PARTICELLA UP,
            DB_TIPO_UTILIZZO TU,
            DB_TIPO_VARIETA TV,
            DB_STORICO_PARTICELLA SP,
            COMUNE C,
            DB_TIPO_CASO_PARTICOLARE TCP
      WHERE UT.ID_AZIENDA = pIdAzienda
        AND UT.ID_UTE = CP.ID_UTE
        AND UT.DATA_FINE_ATTIVITA IS NULL
        AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
        AND CP.DATA_FINE_CONDUZIONE IS NULL
        AND UP.ID_UTILIZZO_SECONDARIO = TU.ID_UTILIZZO
        AND UP.ID_VARIETA_SECONDARIA = TV.ID_VARIETA
        AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
        AND SP.DATA_FINE_VALIDITA IS NULL
        AND SP.COMUNE = C.ISTAT_COMUNE
        AND NVL(SP.ID_CASO_PARTICOLARE,99) = TCP.ID_CASO_PARTICOLARE
        AND TCP.EFFETTUA_CONTROLLI_GIS = 'S'
        AND UP.ID_CATALOGO_MATRICE_SECONDARIO IS NULL) 
   ORDER BY ID_STORICO_PARTICELLA;

  vDescAnomalia         DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
  nIdStoricoParticella  DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE:=-1;

BEGIN

  FOR recDettaglioUsoNonValido IN curDettaglioUsoNonValido LOOP
    vDescAnomalia := '[' || recDettaglioUsoNonValido.DESCOM || ' Sez : ' || NVL(recDettaglioUsoNonValido.SEZIONE,'N.P.') ||' Fgl:' || recDettaglioUsoNonValido.FOGLIO ||
                         ' Part:' || recDettaglioUsoNonValido.PARTICELLA || ' Sub : ' || NVL(recDettaglioUsoNonValido.SUBALTERNO,'N.P.') ||
                         ' l''uso indicato per la coltura ' || recDettaglioUsoNonValido.TIPO_COLTURA || ' (' || recDettaglioUsoNonValido.CODICE || '-' ||
                                                                                                                recDettaglioUsoNonValido.DESCRIZIONE || '/' ||
                                                                                                                recDettaglioUsoNonValido.CODICE_DESTINAZIONE || '-' ||
                                                                                                                recDettaglioUsoNonValido.DESCRIZIONE_DESTINAZIONE || '/' ||
                                                                                                                recDettaglioUsoNonValido.CODICE_DETTAGLIO_USO || '-' ||
                                                                                                                recDettaglioUsoNonValido.DESCRIZIONE_DETTAGLIO_USO || '/' ||
                                                                                                                recDettaglioUsoNonValido.CODICE_QUALITA_USO || '-' ||
                                                                                                                recDettaglioUsoNonValido.DESCRIZIONE_QUALITA_USO || '/' ||
                                                                                                                recDettaglioUsoNonValido.CODICE_VARIETA || '-' ||
                                                                                                                recDettaglioUsoNonValido.DESC_VARIETA ||
                                                                                                                 ') non e'' piu'' valido secondo la matrice AGEA corrente';

        IF nIdStoricoParticella <> recDettaglioUsoNonValido.ID_STORICO_PARTICELLA THEN
           IF NOT SCRIVI_SEGNALAZIONE (pIdAzienda, pIdControllo, vDescAnomalia, pBloccante, recDettaglioUsoNonValido.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (pIdAzienda, pIdControllo, vDescAnomalia, pBloccante, recDettaglioUsoNonValido.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        nIdStoricoParticella := recDettaglioUsoNonValido.ID_STORICO_PARTICELLA;

    END LOOP;

    FOR recDettaglioUsoNonSpecificato IN curDettaglioUsoNonSpecificato LOOP

        vDescAnomalia := '[' || recDettaglioUsoNonSpecificato.DESCOM || ' Sez : ' || NVL(recDettaglioUsoNonSpecificato.SEZIONE,'N.P.') ||' Fgl:' || recDettaglioUsoNonSpecificato.FOGLIO ||
                         ' Part:' || recDettaglioUsoNonSpecificato.PARTICELLA || ' Sub : ' || NVL(recDettaglioUsoNonSpecificato.SUBALTERNO,'N.P.') ||
                         ' non e'' stato indicato l''uso a cinque livelli per la coltura ' || recDettaglioUsoNonSpecificato.TIPO_COLTURA || ' (' || recDettaglioUsoNonSpecificato.CODICE || '-' ||
                                                                                                                recDettaglioUsoNonSpecificato.DESCRIZIONE || '/' ||
                                                                                                                recDettaglioUsoNonSpecificato.CODICE_VARIETA || '-' ||
                                                                                                                recDettaglioUsoNonSpecificato.DESC_VARIETA || ')';

        IF nIdStoricoParticella <> recDettaglioUsoNonSpecificato.ID_STORICO_PARTICELLA THEN
           IF NOT SCRIVI_SEGNALAZIONE (pIdAzienda, pIdControllo, vDescAnomalia, pBloccante, recDettaglioUsoNonSpecificato.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (pIdAzienda, pIdControllo, vDescAnomalia, pBloccante, recDettaglioUsoNonSpecificato.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        nIdStoricoParticella := recDettaglioUsoNonSpecificato.ID_STORICO_PARTICELLA;

    END LOOP;


    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
         p_MsgErr   := 'ERRORE USO_NON_VALIDO : ' || SQLERRM;
         p_CodErr   := SQLCODE;
         RETURN (FALSE);
END USO_NON_VALIDO;

FUNCTION EPOCA_DI_SEMINA_CORRETTA (pIdAzienda   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                   pIdControllo IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                   pBloccante   IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                   P_MSGERR     IN OUT VARCHAR2,
                                   P_CODERR     IN OUT VARCHAR2) RETURN BOOLEAN IS


     CURSOR curPeriodoSeminaNonValido IS
     WITH PARTICELLA_CON_PERIODO AS (
     SELECT SP.COMUNE,
            SP.SEZIONE,
            SP.FOGLIO,
            SP.PARTICELLA,
            SP.SUBALTERNO,
            SP.ID_STORICO_PARTICELLA,
            CP.ID_CONDUZIONE_PARTICELLA,
            C.DESCOM,
            TU.CODICE,
            TU.DESCRIZIONE,
            TV.CODICE_VARIETA,
            TV.DESCRIZIONE AS DESC_VARIETA,
            'PRIMARIA' AS TIPO_COLTURA
       FROM DB_UTE UT,
            DB_CONDUZIONE_PARTICELLA CP,
            DB_UTILIZZO_PARTICELLA UP,
            DB_TIPO_UTILIZZO TU,
            DB_TIPO_VARIETA TV,
            DB_STORICO_PARTICELLA SP,
            COMUNE C,
            DB_TIPO_CASO_PARTICOLARE TCP
      WHERE UT.ID_AZIENDA = pIdAzienda
        AND UT.ID_UTE = CP.ID_UTE
        AND UT.DATA_FINE_ATTIVITA IS NULL
        AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
        AND CP.DATA_FINE_CONDUZIONE IS NULL
        AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
        AND UP.ID_VARIETA = TV.ID_VARIETA
        AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
        AND SP.DATA_FINE_VALIDITA IS NULL
        AND SP.COMUNE = C.ISTAT_COMUNE
        AND NVL(SP.ID_CASO_PARTICOLARE,99) = TCP.ID_CASO_PARTICOLARE
        AND TCP.EFFETTUA_CONTROLLI_GIS = 'S'
        AND ((TV.ID_TIPO_PERIODO_SEMINA = 0 AND NVL(UP.ID_TIPO_PERIODO_SEMINA,0) > 0) OR
             (TV.ID_TIPO_PERIODO_SEMINA > 0 AND NVL(UP.ID_TIPO_PERIODO_SEMINA,0) = 0))

      UNION ALL
     SELECT SP.COMUNE,
            SP.SEZIONE,
            SP.FOGLIO,
            SP.PARTICELLA,
            SP.SUBALTERNO,
            SP.ID_STORICO_PARTICELLA,
            CP.ID_CONDUZIONE_PARTICELLA,
            C.DESCOM,
            TU.CODICE,
            TU.DESCRIZIONE,
            TV.CODICE_VARIETA,
            TV.DESCRIZIONE AS DESC_VARIETA,
            'SECONDARIA' AS TIPO_COLTURA
       FROM DB_UTE UT,
            DB_CONDUZIONE_PARTICELLA CP,
            DB_UTILIZZO_PARTICELLA UP,
            DB_TIPO_UTILIZZO TU,
            DB_TIPO_VARIETA TV,
            DB_STORICO_PARTICELLA SP,
            COMUNE C,
            DB_TIPO_CASO_PARTICOLARE TCP
      WHERE UT.ID_AZIENDA = pIdAzienda
        AND UT.ID_UTE = CP.ID_UTE
        AND UT.DATA_FINE_ATTIVITA IS NULL
        AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
        AND CP.DATA_FINE_CONDUZIONE IS NULL
        AND UP.ID_UTILIZZO_SECONDARIO = TU.ID_UTILIZZO
        AND UP.ID_VARIETA_SECONDARIA = TV.ID_VARIETA
        AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
        AND SP.DATA_FINE_VALIDITA IS NULL
        AND SP.COMUNE = C.ISTAT_COMUNE
        AND NVL(SP.ID_CASO_PARTICOLARE,99) = TCP.ID_CASO_PARTICOLARE
        AND TCP.EFFETTUA_CONTROLLI_GIS = 'S'
        AND ((TV.ID_TIPO_PERIODO_SEMINA = 0 AND NVL(UP.ID_TIPO_PERIODO_SEMINA_SECOND,0) > 0) OR
             (TV.ID_TIPO_PERIODO_SEMINA > 0 AND NVL(UP.ID_TIPO_PERIODO_SEMINA_SECOND,0) = 0)))
    SELECT *
      FROM PARTICELLA_CON_PERIODO
   ORDER BY ID_STORICO_PARTICELLA;


   vDescAnomalia           DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
   nIdStoricoParticella    DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE:=-1;

BEGIN

    FOR recPeriodoSeminaNonValido IN curPeriodoSeminaNonValido LOOP

        vDescAnomalia := '[' || recPeriodoSeminaNonValido.DESCOM || ' Sez : ' || NVL(recPeriodoSeminaNonValido.SEZIONE,'N.P.') ||' Fgl:' || recPeriodoSeminaNonValido.FOGLIO ||
                         ' Part:' || recPeriodoSeminaNonValido.PARTICELLA || ' Sub : ' || NVL(recPeriodoSeminaNonValido.SUBALTERNO,'N.P.') ||
                         ' il periodo di semina indicato per la coltura ' || recPeriodoSeminaNonValido.TIPO_COLTURA || ' (' || recPeriodoSeminaNonValido.CODICE || '-' ||
                                                                                                                recPeriodoSeminaNonValido.DESCRIZIONE || '/' ||
                                                                                                                recPeriodoSeminaNonValido.CODICE_VARIETA || '-' ||
                                                                                                                recPeriodoSeminaNonValido.DESC_VARIETA || ') non e'' piu'' valido secondo la matrice AGEA vigente';

        IF nIdStoricoParticella <> recPeriodoSeminaNonValido.ID_STORICO_PARTICELLA THEN
           IF NOT SCRIVI_SEGNALAZIONE (pIdAzienda, pIdControllo, vDescAnomalia, pBloccante, recPeriodoSeminaNonValido.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (pIdAzienda, pIdControllo, vDescAnomalia, pBloccante, recPeriodoSeminaNonValido.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        nIdStoricoParticella := recPeriodoSeminaNonValido.ID_STORICO_PARTICELLA;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
         p_MsgErr   := 'ERRORE EPOCA_DI_SEMINA_CORRETTA : ' || SQLERRM;
         p_CodErr   := SQLCODE;
         RETURN (FALSE);
END EPOCA_DI_SEMINA_CORRETTA;


-- TER56 verifica che non siano stati impostati
-- sulle particelle eventuali dettaglio uso
-- previsti solo al di sopra dei 2.000 metri sul livello del mare
-- se la particella non ha un'altitudine media sopra i 2.000 metri
FUNCTION USO_NON_AMMESSO_SOTTO_I_2000M (pIdAzienda   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                        pIdControllo IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        pBloccante   IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                        P_MSGERR     IN OUT VARCHAR2,
                                        P_CODERR     IN OUT VARCHAR2) RETURN BOOLEAN IS

     CURSOR curDettUsoNonAmmessoSottoI2000 IS
     SELECT SP.COMUNE,
            SP.SEZIONE,
            SP.FOGLIO,
            SP.PARTICELLA,
            SP.SUBALTERNO,
            SP.ID_STORICO_PARTICELLA,
            CP.ID_CONDUZIONE_PARTICELLA,
            C.DESCOM,
            TU.CODICE,
            TU.DESCRIZIONE,
            TV.CODICE_VARIETA,
            TV.DESCRIZIONE AS DESC_VARIETA,
            TDU.CODICE_DETTAGLIO_USO,
            TDU.DESCRIZIONE_DETTAGLIO_USO,
            NVL(SP.METRI_ALTITUDINE_MEDIA,0) AS ALTITUDINE
       FROM DB_UTE UT,
            DB_CONDUZIONE_PARTICELLA CP,
            DB_UTILIZZO_PARTICELLA UP,
            DB_TIPO_UTILIZZO TU,
            DB_TIPO_VARIETA TV,
            DB_TIPO_DETTAGLIO_USO TDU,
            DB_STORICO_PARTICELLA SP,
            COMUNE C,DB_R_CATALOGO_MATRICE CM
      WHERE UT.ID_AZIENDA = pIdAzienda
        AND UT.ID_UTE = CP.ID_UTE
        AND UT.DATA_FINE_ATTIVITA IS NULL
        AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
        AND CP.DATA_FINE_CONDUZIONE IS NULL
        AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
        AND UP.ID_VARIETA = TV.ID_VARIETA
        AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
        AND SP.DATA_FINE_VALIDITA IS NULL
        AND SP.COMUNE = C.ISTAT_COMUNE
        AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE  
        AND CM.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO 
        AND CM.FLAG_SOLO_OLTRE_2000_MSL = 'S' 
        AND NVL(SP.METRI_ALTITUDINE_MEDIA,0) < 2000
   ORDER BY SP.ID_STORICO_PARTICELLA;

   vDescAnomalia           DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
   nIdStoricoParticella    DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE:=-1;

BEGIN

    FOR recDettUsoNonAmmessoSottoI2000 IN curDettUsoNonAmmessoSottoI2000 LOOP

        vDescAnomalia := '[' || recDettUsoNonAmmessoSottoI2000.DESCOM || ' Sez : ' || NVL(recDettUsoNonAmmessoSottoI2000.SEZIONE,'N.P.') ||' Fgl:' || recDettUsoNonAmmessoSottoI2000.FOGLIO ||
                         ' Part:' || recDettUsoNonAmmessoSottoI2000.PARTICELLA || ' Sub : ' || NVL(recDettUsoNonAmmessoSottoI2000.SUBALTERNO,'N.P.') ||
                         ' il prodotto indicato  '  || ' (' || recDettUsoNonAmmessoSottoI2000.CODICE || '-' ||
                                                               recDettUsoNonAmmessoSottoI2000.DESCRIZIONE || '/' ||
                                                               recDettUsoNonAmmessoSottoI2000.CODICE_VARIETA || '-' ||
                                                               recDettUsoNonAmmessoSottoI2000.DESC_VARIETA || '/' ||
                                                               recDettUsoNonAmmessoSottoI2000.CODICE_DETTAGLIO_USO || '-' ||
                                                               recDettUsoNonAmmessoSottoI2000.DESCRIZIONE_DETTAGLIO_USO || ') non puo'' essere utilizzato in quanto la particella ha un''altitudine inferiore ai 2000 ml.';

        IF nIdStoricoParticella <> recDettUsoNonAmmessoSottoI2000.ID_STORICO_PARTICELLA THEN
           IF NOT SCRIVI_SEGNALAZIONE (pIdAzienda, pIdControllo, vDescAnomalia, pBloccante, recDettUsoNonAmmessoSottoI2000.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (pIdAzienda, pIdControllo, vDescAnomalia, pBloccante, recDettUsoNonAmmessoSottoI2000.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        nIdStoricoParticella := recDettUsoNonAmmessoSottoI2000.ID_STORICO_PARTICELLA;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
         p_MsgErr   := 'ERRORE USO_NON_AMMESSO_SOTTO_I_2000M : ' || SQLERRM;
         p_CodErr   := SQLCODE;
         RETURN (FALSE);
END USO_NON_AMMESSO_SOTTO_I_2000M;


-- TER57 verifica che non siano stati impostati
-- sulle particelle eventuali dettaglio uso
-- non ammessi per il Piemonte
FUNCTION USO_NON_CONSENTITO_PIEMONTE (pIdAzienda   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                      pIdControllo IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                      pBloccante   IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                      P_MSGERR     IN OUT VARCHAR2,
                                      P_CODERR     IN OUT VARCHAR2) RETURN BOOLEAN IS

     CURSOR curDettUsoNonAmmessoPiemonte IS
     SELECT SP.COMUNE,
            SP.SEZIONE,
            SP.FOGLIO,
            SP.PARTICELLA,
            SP.SUBALTERNO,
            SP.ID_STORICO_PARTICELLA,
            CP.ID_CONDUZIONE_PARTICELLA,
            C.DESCOM,
            TU.CODICE,
            TU.DESCRIZIONE,
            TV.CODICE_VARIETA,
            TV.DESCRIZIONE AS DESC_VARIETA,
            TDU.CODICE_DETTAGLIO_USO,
            TDU.DESCRIZIONE_DETTAGLIO_USO
       FROM DB_UTE UT,
            DB_CONDUZIONE_PARTICELLA CP,
            DB_UTILIZZO_PARTICELLA UP,
            DB_TIPO_UTILIZZO TU,
            DB_TIPO_VARIETA TV,
            DB_TIPO_DETTAGLIO_USO TDU,
            DB_STORICO_PARTICELLA SP,
            COMUNE C,
            PROVINCIA P,DB_R_CATALOGO_MATRICE CM
      WHERE UT.ID_AZIENDA = pIdAzienda
        AND UT.ID_UTE = CP.ID_UTE
        AND UT.DATA_FINE_ATTIVITA IS NULL
        AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
        AND CP.DATA_FINE_CONDUZIONE IS NULL
        AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
        AND UP.ID_VARIETA = TV.ID_VARIETA
        AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
        AND SP.DATA_FINE_VALIDITA IS NULL
        AND SP.COMUNE = C.ISTAT_COMUNE
        AND C.ISTAT_PROVINCIA = P.ISTAT_PROVINCIA
        AND P.ID_REGIONE = '01'
        AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
        AND CM.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO 
        AND CM.FLAG_NO_PIEMONTE = 'S' 
   ORDER BY SP.ID_STORICO_PARTICELLA;

   vDescAnomalia           DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
   nIdStoricoParticella    DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE:=-1;

BEGIN

    FOR recDettUsoNonAmmessoPiemonte IN curDettUsoNonAmmessoPiemonte LOOP

        vDescAnomalia := '[' || recDettUsoNonAmmessoPiemonte.DESCOM || ' Sez : ' || NVL(recDettUsoNonAmmessoPiemonte.SEZIONE,'N.P.') ||' Fgl:' || recDettUsoNonAmmessoPiemonte.FOGLIO ||
                         ' Part:' || recDettUsoNonAmmessoPiemonte.PARTICELLA || ' Sub : ' || NVL(recDettUsoNonAmmessoPiemonte.SUBALTERNO,'N.P.') ||
                         ' il prodotto indicato  '  || ' (' || recDettUsoNonAmmessoPiemonte.CODICE || '-' ||
                                                               recDettUsoNonAmmessoPiemonte.DESCRIZIONE || '/' ||
                                                               recDettUsoNonAmmessoPiemonte.CODICE_VARIETA || '-' ||
                                                               recDettUsoNonAmmessoPiemonte.DESC_VARIETA || '/' ||
                                                               recDettUsoNonAmmessoPiemonte.CODICE_DETTAGLIO_USO || '-' ||
                                                               recDettUsoNonAmmessoPiemonte.DESCRIZIONE_DETTAGLIO_USO || ') non puo'' essere utilizzato in quanto la particella e'' ubicata in Piemonte';

        IF nIdStoricoParticella <> recDettUsoNonAmmessoPiemonte.ID_STORICO_PARTICELLA THEN
           IF NOT SCRIVI_SEGNALAZIONE (pIdAzienda, pIdControllo, vDescAnomalia, pBloccante, recDettUsoNonAmmessoPiemonte.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (pIdAzienda, pIdControllo, vDescAnomalia, pBloccante, recDettUsoNonAmmessoPiemonte.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        nIdStoricoParticella := recDettUsoNonAmmessoPiemonte.ID_STORICO_PARTICELLA;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
         p_MsgErr   := 'ERRORE USO_NON_CONSENTITO_PIEMONTE : ' || SQLERRM;
         p_CodErr   := SQLCODE;
         RETURN (FALSE);
END USO_NON_CONSENTITO_PIEMONTE;


-- TER58
-- congruenza dettaglio uso - varieta'
FUNCTION USO_NON_CONGRUENTE_VARIETA (pIdAzienda   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                     pIdControllo IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                     pBloccante   IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                     P_MSGERR     IN OUT VARCHAR2,
                                     P_CODERR     IN OUT VARCHAR2) RETURN BOOLEAN IS

    vDescAnomalia           DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    nIdStoricoParticella    DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE:=-1;

     CURSOR curUsoNonCongruenteVarieta IS
     SELECT *
       FROM (
     SELECT SP.COMUNE,
            SP.SEZIONE,
            SP.FOGLIO,
            SP.PARTICELLA,
            SP.SUBALTERNO,
            SP.ID_STORICO_PARTICELLA,
            CP.ID_CONDUZIONE_PARTICELLA,
            C.DESCOM,
            TU.CODICE,
            TU.DESCRIZIONE,
            TV.CODICE_VARIETA,
            TV.DESCRIZIONE AS DESC_VARIETA,
            TDU.CODICE_DETTAGLIO_USO,
            TDU.DESCRIZIONE_DETTAGLIO_USO,
            'PRIMARIA' AS TIPO_COLTURA
       FROM DB_UTE UT,
            DB_CONDUZIONE_PARTICELLA CP,
            DB_UTILIZZO_PARTICELLA UP,
            DB_TIPO_UTILIZZO TU,
            DB_TIPO_VARIETA TV,
            DB_TIPO_DETTAGLIO_USO TDU,
            DB_STORICO_PARTICELLA SP,
            COMUNE C,
            DB_TIPO_CASO_PARTICOLARE TCP,DB_R_CATALOGO_MATRICE CM
      WHERE UT.ID_AZIENDA = pIdAzienda
        AND UT.ID_UTE = CP.ID_UTE
        AND UT.DATA_FINE_ATTIVITA IS NULL
        AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
        AND CP.DATA_FINE_CONDUZIONE IS NULL
        AND CM.ID_CATALOGO_MATRICE = UP.ID_CATALOGO_MATRICE 
        AND CM.ID_UTILIZZO = TU.ID_UTILIZZO 
        AND CM.ID_VARIETA = TV.ID_VARIETA 
        AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
        AND SP.DATA_FINE_VALIDITA IS NULL
        AND SP.COMUNE = C.ISTAT_COMUNE
        AND NVL(SP.ID_CASO_PARTICOLARE,99) = TCP.ID_CASO_PARTICOLARE
        AND TCP.EFFETTUA_CONTROLLI_GIS = 'S'
        AND CM.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO 
  UNION ALL
     SELECT SP.COMUNE,
            SP.SEZIONE,
            SP.FOGLIO,
            SP.PARTICELLA,
            SP.SUBALTERNO,
            SP.ID_STORICO_PARTICELLA,
            CP.ID_CONDUZIONE_PARTICELLA,
            C.DESCOM,
            TU.CODICE,
            TU.DESCRIZIONE,
            TV.CODICE_VARIETA,
            TV.DESCRIZIONE AS DESC_VARIETA,
            TDU.CODICE_DETTAGLIO_USO,
            TDU.DESCRIZIONE_DETTAGLIO_USO,
            'SECONDARIA' AS TIPO_COLTURA
       FROM DB_UTE UT,
            DB_CONDUZIONE_PARTICELLA CP,
            DB_UTILIZZO_PARTICELLA UP,
            DB_TIPO_UTILIZZO TU,
            DB_TIPO_VARIETA TV,
            DB_TIPO_DETTAGLIO_USO TDU,
            DB_STORICO_PARTICELLA SP,
            COMUNE C,
            DB_TIPO_CASO_PARTICOLARE TCP,DB_R_CATALOGO_MATRICE CM
      WHERE UT.ID_AZIENDA = pIdAzienda
        AND UT.ID_UTE = CP.ID_UTE
        AND UT.DATA_FINE_ATTIVITA IS NULL
        AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
        AND CP.DATA_FINE_CONDUZIONE IS NULL
        AND CM.ID_CATALOGO_MATRICE = UP.ID_CATALOGO_MATRICE_SECONDARIO 
        AND CM.ID_UTILIZZO = TU.ID_UTILIZZO 
        AND CM.ID_VARIETA = TV.ID_VARIETA 
        AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
        AND SP.DATA_FINE_VALIDITA IS NULL
        AND SP.COMUNE = C.ISTAT_COMUNE
        AND NVL(SP.ID_CASO_PARTICOLARE,99) = TCP.ID_CASO_PARTICOLARE
        AND TCP.EFFETTUA_CONTROLLI_GIS = 'S'
        AND CM.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO 
        AND TDU.DATA_FINE_VALIDITA IS NOT NULL)
   ORDER BY ID_STORICO_PARTICELLA;


BEGIN

    FOR recUsoNonCongruenteVarieta IN curUsoNonCongruenteVarieta LOOP

        vDescAnomalia := '[' || recUsoNonCongruenteVarieta.DESCOM || ' Sez : ' || NVL(recUsoNonCongruenteVarieta.SEZIONE,'N.P.') ||' Fgl:' || recUsoNonCongruenteVarieta.FOGLIO ||
                         ' Part:' || recUsoNonCongruenteVarieta.PARTICELLA || ' Sub : ' || NVL(recUsoNonCongruenteVarieta.SUBALTERNO,'N.P.') ||
                         ' l''uso indicato per la coltura ' || recUsoNonCongruenteVarieta.TIPO_COLTURA || ' (' || recUsoNonCongruenteVarieta.CODICE || '-' ||
                                                                                                                recUsoNonCongruenteVarieta.DESCRIZIONE || '/' ||
                                                                                                                recUsoNonCongruenteVarieta.CODICE_VARIETA || '-' ||
                                                                                                                recUsoNonCongruenteVarieta.DESC_VARIETA || ' / ' ||
                                                                                                                recUsoNonCongruenteVarieta.CODICE_DETTAGLIO_USO || '-' ||
                                                                                                                recUsoNonCongruenteVarieta.DESCRIZIONE_DETTAGLIO_USO || ') presenta un dettaglio uso non compatibile con la varieta'' indicata, correggere l''anomalia tornando in modifica della particella';

        IF nIdStoricoParticella <> recUsoNonCongruenteVarieta.ID_STORICO_PARTICELLA THEN
           IF NOT SCRIVI_SEGNALAZIONE (pIdAzienda, pIdControllo, vDescAnomalia, pBloccante, recUsoNonCongruenteVarieta.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (pIdAzienda, pIdControllo, vDescAnomalia, pBloccante, recUsoNonCongruenteVarieta.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        nIdStoricoParticella := recUsoNonCongruenteVarieta.ID_STORICO_PARTICELLA;


    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
         p_MsgErr   := 'ERRORE USO_NON_CONGRUENTE_VARIETA : ' || SQLERRM;
         p_CodErr   := SQLCODE;
         RETURN (FALSE);
END USO_NON_CONGRUENTE_VARIETA;

-- TER59: controllo presenza particelle con uso civico
FUNCTION PresPartUsoCivico(pIdAzienda           DB_AZIENDA.ID_AZIENDA%TYPE,
                           pIdControllo         DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                           pBloccante           DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                           pMsgerr       IN OUT VARCHAR2,
                           pCoderr       IN OUT VARCHAR2) RETURN BOOLEAN IS

  vMessaggio            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
  nIdStoricoParticella  DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE:=-1;
BEGIN
  FOR rec IN (SELECT CP.ID_CONDUZIONE_PARTICELLA, C.DESCOM,SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA,
                     SP.SUBALTERNO,SP.ID_STORICO_PARTICELLA
              FROM   DB_UTE U, DB_CONDUZIONE_PARTICELLA CP, DB_UTILIZZO_PARTICELLA UP,
                     DB_STORICO_PARTICELLA SP, COMUNE C, DB_TIPO_CASO_PARTICOLARE TCP
              WHERE  U.ID_AZIENDA                   = pIdAzienda
              AND    U.ID_UTE                       = CP.ID_UTE
              AND    CP.ID_CONDUZIONE_PARTICELLA    = UP.ID_CONDUZIONE_PARTICELLA
              AND    CP.DATA_FINE_CONDUZIONE        IS NULL
              AND    SP.ID_PARTICELLA               = CP.ID_PARTICELLA
              AND    SP.DATA_FINE_VALIDITA          IS NULL
              AND    C.ISTAT_COMUNE                 = SP.COMUNE
              AND    NVL(SP.ID_CASO_PARTICOLARE,99) = TCP.ID_CASO_PARTICOLARE
              AND    CP.ID_TITOLO_POSSESSO          NOT IN (5,6)
              AND    TCP.ID_CASO_PARTICOLARE        = 3) LOOP

    vMessaggio := 'la particella ha caso particolare USO CIVICO : ' ||
                  '[' || rec.DESCOM || ' Sez : ' || NVL(rec.SEZIONE,'N.P.') ||' Fgl:' || rec.FOGLIO ||
                  ' Part:' || rec.PARTICELLA || ' Sub : ' || NVL(rec.SUBALTERNO,'N.P.') || ']';

    IF nIdStoricoParticella <> rec.ID_STORICO_PARTICELLA THEN
      IF NOT SCRIVI_SEGNALAZIONE(pIdAzienda, pIdControllo, vMessaggio, pBloccante, rec.ID_STORICO_PARTICELLA, NULL, pMsgerr, pCoderr) THEN
        RETURN FALSE;
      END IF;
    END IF;

    IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA(pIdAzienda, pIdControllo, vMessaggio, pBloccante,
                                          rec.ID_CONDUZIONE_PARTICELLA, pMsgerr, pCoderr) THEN
      RETURN FALSE;
    END IF;

    nIdStoricoParticella := rec.ID_STORICO_PARTICELLA;
  END LOOP;

  RETURN TRUE;

EXCEPTION
  WHEN OTHERS THEN
    pMsgerr := 'ERRORE PresPartUsoCivico : ' || SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    pCoderr := SQLCODE;
    RETURN FALSE;
END PresPartUsoCivico;

-- TER60: controllo presenza particelle condivise
FUNCTION PresPartCondivise(pIdAzienda           DB_AZIENDA.ID_AZIENDA%TYPE,
                           pIdControllo         DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                           pBloccante           DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                           pMsgerr       IN OUT VARCHAR2,
                           pCoderr       IN OUT VARCHAR2) RETURN BOOLEAN IS

  vMessaggio            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
  nIdStoricoParticella  DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE:=-1;
BEGIN
  FOR rec IN (SELECT CP.ID_CONDUZIONE_PARTICELLA, C.DESCOM,SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA,
                     SP.SUBALTERNO,AA.CUAA,SP.ID_STORICO_PARTICELLA
              FROM   DB_UTE U, DB_CONDUZIONE_PARTICELLA CP, DB_UTILIZZO_PARTICELLA UP,
                     DB_STORICO_PARTICELLA SP, COMUNE C,DB_CONDUZIONE_DICHIARATA CD,
                     DB_DICHIARAZIONE_CONSISTENZA DC,DB_ANAGRAFICA_AZIENDA AA
              WHERE  U.ID_AZIENDA                       = pIdAzienda
              AND    U.ID_UTE                           = CP.ID_UTE
              AND    CP.ID_CONDUZIONE_PARTICELLA        = UP.ID_CONDUZIONE_PARTICELLA
              AND    CP.DATA_FINE_CONDUZIONE            IS NULL
              AND    SP.ID_PARTICELLA                   = CP.ID_PARTICELLA
              AND    SP.DATA_FINE_VALIDITA              IS NULL
              AND    C.ISTAT_COMUNE                     = SP.COMUNE
              AND    CP.ID_TITOLO_POSSESSO              NOT IN (5,6)
              AND    CD.CODICE_FOTOGRAFIA_TERRENI       = DC.CODICE_FOTOGRAFIA_TERRENI
              AND    AA.ID_AZIENDA                      = DC.ID_AZIENDA
              AND    AA.DATA_FINE_VALIDITA              IS NULL
              AND    AA.DATA_CESSAZIONE                 IS NULL
              AND    CP.ID_PARTICELLA                   = CD.ID_PARTICELLA
              AND    AA.ID_AZIENDA                     != pIdAzienda
              AND    DC.ID_MOTIVO_DICHIARAZIONE        != 7
              AND    DC.DATA_INSERIMENTO_DICHIARAZIONE  = (SELECT MAX(DCX.DATA_INSERIMENTO_DICHIARAZIONE)
                                                           FROM   DB_DICHIARAZIONE_CONSISTENZA DCX,
                                                                  DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                           WHERE  DCX.ID_AZIENDA               = DC.ID_AZIENDA
                                                           AND    DCX.ID_MOTIVO_DICHIARAZIONE != 7
                                                           AND    TI.ID_MOTIVO_DICHIARAZIONE   = DCX.ID_MOTIVO_DICHIARAZIONE
                                                           AND    TI.TIPO_DICHIARAZIONE       != 'C'
                                                           AND    DCX.DATA                    >= TO_DATE('01/01/'||TO_CHAR(EXTRACT(YEAR FROM SYSDATE)-1),'DD/MM/YYYY'))
              AND    CD.ID_TITOLO_POSSESSO              NOT IN (5,6)) LOOP 

    vMessaggio := 'la particella : ' ||
                  '[' || rec.DESCOM || ' Sez : ' || NVL(rec.SEZIONE,'N.P.') ||' Fgl:' || rec.FOGLIO ||
                  ' Part:' || rec.PARTICELLA || ' Sub : ' || NVL(rec.SUBALTERNO,'N.P.') || '] '||
                  'e'' condivisa con un''altra azienda : '||rec.CUAA;

    IF nIdStoricoParticella <> rec.ID_STORICO_PARTICELLA THEN
      IF NOT SCRIVI_SEGNALAZIONE(pIdAzienda, pIdControllo, vMessaggio, pBloccante, rec.ID_STORICO_PARTICELLA, NULL, pMsgerr, pCoderr) THEN
        RETURN FALSE;
      END IF;
    END IF;

    IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA(pIdAzienda, pIdControllo, vMessaggio, pBloccante,
                                          rec.ID_CONDUZIONE_PARTICELLA, pMsgerr, pCoderr) THEN
      RETURN FALSE;
    END IF;

    nIdStoricoParticella := rec.ID_STORICO_PARTICELLA;
  END LOOP;

  RETURN TRUE;

EXCEPTION
  WHEN OTHERS THEN
    pMsgerr := 'ERRORE PresPartCondivise : ' || SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    pCoderr := SQLCODE;
    RETURN FALSE;
END PresPartCondivise;

-- TER61: controllo date destinazione colturali corrette
FUNCTION DateDestColtCorrette(pIdAzienda           DB_AZIENDA.ID_AZIENDA%TYPE,
                              pIdControllo         DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                              pBloccante           DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                              pMsgerr       IN OUT VARCHAR2,
                              pCoderr       IN OUT VARCHAR2) RETURN BOOLEAN IS

  vMessaggio            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
  nIdStoricoParticella  DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE:=-1;
BEGIN
  FOR rec IN (SELECT CP.ID_CONDUZIONE_PARTICELLA, C.DESCOM,SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA,
                     SP.SUBALTERNO,SP.ID_STORICO_PARTICELLA
              FROM   DB_UTE U, DB_CONDUZIONE_PARTICELLA CP, DB_UTILIZZO_PARTICELLA UP,
                     DB_STORICO_PARTICELLA SP, COMUNE C
              WHERE  U.ID_AZIENDA                = pIdAzienda
              AND    U.ID_UTE                    = CP.ID_UTE
              AND    CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
              AND    CP.DATA_FINE_CONDUZIONE     IS NULL
              AND    SP.ID_PARTICELLA            = CP.ID_PARTICELLA
              AND    SP.DATA_FINE_VALIDITA       IS NULL
              AND    C.ISTAT_COMUNE              = SP.COMUNE
              AND    ((UP.DATA_INIZIO_DESTINAZIONE                       >= UP.DATA_FINE_DESTINAZIONE) OR (NVL(UP.DATA_INIZIO_DESTINAZIONE_SEC,SYSDATE)      >= NVL(UP.DATA_FINE_DESTINAZIONE_SEC,SYSDATE+1)) OR
                      (NVL(UP.DATA_INIZIO_DESTINAZIONE_SEC,SYSDATE+4000) < NVL(UP.DATA_INIZIO_DESTINAZIONE,SYSDATE) AND NVL(UP.DATA_FINE_DESTINAZIONE_SEC,SYSDATE-2000) > NVL(UP.DATA_INIZIO_DESTINAZIONE,SYSDATE))
                      OR
                      (NVL(UP.DATA_INIZIO_DESTINAZIONE,SYSDATE) < NVL(UP.DATA_INIZIO_DESTINAZIONE_SEC,SYSDATE-2000) AND NVL(UP.DATA_FINE_DESTINAZIONE,SYSDATE) > NVL(UP.DATA_INIZIO_DESTINAZIONE_SEC,SYSDATE+2000)))) LOOP

    vMessaggio := 'per la particella : ' ||
                  '[' || rec.DESCOM || ' Sez : ' || NVL(rec.SEZIONE,'N.P.') ||' Fgl:' || rec.FOGLIO ||
                  ' Part:' || rec.PARTICELLA || ' Sub : ' || NVL(rec.SUBALTERNO,'N.P.') || '] '||
                  'la data fine destinazione deve essere successiva alla data inizio destinazione '||
                  ', e la destinazione dell''uso secondario deve essere successiva a quella del primario';

    IF nIdStoricoParticella <> rec.ID_STORICO_PARTICELLA THEN
      IF NOT SCRIVI_SEGNALAZIONE(pIdAzienda, pIdControllo, vMessaggio, pBloccante, rec.ID_STORICO_PARTICELLA, NULL, pMsgerr, pCoderr) THEN
        RETURN FALSE;
      END IF;
    END IF;

    IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA(pIdAzienda, pIdControllo, vMessaggio, pBloccante,
                                          rec.ID_CONDUZIONE_PARTICELLA, pMsgerr, pCoderr) THEN
      RETURN FALSE;
    END IF;

    nIdStoricoParticella := rec.ID_STORICO_PARTICELLA;
  END LOOP;

  RETURN TRUE;

EXCEPTION
  WHEN OTHERS THEN
    pMsgerr := 'ERRORE DateDestColtCorrette : ' || SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    pCoderr := SQLCODE;
    RETURN FALSE;
END DateDestColtCorrette;

-- TER62: presenza particelle condivise alla validazione
FUNCTION TER62(pIdAzienda               DB_AZIENDA.ID_AZIENDA%TYPE,
               pIdDichiarazione         DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
               pIdControllo             DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
               pBloccante               DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
               pMsgerr           IN OUT VARCHAR2,
               pCoderr           IN OUT VARCHAR2) RETURN BOOLEAN IS

  vMessaggio            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
  nIdStoricoParticella  DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE:=-1;
BEGIN
  FOR rec IN (SELECT C.DESCOM,SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA,SP.SUBALTERNO,AA.CUAA,
                     SP.ID_STORICO_PARTICELLA,ID_CONDUZIONE_PARTICELLA
              FROM   DB_CONDUZIONE_DICHIARATA CD,DB_DICHIARAZIONE_CONSISTENZA DC,DB_STORICO_PARTICELLA SP,
                     COMUNE C,DB_ANAGRAFICA_AZIENDA AA
              WHERE  DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazione
              AND    CD.CODICE_FOTOGRAFIA_TERRENI    = DC.CODICE_FOTOGRAFIA_TERRENI
              AND    CD.ID_TITOLO_POSSESSO           NOT IN (5,6)
              AND    SP.ID_PARTICELLA                = CD.ID_PARTICELLA
              AND    SP.DATA_FINE_VALIDITA           IS NULL
              AND    C.ISTAT_COMUNE                  = SP.COMUNE
              AND    AA.ID_AZIENDA                   = DC.ID_AZIENDA
              AND    AA.DATA_FINE_VALIDITA           IS NULL
              AND    AA.DATA_CESSAZIONE              IS NULL
              AND    EXISTS                          (SELECT 'X'
                                                      FROM   DB_CONDUZIONE_DICHIARATA CD1,DB_DICHIARAZIONE_CONSISTENZA DC1
                                                      WHERE  CD1.ID_PARTICELLA                   = CD.ID_PARTICELLA
                                                      AND    CD1.CODICE_FOTOGRAFIA_TERRENI       = DC1.CODICE_FOTOGRAFIA_TERRENI
                                                      AND    CD.ID_TITOLO_POSSESSO               NOT IN (5,6)
                                                      AND    DC1.ID_AZIENDA                     != DC.ID_AZIENDA
                                                      AND    DC1.DATA_INSERIMENTO_DICHIARAZIONE  = (SELECT MAX(DCX.DATA_INSERIMENTO_DICHIARAZIONE)
                                                                                                    FROM   DB_DICHIARAZIONE_CONSISTENZA DCX,DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                                                                    WHERE  DCX.ID_AZIENDA               = DC.ID_AZIENDA
                                                                                                    AND    DCX.ANNO                     = TO_CHAR(SYSDATE,'YYYY')
                                                                                                    AND    DCX.ID_MOTIVO_DICHIARAZIONE != 7
                                                                                                    AND    TI.ID_MOTIVO_DICHIARAZIONE   = DCX.ID_MOTIVO_DICHIARAZIONE
                                                                                                    AND    DCX.DATA                    >= TO_DATE('01/01/'||TO_CHAR(TO_NUMBER(EXTRACT (YEAR FROM SYSDATE)-1)),'DD/MM/YYYY')
                                                                                                    AND    TI.TIPO_DICHIARAZIONE       != 'C'))) LOOP
    vMessaggio := 'La particella : ' ||
                  '[' || rec.DESCOM || ' Sez : ' || NVL(rec.SEZIONE,'N.P.') ||' Fgl:' || rec.FOGLIO ||
                  ' Part:' || rec.PARTICELLA || ' Sub : ' || NVL(rec.SUBALTERNO,'N.P.') || '] '||
                  'e'' condivisa con un''altra azienda: '||rec.CUAA;

    IF nIdStoricoParticella <> rec.ID_STORICO_PARTICELLA THEN
      IF NOT SCRIVI_SEGNALAZIONE(pIdAzienda, pIdControllo, vMessaggio, pBloccante, rec.ID_STORICO_PARTICELLA, NULL, pMsgerr, pCoderr) THEN
        RETURN FALSE;
      END IF;
    END IF;

    IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA(pIdAzienda, pIdControllo, vMessaggio, pBloccante,
                                          rec.ID_CONDUZIONE_PARTICELLA, pMsgerr, pCoderr) THEN
      RETURN FALSE;
    END IF;

    nIdStoricoParticella := rec.ID_STORICO_PARTICELLA;
  END LOOP;

  RETURN TRUE;

EXCEPTION
  WHEN OTHERS THEN
    pMsgerr := 'ERRORE TER62 : ' || SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    pCoderr := SQLCODE;
    RETURN FALSE;
END TER62;

-- TER63: PARTICELLE CON P26 ANCORA ACCESE DOPO ISTANZE
FUNCTION TER63(pIdAzienda               DB_AZIENDA.ID_AZIENDA%TYPE,
               pIdDichiarazione         DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
               pVite                    VARCHAR2,
               pIdControllo             DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
               pBloccante               DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
               pMsgerr           IN OUT VARCHAR2,
               pCoderr           IN OUT VARCHAR2) RETURN BOOLEAN IS

  CURSOR C_ELEGG IS SELECT SP.COMUNE, C.DESCOM, SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA, SP.SUBALTERNO,
                           NVL(SUM(UD.SUPERFICIE_UTILIZZATA),0) SUM_SUP_UTIL,  SP.ID_STORICO_PARTICELLA,
                           SP.ID_PARTICELLA,PC.ID_PARTICELLA_CERTIFICATA
                    FROM   DB_STORICO_PARTICELLA SP,DB_CONDUZIONE_DICHIARATA CD,DB_UTILIZZO_DICHIARATO UD,
                           DB_TIPO_UTILIZZO TU,DB_UTE U,COMUNE C,DB_PARTICELLA_CERTIFICATA PC,
                           DB_TIPO_CASO_PARTICOLARE CP,DB_DICHIARAZIONE_CONSISTENZA DC
                    WHERE  DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazione
                    AND    CD.CODICE_FOTOGRAFIA_TERRENI    = DC.CODICE_FOTOGRAFIA_TERRENI
                    AND    SP.DATA_FINE_VALIDITA           IS NULL
                    AND    NVL(SP.ID_CASO_PARTICOLARE,99)  = CP.ID_CASO_PARTICOLARE
                    AND    CP.EFFETTUA_CONTROLLI_GIS       = 'S'
                    AND    SP.ID_PARTICELLA                = CD.ID_PARTICELLA
                    AND    CD.ID_CONDUZIONE_DICHIARATA     = UD.ID_CONDUZIONE_DICHIARATA
                    AND    CD.ID_TITOLO_POSSESSO          != 5
                    AND    CD.DATA_FINE_CONDUZIONE         IS NULL
                    AND    CD.ID_UTE                       = U.ID_UTE
                    AND    U.DATA_FINE_ATTIVITA            IS NULL
                    AND    U.ID_AZIENDA                    = pIdAzienda
                    AND    SP.COMUNE                       = C.ISTAT_COMUNE
                    AND    PC.ID_PARTICELLA                = SP.ID_PARTICELLA
                    AND    PC.DATA_FINE_VALIDITA           IS NULL
                    AND    TU.ID_UTILIZZO                  = UD.ID_UTILIZZO
                    AND    ((pVite = 'S' AND TU.TIPO = 'V')OR (pVite = 'N' AND TU.TIPO <> 'V'))
                    /*AND    NOT EXISTS                      (SELECT ID_ESITO_CONTROLLO_PARTICELLA
                                                            FROM   DB_ESITO_CONTROLLO_PARTICELLA
                                                            WHERE  ID_CONTROLLO             IN (knIdControlloP25,knIdControlloP30)
                                                            AND    ID_CONDUZIONE_PARTICELLA = CD.ID_CONDUZIONE_PARTICELLA)*/
                    AND    NOT EXISTS                      (SELECT SUA.ID_STORICO_UNITA_ARBOREA
                                                            FROM   DB_STORICO_UNITA_ARBOREA SUA,DB_TIPO_CAUSALE_MODIFICA TCM
                                                            WHERE  SUA.ID_AZIENDA          = pIdAzienda
                                                            AND    SUA.ID_PARTICELLA       = SP.ID_PARTICELLA
                                                            AND    SUA.ID_CAUSALE_MODIFICA = TCM.ID_CAUSALE_MODIFICA
                                                            AND    ESCLUDI_P26             = 'S'
                                                            AND    SUA.DATA_FINE_VALIDITA  IS NULL
                                                            AND    SUA.DATA_CESSAZIONE     IS NULL
                                                            AND    DECODE(TCM.IMPIANTO, 'S',SUA.DATA_IMPIANTO, SUA.DATA_AGGIORNAMENTO) >= (SELECT NVL(MAX(DATA_FOTOINTERPRETAZIONE), TO_DATE('01/01/1900','DD/MM/YYYY'))
                                                                                                                                           FROM   DB_PARTICELLA_CERT_ELEG
                                                                                                                                           WHERE  ID_PARTICELLA_CERTIFICATA = PC.ID_PARTICELLA_CERTIFICATA
                                                                                                                                           AND    ANNO_CAMPAGNA             = (SELECT MAX(ANNO_CAMPAGNA)
                                                                                                                                                                               FROM   DB_PARTICELLA_CERT_ELEG
                                                                                                                                                                               WHERE  ID_PARTICELLA_CERTIFICATA = PC.ID_PARTICELLA_CERTIFICATA)))
                    GROUP BY SP.COMUNE, C.DESCOM, SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA, SP.SUBALTERNO,
                             SP.ID_STORICO_PARTICELLA,SP.ID_PARTICELLA, PC.ID_PARTICELLA_CERTIFICATA;

  CURSOR curUnitaArborea(pIdParticella IN DB_STORICO_UNITA_ARBOREA.ID_PARTICELLA%TYPE) IS
         SELECT SUA.*
         FROM   DB_STORICO_UNITA_ARBOREA SUA
         WHERE  SUA.ID_AZIENDA         = pIdAzienda
         AND    SUA.DATA_FINE_VALIDITA IS NULL
         AND    SUA.DATA_CESSAZIONE    IS NULL
         AND    SUA.ID_PARTICELLA      = pIdParticella;

  CURSOR C_CONDUZIONI_ATTIVE(pIdParticella IN DB_CONDUZIONE_DICHIARATA.ID_PARTICELLA%TYPE) IS
         SELECT CD.ID_CONDUZIONE_PARTICELLA
         FROM   DB_CONDUZIONE_DICHIARATA CD,DB_UTE U
         WHERE  U.ID_AZIENDA             = pIdAzienda
         AND    U.DATA_FINE_ATTIVITA     IS NULL
         AND    U.ID_UTE                 = CD.ID_UTE
         AND    CD.DATA_FINE_CONDUZIONE  IS NULL
         AND    CD.ID_TITOLO_POSSESSO   != 5
         AND    CD.ID_PARTICELLA         = pIdParticella;


  vDescrizione  DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
  vSezione      VARCHAR2(20);
  vSub          VARCHAR2(20);
BEGIN
  vDescrizione := NULL;

  FOR R_ELEGG IN C_ELEGG LOOP
    IF R_ELEGG.ID_PARTICELLA_CERTIFICATA IS NOT NULL THEN
      IF NVL(PCK_SMRGAA_LIBRERIA.CALCOLA_P26_CON_TOLLERANZA(pIdAzienda,R_ELEGG.ID_PARTICELLA,
                                                            R_ELEGG.ID_PARTICELLA_CERTIFICATA,
                                                            MY_TO_NUMBER(SelectValoreParametro(kvIdParamPercP26),'999D9999')),0) > 0 THEN

        SELECT DECODE(R_ELEGG.SEZIONE, NULL, '', ' Sz: '|| R_ELEGG.SEZIONE)
        INTO   vSezione
        FROM   DUAL;

        SELECT DECODE(R_ELEGG.subalterno, NULL, '', ' Sub: '|| R_ELEGG.SUBALTERNO)
        INTO   vSub
        FROM   DUAL;

        vDescrizione := '[' || R_ELEGG.DESCOM ||vSezione ||' Fgl:' || R_ELEGG.FOGLIO || ' Part:' || R_ELEGG.PARTICELLA || vSub ||
                        '] Sup.utilizzata: ' ||  TRIM(TO_CHAR(NVL(R_ELEGG.SUM_SUP_UTIL,0),'999G990D9999'))||
                        ' non congruente con la superficie eleggibile';

        IF pVite = 'S' THEN
          FOR recUnitaArborea IN curUnitaArborea(R_ELEGG.ID_PARTICELLA) LOOP
            IF NOT SCRIVI_SEGNALAZIONE (pIdAzienda,pIdControllo, vDescrizione,pBloccante,
                                        R_ELEGG.ID_STORICO_PARTICELLA,
                                        recUnitaArborea.ID_STORICO_UNITA_ARBOREA, pMsgerr, pCoderr) THEN
              RETURN FALSE;
            END IF;

            IF NOT SCRIVI_SEGNALAZIONE_UNAR(pIdAzienda, pIdControllo, vDescrizione,pBloccante,
                                            recUnitaArborea.ID_STORICO_UNITA_ARBOREA, pMsgerr, pCoderr) THEN
              RETURN FALSE;
            END IF;
          END LOOP;
        ELSE
          IF NOT SCRIVI_SEGNALAZIONE(pIdAzienda,pIdControllo, vDescrizione,pBloccante,
                                     R_ELEGG.ID_STORICO_PARTICELLA, NULL, pMsgerr, pCoderr) THEN
            RETURN FALSE;
          END IF;
        END IF;

        FOR REC_CONDUZIONI_ATTIVE IN C_CONDUZIONI_ATTIVE(R_ELEGG.ID_PARTICELLA) LOOP
          IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA(pIdAzienda,pIdControllo, vDescrizione,pBloccante,
                                                REC_CONDUZIONI_ATTIVE.ID_CONDUZIONE_PARTICELLA, pMsgerr,
                                                pCoderr) THEN
            RETURN FALSE;
          END IF;
        END LOOP;
      END IF;
    END IF;
  END LOOP;

  RETURN TRUE;

EXCEPTION
  WHEN OTHERS THEN
    pMsgerr := 'ERRORE TER63 : ' || SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    pCoderr := SQLCODE;
    RETURN FALSE;
END TER63;

-- controllo VERIFICA UGUAGLIANZA CON ELEGGIBILITA¿ GIS
FUNCTION TER65(pIdAzienda           DB_AZIENDA.ID_AZIENDA%TYPE,
               pIdControllo         DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
               pBloccante           DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
               pMsgerr       IN OUT VARCHAR2,
               pCoderr       IN OUT VARCHAR2) RETURN BOOLEAN IS

  nSuperficie              NUMBER := 0;
  vMessaggio               DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
  nIdStoricoParticella     DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE := -1;
  nIdConduzioneParticella  DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
  nIdEleggibilitaFit       DB_PARTICELLA_CERT_ELEG.ID_ELEGGIBILITA_FIT%TYPE;
  nCont                    SIMPLE_INTEGER := 0;
  vBloccante               DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE := 'N';
BEGIN
  /*SELECT DECODE(COUNT(*),0,'N','S')
  INTO   vBloccante
  FROM   DB_AZIENDE_DOM_GRAFICA
  WHERE  ID_AZIENDA         = pIdAzienda
  AND    DATA_FINE_VALIDITA IS NULL;*/

  FOR rec IN (SELECT CG.ID_CATALOGO_GRAFICO,UP.ID_PRATICA_MANTENIMENTO,
                     NVL(SUM(NVL(UP.SUPERFICIE_UTILIZZATA,0)),0) SUPERFICIE_UTILIZZATA,
                     C.DESCOM,SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA,SP.SUBALTERNO,SP.ID_STORICO_PARTICELLA,
                     CP.ID_PARTICELLA
              FROM   DB_CONDUZIONE_PARTICELLA CP, DB_UTE U,DB_UTILIZZO_PARTICELLA UP,DB_STORICO_PARTICELLA SP,
                     COMUNE C,DB_R_CATALOGO_GRAFICO CG,DB_R_CATALOGO_MATRICE CM
              WHERE  U.ID_AZIENDA                = pIdAzienda
              AND    CP.ID_UTE                   = U.ID_UTE
              AND    CP.DATA_FINE_CONDUZIONE     IS NULL
              AND    UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
              AND    SP.ID_PARTICELLA            = CP.ID_PARTICELLA
              AND    SP.DATA_FINE_VALIDITA       IS NULL
              AND    C.ISTAT_COMUNE              = SP.COMUNE
              AND    CG.ID_CATALOGO_GRAFICO      = CM.ID_CATALOGO_GRAFICO
              AND    UP.ID_CATALOGO_MATRICE      = CM.ID_CATALOGO_MATRICE
              AND    CP.ID_TITOLO_POSSESSO       NOT IN (5,6)
              GROUP BY CG.ID_CATALOGO_GRAFICO,UP.ID_PRATICA_MANTENIMENTO,C.DESCOM,SP.SEZIONE, SP.FOGLIO,
                       SP.PARTICELLA,SP.SUBALTERNO,SP.ID_STORICO_PARTICELLA,CP.ID_PARTICELLA) LOOP

    SELECT COUNT(*)
    INTO   nCont
    FROM   DB_PARTICELLA_CERT_ELEG PCE,DB_VARIETA_ELEGGIBILITA VE,DB_R_CATALOGO_MATRICE CM,
           DB_PARTICELLA_CERTIFICATA PC,DB_R_CATALOGO_COMPATIBIL_ELEG CCE
    WHERE  PCE.ID_ELEGGIBILITA_FIT       = VE.ID_ELEGGIBILITA_FIT
    AND    VE.ID_CATALOGO_MATRICE        = CM.ID_CATALOGO_MATRICE
    AND    PCE.SUPERFICIE                = REC.SUPERFICIE_UTILIZZATA
    AND    PCE.ID_PARTICELLA_CERTIFICATA = PC.ID_PARTICELLA_CERTIFICATA
    AND    VE.DATA_FINE_VALIDITA         IS NULL
    AND    PC.DATA_FINE_VALIDITA         IS NULL
    AND    PC.ID_PARTICELLA              = REC.ID_PARTICELLA
    AND    CM.ID_CATALOGO_GRAFICO        = REC.ID_CATALOGO_GRAFICO
    AND    CM.ID_CATALOGO_GRAFICO        = CCE.ID_CATALOGO_GRAFICO
    AND    CCE.DATA_FINE_VALIDITA        IS NULL
    AND    CCE.ID_ELEGGIBILITA_FIT       = VE.ID_ELEGGIBILITA_FIT
    AND    PCE.ANNO_CAMPAGNA             = (SELECT MAX(ANNO_CAMPAGNA)
                                            FROM   DB_PARTICELLA_CERT_ELEG PCE2
                                            WHERE  PCE2.ID_PARTICELLA_CERTIFICATA = PCE.ID_PARTICELLA_CERTIFICATA);
    IF nCont = 0 THEN
      SELECT NVL(SUM(SUPERFICIE),0)
      INTO   nSuperficie
      FROM   DB_PARTICELLA_CERT_ELEG PCE,DB_PARTICELLA_CERTIFICATA PC
      WHERE  PC.ID_PARTICELLA              = REC.ID_PARTICELLA
      AND    PCE.ID_PARTICELLA_CERTIFICATA = PC.ID_PARTICELLA_CERTIFICATA
      AND    PC.DATA_FINE_VALIDITA         IS NULL
      AND    PCE.ANNO_CAMPAGNA             = (SELECT MAX(ANNO_CAMPAGNA)
                                              FROM   DB_PARTICELLA_CERT_ELEG PCE2
                                              WHERE  PCE2.ID_PARTICELLA_CERTIFICATA = PCE.ID_PARTICELLA_CERTIFICATA)
      AND    PCE.ID_ELEGGIBILITA_FIT       IN (SELECT CCE1.ID_ELEGGIBILITA_FIT
                                               FROM   DB_R_CATALOGO_COMPATIBIL_ELEG CCE,
                                                      DB_R_CATALOGO_COMPATIBIL_ELEG CCE1
                                               WHERE  CCE.ID_CATALOGO_GRAFICO  = REC.ID_CATALOGO_GRAFICO
                                               AND    CCE.ID_CATALOGO_GRAFICO  = CCE1.ID_CATALOGO_GRAFICO
                                               AND    CCE.GRUPPO_COMPATIBILITA = CCE1.GRUPPO_COMPATIBILITA
                                               AND    CCE.DATA_FINE_VALIDITA   IS NULL
                                               AND    CCE1.DATA_FINE_VALIDITA  IS NULL);

      IF nSuperficie != REC.SUPERFICIE_UTILIZZATA THEN
        nCont := 0;
      ELSE
        nCont := 1;
      END IF;
    END IF;

    IF nCont = 0 THEN
      vMessaggio := 'La particella : ' ||
                    '[' || rec.DESCOM || ' Sez : ' || NVL(rec.SEZIONE,'N.P.') ||' Fgl:' || rec.FOGLIO ||
                    ' Part:' || rec.PARTICELLA || ' Sub : ' || NVL(rec.SUBALTERNO,'N.P.') || '] '||
                    'La sup.utilizzata: '||rec.SUPERFICIE_UTILIZZATA||'(ha) supera la superficie eleggibile';

      IF nIdStoricoParticella <> rec.ID_STORICO_PARTICELLA THEN
        IF NOT SCRIVI_SEGNALAZIONE(pIdAzienda, pIdControllo, vMessaggio, vBloccante, rec.ID_STORICO_PARTICELLA, NULL, pMsgerr, pCoderr) THEN
          RETURN FALSE;
        END IF;
      END IF;

      SELECT MIN(ID_CONDUZIONE_PARTICELLA)
      INTO   nIdConduzioneParticella
      FROM   DB_CONDUZIONE_PARTICELLA
      WHERE  ID_PARTICELLA        = rec.ID_PARTICELLA
      AND    ID_TITOLO_POSSESSO   NOT IN (5,6)
      AND    DATA_FINE_CONDUZIONE IS NULL;

      IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA(pIdAzienda, pIdControllo, vMessaggio, vBloccante,
                                            nIdConduzioneParticella, pMsgerr, pCoderr) THEN
        RETURN FALSE;
      END IF;

      nIdStoricoParticella := rec.ID_STORICO_PARTICELLA;
    END IF;
  END LOOP;

  RETURN TRUE;
EXCEPTION
  WHEN OTHERS THEN
    pMsgerr := 'ERRORE TER65 : ' || SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    pCoderr := SQLCODE;
    RETURN FALSE;
END TER65;

-- controllo VERIFICA UGUAGLIANZA CON ELEGGIBILITA¿ GIS ALLA VALIDAZIONE
FUNCTION TER66(pIdAzienda           DB_AZIENDA.ID_AZIENDA%TYPE,
               pIdDichiarazione     DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
               pIdControllo         DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
               pBloccante           DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
               pMsgerr       IN OUT VARCHAR2,
               pCoderr       IN OUT VARCHAR2) RETURN BOOLEAN IS

  nCont                    SIMPLE_INTEGER := 0;
  vMessaggio               DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
  nIdStoricoParticella     DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE := -1;
  nIdConduzioneParticella  DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
  nSuperficie              NUMBER := 0;
  vBloccante               DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE;
BEGIN
  SELECT DECODE(COUNT(*),0,'N','S')
  INTO   vBloccante
  FROM   DB_AZIENDE_DOM_GRAFICA
  WHERE  ID_AZIENDA         = pIdAzienda
  AND    DATA_FINE_VALIDITA IS NULL;

  FOR rec IN (SELECT CG.ID_CATALOGO_GRAFICO,UD.ID_PRATICA_MANTENIMENTO,
                     NVL(SUM(NVL(UD.SUPERFICIE_UTILIZZATA,0)),0) SUPERFICIE_UTILIZZATA,
                     C.DESCOM,SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA,SP.SUBALTERNO,SP.ID_STORICO_PARTICELLA,
                     CD.ID_PARTICELLA
              FROM   DB_CONDUZIONE_DICHIARATA CD, DB_UTE U,DB_UTILIZZO_DICHIARATO UD,DB_STORICO_PARTICELLA SP,
                     COMUNE C,DB_R_CATALOGO_GRAFICO CG,DB_R_CATALOGO_MATRICE CM,
                     DB_DICHIARAZIONE_CONSISTENZA DC
              WHERE  DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazione
              AND    CD.CODICE_FOTOGRAFIA_TERRENI    = DC.CODICE_FOTOGRAFIA_TERRENI
              AND    SP.DATA_FINE_VALIDITA           IS NULL
              AND    SP.ID_PARTICELLA                = CD.ID_PARTICELLA
              AND    CD.ID_CONDUZIONE_DICHIARATA     = UD.ID_CONDUZIONE_DICHIARATA
              AND    CD.DATA_FINE_CONDUZIONE         IS NULL
              AND    CD.ID_UTE                       = U.ID_UTE
              AND    U.DATA_FINE_ATTIVITA            IS NULL
              AND    U.ID_AZIENDA                    = pIdAzienda
              AND    SP.COMUNE                       = C.ISTAT_COMUNE
              AND    CG.ID_CATALOGO_GRAFICO          = CM.ID_CATALOGO_GRAFICO
              AND    UD.ID_CATALOGO_MATRICE          = CM.ID_CATALOGO_MATRICE
              AND    CD.ID_TITOLO_POSSESSO           NOT IN (5,6)
              GROUP BY CG.ID_CATALOGO_GRAFICO,UD.ID_PRATICA_MANTENIMENTO,C.DESCOM,SP.SEZIONE, SP.FOGLIO,
                       SP.PARTICELLA,SP.SUBALTERNO,SP.ID_STORICO_PARTICELLA,CD.ID_PARTICELLA) LOOP

    SELECT COUNT(*)
    INTO   nCont
    FROM   DB_PARTICELLA_CERT_ELEG PCE,DB_VARIETA_ELEGGIBILITA VE,DB_R_CATALOGO_MATRICE CM,
           DB_PARTICELLA_CERTIFICATA PC
    WHERE  PCE.ID_ELEGGIBILITA_FIT       = VE.ID_ELEGGIBILITA_FIT
    AND    VE.ID_CATALOGO_MATRICE        = CM.ID_CATALOGO_MATRICE
    AND    PCE.SUPERFICIE                = REC.SUPERFICIE_UTILIZZATA
    AND    PCE.ID_PARTICELLA_CERTIFICATA = PC.ID_PARTICELLA_CERTIFICATA
    AND    VE.DATA_FINE_VALIDITA         IS NULL
    AND    PC.DATA_FINE_VALIDITA         IS NULL
    AND    PC.ID_PARTICELLA              = REC.ID_PARTICELLA
    AND    CM.ID_CATALOGO_GRAFICO        = REC.ID_CATALOGO_GRAFICO
    AND    PCE.ANNO_CAMPAGNA             = (SELECT MAX(ANNO_CAMPAGNA)
                                            FROM   DB_PARTICELLA_CERT_ELEG PCE2
                                            WHERE  PCE2.ID_PARTICELLA_CERTIFICATA = PCE.ID_PARTICELLA_CERTIFICATA);
    IF nCont = 0 THEN
      SELECT NVL(SUM(SUPERFICIE),0)
      INTO   nSuperficie
      FROM   DB_PARTICELLA_CERT_ELEG PCE,DB_PARTICELLA_CERTIFICATA PC
      WHERE  PC.ID_PARTICELLA              = REC.ID_PARTICELLA
      AND    PCE.ID_PARTICELLA_CERTIFICATA = PC.ID_PARTICELLA_CERTIFICATA
      AND    PC.DATA_FINE_VALIDITA         IS NULL
      AND    PCE.ANNO_CAMPAGNA             = (SELECT MAX(ANNO_CAMPAGNA)
                                              FROM   DB_PARTICELLA_CERT_ELEG PCE2
                                              WHERE  PCE2.ID_PARTICELLA_CERTIFICATA = PCE.ID_PARTICELLA_CERTIFICATA)
      AND    PCE.ID_ELEGGIBILITA_FIT       IN (SELECT CCE1.ID_ELEGGIBILITA_FIT
                                               FROM   DB_R_CATALOGO_COMPATIBIL_ELEG CCE,
                                                      DB_R_CATALOGO_COMPATIBIL_ELEG CCE1
                                               WHERE  CCE.ID_CATALOGO_GRAFICO  = REC.ID_CATALOGO_GRAFICO
                                               AND    CCE.ID_CATALOGO_GRAFICO  = CCE1.ID_CATALOGO_GRAFICO
                                               AND    CCE.GRUPPO_COMPATIBILITA = CCE1.GRUPPO_COMPATIBILITA
                                               AND    CCE.DATA_FINE_VALIDITA   IS NULL
                                               AND    CCE1.DATA_FINE_VALIDITA  IS NULL);

      IF nSuperficie != REC.SUPERFICIE_UTILIZZATA THEN
        nCont := 0;
      ELSE
        nCont := 1;
      END IF;
    END IF;

    IF nCont = 0 THEN
      vMessaggio := 'La particella : ' ||
                    '[' || rec.DESCOM || ' Sez : ' || NVL(rec.SEZIONE,'N.P.') ||' Fgl:' || rec.FOGLIO ||
                    ' Part:' || rec.PARTICELLA || ' Sub : ' || NVL(rec.SUBALTERNO,'N.P.') || '] '||
                    'La sup.utilizzata: '||rec.SUPERFICIE_UTILIZZATA||'(ha) supera la superficie eleggibile';

      IF nIdStoricoParticella <> rec.ID_STORICO_PARTICELLA THEN
        IF NOT SCRIVI_SEGNALAZIONE(pIdAzienda, pIdControllo, vMessaggio, vBloccante,
                                   rec.ID_STORICO_PARTICELLA, NULL, pMsgerr, pCoderr) THEN
          RETURN FALSE;
        END IF;
      END IF;

      nIdStoricoParticella := rec.ID_STORICO_PARTICELLA;
    END IF;
  END LOOP;

  RETURN TRUE;
EXCEPTION
  WHEN OTHERS THEN
    pMsgerr := 'ERRORE TER66 : ' || SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    pCoderr := SQLCODE;
    RETURN FALSE;
END TER66;


-- Nuovo controllo che verifica che la sezione
-- se specificata in fase di creazione della particella
-- sia tra quelle ammesse dal comune
FUNCTION SEZIONE_NON_VALIDA (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                             P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                             P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                             P_MSGERR       IN OUT VARCHAR2,
                             P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

        CURSOR curSezioneNonValida IS
        SELECT SP.COMUNE,
               C.DESCOM,
               SP.SEZIONE,
               SP.FOGLIO,
               SP.PARTICELLA,
               SP.SUBALTERNO,
               SP.ID_STORICO_PARTICELLA,
               SP.ID_PARTICELLA,
               CD.ID_CONDUZIONE_PARTICELLA,
               C.GESTIONE_SEZIONE
          FROM DB_UTE UT,
               DB_CONDUZIONE_PARTICELLA CD,
               DB_STORICO_PARTICELLA SP,
               COMUNE C
         WHERE UT.ID_AZIENDA = P_ID_AZIENDA
           AND UT.DATA_FINE_ATTIVITA IS NULL
           AND UT.ID_UTE = CD.ID_UTE
           AND CD.DATA_FINE_CONDUZIONE IS NULL
           AND CD.ID_PARTICELLA = SP.ID_PARTICELLA
           AND SP.DATA_FINE_VALIDITA IS NULL
           AND SP.COMUNE = C.ISTAT_COMUNE
           AND ((C.GESTIONE_SEZIONE = 'N' AND SP.SEZIONE IS NOT NULL) OR
                (C.GESTIONE_SEZIONE = 'O' AND SP.SEZIONE IS NULL) OR
                (C.GESTIONE_SEZIONE = 'O' AND NOT EXISTS (SELECT DESCRIZIONE
                                                            FROM DB_SEZIONE
                                                           WHERE ISTAT_COMUNE = C.ISTAT_COMUNE
                                                             AND SEZIONE = SP.SEZIONE )) OR
                (C.GESTIONE_SEZIONE = 'M' AND SP.SEZIONE IS NOT NULL
                                          AND NOT EXISTS (SELECT DESCRIZIONE
                                                            FROM DB_SEZIONE
                                                           WHERE ISTAT_COMUNE = C.ISTAT_COMUNE
                                                             AND SEZIONE = SP.SEZIONE )))
        ORDER BY SP.ID_STORICO_PARTICELLA;

    vDescAnomalia           DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    nIdStoricoParticella    DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE:=0;
BEGIN

     FOR recSezioneNonValida IN curSezioneNonValida LOOP
         vDescAnomalia := '[' || recSezioneNonValida.DESCOM || ', Sez: '
                              || NVL(recSezioneNonValida.SEZIONE,'N.P.') || ', Fgl:'
                              || recSezioneNonValida.FOGLIO || ', Part:'
                              || recSezioneNonValida.PARTICELLA || ', Sub: '
                              || NVL(recSezioneNonValida.SUBALTERNO,'N.P.') || ']';

         IF recSezioneNonValida.GESTIONE_SEZIONE = 'N' THEN
            vDescAnomalia := vDescAnomalia || ' Per il comune non è prevista la specificazione della sezione';
         END IF;

         IF recSezioneNonValida.GESTIONE_SEZIONE = 'O' THEN
            IF recSezioneNonValida.SEZIONE IS NULL THEN
               vDescAnomalia := vDescAnomalia || ' Per il comune è obbligatorio specificare una sezione valida';
            ELSE
               vDescAnomalia := vDescAnomalia || ' la sezione : ' || recSezioneNonValida.SEZIONE || ' non è prevista sul comune';
            END IF;
         END IF;

        IF recSezioneNonValida.GESTIONE_SEZIONE = 'M' THEN
           vDescAnomalia := vDescAnomalia || ' la sezione : ' || recSezioneNonValida.SEZIONE || ' non è prevista sul comune';
        END IF;

        IF nIdStoricoParticella <> recSezioneNonValida.ID_STORICO_PARTICELLA THEN
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA,P_id_controllo, vDescAnomalia,P_bloccante, recSezioneNonValida.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA,P_id_controllo, vDescAnomalia,P_bloccante, recSezioneNonValida.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        nIdStoricoParticella := recSezioneNonValida.ID_STORICO_PARTICELLA;

     END LOOP;

     RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE SEZIONE_NON_VALIDA: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END SEZIONE_NON_VALIDA;

FUNCTION SUPERO_USO_DEL_SUOLO (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                               P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                P_MSGERR       IN OUT VARCHAR2,
                               P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS
CURSOR C_SUPERO IS
     SELECT C.ID_PARTICELLA, C.ID_STORICO_PARTICELLA, E.DESCOM, C.SEZIONE, C.FOGLIO, C.PARTICELLA, C.SUBALTERNO,
             C.SUP_CATASTALE, D.ID_CONDUZIONE_PARTICELLA, D.SUPERFICIE_CONDOTTA, SUM(F.SUPERFICIE_UTILIZZATA) SUP_UTILIZZATA
     FROM DB_UTE A, DB_PARTICELLA B, DB_STORICO_PARTICELLA C, DB_CONDUZIONE_PARTICELLA D, DB_UTILIZZO_PARTICELLA F,
           COMUNE E
     WHERE A.ID_UTE = D.ID_UTE
       AND A.ID_AZIENDA = P_ID_AZIENDA
       AND B.ID_PARTICELLA = C.ID_PARTICELLA
       AND C.DATA_FINE_VALIDITA IS NULL
       AND D.DATA_FINE_CONDUZIONE IS NULL
       AND B.ID_PARTICELLA = D.ID_PARTICELLA
       AND E.ISTAT_COMUNE = C.COMUNE
       AND F.ID_CONDUZIONE_PARTICELLA = D.ID_CONDUZIONE_PARTICELLA
     GROUP BY C.ID_PARTICELLA, C.ID_STORICO_PARTICELLA, E.DESCOM, C.SEZIONE, C.FOGLIO, C.PARTICELLA, C.SUBALTERNO,
             C.SUP_CATASTALE, D.ID_CONDUZIONE_PARTICELLA, D.SUPERFICIE_CONDOTTA
     HAVING NVL(SUPERFICIE_CONDOTTA,0) <> NVL(SUM(F.SUPERFICIE_UTILIZZATA),0);

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
s_sezione        VARCHAR2(20);
s_sub            VARCHAR2(20);

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_SUPERO IN C_SUPERO LOOP
         IF NVL(REC_SUPERO.SUPERFICIE_CONDOTTA,0) < NVL(REC_SUPERO.SUP_UTILIZZATA,0) THEN

               SELECT DECODE(REC_SUPERO.SEZIONE, NULL, '', ' Sz: '|| REC_SUPERO.SEZIONE)
            INTO S_SEZIONE FROM DUAL;
            SELECT DECODE(REC_SUPERO.subalterno, NULL, '', ' Sub: '|| REC_SUPERO.SUBALTERNO)
            INTO s_sub FROM dual;

            S_DESCRIZIONE := '[' || REC_SUPERO.DESCOM || S_SEZIONE ||
                  ' Fgl:' || REC_SUPERO.FOGLIO ||' Part:' ||  REC_SUPERO.PARTICELLA ||
                  S_SUB || '] uso del suolo specificato per '
                  || TRIM(TO_CHAR(NVL(REC_SUPERO.SUP_UTILIZZATA,0),'999G990D9999'))||
                  ' (ha) su una superficie condotta di '|| TRIM(TO_CHAR(NVL(REC_SUPERO.SUPERFICIE_CONDOTTA,0),'999G990D9999'))||' (ha)' ;

              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_SUPERO.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
              IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_SUPERO.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
         END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE SUPERO_USO_DEL_SUOLO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END SUPERO_USO_DEL_SUOLO;

FUNCTION CONTROLLO_PARTICELLE_PIEMONTE (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                               P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                P_MSGERR       IN OUT VARCHAR2,
                               P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS
S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_CONTATORE                NUMBER(10);
CURSOR C_PARTICELLE_FUORI_PIEM IS
     SELECT E.DESCOM, C.SEZIONE, C.FOGLIO, C.PARTICELLA, C.SUBALTERNO, B.ID_CONDUZIONE_PARTICELLA
       FROM DB_UTE A, DB_CONDUZIONE_PARTICELLA B, DB_STORICO_PARTICELLA C, PROVINCIA D, COMUNE E
      WHERE A.ID_UTE = B.ID_UTE
        AND A.ID_AZIENDA = P_ID_AZIENDA
        AND A.DATA_FINE_ATTIVITA IS NULL
        AND B.DATA_FINE_CONDUZIONE IS NULL
        AND C.ID_PARTICELLA = B.ID_PARTICELLA
        AND C.DATA_FINE_VALIDITA IS NULL
        AND D.ISTAT_PROVINCIA = SUBSTR(C.COMUNE,1,3)
        AND D.ID_REGIONE <> '01'
        AND C.COMUNE = E.ISTAT_COMUNE;

-- questo controllo non viene riportato sulla singola particella, ma è solo una segnalazione globale a livello di dichiarazione
BEGIN
     S_DESCRIZIONE := NULL;

     SELECT COUNT(*)
       INTO N_CONTATORE
       FROM DB_UTE A, DB_CONDUZIONE_PARTICELLA B, DB_STORICO_PARTICELLA C, PROVINCIA D
      WHERE A.ID_UTE = B.ID_UTE
       AND A.ID_AZIENDA = P_ID_AZIENDA
        AND A.DATA_FINE_ATTIVITA IS NULL
        AND B.DATA_FINE_CONDUZIONE IS NULL
        AND C.ID_PARTICELLA = B.ID_PARTICELLA
        AND C.DATA_FINE_VALIDITA IS NULL
        AND D.ISTAT_PROVINCIA = SUBSTR(C.COMUNE,1,3)
        AND D.ID_REGIONE <> '01';

     IF N_CONTATORE > 0 THEN
         S_DESCRIZIONE := 'Sono presenti delle particelle esterne alla REGIONE PIEMONTE. Il sistema NON GARANTISCE la certificazione della superficie catastale';
         IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

    RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'CONTROLLO_PARTICELLE_PIEMONTE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLO_PARTICELLE_PIEMONTE;

FUNCTION CONTROLLO_PARTICELLE_A_GIS (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                         P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        P_BLOCCANTE    IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                         P_MSGERR       IN OUT VARCHAR2,
                                        P_CODERR          IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_CONTATORE                NUMBER(10);
N_CONTATORE_UV            NUMBER(10);

C_COMUNE_C            COMUNE.ISTAT_COMUNE%TYPE;
S_SEZIONE_C            SMRGAA.DB_STORICO_PARTICELLA.SEZIONE%TYPE;
FLAG_FOUND                BOOLEAN;

N_ID_PARTICELLA     DB_STORICO_PARTICELLA.ID_PARTICELLA%TYPE;

FLAG_RET            BOOLEAN;

s_sezione        VARCHAR2(20);
s_sub            VARCHAR2(20);

CURSOR C_PARTICELLE_A_GIS IS
     SELECT C.COMUNE,E.DESCOM, C.SEZIONE, C.FOGLIO, C.PARTICELLA, C.SUBALTERNO, B.ID_CONDUZIONE_PARTICELLA,
             C.ID_STORICO_PARTICELLA, c.ID_PARTICELLA
       FROM DB_UTE A, DB_CONDUZIONE_PARTICELLA B, DB_STORICO_PARTICELLA C, COMUNE E, DB_TIPO_CASO_PARTICOLARE CP
      WHERE A.ID_UTE = B.ID_UTE
        AND A.ID_AZIENDA = P_ID_AZIENDA
        AND A.DATA_FINE_ATTIVITA IS NULL
        AND B.DATA_FINE_CONDUZIONE IS NULL
        AND B.ID_PARTICELLA=C.ID_PARTICELLA
        AND B.ID_TITOLO_POSSESSO <> 5 -- escludo asservimento MS 13/04/2011
        AND C.DATA_FINE_VALIDITA IS NULL
        AND C.COMUNE = E.ISTAT_COMUNE
        AND NVL(C.ID_CASO_PARTICOLARE,99) = CP.ID_CASO_PARTICOLARE
        AND CP.EFFETTUA_CONTROLLI_GIS = 'S'; 

CURSOR C_UV IS
       SELECT ID_STORICO_UNITA_ARBOREA
       FROM DB_STORICO_UNITA_ARBOREA
       WHERE DATA_FINE_VALIDITA IS NULL
         AND ID_PARTICELLA = N_ID_PARTICELLA
         AND ID_AZIENDA = P_ID_AZIENDA;

dCorrettiva    DATE;

BEGIN
     S_DESCRIZIONE := NULL;
     N_CONTATORE_UV := 0;

     IF nAnnoCampagna IS NOT NULL THEN
        dCorrettiva := TO_DATE('01/01/'||TO_CHAR(nAnnoCampagna),'DD/MM/YYYY');
     ELSE
        dCorrettiva := NULL;
     END IF;

     FOR REC_PARTICELLE_A_GIS IN C_PARTICELLE_A_GIS LOOP
         -- sono le UV della particella il contatore va azzerato
         -- nel loop delle particelle ... chi e' l'idiota che ha scritto la funzione ?
         N_CONTATORE_UV := 0;
          FLAG_FOUND:=TRUE;

          /* cerco se esiste nel tabellone AGEA con il campo particella_a_gis=0 */
         N_CONTATORE := PCK_SMRGAA_LIBRERIA.Calcola_P30 (REC_PARTICELLE_A_GIS.ID_STORICO_PARTICELLA,
                                                         dCorrettiva);

         IF N_CONTATORE = 0 THEN
             /* non la trovo */
             FLAG_FOUND:=FALSE;
         END IF;

         IF FLAG_FOUND THEN
               SELECT DECODE(REC_PARTICELLE_A_GIS.SEZIONE, NULL, '', ' Sz: '|| REC_PARTICELLE_A_GIS.SEZIONE)
            INTO S_SEZIONE FROM DUAL;
            SELECT DECODE(REC_PARTICELLE_A_GIS.subalterno, NULL, '', ' Sub: '|| REC_PARTICELLE_A_GIS.SUBALTERNO)
            INTO s_sub FROM dual;
            S_DESCRIZIONE := '[' || REC_PARTICELLE_A_GIS.DESCOM || S_SEZIONE ||
                  ' Fgl:' || REC_PARTICELLE_A_GIS.FOGLIO ||' Part:' || REC_PARTICELLE_A_GIS.PARTICELLA ||
                  S_SUB ||']. P30: Particella non presente nel GIS';

               IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_PARTICELLE_A_GIS.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
               END IF;
              N_ID_PARTICELLA := REC_PARTICELLE_A_GIS.ID_PARTICELLA;
             FOR REC_UV IN C_UV LOOP
              N_CONTATORE_UV := 1;
              IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_UV.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE,
                     REC_PARTICELLE_A_GIS.ID_STORICO_PARTICELLA, REC_UV.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
              END IF;
             END LOOP;

             IF N_CONTATORE_UV <= 0 THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE,
                         REC_PARTICELLE_A_GIS.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
                  END IF;
             END IF;

         END IF;
     END LOOP;

    RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLO_PARTICELLE_A_GIS: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLO_PARTICELLE_A_GIS;

FUNCTION CONTROLLO_PART_GIS_SENZA_USO (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                         P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        P_BLOCCANTE    IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                         P_MSGERR       IN OUT VARCHAR2,
                                        P_CODERR          IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_CONTATORE                NUMBER(10);
N_CONTATORE_UV            NUMBER(10);

C_COMUNE_C            COMUNE.ISTAT_COMUNE%TYPE;
S_SEZIONE_C            SMRGAA.DB_STORICO_PARTICELLA.SEZIONE%TYPE;
FLAG_FOUND                BOOLEAN;

FLAG_RET            BOOLEAN;
N_ID_PARTICELLA     DB_PARTICELLA.ID_PARTICELLA%TYPE;

s_sezione            VARCHAR2(20);
s_sub            VARCHAR2(20);


CURSOR C_PARTICELLE_A_GIS IS
     SELECT C.COMUNE,E.DESCOM, C.SEZIONE, C.FOGLIO, C.PARTICELLA, C.SUBALTERNO, B.ID_CONDUZIONE_PARTICELLA,
             C.ID_STORICO_PARTICELLA, C.ID_PARTICELLA
       FROM DB_UTE A, DB_CONDUZIONE_PARTICELLA B, DB_STORICO_PARTICELLA C, COMUNE E, DB_TIPO_CASO_PARTICOLARE CP
      WHERE A.ID_UTE = B.ID_UTE
        AND A.ID_AZIENDA = P_ID_AZIENDA
        AND A.DATA_FINE_ATTIVITA IS NULL
        AND B.DATA_FINE_CONDUZIONE IS NULL
        AND B.ID_PARTICELLA=C.ID_PARTICELLA
        AND B.ID_TITOLO_POSSESSO <> 5 -- escludo asservimento MS 13/04/2011
        AND C.DATA_FINE_VALIDITA IS NULL
        AND C.COMUNE = E.ISTAT_COMUNE
        AND NVL(C.ID_CASO_PARTICOLARE,99) = CP.ID_CASO_PARTICOLARE
        AND CP.EFFETTUA_CONTROLLI_GIS = 'S'; 

CURSOR C_UV IS
       SELECT ID_STORICO_UNITA_ARBOREA
       FROM DB_STORICO_UNITA_ARBOREA
       WHERE DATA_FINE_VALIDITA IS NULL
         AND ID_PARTICELLA = N_ID_PARTICELLA
         AND ID_AZIENDA = P_ID_AZIENDA;
dCorrettiva    DATE;

BEGIN
     S_DESCRIZIONE := NULL;
     N_CONTATORE_UV := 0;
     IF nAnnoCampagna IS NOT NULL THEN
        dCorrettiva := TO_DATE('01/01/'||TO_CHAR(nAnnoCampagna),'DD/MM/YYYY');
     ELSE
        dCorrettiva := NULL;
     END IF;


     FOR REC_PARTICELLE_A_GIS IN C_PARTICELLE_A_GIS LOOP
         -- sono le UV della particella il contatore va azzerato
         -- nel loop delle particelle ... chi e' l'idiota che ha scritto la funzione ?
         N_CONTATORE_UV := 0;
          FLAG_FOUND:=TRUE;

          /* cerco se esiste nel tabellone AGEA con il campo particella_a_gis=0 */
         N_CONTATORE := PCK_SMRGAA_LIBRERIA.Calcola_P25 (REC_PARTICELLE_A_GIS.ID_STORICO_PARTICELLA,
                                                         dCorrettiva);

         IF N_CONTATORE = 0 THEN
             /* non la trovo */
             FLAG_FOUND:=FALSE;
         END IF;

         IF FLAG_FOUND THEN
              SELECT DECODE(REC_PARTICELLE_A_GIS.SEZIONE, NULL, '', ' Sz: '|| REC_PARTICELLE_A_GIS.SEZIONE)
            INTO S_SEZIONE FROM DUAL;
            SELECT DECODE(REC_PARTICELLE_A_GIS.subalterno, NULL, '', ' Sub: '|| REC_PARTICELLE_A_GIS.SUBALTERNO)
            INTO s_sub FROM dual;

               S_DESCRIZIONE := '[' || REC_PARTICELLE_A_GIS.DESCOM || s_sezione || ' Fgl:' ||
                        REC_PARTICELLE_A_GIS.FOGLIO ||' Part:' || REC_PARTICELLE_A_GIS.PARTICELLA ||s_sub||
                       '] P25-4: Assenza uso del suolo / esiti di lavorazioni - lavorazioni in corso';

               IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_PARTICELLE_A_GIS.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
               END IF;
             N_ID_PARTICELLA := REC_PARTICELLE_A_GIS.ID_PARTICELLA;
             FOR REC_UV IN C_UV LOOP
             N_CONTATORE_UV := 1;
              IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_UV.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE,
                    REC_PARTICELLE_A_GIS.ID_STORICO_PARTICELLA, REC_UV.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
              END IF;
             END LOOP;
             IF N_CONTATORE_UV <=0 THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE,
                        REC_PARTICELLE_A_GIS.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
                        RETURN (FALSE);
                  END IF;
             END IF;
         END IF;
     END LOOP;

    RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLO_PART_A_GIS_SENZA_USO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLO_PART_GIS_SENZA_USO;

FUNCTION CONTROLLO_ZONA_ALTIM (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                               P_BLOCCANTE    IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                P_MSGERR       IN OUT VARCHAR2,
                               P_CODERR          IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
s_sezione            VARCHAR2(20);
s_sub            VARCHAR2(20);
N_CONTATORE                NUMBER(10);

C_COMUNE_C            COMUNE.ISTAT_COMUNE%TYPE;
S_SEZIONE_C            SMRGAA.DB_STORICO_PARTICELLA.SEZIONE%TYPE;
FLAG_FOUND                BOOLEAN;

FLAG_RET            BOOLEAN;

/* cursore che cicla sulle particelle con zona altimetrica non indicata */
CURSOR C_PART IS
     SELECT C.COMUNE,E.DESCOM, C.SEZIONE, C.FOGLIO, C.PARTICELLA, C.SUBALTERNO, B.ID_CONDUZIONE_PARTICELLA,
             C.ID_STORICO_PARTICELLA
       FROM DB_UTE A, DB_CONDUZIONE_PARTICELLA B, DB_STORICO_PARTICELLA C, COMUNE E
       WHERE A.ID_UTE = B.ID_UTE
        AND A.ID_AZIENDA = P_ID_AZIENDA
        AND A.DATA_FINE_ATTIVITA IS NULL
        AND B.DATA_FINE_CONDUZIONE IS NULL
        AND B.ID_PARTICELLA=C.ID_PARTICELLA
        AND C.DATA_FINE_VALIDITA IS NULL
        AND C.COMUNE = E.ISTAT_COMUNE
        AND C.ID_ZONA_ALTIMETRICA IS NULL;

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_PART IN C_PART LOOP
           SELECT DECODE(REC_PART.SEZIONE, NULL, '', ' Sz: '|| REC_PART.SEZIONE)
           INTO S_SEZIONE FROM DUAL;
         SELECT DECODE(REC_PART.subalterno, NULL, '', ' Sub: '|| REC_PART.SUBALTERNO)
           INTO s_sub FROM dual;

         S_DESCRIZIONE := '[' || REC_PART.DESCOM || S_SEZIONE ||
          ' Fgl:' || REC_PART.FOGLIO ||' Part:' || REC_PART.PARTICELLA ||S_SUB ||
              ']. Particella con zona altimetrica non indicata';

         IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE,
                 REC_PART.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
         END IF;
           IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, REC_PART.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
           END IF;
     END LOOP;

    RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLO_ZONA_ALTIM: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLO_ZONA_ALTIM;



/* controllo che il catasto sia attivo */
FUNCTION CONTROLLA_CATASTO_ATTIVO(P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                   P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                  P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                   P_MSGERR       IN OUT VARCHAR2,
                                  P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

/* cursore che cicla su particelle senza caso particolare e catasto non attivo */
CURSOR C_PART IS
    SELECT A.COMUNE, G.DESCOM, A.SEZIONE, A.FOGLIO, A.PARTICELLA, A.SUBALTERNO, B.ID_CONDUZIONE_PARTICELLA, A.ID_STORICO_PARTICELLA
    FROM DB_STORICO_PARTICELLA A, DB_CONDUZIONE_PARTICELLA B, DB_UTE F, COMUNE G
    WHERE A.DATA_FINE_VALIDITA IS NULL
    AND NVL(A.ID_CASO_PARTICOLARE,99)=99
    AND A.ID_PARTICELLA=B.ID_PARTICELLA
    AND B.DATA_FINE_CONDUZIONE IS NULL
    AND B.ID_UTE=F.ID_UTE
    AND F.DATA_FINE_ATTIVITA IS NULL
    AND F.ID_AZIENDA=P_ID_AZIENDA
    AND A.COMUNE=G.ISTAT_COMUNE
    AND G.FLAG_CATASTO_ATTIVO='N';

S_DESCRIZIONE                         DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

N_SUP_CORR                            NUMBER(10,4);

FLAG_FOUND                BOOLEAN;

S_COD_PART                DB_TIPO_ELEGGIBILITA.CODICE%TYPE;

C_COMUNE_C            COMUNE.ISTAT_COMUNE%TYPE;
S_SEZIONE_C            SMRGAA.DB_STORICO_PARTICELLA.SEZIONE%TYPE;

FLAG_RET            BOOLEAN;
s_sezione            VARCHAR2(20);
s_sub            VARCHAR2(20);


BEGIN
     S_DESCRIZIONE := NULL;

     FOR R_PART IN C_PART LOOP
         SELECT DECODE(R_PART.SEZIONE, NULL, '', ' Sz: '|| R_PART.SEZIONE)
           INTO S_SEZIONE FROM DUAL;
          SELECT DECODE(R_PART.subalterno, NULL, '', ' Sub: '|| R_PART.SUBALTERNO)
           INTO s_sub FROM dual;
         S_DESCRIZIONE := '[' || R_PART.DESCOM ||S_SEZIONE ||' Fgl:' || R_PART.FOGLIO ||
                 ' Part:' || R_PART.PARTICELLA || S_SUB ||'] Comune catastalmente non attivo';

          IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA,P_id_controllo, S_DESCRIZIONE,
               P_bloccante, R_PART.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;
          IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA,P_id_controllo, S_DESCRIZIONE,
               P_bloccante, R_PART.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_CATASTO_ATTIVO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLA_CATASTO_ATTIVO;

/* verifica che le particelle in conduzione all'azienda non abbiano superficie condotta pari a 0 */
FUNCTION CONTROLLA_SUP_CONDOTTA (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                   P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                   P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                   P_MSGERR       IN OUT VARCHAR2,
                                   P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
s_sezione            VARCHAR2(20);
s_sub            VARCHAR2(20);


/* cursore che cicla sulle particelle con sup.cond.=0 */
CURSOR C_SUP_COND IS
     SELECT B.ID_CONDUZIONE_PARTICELLA, F.DESCOM, E.SEZIONE, E.FOGLIO, E.PARTICELLA, E.SUBALTERNO,
             E.ID_STORICO_PARTICELLA
     FROM DB_UTE A, DB_CONDUZIONE_PARTICELLA B, DB_STORICO_PARTICELLA E, COMUNE F
     WHERE A.ID_AZIENDA = P_ID_AZIENDA
       AND A.ID_UTE = B.ID_UTE
       AND A.DATA_FINE_ATTIVITA IS NULL
       AND B.DATA_FINE_CONDUZIONE IS NULL
       AND E.ID_PARTICELLA = B.ID_PARTICELLA
       AND E.DATA_FINE_VALIDITA IS NULL
       AND F.ISTAT_COMUNE = E.COMUNE
       AND B.SUPERFICIE_CONDOTTA = 0
     ORDER BY F.DESCOM, E.SEZIONE, E.FOGLIO, E.PARTICELLA, E.SUBALTERNO, E.ID_STORICO_PARTICELLA;

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_SUP_COND IN C_SUP_COND LOOP
          SELECT DECODE(REC_SUP_COND.SEZIONE, NULL, '', ' Sz: '|| REC_SUP_COND.SEZIONE)
           INTO S_SEZIONE FROM DUAL;
          SELECT DECODE(REC_SUP_COND.subalterno, NULL, '', ' Sub: '|| REC_SUP_COND.SUBALTERNO)
           INTO s_sub FROM dual;
         S_DESCRIZIONE := '[' || REC_SUP_COND.DESCOM || S_SEZIONE ||' Fgl:' || REC_SUP_COND.FOGLIO ||
                      ' Part:'||REC_SUP_COND.PARTICELLA || S_SUB || '] La superficie condotta è uguale a 0';

          IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, REC_SUP_COND.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;

          IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, REC_SUP_COND.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_SUP_CONDOTTA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLA_SUP_CONDOTTA;

FUNCTION CONTROLLA_SUP_UV_CATASTALE (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                       P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_ID_CONDUZIONE        DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
s_sezione            VARCHAR2(20);
s_sub            VARCHAR2(20);
N_ID_PARTICELLA     DB_PARTICELLA.ID_PARTICELLA%TYPE;

N_CONTA_UV     NUMBER(10);

       CURSOR C_CONFRONTO_UV IS
       SELECT B.ID_PARTICELLA, B.SUP_CATASTALE, SUM(A.AREA) SUP_UV, E.DESCOM, B.SEZIONE, B.FOGLIO, B.PARTICELLA,
                 B.SUBALTERNO, c.id_conduzione_particella, b.ID_STORICO_PARTICELLA,
              CASE
              WHEN NVL(FO.FLAG_STABILIZZAZIONE,2) <> 0 AND B.SUP_CATASTALE > B.SUPERFICIE_GRAFICA THEN 
                  B.SUP_CATASTALE
              ELSE
                  DECODE(B.SUPERFICIE_GRAFICA,0,B.SUP_CATASTALE, B.SUPERFICIE_GRAFICA) -- oppure se e' stabilizzato ma la grafica e' a zero
              END AS SUP_CONFRONTO, 
              CASE
              WHEN NVL(FO.FLAG_STABILIZZAZIONE,2) <> 0 AND B.SUP_CATASTALE > B.SUPERFICIE_GRAFICA THEN
                  'catastale'
              WHEN NVL(FO.FLAG_STABILIZZAZIONE,2) = 0 AND B.SUPERFICIE_GRAFICA > 0 THEN
                  'grafica'
              WHEN NVL(FO.FLAG_STABILIZZAZIONE,2) = 0 AND B.SUPERFICIE_GRAFICA = 0 THEN
                  'catastale'
              END AS TIPO_SUPERFICIE 
         FROM DB_STORICO_UNITA_ARBOREA a,
              DB_STORICO_PARTICELLA b,
              DB_CONDUZIONE_PARTICELLA c,
              DB_UTE d,
               COMUNE E,
              PROVINCIA P,
              DB_FOGLIO FO 
        WHERE a.id_particella = b.id_particella
          AND A.ID_AZIENDA = P_ID_AZIENDA
          AND a.data_Fine_validita IS NULL
          AND b.data_fine_validita IS NULL
          AND b.id_particella = c.id_particella
          AND c.data_fine_conduzione IS NULL
          AND c.id_ute = d.id_ute
          AND d.id_azienda = p_id_azienda
          AND E.ISTAT_COMUNE = B.COMUNE
          AND B.PARTICELLA IS NOT NULL 
          AND P.ISTAT_PROVINCIA = E.ISTAT_PROVINCIA
          AND P.ID_REGIONE = '01' 
--          AND c.ID_TITOLO_POSSESSO <> 5
          AND c.ID_TITOLO_POSSESSO NOT IN (5,6)
          AND B.COMUNE = FO.COMUNE (+)
          AND B.FOGLIO = FO.FOGLIO (+)
          AND NVL(B.SEZIONE,'#') = NVL(FO.SEZIONE (+),'#')
     GROUP BY B.ID_PARTICELLA,
              B.SUP_CATASTALE,
              B.SUPERFICIE_GRAFICA,
              E.DESCOM,
              B.SEZIONE,
              B.FOGLIO,
              FO.FLAG_STABILIZZAZIONE, 
              B.PARTICELLA,
              B.SUBALTERNO,
              C.ID_CONDUZIONE_PARTICELLA,
              B.ID_STORICO_PARTICELLA;

       CURSOR C_UV IS
       SELECT A.ID_STORICO_UNITA_ARBOREA
         FROM DB_STORICO_UNITA_ARBOREA a
        WHERE a.id_particella = N_ID_PARTICELLA
          AND A.ID_AZIENDA = P_ID_AZIENDA
          AND a.data_fine_validita IS NULL;
BEGIN
     S_DESCRIZIONE := NULL;
     N_CONTA_UV       := 0;

     FOR REC_CONFRONTO_UV IN C_CONFRONTO_UV LOOP
         SELECT DECODE(REC_CONFRONTO_UV.SEZIONE, NULL, '', ' Sz: '|| REC_CONFRONTO_UV.SEZIONE)
        INTO S_SEZIONE FROM DUAL;
        SELECT DECODE(REC_CONFRONTO_UV.subalterno, NULL, '', ' Sub: '|| REC_CONFRONTO_UV.SUBALTERNO)
        INTO s_sub FROM dual;

        IF REC_CONFRONTO_UV.SUP_UV > REC_CONFRONTO_UV.SUP_CONFRONTO THEN
            S_DESCRIZIONE := '[' || REC_CONFRONTO_UV.DESCOM || s_sezione || ' Fgl:' ||
                        REC_CONFRONTO_UV.FOGLIO ||' Part:' || REC_CONFRONTO_UV.PARTICELLA ||s_sub||
                       '] la somma UV che insistono sulla particella' || TO_CHAR(REC_CONFRONTO_UV.sup_uv,'999G990D9999') || '(ha) supera la sup.' ||
                       REC_CONFRONTO_UV.TIPO_SUPERFICIE || ' ' || TO_CHAR(REC_CONFRONTO_UV.SUP_CONFRONTO,'999G990D9999') || ' (ha)';

          N_ID_PARTICELLA := REC_CONFRONTO_UV.ID_PARTICELLA;

          IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, REC_CONFRONTO_UV.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;

          FOR REC_UV IN C_UV LOOP
                N_CONTA_UV := 1;
              IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_UV.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_CONFRONTO_UV.ID_STORICO_PARTICELLA, REC_UV.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;

          END LOOP;

          IF N_CONTA_UV <= 0 THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_CONFRONTO_UV.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
          END IF;

        END IF;
     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CONTROLLA_SUP_UV_CATASTALE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLA_SUP_UV_CATASTALE;

-- Nuovo controllo che verifica che la superficie vitata sia minore della superficie eleggibile
-- a vite incrementata di una quota percentuale
FUNCTION UV_MAGGIORE_ELEGGIBILE (pIdAzienda   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                 pIdControllo IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                 pBloccante   IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                 P_MSGERR     IN OUT VARCHAR2,
                                 P_CODERR     IN OUT VARCHAR2) RETURN BOOLEAN IS

    nPerc DB_TIPO_CONTROLLO_PARAMETRO.VALORE_NUMERICO%TYPE;

    CURSOR curParticellaAViteInSupero IS
    WITH PARTICELLA_DISTINTA AS
    (SELECT DISTINCT SUA.ID_PARTICELLA
       FROM DB_STORICO_UNITA_ARBOREA SUA
      WHERE SUA.ID_AZIENDA = pIdAzienda
        AND SUA.DATA_FINE_VALIDITA IS NULL
        AND SUA.DATA_CESSAZIONE IS NULL
        ),
    PARTICELLA_ELEG AS
    (SELECT PD.ID_PARTICELLA , NVL(SUM(DECODE(PCE.ID_ELEGGIBILITA_FIT, knIdTipoEleggibilitaFitVite,PCE.SUPERFICIE)),0) AS TOT_ELEG
       FROM DB_PARTICELLA_CERT_ELEG PCE,
            DB_PARTICELLA_CERTIFICATA PC,
            PARTICELLA_DISTINTA PD
      WHERE PD.ID_PARTICELLA = PC.ID_PARTICELLA (+)
        AND PC.ID_PARTICELLA_CERTIFICATA = PCE.ID_PARTICELLA_CERTIFICATA (+)
        AND PC.DATA_FINE_VALIDITA IS NULL
        AND NVL(PCE.ANNO_CAMPAGNA,9999) = NVL((SELECT MAX(ANNO_CAMPAGNA)
                                                 FROM DB_PARTICELLA_CERT_ELEG
                                                WHERE ID_PARTICELLA_CERTIFICATA = PC.ID_PARTICELLA_CERTIFICATA),9999)
    GROUP BY PD.ID_PARTICELLA)
   SELECT SP.ID_PARTICELLA,
          SUM(S.AREA) SUP_UV,
          C.DESCOM,
          SP.SEZIONE,
          SP.FOGLIO,
          SP.PARTICELLA,
          SP.SUBALTERNO,
          SP.ID_STORICO_PARTICELLA,
          PE.TOT_ELEG
     FROM DB_STORICO_UNITA_ARBOREA S,
          DB_STORICO_PARTICELLA SP,
          DB_CONDUZIONE_PARTICELLA CP,
          DB_UTE U,
          COMUNE C,
          PROVINCIA P,
          PARTICELLA_ELEG PE
    WHERE S.ID_AZIENDA = pIdAzienda
      AND S.DATA_FINE_VALIDITA IS NULL
      AND S.DATA_CESSAZIONE IS NULL
      AND S.ID_PARTICELLA = PE.ID_PARTICELLA
      AND S.ID_PARTICELLA = SP.ID_PARTICELLA
      AND SP.DATA_FINE_VALIDITA IS NULL
      AND SP.ID_PARTICELLA = CP.ID_PARTICELLA
      AND CP.ID_TITOLO_POSSESSO NOT IN (5,6)
      AND CP.DATA_FINE_CONDUZIONE IS NULL
      AND CP.ID_UTE = U.ID_UTE
      AND U.ID_AZIENDA = pIdAzienda
      AND C.ISTAT_COMUNE = SP.COMUNE
      AND P.ISTAT_PROVINCIA = C.ISTAT_PROVINCIA
      AND P.ID_REGIONE = '01' -- SOLO PIEMONTE
      AND NOT EXISTS (SELECT ID_ESITO_CONTROLLO_PARTICELLA
                        FROM DB_ESITO_CONTROLLO_PARTICELLA
                       WHERE ID_CONTROLLO IN (knIdControlloP25,knIdControlloP30)
                         AND ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA)
 GROUP BY SP.ID_PARTICELLA,
          C.DESCOM,
          SP.SEZIONE,
          SP.FOGLIO,
          SP.PARTICELLA,
          SP.SUBALTERNO,
          SP.ID_STORICO_PARTICELLA,
          PE.TOT_ELEG
 HAVING SUM(S.AREA) > PE.TOT_ELEG + (PE.TOT_ELEG * nPerc/100);

    vDescrizionePart1    DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    vDescrizionePart2    DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    vDescrizione         DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

    CURSOR curUnitaVitateParticella (pIdParticella IN DB_STORICO_UNITA_ARBOREA.ID_PARTICELLA%TYPE) IS
    SELECT A.ID_STORICO_UNITA_ARBOREA, A.PROGR_UNAR
      FROM DB_STORICO_UNITA_ARBOREA A
     WHERE A.ID_PARTICELLA = pIdParticella
       AND A.ID_AZIENDA = pIdAzienda
       AND A.DATA_FINE_VALIDITA IS NULL;

    CURSOR curConduzioniParticella (pIdParticella IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT CP.ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA CP,
           DB_UTE U
     WHERE CP.ID_PARTICELLA = pIdParticella
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_UTE = U.ID_UTE
       AND CP.ID_TITOLO_POSSESSO NOT IN (5,6)
       AND U.ID_AZIENDA = pIdAzienda;

    recTpCtrlParam  DB_TIPO_CONTROLLO_PARAMETRO%ROWTYPE;

BEGIN

     -- cerco su DB_TIPO_CONTROLLO_PARAMETRO il parametro del controllo contenente la percentuale di tolleranza da
     -- applicare alla superficie eleggibile (in maggiorazione)
     recTpCtrlParam := SelValoreParametroCtrlByCodice (pIdControllo, kvCodParControlloTer41);

     IF recTpCtrlParam.ID_CONTROLLO_PARAMETRO IS NOT NULL THEN
        -- se il campo valore numerico è valorizzato
        IF recTpCtrlParam.VALORE_NUMERICO IS NOT NULL THEN
           nPerc := recTpCtrlParam.VALORE_NUMERICO;
        ELSE
           -- altrimenti assegno zero alla parcentuale di maggiorazione
           nPerc := 0;
        END IF;
     ELSE
        --  idem se non c'è proprio il parametro su DB_TIPO_CONTROLLO_PARAMETRO
        nPerc := 0;
     END IF;

     FOR recParticellaAViteInSupero IN curParticellaAViteInSupero LOOP
         vDescrizionePart1 := '[' || recParticellaAViteInSupero.DESCOM || ' Sez : ' ||  NVL(recParticellaAViteInSupero.SEZIONE,'N.P.') ||
                              ' Flg : ' || recParticellaAViteInSupero.FOGLIO || ' Part : ' || recParticellaAViteInSupero.PARTICELLA ||
                              ' Sub : ' || NVL(recParticellaAViteInSupero.SUBALTERNO,'N.P.') ;

         vDescrizionePart2 := ' ] la somma della superficie vitate che insiste sulla particella : ' || TO_CHAR(recParticellaAViteInSupero.SUP_UV,'999G990D9999')  ||
                              ' (ha) supera la somma della superficie eleggbile a vite : ' || TO_CHAR(recParticellaAViteInSupero.TOT_ELEG,'999G990D9999')  ||
                              ' (ha) maggiorata del : ' || TO_CHAR(nPerc,'990D99') || ' per cento';

         FOR recUnitaVitateParticella IN curUnitaVitateParticella (recParticellaAViteInSupero.ID_PARTICELLA) LOOP

             vDescrizione := vDescrizionePart1 || ', Prog. Unar : ' || recUnitaVitateParticella.PROGR_UNAR || vDescrizionePart2;

             IF NOT SCRIVI_SEGNALAZIONE (pIdAzienda, pIdControllo, vDescrizione,pBloccante, recParticellaAViteInSupero.ID_STORICO_PARTICELLA, recUnitaVitateParticella.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
             END IF;

             IF NOT SCRIVI_SEGNALAZIONE_UNAR (pIdAzienda, pIdControllo, vDescrizione,pBloccante, recUnitaVitateParticella.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
             END IF;
         END LOOP;

         FOR recConduzioniParticella IN curConduzioniParticella (recParticellaAViteInSupero.ID_PARTICELLA) LOOP
             vDescrizione := vDescrizionePart1 || vDescrizionePart2;
             IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (pIdAzienda, pIdControllo, vDescrizione,pBloccante, recConduzioniParticella.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
             END IF;
         END LOOP;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE UV_MAGGIORE_ELEGGIBILE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END UV_MAGGIORE_ELEGGIBILE;

-- Nuovo controllo che verifica che la superficie vitata sia maggiore della superficie eleggibile a vite
-- decurtata di una quota percentuale
FUNCTION UV_MINORE_ELEGGIBILE (pIdAzienda   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                               pIdControllo IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                               pBloccante   IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                               P_MSGERR     IN OUT VARCHAR2,
                               P_CODERR     IN OUT VARCHAR2) RETURN BOOLEAN IS

    nPerc DB_TIPO_CONTROLLO_PARAMETRO.VALORE_NUMERICO%TYPE;

    CURSOR curParticellaAViteInDeficit IS
    WITH PARTICELLA_DISTINTA AS
    (SELECT DISTINCT SUA.ID_PARTICELLA
       FROM DB_STORICO_UNITA_ARBOREA SUA
      WHERE SUA.ID_AZIENDA = pIdAzienda
        AND SUA.DATA_FINE_VALIDITA IS NULL
        AND SUA.DATA_CESSAZIONE IS NULL
        ),
    PARTICELLA_ELEG AS
    (SELECT PD.ID_PARTICELLA , NVL(SUM(DECODE(PCE.ID_ELEGGIBILITA_FIT, knIdTipoEleggibilitaFitVite,PCE.SUPERFICIE)),0) AS TOT_ELEG
       FROM DB_PARTICELLA_CERT_ELEG PCE,
            DB_PARTICELLA_CERTIFICATA PC,
            PARTICELLA_DISTINTA PD
      WHERE PD.ID_PARTICELLA = PC.ID_PARTICELLA (+)
        AND PC.ID_PARTICELLA_CERTIFICATA = PCE.ID_PARTICELLA_CERTIFICATA (+)
        AND PC.DATA_FINE_VALIDITA IS NULL
        AND NVL(PCE.ANNO_CAMPAGNA,9999) = NVL((SELECT MAX(ANNO_CAMPAGNA)
                                                 FROM DB_PARTICELLA_CERT_ELEG
                                                WHERE ID_PARTICELLA_CERTIFICATA = PC.ID_PARTICELLA_CERTIFICATA),9999)
    GROUP BY PD.ID_PARTICELLA)
   SELECT SP.ID_PARTICELLA,
          SUM(S.AREA) SUP_UV,
          C.DESCOM,
          SP.SEZIONE,
          SP.FOGLIO,
          SP.PARTICELLA,
          SP.SUBALTERNO,
          SP.ID_STORICO_PARTICELLA,
          PE.TOT_ELEG
     FROM DB_STORICO_UNITA_ARBOREA S,
          DB_STORICO_PARTICELLA SP,
          DB_CONDUZIONE_PARTICELLA CP,
          DB_UTE U,
          COMUNE C,
          PROVINCIA P,
          PARTICELLA_ELEG PE
    WHERE S.ID_AZIENDA = pIdAzienda
      AND S.DATA_FINE_VALIDITA IS NULL
      AND S.ID_PARTICELLA = PE.ID_PARTICELLA
      AND S.ID_PARTICELLA = SP.ID_PARTICELLA
      AND SP.DATA_FINE_VALIDITA IS NULL
      AND SP.ID_PARTICELLA = CP.ID_PARTICELLA
      AND CP.ID_TITOLO_POSSESSO NOT IN (5,6)
      AND CP.DATA_FINE_CONDUZIONE IS NULL
      AND CP.ID_UTE = U.ID_UTE
      AND U.ID_AZIENDA = pIdAzienda
      AND C.ISTAT_COMUNE = SP.COMUNE
      AND P.ISTAT_PROVINCIA = C.ISTAT_PROVINCIA
      AND P.ID_REGIONE = '01' -- SOLO PIEMONTE
      AND NOT EXISTS (SELECT ID_ESITO_CONTROLLO_PARTICELLA
                        FROM DB_ESITO_CONTROLLO_PARTICELLA
                       WHERE ID_CONTROLLO IN (knIdControlloP25,knIdControlloP30)
                         AND ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA)
 GROUP BY SP.ID_PARTICELLA,
          C.DESCOM,
          SP.SEZIONE,
          SP.FOGLIO,
          SP.PARTICELLA,
          SP.SUBALTERNO,
          SP.ID_STORICO_PARTICELLA,
          PE.TOT_ELEG
 HAVING SUM(S.AREA) < PE.TOT_ELEG - (PE.TOT_ELEG * nPerc/100);


    vDescrizionePart1    DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    vDescrizionePart2    DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    vDescrizione    DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

    CURSOR curUnitaVitateParticella (pIdParticella IN DB_STORICO_UNITA_ARBOREA.ID_PARTICELLA%TYPE) IS
    SELECT A.ID_STORICO_UNITA_ARBOREA, A.PROGR_UNAR
      FROM DB_STORICO_UNITA_ARBOREA A
     WHERE A.ID_PARTICELLA = pIdParticella
       AND A.ID_AZIENDA = pIdAzienda
       AND A.DATA_FINE_VALIDITA IS NULL;

    CURSOR curConduzioniParticella (pIdParticella IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT CP.ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA CP,
           DB_UTE U
     WHERE CP.ID_PARTICELLA = pIdParticella
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_UTE = U.ID_UTE
       AND CP.ID_TITOLO_POSSESSO NOT IN (5,6)
       AND U.ID_AZIENDA = pIdAzienda;

    recTpCtrlParam  DB_TIPO_CONTROLLO_PARAMETRO%ROWTYPE;

BEGIN

     -- cerco su DB_TIPO_CONTROLLO_PARAMETRO il parametro del controllo contenente la percentuale di tolleranza da
     -- applicare alla superficie eleggibile (in maggiorazione)
     recTpCtrlParam := SelValoreParametroCtrlByCodice (pIdControllo, kvCodParControlloTer42);

     IF recTpCtrlParam.ID_CONTROLLO_PARAMETRO IS NOT NULL THEN
        -- se il campo valore numerico è valorizzato
        IF recTpCtrlParam.VALORE_NUMERICO IS NOT NULL THEN
           nPerc := recTpCtrlParam.VALORE_NUMERICO;
        ELSE
           -- altrimenti assegno zero alla parcentuale di maggiorazione
           nPerc := 0;
        END IF;
     ELSE
        --  idem se non c'è proprio il parametro su DB_TIPO_CONTROLLO_PARAMETRO
        nPerc := 0;
     END IF;

     FOR recParticellaAViteInDeficit IN curParticellaAViteInDeficit LOOP

         vDescrizionePart1 := '[' || recParticellaAViteInDeficit.DESCOM || ' Sez : ' ||  NVL(recParticellaAViteInDeficit.SEZIONE,'N.P.') ||
                              ' Flg : ' || recParticellaAViteInDeficit.FOGLIO || ' Part : ' || recParticellaAViteInDeficit.PARTICELLA ||
                              ' Sub : ' || NVL(recParticellaAViteInDeficit.SUBALTERNO,'N.P.') ;


         vDescrizionePart2 := ' ] la somma della superficie vitate che insiste sulla particella : ' || TO_CHAR(recParticellaAViteInDeficit.SUP_UV,'999G990D9999')  ||
                              ' (ha) è inferiore la somma della superficie eleggbile a vite : ' || TO_CHAR(recParticellaAViteInDeficit.TOT_ELEG,'999G990D9999')  ||
                              ' (ha) decurtata del : ' || TO_CHAR(nPerc,'990D99') || ' per cento';

         FOR recUnitaVitateParticella IN curUnitaVitateParticella (recParticellaAViteInDeficit.ID_PARTICELLA) LOOP

             vDescrizione := vDescrizionePart1 || ', Prog. Unar : ' || recUnitaVitateParticella.PROGR_UNAR || vDescrizionePart2;

             IF NOT SCRIVI_SEGNALAZIONE (pIdAzienda, pIdControllo, vDescrizione,pBloccante, recParticellaAViteInDeficit.ID_STORICO_PARTICELLA, recUnitaVitateParticella.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
             END IF;

             IF NOT SCRIVI_SEGNALAZIONE_UNAR (pIdAzienda, pIdControllo, vDescrizione,pBloccante, recUnitaVitateParticella.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
             END IF;
         END LOOP;

         FOR recConduzioniParticella IN curConduzioniParticella (recParticellaAViteInDeficit.ID_PARTICELLA) LOOP
             vDescrizione := vDescrizionePart1 || vDescrizionePart2;
             IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (pIdAzienda, pIdControllo, vDescrizione,pBloccante, recConduzioniParticella.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
             END IF;
         END LOOP;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE UV_MINORE_ELEGGIBILE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END UV_MINORE_ELEGGIBILE;

-- se un'azienda ha effettuato la compensanzione delle UV
-- allora deve aver fatto anche il consolidamento a GIS
FUNCTION IfCompensataThenConsolidata (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                      P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                      P_BLOCCANTE    IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                      P_MSGERR   IN OUT VARCHAR2,
                                      P_CODERR   IN OUT VARCHAR2) RETURN BOOLEAN IS

    vDescAnomalia DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    nContatore    INTEGER:=0;

BEGIN

    SELECT COUNT(ID_COMPENSAZIONE_AZIENDA)
      INTO nContatore
      FROM DB_COMPENSAZIONE_AZIENDA
     WHERE ID_AZIENDA = P_ID_AZIENDA
       AND DATA_COMPENSAZIONE IS NOT NULL
       AND DATA_CONSOLIDAMENTO_GIS IS NULL
       AND DATA_FINE_VALIDITA IS NULL;

    IF nContatore > 0 THEN
       vDescAnomalia :=  'Le unita'' vitate sono state oggetto di compensazione aziendale pertanto e'' necessario procedere nel consolidamento GIS';
       IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
          RETURN (FALSE);
       END IF;
    END IF;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'IfCompensataThenConsolidata: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END IfCompensataThenConsolidata;

-- Nuovo controllo che verifica che le unita' vitate con ANNO_ISCRIZIONE_ALBO
-- maggiore od uguale a 2010 siano state inserite od aggiornate dall'applicativo di VITI
FUNCTION UV_IDONEITA_CONFERITA (pIdAzienda   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                pIdControllo IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                pBloccante   IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                P_MSGERR     IN OUT VARCHAR2,
                                P_CODERR     IN OUT VARCHAR2) RETURN BOOLEAN IS



    nAnnoRif        DB_STORICO_UNITA_ARBOREA.ANNO_ISCRIZIONE_ALBO%TYPE;
    vDescAnomalia   DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

    CURSOR curUnitaVitata (pAnnoRif IN DB_STORICO_UNITA_ARBOREA.ANNO_ISCRIZIONE_ALBO%TYPE) IS
    SELECT C.DESCOM,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           SUA.PROGR_UNAR,
           TTV.DESCRIZIONE ,
           SUA.ID_STORICO_UNITA_ARBOREA,
           SUA.ANNO_ISCRIZIONE_ALBO,
           SP.ID_PARTICELLA,
           SP.ID_STORICO_PARTICELLA
      FROM DB_STORICO_UNITA_ARBOREA SUA,
           DB_TIPO_TIPOLOGIA_VINO TTV,
           DB_STORICO_PARTICELLA SP,
           COMUNE C,
           PROVINCIA P
     WHERE SUA.ID_AZIENDA = pIdAzienda
       AND SUA.DATA_FINE_VALIDITA IS NULL
       AND SUA.DATA_CESSAZIONE IS NULL
       AND SUA.ID_TIPOLOGIA_VINO = TTV.ID_TIPOLOGIA_VINO
       AND TTV.VINO_DOC = 'S'
       AND SUA.ANNO_ISCRIZIONE_ALBO >= pAnnoRif
       AND SUA.ID_PARTICELLA = SP.ID_PARTICELLA
       AND SP.DATA_FINE_VALIDITA IS NULL
       AND C.ISTAT_COMUNE = SP.COMUNE
       AND P.ISTAT_PROVINCIA = C.ISTAT_PROVINCIA
       AND P.ID_REGIONE = '01' -- SOLO PIEMONTE
       AND EXISTS (SELECT CP.ID_CONDUZIONE_PARTICELLA
                     FROM DB_CONDUZIONE_PARTICELLA CP,
                          DB_UTE U
                    WHERE SP.ID_PARTICELLA = CP.ID_PARTICELLA
                      AND CP.ID_TITOLO_POSSESSO NOT IN (5,6)
                      AND CP.DATA_FINE_CONDUZIONE IS NULL
                      AND CP.ID_UTE = U.ID_UTE
                      AND U.ID_AZIENDA = pIdAzienda)
       AND NOT EXISTS (SELECT ID_STORICO_UNITA_ARBOREA
                         FROM DB_STORICO_UNITA_ARBOREA
                        WHERE ID_UNITA_ARBOREA = SUA.ID_UNITA_ARBOREA
                          AND ID_CAUSALE_MODIFICA IN (knIdCausaleModImpAccComVit,
                                                      knIdCausaleModImpTraComVit,
                                                      knIdCausaleModVarIdoTraComVit,
                                                      knIdCausaleModVarIdoAccComVit));

    CURSOR curConduzioniParticella (pIdParticella IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT CP.ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA CP,
           DB_UTE U
     WHERE CP.ID_PARTICELLA = pIdParticella
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_UTE = U.ID_UTE
       AND CP.ID_TITOLO_POSSESSO NOT IN (5,6)
       AND U.ID_AZIENDA = pIdAzienda;

BEGIN

    BEGIN
        nAnnoRif := SelectValoreParametro(kvIdParamAnnoUV26);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             nAnnoRif := 2010;
    END;

    FOR recUnitaVitata IN curUnitaVitata (nAnnoRif) LOOP

        vDescAnomalia :=  '[' || recUnitaVitata.DESCOM || ' Sez:'
                              || NVL(recUnitaVitata.SEZIONE,'N.V.') ||' Fgl:'
                              || recUnitaVitata.FOGLIO || ' Part:'
                              || recUnitaVitata.PARTICELLA || ' Sub:'
                              || NVL(recUnitaVitata.SUBALTERNO,'N.V') || ' Progr: '
                              || recUnitaVitata.PROGR_UNAR || '] con vino Doc : ' || recUnitaVitata.DESCRIZIONE || ' non compare in dichiarazioni viticole comunicate od accertate';

        IF NOT SCRIVI_SEGNALAZIONE (pIdAzienda, pIdControllo, vDescAnomalia,pBloccante, recUnitaVitata.ID_STORICO_PARTICELLA, recUnitaVitata.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_UNAR (pIdAzienda, pIdControllo, vDescAnomalia,pBloccante, recUnitaVitata.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        FOR recConduzioniParticella IN curConduzioniParticella(recUnitaVitata.ID_PARTICELLA) LOOP
            IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (pIdAzienda, pIdControllo, vDescAnomalia,
                                                   pBloccante, recConduzioniParticella.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
        END LOOP;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
         p_MsgErr   := 'ERRORE UV_IDONEITA_CONFERITA: ' || SQLERRM;
         p_CodErr   := SQLCODE;
         RETURN (FALSE);
END UV_IDONEITA_CONFERITA;

-- 628
-- Verifica che le particelle dell'azienda con titolo possesso proprieta' in anagrafe
-- abbiano proprieta' anche su sigmater
FUNCTION VERIFICA_TITOLARITA_SIGMATER (pIdAzienda   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                       pIdControllo IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       pBloccante   IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR     IN OUT VARCHAR2,
                                       P_CODERR     IN OUT VARCHAR2) RETURN BOOLEAN IS

    CURSOR curParticellaNonInPropSig IS
    SELECT SP.ID_STORICO_PARTICELLA,
           SP.ID_PARTICELLA,
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           C.DESCOM
      FROM DB_STORICO_PARTICELLA SP,
           DB_CONDUZIONE_PARTICELLA CP,
           DB_UTE U,
           COMUNE C
     WHERE U.ID_AZIENDA = pIdAzienda
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND U.ID_UTE = CP.ID_UTE
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_TITOLO_POSSESSO = 1 -- proprieta'
       AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
       AND SP.DATA_FINE_VALIDITA IS NULL
       AND SP.COMUNE = C.ISTAT_COMUNE
       AND SP.PARTICELLA IS NOT NULL -- il numero particella dev'essere valorizzato
       AND NOT EXISTS (SELECT PS.ID_PARTICELLA_SIGMATER
                         FROM DB_PARTICELLA_SIGMATER PS,
                              DB_TITOLARITA_PARTICELLA_SIG TPS,
                              DB_TITOLARITA_SIGMATER TS,
                              DB_RICHIESTA_SIGMATER RS,
                              DB_TIPO_DIRITTO TDS
                        WHERE PS.COMUNE = SP.COMUNE
                          AND NVL(PS.SEZIONE,'#') = NVL(SP.SEZIONE,'#')
                          AND PS.FOGLIO = SP.FOGLIO
                          AND PS.PARTICELLA = SP.PARTICELLA
                          AND NVL(PS.SUBALTERNO,'#') = NVL(SP.SUBALTERNO,'#')
                          AND TPS.ID_PARTICELLA_SIGMATER = PS.ID_PARTICELLA_SIGMATER
                          AND TPS.ID_TITOLARITA_SIGMATER = TS.ID_TITOLARITA_SIGMATER
                          AND TS.ID_RICHIESTA_SIGMATER = RS.ID_RICHIESTA_SIGMATER
                          AND TS.ID_DIRITTO_SIGMATER = TDS.ID_TIPO_DIRITTO
                          AND RS.ID_AZIENDA = pIdAzienda
                          AND TDS.ID_TITOLO_POSSESSO = CP.ID_TITOLO_POSSESSO -- proprieta'
                          AND TDS.DATA_FINE_VALIDITA IS NULL)
  GROUP BY SP.ID_STORICO_PARTICELLA,
           SP.ID_PARTICELLA,
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           C.DESCOM;


    CURSOR curConduzioniParticella (pIdParticella IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT CP.ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA CP,
           DB_UTE U
     WHERE CP.ID_PARTICELLA = pIdParticella
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_UTE = U.ID_UTE
       AND CP.ID_TITOLO_POSSESSO = 1 -- proprieta'
       AND U.ID_AZIENDA = pIdAzienda
       AND U.DATA_FINE_ATTIVITA IS NULL;

    vDescAnomalia   DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
BEGIN

    FOR recParticellaNonInPropSig IN curParticellaNonInPropSig LOOP

         vDescAnomalia := '[' || recParticellaNonInPropSig.DESCOM || ' Sez : ' || NVL(recParticellaNonInPropSig.SEZIONE,'N.P.') ||' Fgl:' || recParticellaNonInPropSig.FOGLIO ||
                            ' Part:' || recParticellaNonInPropSig.PARTICELLA || ' Sub : ' || NVL(recParticellaNonInPropSig.SUBALTERNO,'N.P.') || '] ' ||
                          ' la titolarita'' definita in fascicolo e'' diversa da quella presente su fonte dati Sigmater oppure la particella non e'' presente su fonte dati Sigmater';


         IF NOT SCRIVI_SEGNALAZIONE (pIdAzienda,pIdControllo, vDescAnomalia,
                                     pBloccante, recParticellaNonInPropSig.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
            RETURN FALSE;
         END IF;

         FOR recConduzioniParticella IN curConduzioniParticella (recParticellaNonInPropSig.ID_PARTICELLA) LOOP
             IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (pIdAzienda,pIdControllo,vDescAnomalia,
                                                    pBloccante,recConduzioniParticella.ID_CONDUZIONE_PARTICELLA,P_MSGERR,P_CODERR) THEN
                RETURN FALSE;
             END IF;
         END LOOP;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
         p_MsgErr   := 'ERRORE VERIFICA_TITOLARITA_SIGMATER: ' || SQLERRM;
         p_CodErr   := SQLCODE;
         RETURN (FALSE);
END VERIFICA_TITOLARITA_SIGMATER;

-- se la particella e' dichiarata con titolo possesso proprieta'
-- su anagrafe deve esserlo anche sul catasto e
FUNCTION PART_PROPRIETA_GAA_CATASTO (pIdAzienda   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                     pIdControllo IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                     pBloccante   IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                     P_MSGERR     IN OUT VARCHAR2,
                                     P_CODERR     IN OUT VARCHAR2) RETURN BOOLEAN IS

    CURSOR curParticellaNonInPropCatasto IS
    SELECT SP.ID_STORICO_PARTICELLA,
           SP.ID_PARTICELLA,
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           C.DESCOM
      FROM DB_STORICO_PARTICELLA SP,
           DB_CONDUZIONE_PARTICELLA CP,
           DB_UTE U,
           COMUNE C
     WHERE U.ID_AZIENDA = pIdAzienda
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND U.ID_UTE = CP.ID_UTE
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_TITOLO_POSSESSO IN (1,10,11,12) 
       AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
       AND SP.DATA_FINE_VALIDITA IS NULL
       AND SP.COMUNE = C.ISTAT_COMUNE
       AND SP.PARTICELLA IS NOT NULL -- il numero particella dev'essere valorizzato
       /*AND NOT EXISTS (SELECT CPA.ID_CONDUZIONE_PARTICELLA
                         FROM DB_CONDUZIONE_PARTICELLA CPA
                        WHERE CPA.ID_UTE = U.ID_UTE
                          AND CPA.DATA_FINE_CONDUZIONE IS NULL
                          AND CPA.ID_PARTICELLA = CP.ID_PARTICELLA
                          AND CPA.ID_TITOLO_POSSESSO <> 1)*/ 
       AND NOT EXISTS (SELECT PC.ID_PARTICELLA_CERTIFICATA
                     FROM DB_PARTICELLA_CERTIFICATA PC,
                          DB_PROPRIETA_CERTIFICATA PRC,
                          DB_TIPO_DIRITTO TD,
                          DB_ANAGRAFICA_AZIENDA AZ,
                          DB_SOGGETTO SO
                    WHERE PC.ID_PARTICELLA = SP.ID_PARTICELLA
                      AND PC.ID_PARTICELLA_CERTIFICATA = PRC.ID_PARTICELLA_CERTIFICATA
                      AND PRC.DATA_FINE_VALIDITA IS NULL
                      AND PRC.ID_TIPO_DIRITTO = TD.ID_TIPO_DIRITTO
                      AND TD.ID_TITOLO_POSSESSO = 1 -- proprieta
                      AND PRC.ID_SOGGETTO = SO.ID_SOGGETTO
                      AND AZ.ID_AZIENDA = pIdAzienda
                      AND AZ.DATA_FINE_VALIDITA IS NULL
                      AND (EXISTS (SELECT PG.ID_PERSONA_GIURIDICA
                                     FROM DB_PERSONA_GIURIDICA PG
                                    WHERE SO.FLAG_FISICO = 'N'
                                      AND SO.ID_SOGGETTO = PG.ID_SOGGETTO
                                      AND (AZ.CUAA = PG.CODICE_FISCALE OR AZ.CUAA = PG.PARTITA_IVA) OR
                              exists (select *
                                         from db_contitolare c, db_Tipo_Ruolo tr
                                         where   C.ID_AZIENDA = az.ID_AZIENDA
                                          and C.ID_RUOLO = tr.id_ruolo
                                          and TR.POTENZIALE_PROPRIETARIO_PART = 'S'
                                          and c.id_soggetto = so.id_soggetto)
                                          or
                           EXISTS (SELECT PF.ID_PERSONA_FISICA
                                     FROM DB_PERSONA_FISICA PF
                                    WHERE SO.FLAG_FISICO = 'S'
                                      AND SO.ID_SOGGETTO = PF.ID_SOGGETTO
                                      AND AZ.CUAA = PF.CODICE_FISCALE))))
  GROUP BY SP.ID_STORICO_PARTICELLA,
           SP.ID_PARTICELLA,
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           C.DESCOM;


    CURSOR curConduzioniParticella (pIdParticella IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT CP.ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA CP,
           DB_UTE U
     WHERE CP.ID_PARTICELLA = pIdParticella
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_UTE = U.ID_UTE
       AND CP.ID_TITOLO_POSSESSO = 1 -- proprieta'
       AND U.ID_AZIENDA = pIdAzienda
       AND U.DATA_FINE_ATTIVITA IS NULL;

    vDescAnomalia   DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
BEGIN

    FOR recParticellaNonInPropCatasto IN curParticellaNonInPropCatasto LOOP

         vDescAnomalia := '[' || recParticellaNonInPropCatasto.DESCOM || ' Sez : ' || NVL(recParticellaNonInPropCatasto.SEZIONE,'N.P.') ||' Fgl:' || recParticellaNonInPropCatasto.FOGLIO ||
                            ' Part:' || recParticellaNonInPropCatasto.PARTICELLA || ' Sub : ' || NVL(recParticellaNonInPropCatasto.SUBALTERNO,'N.P.') || '] ' ||
                          ' la titolarita'' definita in fascicolo e'' diversa da quella presente su fonte dati catasto';


         IF NOT SCRIVI_SEGNALAZIONE (pIdAzienda,pIdControllo, vDescAnomalia,
                                     pBloccante, recParticellaNonInPropCatasto.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
            RETURN FALSE;
         END IF;

         FOR recConduzioniParticella IN curConduzioniParticella (recParticellaNonInPropCatasto.ID_PARTICELLA) LOOP
             IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (pIdAzienda,pIdControllo,vDescAnomalia,
                                                    pBloccante,recConduzioniParticella.ID_CONDUZIONE_PARTICELLA,P_MSGERR,P_CODERR) THEN
                RETURN FALSE;
             END IF;
         END LOOP;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
         p_MsgErr   := 'ERRORE PART_PROPRIETA_GAA_CATASTO: ' || SQLERRM;
         p_CodErr   := SQLCODE;
         RETURN (FALSE);
END PART_PROPRIETA_GAA_CATASTO;

-- se la particella e' dichiarata con titolo possesso <> proprieta'
-- su anagrafe non deve essere in proprieta' al 100% sul catasto
FUNCTION PART_NO_PROPRIETA_GAA_CATASTO (pIdAzienda   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                        pIdControllo IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        pBloccante   IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                        P_MSGERR     IN OUT VARCHAR2,
                                        P_CODERR     IN OUT VARCHAR2) RETURN BOOLEAN IS

    CURSOR curParticellaNonInPropCatasto IS
    SELECT SP.ID_STORICO_PARTICELLA,
           SP.ID_PARTICELLA,
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           C.DESCOM
      FROM DB_STORICO_PARTICELLA SP,
           DB_CONDUZIONE_PARTICELLA CP,
           DB_UTE U,
           COMUNE C
     WHERE U.ID_AZIENDA = pIdAzienda
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND U.ID_UTE = CP.ID_UTE
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_TITOLO_POSSESSO NOT IN (1,10,11,12) 
       AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
       AND SP.DATA_FINE_VALIDITA IS NULL
       AND SP.COMUNE = C.ISTAT_COMUNE
       AND SP.PARTICELLA IS NOT NULL -- il numero particella dev'essere valorizzato
       AND EXISTS (SELECT PC.ID_PARTICELLA_CERTIFICATA
                     FROM DB_PARTICELLA_CERTIFICATA PC,
                          DB_PROPRIETA_CERTIFICATA PRC,
                          DB_TIPO_DIRITTO TD,
                          DB_ANAGRAFICA_AZIENDA AZ,
                          DB_SOGGETTO SO
                    WHERE PC.ID_PARTICELLA = SP.ID_PARTICELLA
                      AND PC.ID_PARTICELLA_CERTIFICATA = PRC.ID_PARTICELLA_CERTIFICATA
                      AND PRC.DATA_FINE_VALIDITA IS NULL
                      AND PRC.ID_TIPO_DIRITTO = TD.ID_TIPO_DIRITTO
                      AND TD.ID_TITOLO_POSSESSO = 1 -- proprieta
                      AND PRC.ID_SOGGETTO = SO.ID_SOGGETTO
                      --AND PRC.PERCENTUALE_POSSESSO = 100  
                      AND AZ.ID_AZIENDA = pIdAzienda
                      AND AZ.DATA_FINE_VALIDITA IS NULL
                      AND (EXISTS (SELECT PG.ID_PERSONA_GIURIDICA
                                     FROM DB_PERSONA_GIURIDICA PG
                                    WHERE SO.FLAG_FISICO = 'N'
                                      AND SO.ID_SOGGETTO = PG.ID_SOGGETTO
                                      AND (AZ.CUAA = PG.CODICE_FISCALE OR AZ.CUAA = PG.PARTITA_IVA))  OR
                           exists (select *
                                         from db_contitolare c, db_Tipo_Ruolo tr
                                         where   C.ID_AZIENDA = az.ID_AZIENDA
                                          and C.ID_RUOLO = tr.id_ruolo
                                          and TR.POTENZIALE_PROPRIETARIO_PART = 'S'
                                          and c.id_soggetto = so.id_soggetto)
                                          or
                           EXISTS (SELECT PF.ID_PERSONA_FISICA
                                     FROM DB_PERSONA_FISICA PF
                                    WHERE SO.FLAG_FISICO = 'S'
                                      AND SO.ID_SOGGETTO = PF.ID_SOGGETTO
                                      AND AZ.CUAA = PF.CODICE_FISCALE)))
  GROUP BY SP.ID_STORICO_PARTICELLA,
           SP.ID_PARTICELLA,
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           C.DESCOM;


    CURSOR curConduzioniParticella (pIdParticella IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT CP.ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA CP,
           DB_UTE U
     WHERE CP.ID_PARTICELLA = pIdParticella
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_UTE = U.ID_UTE
       AND CP.ID_TITOLO_POSSESSO <> 1 -- proprieta'
       AND U.ID_AZIENDA = pIdAzienda
       AND U.DATA_FINE_ATTIVITA IS NULL;

    vDescAnomalia   DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
BEGIN

    FOR recParticellaNonInPropCatasto IN curParticellaNonInPropCatasto LOOP

         vDescAnomalia := '[' || recParticellaNonInPropCatasto.DESCOM || ' Sez : ' || NVL(recParticellaNonInPropCatasto.SEZIONE,'N.P.') ||' Fgl:' || recParticellaNonInPropCatasto.FOGLIO ||
                            ' Part:' || recParticellaNonInPropCatasto.PARTICELLA || ' Sub : ' || NVL(recParticellaNonInPropCatasto.SUBALTERNO,'N.P.') || '] ' ||
                          ' la titolarita'' definita in fascicolo e'' diversa da quella presente su fonte dati catasto';


         IF NOT SCRIVI_SEGNALAZIONE (pIdAzienda,pIdControllo, vDescAnomalia,
                                     pBloccante, recParticellaNonInPropCatasto.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
            RETURN FALSE;
         END IF;

         FOR recConduzioniParticella IN curConduzioniParticella (recParticellaNonInPropCatasto.ID_PARTICELLA) LOOP
             IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (pIdAzienda,pIdControllo,vDescAnomalia,
                                                    pBloccante,recConduzioniParticella.ID_CONDUZIONE_PARTICELLA,P_MSGERR,P_CODERR) THEN
                RETURN FALSE;
             END IF;
         END LOOP;

    END LOOP;

    RETURN (TRUE);

EXCEPTION
    WHEN OTHERS THEN
         p_MsgErr   := 'ERRORE PART_NO_PROPRIETA_GAA_CATASTO: ' || SQLERRM;
         p_CodErr   := SQLCODE;
         RETURN (FALSE);
END PART_NO_PROPRIETA_GAA_CATASTO;


FUNCTION PRESENZA_UV_SU_USO_VINO (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                  P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_ID_CONDUZIONE        DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
s_sezione            VARCHAR2(20);
s_sub            VARCHAR2(20);
N_ID_PARTICELLA     DB_PARTICELLA.ID_PARTICELLA%TYPE;

CURSOR C_PARTICELLE_SENZA_UV IS
    SELECT CP.ID_PARTICELLA, C.DESCOM, SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA, SP.SUBALTERNO,
           cP.ID_CONDUZIONE_PARTICELLA, SP.ID_STORICO_PARTICELLA
    FROM DB_CONDUZIONE_PARTICELLA CP, DB_UTILIZZO_PARTICELLA UP, DB_UTE U, COMUNE C, DB_STORICO_PARTICELLA SP,
         DB_TIPO_UTILIZZO TTU, PROVINCIA P
    WHERE CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
    AND CP.DATA_FINE_CONDUZIONE IS NULL
    AND CP.ID_UTE = U.ID_UTE
    AND U.ID_AZIENDA = P_ID_AZIENDA
    AND SP.ID_PARTICELLA = CP.ID_PARTICELLA
    AND SP.DATA_FINE_VALIDITA IS NULL
    AND C.ISTAT_COMUNE = SP.COMUNE
    AND TTU.ID_UTILIZZO = UP.ID_UTILIZZO
    AND TTU.ANNO_FINE_VALIDITA IS NULL
    AND TTU.ID_INDIRIZZO_UTILIZZO = 20
--    AND cp.ID_TITOLO_POSSESSO<>5
    AND cp.ID_TITOLO_POSSESSO NOT IN  (5,6)
    AND P.ISTAT_PROVINCIA = C.ISTAT_PROVINCIA
    AND P.ID_REGIONE = '01' --CONTROLLO SOLO LE PARTICELLE CON CONDUZIONE IN PIEMONTE
    AND NOT EXISTS
    (SELECT ID_PARTICELLA FROM DB_STORICO_UNITA_ARBOREA SUA WHERE  SUA.ID_PARTICELLA = CP.ID_PARTICELLA AND  SUA.ID_AZIENDA = U.ID_AZIENDA
                                 AND SUA.DATA_FINE_VALIDITA IS NULL)
    GROUP BY CP.ID_PARTICELLA, C.DESCOM, SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA, SP.SUBALTERNO, cP.ID_CONDUZIONE_PARTICELLA,
          SP.ID_STORICO_PARTICELLA;

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_PARTICELLE_SENZA_UV IN C_PARTICELLE_SENZA_UV LOOP
         SELECT DECODE(REC_PARTICELLE_SENZA_UV.SEZIONE, NULL, '', ' Sz: '|| REC_PARTICELLE_SENZA_UV.SEZIONE)
        INTO S_SEZIONE FROM DUAL;
        SELECT DECODE(REC_PARTICELLE_SENZA_UV.subalterno, NULL, '', ' Sub: '|| REC_PARTICELLE_SENZA_UV.SUBALTERNO)
        INTO s_sub FROM dual;
        S_DESCRIZIONE := '[' || REC_PARTICELLE_SENZA_UV.DESCOM || s_sezione || ' Fgl:' ||
                        REC_PARTICELLE_SENZA_UV.FOGLIO ||' Part:' || REC_PARTICELLE_SENZA_UV.PARTICELLA ||s_sub||
                       '] E'' presente un uso del suolo a vigneto, ma non vi è un''unità vitata legata';

          IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, REC_PARTICELLE_SENZA_UV.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;

            IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, REC_PARTICELLE_SENZA_UV.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;
     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'PRESENZA_UV_SU_USO_VINO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END PRESENZA_UV_SU_USO_VINO;

FUNCTION PRESENZA_USO_VINO_SU_UV (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                       P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_ID_CONDUZIONE        DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
s_sezione            VARCHAR2(20);
s_sub            VARCHAR2(20);
N_ID_PARTICELLA     DB_PARTICELLA.ID_PARTICELLA%TYPE;
N_CONTATORE            NUMBER(10);
v_conta_conduz_no_asservimento NUMBER;

CURSOR C_ELENCO_UV IS
       SELECT B.ID_PARTICELLA, C.DESCOM, B.SEZIONE, B.FOGLIO, B.PARTICELLA, B.SUBALTERNO, a.ID_STORICO_UNITA_ARBOREA,
                 a.PROGR_UNAR, B.ID_STORICO_PARTICELLA
         FROM DB_STORICO_UNITA_ARBOREA a, DB_STORICO_PARTICELLA b, COMUNE C, PROVINCIA P, DB_UTE U, DB_CONDUZIONE_PARTICELLA CO
        WHERE A.id_particella = B.id_particella
          AND b.data_fine_validita IS NULL
          AND A.ID_AZIENDA = P_ID_AZIENDA
          AND C.ISTAT_COMUNE = B.COMUNE
          AND P.ISTAT_PROVINCIA = C.ISTAT_PROVINCIA
          AND P.ID_REGIONE = '01' -- SOLO PIEMONTE
          AND A.DATA_FINE_VALIDITA IS NULL
          AND U.ID_AZIENDA=A.ID_AZIENDA
        AND U.DATA_FINE_ATTIVITA IS NULL
        AND CO.ID_UTE=U.ID_UTE
        AND CO.DATA_FINE_CONDUZIONE IS NULL
        AND A.ID_PARTICELLA=CO.ID_PARTICELLA
        GROUP BY B.ID_PARTICELLA, C.DESCOM, B.SEZIONE, B.FOGLIO, B.PARTICELLA, B.SUBALTERNO,
                   a.ID_STORICO_UNITA_ARBOREA, a.PROGR_UNAR, B.ID_STORICO_PARTICELLA;

CURSOR C_PARTICELLE_SENZA_USO_VINO IS
       SELECT cp.id_conduzione_particella
          FROM DB_CONDUZIONE_PARTICELLA CP, DB_UTE U
         WHERE CP.ID_PARTICELLA = N_ID_PARTICELLA
           AND CP.DATA_FINE_CONDUZIONE IS NULL
           AND CP.ID_UTE = U.ID_UTE
--           AND cp.ID_TITOLO_POSSESSO<>5
           AND cP.ID_TITOLO_POSSESSO NOT IN (5,6)
           AND U.ID_AZIENDA = P_ID_AZIENDA
           GROUP BY CP.id_conduzione_particella ;

BEGIN
     S_DESCRIZIONE := NULL;
     N_ID_PARTICELLA := NULL;

     FOR REC_ELENCO_UV IN C_ELENCO_UV LOOP
         SELECT DECODE(REC_ELENCO_UV.SEZIONE, NULL, '', ' Sz: '|| REC_ELENCO_UV.SEZIONE)
        INTO S_SEZIONE FROM DUAL;
        SELECT DECODE(REC_ELENCO_UV.subalterno, NULL, '', ' Sub: '|| REC_ELENCO_UV.SUBALTERNO)
        INTO s_sub FROM dual;

        IF N_ID_PARTICELLA IS NULL OR --PRIMA VOLTA
           N_ID_PARTICELLA <> REC_ELENCO_UV.ID_PARTICELLA THEN

            N_ID_PARTICELLA := REC_ELENCO_UV.ID_PARTICELLA;

            N_CONTATORE := 0;

            SELECT COUNT(*)
            INTO   v_conta_conduz_no_asservimento
            FROM   DB_CONDUZIONE_PARTICELLA CP, DB_UTE U
            WHERE  CP.ID_UTE = U.ID_UTE
            AND       CP.ID_PARTICELLA = N_ID_PARTICELLA
--            AND       CP.ID_TITOLO_POSSESSO <> 5
           AND         cP.ID_TITOLO_POSSESSO NOT IN (5,6)
            AND       CP.DATA_FINE_CONDUZIONE IS NULL
            AND       U.DATA_FINE_ATTIVITA IS NULL
            AND       U.ID_AZIENDA = P_ID_AZIENDA;

            IF  v_conta_conduz_no_asservimento > 0 THEN

               SELECT COUNT(*)
                  INTO N_CONTATORE
                  FROM DB_CONDUZIONE_PARTICELLA CP, DB_UTE U, DB_UTILIZZO_PARTICELLA UP, DB_TIPO_UTILIZZO TU
                 WHERE CP.ID_PARTICELLA = N_ID_PARTICELLA
                   AND CP.DATA_FINE_CONDUZIONE IS NULL
                   AND CP.ID_UTE = U.ID_UTE
                   AND U.ID_AZIENDA = P_ID_AZIENDA
                   AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
                   AND TU.ID_UTILIZZO = UP.ID_UTILIZZO
                   AND TU.ID_INDIRIZZO_UTILIZZO = 20 --UTILIZZO VINO
                   AND TU.ANNO_FINE_VALIDITA IS NULL;
                 IF N_CONTATORE <= 0 THEN
                   SELECT COUNT(*)
                      INTO N_CONTATORE
                      FROM DB_CONDUZIONE_PARTICELLA CP, DB_UTE U
                     WHERE CP.ID_PARTICELLA = N_ID_PARTICELLA
                       AND CP.DATA_FINE_CONDUZIONE IS NULL
                       AND CP.ID_UTE = U.ID_UTE
                       AND U.ID_AZIENDA = P_ID_AZIENDA;
                   IF N_CONTATORE > 0 THEN
                          S_DESCRIZIONE := '[' || REC_ELENCO_UV.DESCOM || s_sezione || ' Fgl:' ||
                           REC_ELENCO_UV.FOGLIO ||' Part:' || REC_ELENCO_UV.PARTICELLA ||s_sub||
                        '] è presente almeno una unità vitata senza un utilizzo a vigneto sulla particella';

                          IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                               P_BLOCCANTE, REC_ELENCO_UV.ID_STORICO_PARTICELLA, REC_ELENCO_UV.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                             RETURN (FALSE);
                          END IF;

                          IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                                P_BLOCCANTE, REC_ELENCO_UV.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                             RETURN (FALSE);
                          END IF;
                          FOR REC_PARTICELLE_SENZA_USO_VINO IN C_PARTICELLE_SENZA_USO_VINO LOOP
                                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                                   P_BLOCCANTE, REC_PARTICELLE_SENZA_USO_VINO.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                                 RETURN (FALSE);
                              END IF;
                         END LOOP;
                    END IF;
                 END IF;

            END IF;
        END IF;
     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'PRESENZA_USO_VINO_SU_UV: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END PRESENZA_USO_VINO_SU_UV;

FUNCTION CONGRUENZA_UV_E_USO (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                       P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_ID_CONDUZIONE        DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
s_sezione            VARCHAR2(20);
s_sub            VARCHAR2(20);
N_ID_PARTICELLA     DB_PARTICELLA.ID_PARTICELLA%TYPE;
N_ID_PARTICELLA_COM     DB_PARTICELLA.ID_PARTICELLA%TYPE;
N_ID_STORICO_UNITA_ARBOREA DB_STORICO_UNITA_ARBOREA.ID_STORICO_UNITA_ARBOREA%TYPE;
N_TOTALE NUMBER(10);
N_TOTALE_UV NUMBER(10);

CURSOR C_UV IS
       SELECT a.ID_STORICO_UNITA_ARBOREA
       FROM DB_STORICO_UNITA_ARBOREA a,    DB_STORICO_PARTICELLA b
       WHERE a.id_particella = N_ID_PARTICELLA
          AND a.id_azienda = P_ID_AZIENDA
          AND a.DATA_FINE_VALIDITA IS NULL
          AND b.ID_PARTICELLA = a.ID_PARTICELLA
          AND b.DATA_FINE_VALIDITA IS NULL;


CURSOR C_CONDUZIONI_A_VIGNETO IS
       SELECT cP.ID_PARTICELLA, C.DESCOM, SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA, SP.SUBALTERNO, CP.ID_CONDUZIONE_PARTICELLA,
                 DECODE(UP.ID_UTILIZZO, 178, 487, UP.ID_UTILIZZO) ID_UTILIZZO, UP.ID_VARIETA, SP.ID_STORICO_PARTICELLA,
                 ID_CATALOGO_MATRICE
         FROM     DB_CONDUZIONE_PARTICELLA cp, DB_UTE u, DB_STORICO_PARTICELLA sp,
                       COMUNE C, DB_UTILIZZO_PARTICELLA UP, DB_TIPO_UTILIZZO TUT, PROVINCIA P
        WHERE CP.data_fine_conduzione IS NULL
          AND cP.id_ute = U.id_ute
          AND U.id_azienda = p_id_azienda
          AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
          AND SP.DATA_FINE_VALIDITA IS NULL
          AND SP.COMUNE = C.ISTAT_COMUNE
          AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
          AND TUT.ID_INDIRIZZO_UTILIZZO = 20
          AND TUT.ANNO_FINE_VALIDITA IS NULL
          AND UP.ID_UTILIZZO = TUT.ID_UTILIZZO
          AND P.ISTAT_PROVINCIA = C.ISTAT_PROVINCIA
--          AND cp.ID_TITOLO_POSSESSO<>5
          AND cp.ID_TITOLO_POSSESSO NOT IN (5,6)
          AND P.ID_REGIONE = '01'
         GROUP BY cP.ID_PARTICELLA, C.DESCOM, SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA, SP.SUBALTERNO, CP.ID_CONDUZIONE_PARTICELLA,
                 UP.ID_UTILIZZO, UP.ID_VARIETA, SP.ID_STORICO_PARTICELLA,ID_CATALOGO_MATRICE;

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_CONDUZIONI_A_VIGNETO IN C_CONDUZIONI_A_VIGNETO LOOP
         SELECT DECODE(REC_CONDUZIONI_A_VIGNETO.SEZIONE, NULL, '', ' Sz: '|| REC_CONDUZIONI_A_VIGNETO.SEZIONE)
        INTO S_SEZIONE FROM DUAL;
        SELECT DECODE(REC_CONDUZIONI_A_VIGNETO.subalterno, NULL, '', ' Sub: '|| REC_CONDUZIONI_A_VIGNETO.SUBALTERNO)
        INTO s_sub FROM dual;

        SELECT COUNT(*)
          INTO N_TOTALE
          FROM DB_STORICO_UNITA_ARBOREA UA
         WHERE UA.ID_PARTICELLA =     REC_CONDUZIONI_A_VIGNETO.ID_PARTICELLA
           AND UA.ID_CATALOGO_MATRICE = REC_CONDUZIONI_A_VIGNETO.ID_CATALOGO_MATRICE
           --AND UA.ID_AZIENDA     =    P_ID_AZIENDA
           --AND UA.ID_UTILIZZO     =     REC_CONDUZIONI_A_VIGNETO.ID_UTILIZZO
            AND UA.ID_VARIETA        =    REC_CONDUZIONI_A_VIGNETO.ID_VARIETA
           AND UA.DATA_FINE_VALIDITA IS NULL;

         IF N_TOTALE = 0 THEN
             SELECT COUNT(*)
              INTO N_TOTALE_UV
             FROM DB_STORICO_UNITA_ARBOREA UA
            WHERE UA.ID_PARTICELLA = REC_CONDUZIONI_A_VIGNETO.ID_PARTICELLA
              AND UA.ID_AZIENDA = P_ID_AZIENDA
              AND UA.DATA_FINE_VALIDITA IS NULL;

             IF N_TOTALE_UV > 0 THEN
                 S_DESCRIZIONE := '[' || REC_CONDUZIONI_A_VIGNETO.DESCOM || s_sezione || ' Fgl:' ||
                      REC_CONDUZIONI_A_VIGNETO.FOGLIO ||' Part:' || REC_CONDUZIONI_A_VIGNETO.PARTICELLA ||s_sub||
                     '] I dati dell''uso del suolo non sono congruenti con quelli della dest.prod delle UV associate';

              IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_CONDUZIONI_A_VIGNETO.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
                 IF N_ID_PARTICELLA IS NULL OR
                     N_ID_PARTICELLA <> REC_CONDUZIONI_A_VIGNETO.ID_PARTICELLA THEN

                     N_ID_PARTICELLA := REC_CONDUZIONI_A_VIGNETO.ID_PARTICELLA;
                     FOR REC_UV IN C_UV LOOP
                      IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                           P_BLOCCANTE, REC_UV.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                         RETURN (FALSE);
                      END IF;
                      IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                           P_BLOCCANTE, REC_CONDUZIONI_A_VIGNETO.ID_STORICO_PARTICELLA, REC_UV.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                         RETURN (FALSE);
                      END IF;
                     END LOOP;
                END IF;
           END IF;
         END IF;
     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'CONGRUENZA_UV_E_USO_VARIETA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONGRUENZA_UV_E_USO;

FUNCTION CONGRUENZA_SUP_UTIL_VITATA (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                       P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_ID_CONDUZIONE        DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
s_sezione            VARCHAR2(20);
s_sub            VARCHAR2(20);
N_ID_PARTICELLA     DB_PARTICELLA.ID_PARTICELLA%TYPE;
N_AREA                NUMBER(10,4);

CURSOR C_CONDUZIONI_A_VIGNETO IS
       SELECT cP.ID_PARTICELLA, C.DESCOM, SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA, SP.SUBALTERNO, SUM(UP.SUPERFICIE_UTILIZZATA) SUP_UTIL
         FROM DB_CONDUZIONE_PARTICELLA cp, DB_UTE u, DB_STORICO_PARTICELLA sp,
               COMUNE C, DB_UTILIZZO_PARTICELLA UP, DB_TIPO_UTILIZZO TUT, PROVINCIA P
        WHERE CP.data_fine_conduzione IS NULL
          AND cP.id_ute = U.id_ute
          AND U.id_azienda = p_id_azienda
          AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
          AND SP.DATA_FINE_VALIDITA IS NULL
          AND SP.COMUNE = C.ISTAT_COMUNE
          AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
          AND TUT.ID_INDIRIZZO_UTILIZZO = 20
          AND TUT.ANNO_FINE_VALIDITA IS NULL
          AND UP.ID_UTILIZZO = TUT.ID_UTILIZZO
          AND P.ISTAT_PROVINCIA = C.ISTAT_PROVINCIA
--          AND cp.ID_TITOLO_POSSESSO<>5
          AND cp.ID_TITOLO_POSSESSO NOT IN (5,6)
          AND P.ID_REGIONE = '01'
         GROUP BY cP.ID_PARTICELLA, C.DESCOM, SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA, SP.SUBALTERNO;

CURSOR C_UV IS
       SELECT SUA.ID_STORICO_UNITA_ARBOREA, SP.ID_STORICO_PARTICELLA
         FROM DB_STORICO_UNITA_ARBOREA  sua, DB_STORICO_PARTICELLA sp
        WHERE sua.id_particella = N_ID_PARTICELLA
          AND sua.id_azienda = P_ID_AZIENDA
          AND suA.DATA_FINE_VALIDITA IS NULL
          AND SP.ID_PARTICELLA = SUA.ID_PARTICELLA
          AND SP.DATA_FINE_VALIDITA IS NULL;

CURSOR C_CONDUZIONI IS
       SELECT CP.ID_CONDUZIONE_PARTICELLA
         FROM DB_CONDUZIONE_PARTICELLA cp, DB_UTE u
        WHERE CP.data_fine_conduzione IS NULL
          AND cP.id_ute = U.id_ute
          AND U.id_azienda = p_id_azienda
--          AND cp.ID_TITOLO_POSSESSO<>5
          AND cp.ID_TITOLO_POSSESSO NOT IN (5,6)
          AND CP.ID_PARTICELLA = N_ID_PARTICELLA
         GROUP BY CP.ID_CONDUZIONE_PARTICELLA;

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_CONDUZIONI_A_VIGNETO IN C_CONDUZIONI_A_VIGNETO LOOP
         SELECT DECODE(REC_CONDUZIONI_A_VIGNETO.SEZIONE, NULL, '', ' Sz: '|| REC_CONDUZIONI_A_VIGNETO.SEZIONE)
        INTO S_SEZIONE FROM DUAL;
        SELECT DECODE(REC_CONDUZIONI_A_VIGNETO.subalterno, NULL, '', ' Sub: '|| REC_CONDUZIONI_A_VIGNETO.SUBALTERNO)
        INTO s_sub FROM dual;

        BEGIN
            SELECT SUM(UA.AREA)
              INTO N_AREA
              FROM DB_STORICO_UNITA_ARBOREA UA
             WHERE UA.ID_PARTICELLA = REC_CONDUZIONI_A_VIGNETO.ID_PARTICELLA
               AND UA.ID_AZIENDA = P_ID_AZIENDA
               AND UA.DATA_FINE_VALIDITA IS NULL; --- SOLO LE UV ATTIVE
        EXCEPTION
        WHEN NO_DATA_FOUND THEN
             N_AREA := 0;
        WHEN OTHERS THEN
            p_MsgErr   := 'CONGRUENZA_SUP_UTIL_VITATA: ' || SQLERRM;
            p_CodErr   := SQLCODE;
            RETURN (FALSE);
        END;

        IF REC_CONDUZIONI_A_VIGNETO.SUP_UTIL <> N_AREA THEN
             S_DESCRIZIONE := '[' || REC_CONDUZIONI_A_VIGNETO.DESCOM || s_sezione || ' Fgl:' ||
                  REC_CONDUZIONI_A_VIGNETO.FOGLIO ||' Part:' || REC_CONDUZIONI_A_VIGNETO.PARTICELLA ||s_sub||
                 '] La somma delle superifici delle unità vitate che insistono sulla particella ' ||
                 TO_CHAR(N_AREA,'999G990D9999') || ' (ha)' || 'deve essere uguale alla sup.utilizzata a vigneto' ||
                 TO_CHAR(REC_CONDUZIONI_A_VIGNETO.SUP_UTIL,'999G990D9999') || ' (ha)';

         N_ID_PARTICELLA := REC_CONDUZIONI_A_VIGNETO.ID_PARTICELLA;

         FOR REC_CONDUZIONI IN C_CONDUZIONI LOOP
                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_CONDUZIONI.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
         END LOOP;

         FOR REC_UV IN C_UV LOOP
             IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                  P_BLOCCANTE, REC_UV.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
             END IF;
             IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_UV.ID_STORICO_PARTICELLA, REC_UV.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
             END IF;
         END LOOP;

        END IF;
     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'CONGRUENZA_SUP_UTIL_VITATA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONGRUENZA_SUP_UTIL_VITATA;

FUNCTION CONTROLLO_DATI_SCHEDARIO (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                       P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_ID_CONDUZIONE        DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
s_sezione            VARCHAR2(20);
s_sub            VARCHAR2(20);
N_ID_PARTICELLA     DB_PARTICELLA.ID_PARTICELLA%TYPE;
N_AREA                NUMBER(10,4);
N_ID_STORICO_UNITA_ARBOREA DB_STORICO_UNITA_ARBOREA.ID_STORICO_UNITA_ARBOREA%TYPE;
S_DESC_PROD            VARCHAR2(100);
S_DESC_VAR            VARCHAR2(100);

       CURSOR C_DATI_SCHEDARIO IS
       SELECT C.DESCOM, B.SEZIONE, B.FOGLIO, B.PARTICELLA, B.SUBALTERNO,
                 A.ID_UTILIZZO, A.ID_VARIETA, B.ID_PARTICELLA
        FROM DB_STORICO_UNITA_ARBOREA A, DB_STORICO_PARTICELLA  B, COMUNE C
        WHERE A.ID_AZIENDA = P_ID_AZIENDA
          AND A.DATA_FINE_VALIDITA IS NULL 
          AND A.ID_PARTICELLA = B.ID_PARTICELLA
          AND B.DATA_FINE_VALIDITA IS NULL
          AND C.ISTAT_COMUNE = B.COMUNE
          AND a.ID_PARTICELLA NOT IN (SELECT ID_PARTICELLA FROM DB_CONDUZIONE_PARTICELLA CP, DB_UTE U
                                        WHERE CP.ID_UTE = U.ID_UTE
                                      AND CP.DATA_FINE_CONDUZIONE IS NULL
                                      AND U.ID_AZIENDA = P_ID_AZIENDA
                                      AND U.DATA_FINE_ATTIVITA IS NULL)
       GROUP BY C.DESCOM, B.SEZIONE, B.FOGLIO, B.PARTICELLA, B.SUBALTERNO, A.ID_UTILIZZO, A.ID_VARIETA, B.ID_PARTICELLA;

       CURSOR C_UV IS
       SELECT SUA.ID_STORICO_UNITA_ARBOREA, SP.ID_STORICO_PARTICELLA
         FROM DB_STORICO_UNITA_ARBOREA  sua, DB_STORICO_PARTICELLA sp
        WHERE sua.id_particella = N_ID_PARTICELLA
          AND sua.id_azienda = P_ID_AZIENDA
          AND suA.DATA_FINE_VALIDITA IS NULL
          AND SP.ID_PARTICELLA = SUA.ID_PARTICELLA
          AND SP.DATA_FINE_VALIDITA IS NULL;

BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_DATI_SCHEDARIO IN C_DATI_SCHEDARIO LOOP
          SELECT DECODE(REC_DATI_SCHEDARIO.SEZIONE, NULL, '', ' Sz: '|| REC_DATI_SCHEDARIO.SEZIONE)
        INTO S_SEZIONE FROM DUAL;
        SELECT DECODE(REC_DATI_SCHEDARIO.subalterno, NULL, '', ' Sub: '|| REC_DATI_SCHEDARIO.SUBALTERNO)
        INTO s_sub FROM dual;

        BEGIN
            SELECT ' Dest. Prod.: [' || CODICE || '] '|| DESCRIZIONE INTO S_DESC_PROD
            FROM DB_TIPO_UTILIZZO WHERE ID_UTILIZZO = REC_DATI_SCHEDARIO.ID_UTILIZZO;
        EXCEPTION
        WHEN NO_DATA_FOUND THEN
             S_DESC_PROD := NULL;
        END;
        BEGIN
            SELECT ' Vit. [' || CODICE_VARIETA || '] '|| DESCRIZIONE INTO S_DESC_VAR
            FROM DB_TIPO_VARIETA WHERE ID_UTILIZZO = REC_DATI_SCHEDARIO.ID_UTILIZZO
            AND ID_VARIETA = REC_DATI_SCHEDARIO.ID_VARIETA;
        EXCEPTION
        WHEN NO_DATA_FOUND THEN
             S_DESC_VAR := NULL;
        END;


         S_DESCRIZIONE := 'A schedario è presente l''unita vitata [' || REC_DATI_SCHEDARIO.DESCOM || s_sezione || ' Fgl:' ||
         REC_DATI_SCHEDARIO.FOGLIO ||' Part:' || REC_DATI_SCHEDARIO.PARTICELLA ||s_sub||']'||
         TRIM (S_DESC_PROD) ||TRIM (S_DESC_VAR) ||' la cui particella non risulta in conduzione all''azienda';
         N_ID_PARTICELLA := REC_DATI_SCHEDARIO.ID_PARTICELLA;

         FOR REC_UV IN C_UV LOOP
             IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                  P_BLOCCANTE, REC_UV.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
             END IF;
             IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_UV.ID_STORICO_PARTICELLA, REC_UV.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
             END IF;
         END LOOP;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'CONTROLLO_DATI_SCHEDARIO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CONTROLLO_DATI_SCHEDARIO;

FUNCTION COMPLETEZZA_SCHEDA_AGRONOMICA (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                       P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_ID_CONDUZIONE        DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
s_sezione            VARCHAR2(20);
s_sub            VARCHAR2(20);
N_ID_PARTICELLA     DB_PARTICELLA.ID_PARTICELLA%TYPE;
N_AREA                NUMBER(10,4);
N_ID_STORICO_UNITA_ARBOREA DB_STORICO_UNITA_ARBOREA.ID_STORICO_UNITA_ARBOREA%TYPE;

CURSOR C_UNITA_ARBOREE_INCOMPLETE IS
       SELECT CP.ID_CONDUZIONE_PARTICELLA, UA.ID_STORICO_UNITA_ARBOREA, C.DESCOM, SP.SEZIONE, SP.FOGLIO,
                 SP.PARTICELLA, SP.SUBALTERNO, SP.ID_STORICO_PARTICELLA
         FROM DB_CONDUZIONE_PARTICELLA cp, DB_UTE u, DB_STORICO_UNITA_ARBOREA UA, DB_STORICO_PARTICELLA SP,
               COMUNE C
        WHERE CP.data_fine_conduzione IS NULL
          AND cP.id_ute = U.id_ute
          AND U.id_azienda = p_id_azienda
          AND CP.ID_PARTICELLA = UA.ID_PARTICELLA
          AND UA.ID_AZIENDA = P_ID_AZIENDA
          AND UA.DATA_FINE_VALIDITA IS NULL
          AND (NVL(UA.SESTO_SU_FILA,0) = 0
           OR  NVL(UA.SESTO_TRA_FILE,0) = 0
           OR  NVL(UA.NUM_CEPPI,0) = 0
           OR NVL(UA.ID_FORMA_ALLEVAMENTO,0) = 0)
          AND SP.ID_PARTICELLA = CP.ID_PARTICELLA
          AND SP.DATA_FINE_VALIDITA IS NULL
          AND SP.COMUNE = C.ISTAT_COMUNE
--          AND cp.ID_TITOLO_POSSESSO<>5
          AND cp.ID_TITOLO_POSSESSO NOT IN (5,6)
         GROUP BY CP.ID_CONDUZIONE_PARTICELLA, UA.ID_STORICO_UNITA_ARBOREA, C.DESCOM, SP.SEZIONE, SP.FOGLIO,
                 SP.PARTICELLA, SP.SUBALTERNO, SP.ID_STORICO_PARTICELLA
         ORDER BY UA.ID_STORICO_UNITA_ARBOREA;


BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_UNITA_ARBOREE_INCOMPLETE IN C_UNITA_ARBOREE_INCOMPLETE LOOP
           SELECT DECODE(REC_UNITA_ARBOREE_INCOMPLETE.SEZIONE, NULL, '', ' Sz: '|| REC_UNITA_ARBOREE_INCOMPLETE.SEZIONE)
        INTO S_SEZIONE FROM DUAL;
        SELECT DECODE(REC_UNITA_ARBOREE_INCOMPLETE.subalterno, NULL, '', ' Sub: '|| REC_UNITA_ARBOREE_INCOMPLETE.SUBALTERNO)
        INTO s_sub FROM dual;

         S_DESCRIZIONE := '[' || REC_UNITA_ARBOREE_INCOMPLETE.DESCOM || s_sezione || ' Fgl:' ||
                  REC_UNITA_ARBOREE_INCOMPLETE.FOGLIO ||' Part:' || REC_UNITA_ARBOREE_INCOMPLETE.PARTICELLA ||s_sub||
                 '] I dati della scheda agronomica non sono completi';

            IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, REC_UNITA_ARBOREE_INCOMPLETE.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;

          IF N_ID_STORICO_UNITA_ARBOREA IS NULL OR
               N_ID_STORICO_UNITA_ARBOREA <> REC_UNITA_ARBOREE_INCOMPLETE.ID_STORICO_UNITA_ARBOREA THEN
              IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_UNITA_ARBOREE_INCOMPLETE.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_UNITA_ARBOREE_INCOMPLETE.ID_STORICO_PARTICELLA, REC_UNITA_ARBOREE_INCOMPLETE.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
          END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'COMPLETEZZA_SCHEDA_AGRONOMICA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END COMPLETEZZA_SCHEDA_AGRONOMICA;

FUNCTION SCHEDA_AGRONOMICA_ERRATA (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                   P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                   P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                   P_MSGERR       IN OUT VARCHAR2,
                                                   P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_ID_CONDUZIONE        DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
s_sezione            VARCHAR2(20);
s_sub            VARCHAR2(20);
N_ID_PARTICELLA     DB_PARTICELLA.ID_PARTICELLA%TYPE;
N_AREA                NUMBER(10,4);
N_ID_STORICO_UNITA_ARBOREA DB_STORICO_UNITA_ARBOREA.ID_STORICO_UNITA_ARBOREA%TYPE;

CURSOR C_UNITA_ARBOREE_INCOMPLETE IS
       SELECT CP.ID_CONDUZIONE_PARTICELLA, UA.ID_STORICO_UNITA_ARBOREA, C.DESCOM, SP.SEZIONE, SP.FOGLIO,
                 SP.PARTICELLA, SP.SUBALTERNO, SP.ID_STORICO_PARTICELLA
         FROM DB_CONDUZIONE_PARTICELLA cp, DB_UTE u, DB_STORICO_UNITA_ARBOREA UA, DB_STORICO_PARTICELLA SP,
               COMUNE C
        WHERE CP.data_fine_conduzione IS NULL
          AND cP.id_ute = U.id_ute
          AND U.id_azienda = p_id_azienda
          AND CP.ID_PARTICELLA = UA.ID_PARTICELLA
           AND UA.ID_AZIENDA = P_ID_AZIENDA
          AND UA.DATA_FINE_VALIDITA IS NULL
          AND (NVL(UA.AREA,0) = 0
           OR  NVL(UA.ID_UTILIZZO,0) = 0
           OR  NVL(UA.ID_VARIETA,0) = 0
           OR  NVL(UA.ANNO_IMPIANTO,1000) <= 1000
           OR  NVL(UA.ANNO_RIFERIMENTO,0) = 0)
          AND SP.ID_PARTICELLA = CP.ID_PARTICELLA
          AND SP.DATA_FINE_VALIDITA IS NULL
          AND cp.ID_TITOLO_POSSESSO NOT IN (5,6)
          AND SP.COMUNE = C.ISTAT_COMUNE
         GROUP BY CP.ID_CONDUZIONE_PARTICELLA, UA.ID_STORICO_UNITA_ARBOREA, C.DESCOM, SP.SEZIONE, SP.FOGLIO,
                 SP.PARTICELLA, SP.SUBALTERNO, SP.ID_STORICO_PARTICELLA
         ORDER BY UA.ID_STORICO_UNITA_ARBOREA;


BEGIN
     S_DESCRIZIONE := NULL;

     FOR REC_UNITA_ARBOREE_INCOMPLETE IN C_UNITA_ARBOREE_INCOMPLETE LOOP
           SELECT DECODE(REC_UNITA_ARBOREE_INCOMPLETE.SEZIONE, NULL, '', ' Sz: '|| REC_UNITA_ARBOREE_INCOMPLETE.SEZIONE)
        INTO S_SEZIONE FROM DUAL;
        SELECT DECODE(REC_UNITA_ARBOREE_INCOMPLETE.subalterno, NULL, '', ' Sub: '|| REC_UNITA_ARBOREE_INCOMPLETE.SUBALTERNO)
        INTO s_sub FROM dual;

         S_DESCRIZIONE := '[' || REC_UNITA_ARBOREE_INCOMPLETE.DESCOM || s_sezione || ' Fgl:' ||
                  REC_UNITA_ARBOREE_INCOMPLETE.FOGLIO ||' Part:' || REC_UNITA_ARBOREE_INCOMPLETE.PARTICELLA ||s_sub||
                 '] I dati della scheda agronomica (anno, sup.vit, dest.prod., vitigno) sono errati o non valorizzati';


            IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, REC_UNITA_ARBOREE_INCOMPLETE.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;

          IF N_ID_STORICO_UNITA_ARBOREA IS NULL OR
               N_ID_STORICO_UNITA_ARBOREA <> REC_UNITA_ARBOREE_INCOMPLETE.ID_STORICO_UNITA_ARBOREA THEN
              IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_UNITA_ARBOREE_INCOMPLETE.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_UNITA_ARBOREE_INCOMPLETE.ID_STORICO_PARTICELLA, REC_UNITA_ARBOREE_INCOMPLETE.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
          END IF;

     END LOOP;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'SCHEDA_AGRONOMICA_ERRATA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END SCHEDA_AGRONOMICA_ERRATA;

FUNCTION INCOERENZA_SUP_FABBRICATO (P_ID_AZIENDA   IN       DB_AZIENDA.ID_AZIENDA%TYPE,
                                    P_ID_CONTROLLO IN       DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                    P_BLOCCANTE       IN       DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                    P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE            DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_TOTALE_SUP_FABBRICATO DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
N_TOTALE_SUP_UTILIZZATA DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;

BEGIN
     S_DESCRIZIONE := NULL;

    SELECT SUM(SUPERFICIE)
    INTO   N_TOTALE_SUP_FABBRICATO
    FROM   DB_FABBRICATO A, DB_UTE B
    WHERE  A.ID_UTE = B.ID_UTE
      AND  A.DATA_FINE_VALIDITA IS NULL
      AND  B.ID_AZIENDA = P_ID_AZIENDA
      AND  A.ID_TIPOLOGIA_FABBRICATO <> 5; ---SERRE

    N_TOTALE_SUP_FABBRICATO := N_TOTALE_SUP_FABBRICATO / 10000;
     --somma della superficie utilizzata di tutte le particelle legate all'azienda con
     --utilizzo a fabbricato
     SELECT SUM(SUPERFICIE_UTILIZZATA)
     INTO    N_TOTALE_SUP_UTILIZZATA
     FROM DB_UTE A, DB_CONDUZIONE_PARTICELLA B, DB_UTILIZZO_PARTICELLA C,
           DB_STORICO_PARTICELLA E, DB_TIPO_UTILIZZO F
     WHERE A.ID_UTE = B.ID_UTE
       AND A.ID_AZIENDA = P_ID_AZIENDA
       AND B.DATA_FINE_CONDUZIONE IS NULL
       AND B.ID_PARTICELLA = E.ID_PARTICELLA
       AND E.DATA_FINE_VALIDITA IS NULL
       AND B.ID_CONDUZIONE_PARTICELLA = C.ID_CONDUZIONE_PARTICELLA
       AND F.ID_UTILIZZO = C.ID_UTILIZZO
       AND F.ANNO_FINE_VALIDITA IS NULL
       AND F.TIPO = 'F';        ---FABBRICATO

     IF NVL(N_TOTALE_SUP_UTILIZZATA,0) <> NVL(N_TOTALE_SUP_FABBRICATO,0) AND
         NVL(N_TOTALE_SUP_FABBRICATO,0) > 0 THEN
         S_DESCRIZIONE := 'La somma delle superfici dei Fabbricati ( ' ||
                      TRIM(TO_CHAR(NVL(N_TOTALE_SUP_FABBRICATO,0),'999G990D9999')) ||
                      'ha) è diversa dalla somma delle superfici con utilizzo a Fabbricato ( '||
                      TRIM(TO_CHAR(NVL(N_TOTALE_SUP_UTILIZZATA,0),'999G990D9999')) || ' ha) ';
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
           P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE INCOERENZA_SUP_FABBRICATO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END INCOERENZA_SUP_FABBRICATO;



FUNCTION PRESENZA_CONTO_CORRENTE (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                 P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                 P_MSGERR       IN OUT VARCHAR2,
                                P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
S_NUMERO             NUMBER;

BEGIN
     S_DESCRIZIONE := NULL;
    SELECT COUNT(*)
    INTO  S_NUMERO
    FROM DB_CONTO_CORRENTE
    WHERE ID_AZIENDA=P_ID_AZIENDA
    AND DATA_ESTINZIONE IS NULL;

    S_DESCRIZIONE := 'Non è stato dichiarato un conto corrente per il pagamento';

    IF S_NUMERO = 0 THEN
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
             P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
        END IF;
    END IF;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE PRESENZA_CONTO_CORRENTE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END PRESENZA_CONTO_CORRENTE;

FUNCTION INTESTATARIO_CONTO_CORRENTE (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                 P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                P_BLOCCANTE       IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                 P_MSGERR       IN OUT VARCHAR2,
                                P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
CURSOR C_CONTI_CORRENTI IS
    SELECT TRIM(A.INTESTAZIONE) INTESTAZIONE, TRIM(B.DENOMINAZIONE) DENOMINAZIONE, A.BBAN
    FROM DB_CONTO_CORRENTE A, DB_ANAGRAFICA_AZIENDA B
    WHERE A.ID_AZIENDA=P_ID_AZIENDA
    AND A.ID_AZIENDA = B.ID_AZIENDA
    AND B.DATA_FINE_VALIDITA IS NULL
    AND A.DATA_ESTINZIONE IS NULL
    AND A.DATA_FINE_VALIDITA IS NULL;

BEGIN
     FOR REC_CONTI_CORRENTI IN C_CONTI_CORRENTI LOOP
          S_DESCRIZIONE := NULL;
          IF REC_CONTI_CORRENTI.INTESTAZIONE <> REC_CONTI_CORRENTI.DENOMINAZIONE THEN
             S_DESCRIZIONE := 'C/C N.' || REC_CONTI_CORRENTI.BBAN ||
            ': l''intestatario del conto non coincide con la denominazione dell''azienda';
             IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                 P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
            END IF;
         END IF;
     END LOOP;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE PRESENZA_CONTO_CORRENTE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END INTESTATARIO_CONTO_CORRENTE;

/* controlla che esista un documento di identità valido */
FUNCTION PRESENZA_CARTA_IDENTITA (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                   P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                  P_BLOCCANTE     IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                   P_MSGERR       IN OUT VARCHAR2,
                                  P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_NUMERO             NUMBER;

BEGIN
    S_DESCRIZIONE := NULL;
    n_NUMERO       := 0;

    SELECT COUNT(*)
    INTO  N_NUMERO
    FROM DB_DOCUMENTO
    WHERE ID_AZIENDA= P_ID_AZIENDA
--      AND TO_CHAR(NVL(DATA_FINE_VALIDITA,to_date('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') > TO_CHAR(sysdate,'YYYYMMDD')
    AND (     (            ID_STATO_DOCUMENTO IS NULL
                    AND    dDataConfCorrettiva     IS NULL
                )
            OR    (            DATA_INIZIO_VALIDITA <=    dDataConfCorrettiva
                     AND    dDataConfCorrettiva IS NOT NULL
                    AND    NVL(DATA_FINE_VALIDITA,dDataConfCorrettiva) >= dDataConfCorrettiva
                )
            )
--                        AND    ID_STATO_DOCUMENTO IS NULL
      AND (EXT_ID_DOCUMENTO = 149 OR EXT_ID_DOCUMENTO = 150 OR EXT_ID_DOCUMENTO = 151
          OR EXT_ID_DOCUMENTO = 18 OR EXT_ID_DOCUMENTO = 19 OR EXT_ID_DOCUMENTO = 59  OR EXT_ID_DOCUMENTO = 87
        OR EXT_ID_DOCUMENTO = 153 OR EXT_ID_DOCUMENTO = 154 OR EXT_ID_DOCUMENTO = 155  OR EXT_ID_DOCUMENTO = 156 --CARTA IDENTITA, PASSAPORTO PATENTE
        OR  EXT_ID_DOCUMENTO = 472 OR EXT_ID_DOCUMENTO = 473 OR EXT_ID_DOCUMENTO = 474); -- rc 20/07/2016

    S_DESCRIZIONE := 'Non risulta associato all''azienda un documento di identità. Documenti associabili:'||
    '1) Doc.identità - carta d''identità - 2) Doc.identità - passaporto - 3) Doc.identità - patente di guida rilasciata dalla Prefettura';

    IF N_NUMERO = 0 THEN
        VAR_PRESENZA_DOC_IDENTITA:=FALSE;
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
             P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
        END IF;
    ELSE
        VAR_PRESENZA_DOC_IDENTITA :=TRUE;
    END IF;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE PRESENZA_CARTA_IDENTITA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END PRESENZA_CARTA_IDENTITA;

/* controlla che esista un documento di identità valido */
FUNCTION VALIDITA_CARTA_IDENTITA (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                   P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                  P_BLOCCANTE     IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                   P_MSGERR       IN OUT VARCHAR2,
                                  P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
--S_DESCRIZIONE_BIS    DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_NUMERO             NUMBER;
N_NUMERO_BIS        NUMBER;
N_NUMERO_ALL        NUMBER;


BEGIN
    S_DESCRIZIONE := NULL;
    n_NUMERO       := 0;

    /* cerco nei 3 attivi */
    SELECT COUNT(1)
    INTO  N_NUMERO
    FROM DB_DOCUMENTO
    WHERE ID_AZIENDA= P_ID_AZIENDA
   AND (     (            ID_STATO_DOCUMENTO IS NULL
                AND TRUNC(NVL(DATA_FINE_VALIDITA,SYSDATE)) >= TRUNC(SYSDATE)
                AND    dDataConfCorrettiva     IS NULL
            )
        OR    (            DATA_INIZIO_VALIDITA <=    dDataConfCorrettiva
                 AND    dDataConfCorrettiva IS NOT NULL
                AND    NVL(DATA_FINE_VALIDITA,dDataConfCorrettiva) >= dDataConfCorrettiva
            )
        )
--        AND    ID_STATO_DOCUMENTO IS NULL
---    AND     TRUNC(NVL(DATA_FINE_VALIDITA,SYSDATE)) >= TRUNC(SYSDATE)
      AND ID_STATO_DOCUMENTO IS NULL
      AND (EXT_ID_DOCUMENTO = 149 OR EXT_ID_DOCUMENTO = 150 OR EXT_ID_DOCUMENTO = 151 --CARTA IDENTITA, PASSAPORTO PATENTE
           OR EXT_ID_DOCUMENTO = 472 OR EXT_ID_DOCUMENTO = 473 OR EXT_ID_DOCUMENTO = 474); -- rc 20/07/2016

    S_DESCRIZIONE := 'Non risulta presente un documento di identità valido. Documenti associabili:'||
    '1) Doc.identità - carta d''identità - 2) Doc.identità - passaporto - 3) Doc.identità - patente di guida rilasciata dalla Prefettura';


    IF N_NUMERO=0 THEN

        /* cerco negli altri 8 attivi */
        SELECT COUNT(*)
        INTO  N_NUMERO_BIS
        FROM DB_DOCUMENTO
        WHERE ID_AZIENDA= P_ID_AZIENDA
       AND (     (            ID_STATO_DOCUMENTO IS NULL
                    AND TRUNC(NVL(DATA_FINE_VALIDITA,SYSDATE)) >= TRUNC(SYSDATE)
                    AND    dDataConfCorrettiva     IS NULL
                )
            OR    (            DATA_INIZIO_VALIDITA <=    dDataConfCorrettiva
                     AND    dDataConfCorrettiva IS NOT NULL
                    AND    NVL(DATA_FINE_VALIDITA,dDataConfCorrettiva) >= dDataConfCorrettiva
                )
            )
--          AND TRUNC(NVL(DATA_FINE_VALIDITA,SYSDATE)) >= TRUNC(SYSDATE)
--          AND ID_STATO_DOCUMENTO IS NULL
          AND (EXT_ID_DOCUMENTO = 153 OR EXT_ID_DOCUMENTO = 154 OR EXT_ID_DOCUMENTO = 155 OR EXT_ID_DOCUMENTO = 156
               OR EXT_ID_DOCUMENTO = 18 OR EXT_ID_DOCUMENTO = 19 OR EXT_ID_DOCUMENTO = 59  OR EXT_ID_DOCUMENTO = 87);


        IF N_NUMERO_BIS=0 THEN

            /* cerco se i primi 3 esistono, attivi o meno */
            SELECT COUNT(1)
            INTO  N_NUMERO_ALL
            FROM DB_DOCUMENTO
            WHERE ID_AZIENDA= P_ID_AZIENDA
           AND     (
                        (            ID_STATO_DOCUMENTO IS NULL
                            AND    dDataConfCorrettiva     IS NULL
                        )
                    OR    (            DATA_INIZIO_VALIDITA >=    dDataConfCorrettiva
                             AND    dDataConfCorrettiva IS NOT NULL
                        )
                    )
--              AND ID_STATO_DOCUMENTO IS NULL
              AND (EXT_ID_DOCUMENTO = 149 OR EXT_ID_DOCUMENTO = 150 OR EXT_ID_DOCUMENTO = 151);

            IF N_NUMERO_ALL > 0 THEN
               /* esistono */
                -- DOC18
                IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                     P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                END IF;
            ELSE
                /* non esistono */
                -- DOC19
                IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, 498 /* DOC19 */, S_DESCRIZIONE,
                     P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                END IF;
            END IF;

        END IF;
    END IF;

    RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE VALIDITA_CARTA_IDENTITA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END VALIDITA_CARTA_IDENTITA;

FUNCTION PRESENZA_ESTREMI_DOC_IDENTITA (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                   P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                  P_BLOCCANTE     IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                   P_MSGERR       IN OUT VARCHAR2,
                                  P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_NUMERO             NUMBER;

BEGIN
    S_DESCRIZIONE := NULL;
    n_NUMERO       := 0;

    /* cerco nei 3 attivi */
    SELECT COUNT(1)
    INTO  N_NUMERO
    FROM DB_DOCUMENTO D
    WHERE ID_AZIENDA= P_ID_AZIENDA
      AND TRUNC(NVL(DATA_FINE_VALIDITA,SYSDATE)) >= TRUNC(SYSDATE)
      AND ID_STATO_DOCUMENTO IS NULL
      AND (EXT_ID_DOCUMENTO = 149 OR EXT_ID_DOCUMENTO = 150 OR EXT_ID_DOCUMENTO = 151 OR --CARTA IDENTITA, PASSAPORTO PATENTE
             EXT_ID_DOCUMENTO = 153 OR EXT_ID_DOCUMENTO = 154 OR EXT_ID_DOCUMENTO = 155 OR EXT_ID_DOCUMENTO = 156 OR
              EXT_ID_DOCUMENTO = 18 OR EXT_ID_DOCUMENTO = 19 OR EXT_ID_DOCUMENTO = 59  OR EXT_ID_DOCUMENTO = 87
              OR EXT_ID_DOCUMENTO = 472 OR EXT_ID_DOCUMENTO = 473 OR EXT_ID_DOCUMENTO = 474 ) -- rc 20/07/2016
      AND (D.NUMERO_DOCUMENTO IS NULL OR D.ENTE_RILASCIO_DOCUMENTO IS NULL);

    IF N_NUMERO > 0 THEN
       S_DESCRIZIONE := 'Il numero e l''ente di rilascio sono informazioni obbligatorie per i documenti di identità';

       IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL,
                   P_MSGERR, P_CODERR) THEN
          RETURN (FALSE);
       END IF;
    END IF;

    RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE PRESENZA_ESTREMI_DOC_IDENTITA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END PRESENZA_ESTREMI_DOC_IDENTITA;

FUNCTION DOCUMENTI_CONDUZIONI_SCADUTE (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                         P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        P_BLOCCANTE     IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                         P_MSGERR       IN OUT VARCHAR2,
                                        P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
s_sezione            VARCHAR2(20);
s_sub                VARCHAR2(20);

CURSOR C_CONDUZIONE_DOCUMENTO IS
    SELECT D.DESCRIZIONE, a.NUMERO_PROTOCOLLO, A.DATA_PROTOCOLLO, b.ID_CONDUZIONE_PARTICELLA,
           E.DESCRIZIONE AS CONDUZIONE, G.DESCOM, F.SEZIONE, F.FOGLIO, F.PARTICELLA, F.SUBALTERNO, a.ID_DOCUMENTO
    FROM DB_DOCUMENTO A, DB_DOCUMENTO_CONDUZIONE B, DB_CONDUZIONE_PARTICELLA C, DB_TIPO_DOCUMENTO D,
         DB_TIPO_TITOLO_POSSESSO E, DB_STORICO_PARTICELLA F, COMUNE G
    WHERE A.ID_AZIENDA= P_ID_AZIENDA
      AND TO_CHAR(NVL(A.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') > TO_CHAR(SYSDATE,'YYYYMMDD')
      AND A.ID_DOCUMENTO = B.ID_DOCUMENTO
      AND B.ID_CONDUZIONE_PARTICELLA = C.ID_CONDUZIONE_PARTICELLA
      AND C.DATA_FINE_CONDUZIONE IS NOT NULL
      AND D.ID_DOCUMENTO = A.EXT_ID_DOCUMENTO
      AND E.ID_TITOLO_POSSESSO = C.ID_TITOLO_POSSESSO
      AND F.ID_PARTICELLA = C.ID_PARTICELLA
      AND F.DATA_FINE_VALIDITA IS NULL
      AND G.ISTAT_COMUNE = F.COMUNE
      AND A.ID_STATO_DOCUMENTO IS NULL
      AND TO_CHAR(NVL(B.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') > TO_CHAR(SYSDATE,'YYYYMMDD')
      ORDER BY G.DESCOM, F.SEZIONE, F.FOGLIO, F.PARTICELLA, F.SUBALTERNO;


BEGIN
    S_DESCRIZIONE := NULL;
    FOR REC_CONDUZIONE_DOCUMENTO IN C_CONDUZIONE_DOCUMENTO LOOP
         SELECT DECODE(REC_CONDUZIONE_DOCUMENTO.SEZIONE, NULL, '', ' Sz: '|| REC_CONDUZIONE_DOCUMENTO.SEZIONE)
        INTO S_SEZIONE FROM DUAL;
        SELECT DECODE(REC_CONDUZIONE_DOCUMENTO.subalterno, NULL, '', ' Sub: '|| REC_CONDUZIONE_DOCUMENTO.SUBALTERNO)
        INTO s_sub FROM dual;
           S_DESCRIZIONE := 'Il documento: '|| REC_CONDUZIONE_DOCUMENTO.DESCRIZIONE ||
                         ' Prot.'|| REC_CONDUZIONE_DOCUMENTO.NUMERO_PROTOCOLLO|| ' del ' || TO_CHAR(REC_CONDUZIONE_DOCUMENTO.DATA_PROTOCOLLO,'DD/MM/YYYY')||
                         ' è legato alla conduzione scaduta ' ||REC_CONDUZIONE_DOCUMENTO.DESCOM || s_sezione ||
                        ' Fgl:' || REC_CONDUZIONE_DOCUMENTO.FOGLIO ||' Part:'||REC_CONDUZIONE_DOCUMENTO.PARTICELLA ||
                     s_sub || ']'||' ('|| REC_CONDUZIONE_DOCUMENTO.CONDUZIONE||');';

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                 P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
        END IF;
        /* documento */
        IF NOT SCRIVI_SEGNALAZIONE_DOCUMENTO (P_ID_CONTROLLO, S_DESCRIZIONE,
                 P_BLOCCANTE, REC_CONDUZIONE_DOCUMENTO.ID_DOCUMENTO, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
        END IF;
        S_DESCRIZIONE := ' Conduzione ancora legata al documento attivo '|| REC_CONDUZIONE_DOCUMENTO.DESCRIZIONE ||
                         ' Prot.'|| REC_CONDUZIONE_DOCUMENTO.NUMERO_PROTOCOLLO|| ' del ' || TO_CHAR(REC_CONDUZIONE_DOCUMENTO.DATA_PROTOCOLLO,'DD/MM/YYYY');
        IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, REC_CONDUZIONE_DOCUMENTO.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
        END IF;


    END LOOP;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE DOCUMENTI_CONDUZIONI_SCADUTE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END DOCUMENTI_CONDUZIONI_SCADUTE;

FUNCTION DOCUMENTI_PARTICELLA_DOPPIA (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                         P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        P_BLOCCANTE     IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                         P_MSGERR       IN OUT VARCHAR2,
                                        P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_NUMERO             NUMBER;
N_ID_CONDUZIONE_PARTICELLA DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
s_sezione            VARCHAR2(20);
s_sub                VARCHAR2(20);

CURSOR C_CONDUZIONE_DOCUMENTO IS
    SELECT D.DESCRIZIONE, a.NUMERO_PROTOCOLLO, A.DATA_PROTOCOLLO,
           E.DESCRIZIONE AS CONDUZIONE, G.DESCOM, F.SEZIONE, F.FOGLIO, F.PARTICELLA, F.SUBALTERNO, A.ID_DOCUMENTO
    FROM DB_DOCUMENTO A, DB_DOCUMENTO_CONDUZIONE B, DB_CONDUZIONE_PARTICELLA C, DB_TIPO_DOCUMENTO D,
         DB_TIPO_TITOLO_POSSESSO E, DB_STORICO_PARTICELLA F, COMUNE G
    WHERE A.ID_AZIENDA= P_ID_AZIENDA
      AND TO_CHAR(NVL(A.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') > TO_CHAR(SYSDATE,'YYYYMMDD')
      AND A.ID_DOCUMENTO = B.ID_DOCUMENTO
      AND B.ID_CONDUZIONE_PARTICELLA = C.ID_CONDUZIONE_PARTICELLA
      AND C.DATA_FINE_CONDUZIONE IS NULL
      AND D.ID_DOCUMENTO = A.EXT_ID_DOCUMENTO
      AND E.ID_TITOLO_POSSESSO = C.ID_TITOLO_POSSESSO
      AND F.ID_PARTICELLA = C.ID_PARTICELLA
      AND F.DATA_FINE_VALIDITA IS NULL
      AND G.ISTAT_COMUNE = F.COMUNE
      AND B.ID_CONDUZIONE_PARTICELLA = N_ID_CONDUZIONE_PARTICELLA
      AND A.ID_STATO_DOCUMENTO IS NULL
      AND TO_CHAR(NVL(B.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') > TO_CHAR(SYSDATE,'YYYYMMDD')
      ORDER BY G.DESCOM, F.SEZIONE, F.FOGLIO, F.PARTICELLA, F.SUBALTERNO;

CURSOR C_CONDUZIONE_DOPPIA IS
    SELECT A.EXT_ID_DOCUMENTO, B.ID_CONDUZIONE_PARTICELLA, COUNT(*)
    FROM DB_DOCUMENTO A, DB_DOCUMENTO_CONDUZIONE B
    WHERE A.ID_AZIENDA= P_ID_AZIENDA
      AND NVL(A.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')) > SYSDATE
      AND A.ID_DOCUMENTO = B.ID_DOCUMENTO
      AND A.ID_STATO_DOCUMENTO IS NULL
        AND TO_CHAR(NVL(B.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') > TO_CHAR(SYSDATE,'YYYYMMDD')
    GROUP BY A.EXT_ID_DOCUMENTO, B.ID_CONDUZIONE_PARTICELLA
    HAVING COUNT(*) > 1;
BEGIN
    S_DESCRIZIONE := NULL;

    FOR REC_CONDUZIONE_DOPPIA IN C_CONDUZIONE_DOPPIA LOOP
        N_ID_CONDUZIONE_PARTICELLA := REC_CONDUZIONE_DOPPIA.ID_CONDUZIONE_PARTICELLA;
        FOR REC_CONDUZIONE_DOCUMENTO IN C_CONDUZIONE_DOCUMENTO LOOP
         SELECT DECODE(REC_CONDUZIONE_DOCUMENTO.SEZIONE, NULL, '', ' Sz: '|| REC_CONDUZIONE_DOCUMENTO.SEZIONE)
        INTO S_SEZIONE FROM DUAL;
        SELECT DECODE(REC_CONDUZIONE_DOCUMENTO.subalterno, NULL, '', ' Sub: '|| REC_CONDUZIONE_DOCUMENTO.SUBALTERNO)
        INTO s_sub FROM dual;
           S_DESCRIZIONE := 'La particella ' ||REC_CONDUZIONE_DOCUMENTO.DESCOM || s_sezione ||
                        ' Fgl:' || REC_CONDUZIONE_DOCUMENTO.FOGLIO ||' Part:'||REC_CONDUZIONE_DOCUMENTO.PARTICELLA ||
                     s_sub || ' è legata al documento '|| REC_CONDUZIONE_DOCUMENTO.DESCRIZIONE ||
                     ' Prot.'|| REC_CONDUZIONE_DOCUMENTO.NUMERO_PROTOCOLLO|| ' del ' || TO_CHAR(REC_CONDUZIONE_DOCUMENTO.DATA_PROTOCOLLO,'DD/MM/YYYY');

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                     P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
            END IF;
            /* documento */
            IF NOT SCRIVI_SEGNALAZIONE_DOCUMENTO (P_ID_CONTROLLO, S_DESCRIZIONE,
                     P_BLOCCANTE, REC_CONDUZIONE_DOCUMENTO.ID_DOCUMENTO, P_MSGERR, P_CODERR) THEN
                      RETURN (FALSE);
            END IF;
            S_DESCRIZIONE := 'Particella legata al documento '|| REC_CONDUZIONE_DOCUMENTO.DESCRIZIONE ||
                             ' Prot.'|| REC_CONDUZIONE_DOCUMENTO.NUMERO_PROTOCOLLO|| ' del ' || TO_CHAR(REC_CONDUZIONE_DOCUMENTO.DATA_PROTOCOLLO,'DD/MM/YYYY');
            IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, N_ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
            END IF;
        END LOOP;
    END LOOP;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE DOCUMENTI_PARTICELLA_DOPPIA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END DOCUMENTI_PARTICELLA_DOPPIA;

-- Verifica che sia presente una solo documento di istanza di riesame per particella
-- in un arco temporale parametrizzabile come gg/mm + anno(sysdate) x inizio - fine
FUNCTION PART_CON_DOC_RIESAME_MULTIPLI (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                        P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        P_BLOCCANTE    IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                        P_MSGERR       IN      OUT VARCHAR2,
                                        P_CODERR       IN      OUT VARCHAR2) RETURN BOOLEAN IS

    S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

    CURSOR curParticellaConDocRiesameMult IS
    SELECT CP.ID_PARTICELLA ,
           TD.ID_DOCUMENTO, 
           TD.DESCRIZIONE,  -- non raggruppo più per categoria documento ma x tipo documento e descrizione
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           C.DESCOM,
           TO_CHAR(A.DATA_INSERIMENTO,'YYYY') AS ANNO_DOCUMENTO,
           COUNT(DISTINCT(A.ID_DOCUMENTO)) AS QUANTI
      FROM DB_DOCUMENTO A,
           DB_DOCUMENTO_CONDUZIONE B,
           DB_CONDUZIONE_PARTICELLA CP,
           DB_STORICO_PARTICELLA SP,
           DB_PARTICELLA P, 
           COMUNE C,
           DB_TIPO_CATEGORIA_DOCUMENTO TCD,
           DB_DOCUMENTO_CATEGORIA DCT,
           DB_TIPO_DOCUMENTO TD
     WHERE TCD.IDENTIFICATIVO = knIdentificativoDocRiesame
       AND TCD.TIPO_IDENTIFICATIVO = 'TC'
       AND TCD.ID_CATEGORIA_DOCUMENTO = DCT.ID_CATEGORIA_DOCUMENTO
       AND DCT.ID_DOCUMENTO = TD.ID_DOCUMENTO
       AND DCT.ID_DOCUMENTO = A.EXT_ID_DOCUMENTO
       AND A.ID_AZIENDA= P_ID_AZIENDA
       -- AND SYSDATE BETWEEN A.DATA_INIZIO_VALIDITA AND NVL(A.DATA_FINE_VALIDITA,SYSDATE)
       AND A.ID_DOCUMENTO = B.ID_DOCUMENTO
       AND A.ID_STATO_DOCUMENTO IS NULL
       -- AND SYSDATE BETWEEN B.DATA_INIZIO_VALIDITA AND NVL(B.DATA_FINE_VALIDITA,SYSDATE)
       AND B.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
       -- AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
       AND SP.ID_PARTICELLA = P.ID_PARTICELLA
       AND SP.DATA_FINE_VALIDITA IS NULL
       AND SP.COMUNE = C.ISTAT_COMUNE
  GROUP BY CP.ID_PARTICELLA, TD.ID_DOCUMENTO, TD.DESCRIZIONE, SP.COMUNE, SP.SEZIONE, SP.FOGLIO, SP.PARTICELLA,SP.SUBALTERNO, C.DESCOM, TO_CHAR(A.DATA_INSERIMENTO,'YYYY')
  HAVING COUNT(DISTINCT(A.ID_DOCUMENTO)) > 1;

    CURSOR curDocumentoParticella (pIdAzienda    IN DB_UTE.ID_AZIENDA%TYPE,
                                   pIdParticella IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE,
                                   pIdTipoDoc    IN DB_DOCUMENTO_CATEGORIA.ID_DOCUMENTO%TYPE
                                   ) IS
    SELECT A.ID_DOCUMENTO
      FROM DB_DOCUMENTO A,
           DB_DOCUMENTO_CONDUZIONE B,
           DB_CONDUZIONE_PARTICELLA CP,
           DB_UTE U,
           DB_TIPO_CATEGORIA_DOCUMENTO TCD,
           DB_DOCUMENTO_CATEGORIA DCT
     WHERE TCD.IDENTIFICATIVO = knIdentificativoDocRiesame
       AND TCD.TIPO_IDENTIFICATIVO = 'TC'
       AND TCD.ID_CATEGORIA_DOCUMENTO = DCT.ID_CATEGORIA_DOCUMENTO
       AND DCT.ID_DOCUMENTO = A.EXT_ID_DOCUMENTO
       AND A.EXT_ID_DOCUMENTO = pIdTipoDoc
       AND A.ID_AZIENDA= P_ID_AZIENDA
       -- AND SYSDATE BETWEEN A.DATA_INIZIO_VALIDITA AND NVL(A.DATA_FINE_VALIDITA,SYSDATE)
       AND A.ID_DOCUMENTO = B.ID_DOCUMENTO
       AND A.ID_STATO_DOCUMENTO IS NULL
       -- AND SYSDATE BETWEEN B.DATA_INIZIO_VALIDITA AND NVL(B.DATA_FINE_VALIDITA,SYSDATE)
       AND B.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
       AND CP.ID_PARTICELLA = pIdParticella
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_UTE = U.ID_UTE
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND U.ID_AZIENDA = pIdAzienda
  GROUP BY A.ID_DOCUMENTO;

    CURSOR curConduzioniParticella (pIdAzienda      IN DB_UTE.ID_AZIENDA%TYPE,
                                    pIdParticella   IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE
                                    )IS
    SELECT B.ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA B,
           DB_UTE U
     WHERE B.DATA_FINE_CONDUZIONE IS NULL
       AND B.ID_UTE = U.ID_UTE
       AND U.ID_AZIENDA = pIdAzienda
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND B.ID_PARTICELLA= pIdParticella;

    nAnnoCampagna       DB_PARTICELLA_CERT_ELEG.ANNO_CAMPAGNA%TYPE;
    dDataFoto           DB_PARTICELLA_CERT_ELEG.DATA_FOTOINTERPRETAZIONE%TYPE;
    bAnomala            BOOLEAN;
    recTIstanzaRiesame  DB_ISTANZA_RIESAME%ROWTYPE;

BEGIN

    S_DESCRIZIONE := NULL;
    -- scorro le particelle che risultano avere più di un documento di riesame nel range di date
    -- e le segnalo come anomale
    FOR recParticellaConDocRiesameMult IN curParticellaConDocRiesameMult LOOP
        bAnomala := FALSE;

        S_DESCRIZIONE := 'Particella [' ||recParticellaConDocRiesameMult.DESCOM ||
                         ' Sez : ' || NVL(recParticellaConDocRiesameMult.SEZIONE,'N.V.') ||
                         ' Fgl : ' || recParticellaConDocRiesameMult.FOGLIO ||
                         ' Part : ' || recParticellaConDocRiesameMult.PARTICELLA ||
                         ' Sub : ' || NVL(recParticellaConDocRiesameMult.SUBALTERNO,'N.V') || ']';
        -- cerco se la particella / azienda è presente in istanze riesame
        -- per la fase in lavorazione
        BEGIN
            -- a seconda della tipologia del documento potrei
            -- essere in fasi diverse dell'istanza di riesame
            -- uso l'apposita tabella di relazione per capire quale
            SELECT IR.*
              INTO recTIstanzaRiesame
              FROM DB_ISTANZA_RIESAME IR
             WHERE IR.ID_AZIENDA = P_ID_AZIENDA
               AND IR.ID_PARTICELLA = recParticellaConDocRiesameMult.ID_PARTICELLA
               AND IR.ID_FASE_ISTANZA_RIESAME IN (SELECT ID_FASE_ISTANZA_RIESAME
                                                    FROM DB_R_FASE_RIESAME_TP_DOCUMENTO
                                                   WHERE ID_DOCUMENTO =  recParticellaConDocRiesameMult.ID_DOCUMENTO
                                                     AND DATA_FINE_VALIDITA IS NULL)
               AND IR.DATA_RICHIESTA = (SELECT MAX(DATA_RICHIESTA)
                                          FROM DB_ISTANZA_RIESAME
                                         WHERE ID_AZIENDA = IR.ID_AZIENDA
                                           AND ID_FASE_ISTANZA_RIESAME IN (SELECT ID_FASE_ISTANZA_RIESAME
                                                                             FROM DB_R_FASE_RIESAME_TP_DOCUMENTO
                                                                            WHERE ID_DOCUMENTO = recParticellaConDocRiesameMult.ID_DOCUMENTO
                                                                              AND DATA_FINE_VALIDITA IS NULL)
                                           AND ID_PARTICELLA = IR.ID_PARTICELLA
                                           AND DATA_ANNULLAMENTO IS NULL);
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 recTIstanzaRiesame := NULL;

        END;

        -- se la particella è presente in istanza di riesame
        IF recTIstanzaRiesame.DATA_RICHIESTA IS NOT NULL THEN
           -- controllo se la lavorazione GIS è stata effettuta
           IF recTIstanzaRiesame.DATA_EVASIONE IS NULL THEN
              -- se non lo è stata do apposita segnalazione
              S_DESCRIZIONE := S_DESCRIZIONE  || ' non è possibile inserire tale particella in un nuovo documento "' || recParticellaConDocRiesameMult.DESCRIZIONE ||'" in quanto risulta già presente una richiesta di lavorazione al GIS non ancora evasa.';
              bAnomala := TRUE;
           ELSE
              -- altrimenti se la lavorazione GIS è stata effettuata controllo ancora
              -- se è stata effettuata per l'anno in corso o per un anno successivo a quello
              -- in corso in tal caso segnalo che la lavorazione è già state effettuata
              -- per l'anno in corso
              IF recTIstanzaRiesame.ANNO >= EXTRACT (YEAR FROM SYSDATE) THEN
                 S_DESCRIZIONE := S_DESCRIZIONE  || ' non è possibile inserire tale particella in un nuovo documento "' || recParticellaConDocRiesameMult.DESCRIZIONE || '" in quanto  risulta già presente lavorazione al GIS effettuata per l''anno in corso.';
                 bAnomala := TRUE;
              END IF;
           END IF;
        ELSE
            S_DESCRIZIONE := S_DESCRIZIONE  || ' legata a : ' ||  recParticellaConDocRiesameMult.QUANTI || ' documenti di tipo : ' || recParticellaConDocRiesameMult.DESCRIZIONE;
            bAnomala := TRUE;
        END IF;

        IF bAnomala THEN
            -- segnalazione generica
            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
            -- segnalazione sui documenti
            FOR recDocumentoParticella IN curDocumentoParticella (P_ID_AZIENDA, recParticellaConDocRiesameMult.ID_PARTICELLA, recParticellaConDocRiesameMult.ID_DOCUMENTO) LOOP
                IF NOT SCRIVI_SEGNALAZIONE_DOCUMENTO (P_ID_CONTROLLO, S_DESCRIZIONE,P_BLOCCANTE, recDocumentoParticella.ID_DOCUMENTO, P_MSGERR, P_CODERR) THEN
                   RETURN (FALSE);
                END IF;
            END LOOP;
            -- segnalazione sulle particelle
            FOR recConduzioniParticella IN curConduzioniParticella (P_ID_AZIENDA,recParticellaConDocRiesameMult.ID_PARTICELLA) LOOP
                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,P_BLOCCANTE, recConduzioniParticella.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                   RETURN (FALSE);
                END IF;
            END LOOP;
        END IF;
    END LOOP;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE PART_CON_DOC_RIESAME_MULTIPLI: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END PART_CON_DOC_RIESAME_MULTIPLI;

FUNCTION DOCUMENTI_SCADUTI_ANNO (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                         P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        P_BLOCCANTE     IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                         P_MSGERR       IN OUT VARCHAR2,
                                        P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_NUMERO             NUMBER;
N_ID_DOCUMENTO               DB_DOCUMENTO.ID_DOCUMENTO%TYPE;

CURSOR C_CONDUZIONE_DOCUMENTO IS
    SELECT D.DESCRIZIONE, a.NUMERO_PROTOCOLLO, A.DATA_PROTOCOLLO, A.ID_DOCUMENTO,
           E.DESCRIZIONE AS CONDUZIONE, G.DESCOM, F.SEZIONE, F.FOGLIO, F.PARTICELLA, F.SUBALTERNO, B.ID_CONDUZIONE_PARTICELLA
    FROM DB_DOCUMENTO A, DB_DOCUMENTO_CONDUZIONE B, DB_CONDUZIONE_PARTICELLA C, DB_TIPO_DOCUMENTO D,
         DB_TIPO_TITOLO_POSSESSO E, DB_STORICO_PARTICELLA F, COMUNE G
    WHERE A.ID_AZIENDA= P_ID_AZIENDA
      AND TO_CHAR(NVL(A.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') < TO_CHAR(SYSDATE,'YYYYMMDD')
      AND TO_CHAR(NVL(A.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') >= TO_CHAR(SYSDATE,'YYYY')||'0101'
      AND A.ID_DOCUMENTO = B.ID_DOCUMENTO
      AND B.ID_CONDUZIONE_PARTICELLA = C.ID_CONDUZIONE_PARTICELLA
      AND C.DATA_FINE_CONDUZIONE IS NULL
      AND D.ID_DOCUMENTO = A.EXT_ID_DOCUMENTO
      AND E.ID_TITOLO_POSSESSO = C.ID_TITOLO_POSSESSO
      AND F.ID_PARTICELLA = C.ID_PARTICELLA
      AND F.DATA_FINE_VALIDITA IS NULL
      AND G.ISTAT_COMUNE = F.COMUNE
      AND A.ID_STATO_DOCUMENTO IS NULL
      AND D.ID_TIPOLOGIA_DOCUMENTO = 2
        AND TO_CHAR(NVL(B.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') > TO_CHAR(SYSDATE,'YYYYMMDD');

CURSOR C_DOCUMENTI_ANAGRAFICI IS
    SELECT B.DESCRIZIONE, a.NUMERO_PROTOCOLLO, A.DATA_PROTOCOLLO, A.ID_DOCUMENTO
    FROM DB_DOCUMENTO A , DB_TIPO_DOCUMENTO B
    WHERE A.ID_AZIENDA= P_ID_AZIENDA
      AND TO_CHAR(NVL(A.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') < TO_CHAR(SYSDATE,'YYYYMMDD')
      AND TO_CHAR(NVL(A.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') >= TO_CHAR(SYSDATE,'YYYY')||'0101'
      AND B.ID_DOCUMENTO = A.EXT_ID_DOCUMENTO
      AND A.ID_STATO_DOCUMENTO IS NULL
      AND B.ID_TIPOLOGIA_DOCUMENTO IN (1,3,5); 

BEGIN
    S_DESCRIZIONE := NULL;
--DOCUMENTI ANAGRAFICI E ZOO
    FOR  REC_DOCUMENTI_ANAGRAFICI IN C_DOCUMENTI_ANAGRAFICI LOOP
       S_DESCRIZIONE := ' Il documento ' ||
                            ' Prot.'|| REC_DOCUMENTI_ANAGRAFICI.NUMERO_PROTOCOLLO|| ' del ' || TO_CHAR(REC_DOCUMENTI_ANAGRAFICI.DATA_PROTOCOLLO,'DD/MM/YYYY')||
                        ' risulta scaduto nell''anno';
       IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                 P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
       END IF;
       /* documento */
       IF NOT SCRIVI_SEGNALAZIONE_DOCUMENTO (P_ID_CONTROLLO, S_DESCRIZIONE,
                 P_BLOCCANTE, REC_DOCUMENTI_ANAGRAFICI.ID_DOCUMENTO, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
       END IF;
    END LOOP;

-- DOCUMENTI TERRITORIALI
    FOR REC_CONDUZIONE_DOCUMENTO IN C_CONDUZIONE_DOCUMENTO LOOP
        IF N_ID_DOCUMENTO IS NULL OR --PRIMA VOLTA
           N_ID_DOCUMENTO <> REC_CONDUZIONE_DOCUMENTO.ID_DOCUMENTO THEN
           N_ID_DOCUMENTO := REC_CONDUZIONE_DOCUMENTO.ID_DOCUMENTO;
           S_DESCRIZIONE := ' Il documento ' ||
                                ' Prot.'|| REC_CONDUZIONE_DOCUMENTO.NUMERO_PROTOCOLLO|| ' del ' ||
                            TO_CHAR(REC_CONDUZIONE_DOCUMENTO.DATA_PROTOCOLLO,'DD/MM/YYYY') ||' risulta scaduto nell''anno';
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                     P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
           END IF;
           /* documento */
           IF NOT SCRIVI_SEGNALAZIONE_DOCUMENTO (P_ID_CONTROLLO, S_DESCRIZIONE,
                     P_BLOCCANTE, REC_CONDUZIONE_DOCUMENTO.ID_DOCUMENTO, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
           END IF;
         END IF;
        S_DESCRIZIONE := 'Particella legata al documento '|| REC_CONDUZIONE_DOCUMENTO.DESCRIZIONE ||
                         ' Prot.'|| REC_CONDUZIONE_DOCUMENTO.NUMERO_PROTOCOLLO|| ' del ' || TO_CHAR(REC_CONDUZIONE_DOCUMENTO.DATA_PROTOCOLLO,'DD/MM/YYYY')||
                         ' scaduto nell''anno';
        IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, REC_CONDUZIONE_DOCUMENTO.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
        END IF;
    END LOOP;

   RETURN (TRUE);
EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE DOCUMENTI_SCADUTI_ANNO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END DOCUMENTI_SCADUTI_ANNO;

-- aggiunto parametro per controllare solo le particelle
-- sulle quali insiste almeno un'unità vitata
FUNCTION PARTICELLE_SENZA_DOCUMENTO (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                        P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE    IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                     P_SOLO_VITATE  IN   VARCHAR2, 
                                        P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

    S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    N_NUMERO             NUMBER;
    N_ID_DOCUMENTO        DB_DOCUMENTO.ID_DOCUMENTO%TYPE;
    s_sezione            VARCHAR2(20);
    s_sub                VARCHAR2(20);
    vStrSql             VARCHAR2(4000);
    vStrSqlExist        VARCHAR2(500);

    CURSOR TypCurPartSenzaDocumenti IS
    SELECT DISTINCT D.COMUNE, D.SEZIONE, D.FOGLIO, D.PARTICELLA, D.SUBALTERNO, A.ID_TITOLO_POSSESSO , E.DESCOM, D.ID_STORICO_PARTICELLA, A.ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA A, DB_UTE C, DB_STORICO_PARTICELLA D, COMUNE E, DB_TIPO_CASO_PARTICOLARE CP
     WHERE A.DATA_FINE_CONDUZIONE IS NULL
       AND C.ID_AZIENDA = P_ID_AZIENDA
       AND C.ID_UTE = A.ID_UTE
       AND A.ID_TITOLO_POSSESSO IN (2,3,4,5,8) 
       AND A.ID_PARTICELLA = D.ID_PARTICELLA
       AND D.DATA_FINE_VALIDITA IS NULL
       AND NVL(D.ID_CASO_PARTICOLARE,99) = CP.ID_CASO_PARTICOLARE
       AND CP.EFFETTUA_CONTROLLI_GIS = 'S' 
       AND E.ISTAT_COMUNE = D.COMUNE;

    TYPE TypRefCursor IS REF CURSOR;
    curPartSenzaDocumenti   TypRefCursor; -- cursore dinamico
    recPartSenzaDocumenti   TypCurPartSenzaDocumenti%ROWTYPE;

BEGIN

    -- pezzo di filtro alla query da aggiungere se il parametro
    -- P_SOLO_VITATE è ad 'S'
    IF P_SOLO_VITATE = 'S' THEN
       vStrSqlExist := ' AND EXISTS (SELECT SUA.ID_STORICO_UNITA_ARBOREA
                                       FROM DB_STORICO_UNITA_ARBOREA SUA
                                      WHERE SUA.ID_AZIENDA = C.ID_AZIENDA
                                        AND SUA.ID_PARTICELLA = A.ID_PARTICELLA
                                        AND SUA.DATA_FINE_VALIDITA IS NULL)';
    END IF;

    -- se è valorizzata non controllo lo stato documento ed il fatto che sia attivo alla sysdate
    -- ed idem per la conduzione del documento
    IF dDataConfCorrettiva IS NOT NULL THEN
       vStrSql := 'SELECT DISTINCT D.COMUNE, D.SEZIONE, D.FOGLIO, D.PARTICELLA, D.SUBALTERNO, A.ID_TITOLO_POSSESSO , E.DESCOM, D.ID_STORICO_PARTICELLA, A.ID_CONDUZIONE_PARTICELLA
                     FROM DB_CONDUZIONE_PARTICELLA A, DB_UTE C, DB_STORICO_PARTICELLA D, COMUNE E, DB_TIPO_CASO_PARTICOLARE CP
                    WHERE A.DATA_FINE_CONDUZIONE IS NULL
                      AND C.ID_AZIENDA = :P_ID_AZIENDA
                      AND C.ID_UTE = A.ID_UTE
                      AND A.ID_TITOLO_POSSESSO IN (2,3,4,5,8)
                      AND A.ID_PARTICELLA = D.ID_PARTICELLA
                      AND D.DATA_FINE_VALIDITA IS NULL
                      AND NVL(D.ID_CASO_PARTICOLARE,99) = CP.ID_CASO_PARTICOLARE
                      AND CP.EFFETTUA_CONTROLLI_GIS = :pYes
                      AND E.ISTAT_COMUNE = D.COMUNE
                      AND NOT EXISTS (SELECT 1
                                        FROM DB_DOCUMENTO_CONDUZIONE DC, DB_DOCUMENTO D,
                                             DB_DOCUMENTO_CATEGORIA DCA, DB_TIPO_CATEGORIA_DOCUMENTO CD
                                       WHERE DC.ID_CONDUZIONE_PARTICELLA = A.ID_CONDUZIONE_PARTICELLA
                                         AND D.ID_DOCUMENTO = DC.ID_DOCUMENTO
                                         AND DCA.ID_DOCUMENTO = D.EXT_ID_DOCUMENTO
                                         AND DCA.ID_CATEGORIA_DOCUMENTO = CD.ID_CATEGORIA_DOCUMENTO
                                         AND CD.TIPO_IDENTIFICATIVO = ''TP''
                                         AND CD.IDENTIFICATIVO = A.ID_TITOLO_POSSESSO
                                         AND D.DATA_INIZIO_VALIDITA <= :pDataConfCorrettiva
                                         AND NVL(D.DATA_FINE_VALIDITA,:pDataConfCorrettiva) >= :pDataConfCorrettiva)';
        vStrSql := vStrSql || vStrSqlExist;

        OPEN curPartSenzaDocumenti FOR vStrSql
        USING IN P_ID_AZIENDA, 'S',dDataConfCorrettiva,dDataConfCorrettiva,dDataConfCorrettiva;
    ELSE
        -- altrimenti controllo che l'ID_STATO_DOCUMENTO sia nullable
        -- e che la data_fine_validità di DB_DOCUMENTO e DB_CONSUZIONE sia >= alla sysdate
        vStrSql := 'SELECT DISTINCT D.COMUNE, D.SEZIONE, D.FOGLIO, D.PARTICELLA, D.SUBALTERNO, A.ID_TITOLO_POSSESSO , E.DESCOM, D.ID_STORICO_PARTICELLA, A.ID_CONDUZIONE_PARTICELLA
                      FROM DB_CONDUZIONE_PARTICELLA A, DB_UTE C, DB_STORICO_PARTICELLA D, COMUNE E, DB_TIPO_CASO_PARTICOLARE CP
                     WHERE A.DATA_FINE_CONDUZIONE IS NULL
                       AND C.ID_AZIENDA = :P_ID_AZIENDA
                       AND C.ID_UTE = A.ID_UTE
                       AND A.ID_TITOLO_POSSESSO IN (2,3,4,5,8)
                       AND A.ID_PARTICELLA = D.ID_PARTICELLA
                       AND D.DATA_FINE_VALIDITA IS NULL
                       AND NVL(D.ID_CASO_PARTICOLARE,99) = CP.ID_CASO_PARTICOLARE
                       AND CP.EFFETTUA_CONTROLLI_GIS = :pYes
                       AND E.ISTAT_COMUNE = D.COMUNE
                       AND NOT EXISTS (SELECT 1
                                         FROM DB_DOCUMENTO_CONDUZIONE DC, DB_DOCUMENTO D,
                                              DB_DOCUMENTO_CATEGORIA DCA, DB_TIPO_CATEGORIA_DOCUMENTO CD
                                        WHERE DC.ID_CONDUZIONE_PARTICELLA = A.ID_CONDUZIONE_PARTICELLA
                                          AND D.ID_DOCUMENTO = DC.ID_DOCUMENTO
                                          AND D.ID_STATO_DOCUMENTO IS NULL
                                          AND DCA.ID_DOCUMENTO = D.EXT_ID_DOCUMENTO
                                          AND DCA.ID_CATEGORIA_DOCUMENTO = CD.ID_CATEGORIA_DOCUMENTO
                                          AND CD.TIPO_IDENTIFICATIVO = ''TP''
                                          AND CD.IDENTIFICATIVO = A.ID_TITOLO_POSSESSO
                                          AND D.DATA_INIZIO_VALIDITA <= TRUNC(SYSDATE)
                                          AND NVL(D.DATA_FINE_VALIDITA,:pDataNvl) > TRUNC(SYSDATE)
                                          AND NVL(DC.DATA_FINE_VALIDITA,:pDataNvl) > TRUNC(SYSDATE))';
        vStrSql := vStrSql || vStrSqlExist;
        OPEN curPartSenzaDocumenti FOR vStrSql
        USING IN P_ID_AZIENDA, 'S',TO_DATE('31/12/9999','DD/MM/YYYY'),TO_DATE('31/12/9999','DD/MM/YYYY');
    END IF;

    LOOP
        FETCH curPartSenzaDocumenti INTO recPartSenzaDocumenti;
        EXIT WHEN curPartSenzaDocumenti%NOTFOUND;

        SELECT DECODE(recPartSenzaDocumenti.SEZIONE, NULL, '', ' Sz: '|| recPartSenzaDocumenti.SEZIONE)
        INTO S_SEZIONE FROM DUAL;
        SELECT DECODE(recPartSenzaDocumenti.subalterno, NULL, '', ' Sub: '|| recPartSenzaDocumenti.SUBALTERNO)
        INTO s_sub FROM dual;

        S_DESCRIZIONE := '[' || recPartSenzaDocumenti.DESCOM || s_sezione || ' Fgl:' || recPartSenzaDocumenti.FOGLIO ||' Part:' ||
                                recPartSenzaDocumenti.PARTICELLA ||s_sub    || '] TP: ' ||recPartSenzaDocumenti.ID_TITOLO_POSSESSO || ' manca il documento giustificativo della conduzione';
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,P_BLOCCANTE, recPartSenzaDocumenti.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,P_BLOCCANTE, recPartSenzaDocumenti.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

    END LOOP;

    CLOSE curPartSenzaDocumenti;

    RETURN (TRUE);
EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE PARTICELLE_SENZA_DOCUMENTO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END PARTICELLE_SENZA_DOCUMENTO;

/* Questo controllo sostituisce:
DOCUMENTO_AFFITTO
DOCUMENTO_MEZZADRIA
DOCUMENTO_ALTRE_FORME
*/
FUNCTION DOCUMENTO_FORME_COND (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                               P_BLOCCANTE     IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                P_MSGERR       IN OUT VARCHAR2,
                               P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_NUMERO             NUMBER;
N_ID_DOCUMENTO        DB_DOCUMENTO.ID_DOCUMENTO%TYPE;
s_sezione            VARCHAR2(20);
s_sub                VARCHAR2(20);

N_IDENTIFICATIVO    DB_TIPO_CATEGORIA_DOCUMENTO.IDENTIFICATIVO%TYPE;
S_ELENCO_DESCR        VARCHAR2(32627);
N_CONT                INTEGER;

CURSOR C_DESCR_DOC IS
    SELECT Z.DESCRIZIONE
    FROM DB_TIPO_DOCUMENTO Z, DB_DOCUMENTO_CATEGORIA Y, DB_TIPO_CATEGORIA_DOCUMENTO X
    WHERE Z.ID_DOCUMENTO=Y.ID_DOCUMENTO
    AND Y.ID_CATEGORIA_DOCUMENTO=X.ID_CATEGORIA_DOCUMENTO
    AND X.TIPO_IDENTIFICATIVO='TP'
    AND X.IDENTIFICATIVO=N_IDENTIFICATIVO;

CURSOR C_DOCUMENTO IS
   SELECT DISTINCT D.COMUNE, D.SEZIONE, D.FOGLIO, D.PARTICELLA, D.SUBALTERNO, A.ID_TITOLO_POSSESSO , E.DESCOM,
           d.id_storico_particella, a.id_conduzione_particella
     FROM DB_CONDUZIONE_PARTICELLA A, DB_UTE C, DB_STORICO_PARTICELLA D,
           COMUNE E
    WHERE A.DATA_FINE_CONDUZIONE IS NULL
      AND C.ID_AZIENDA = P_ID_AZIENDA
      AND C.ID_UTE = A.ID_UTE
      AND A.ID_TITOLO_POSSESSO = N_IDENTIFICATIVO
      AND A.ID_PARTICELLA = D.ID_PARTICELLA
      AND D.DATA_FINE_VALIDITA IS NULL
      AND NVL(D.ID_CASO_PARTICOLARE,99) = 99 --SENZA CP
      AND E.ISTAT_COMUNE = D.COMUNE
      AND NOT EXISTS (SELECT *
                          FROM DB_DOCUMENTO_CONDUZIONE DC,
                             DB_DOCUMENTO F,
                             DB_TIPO_DOCUMENTO Z,
                             DB_DOCUMENTO_CATEGORIA Y,
                             DB_TIPO_CATEGORIA_DOCUMENTO X,
                             DB_UTILIZZO_PARTICELLA UP 
                       WHERE DC.ID_DOCUMENTO = F.ID_DOCUMENTO
                         AND (F.ID_STATO_DOCUMENTO IS NULL and
                               (UP.DATA_INIZIO_DESTINAZIONE BETWEEN F.DATA_INIZIO_VALIDITA AND NVL(F.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')) AND
                                 NVL(UP.DATA_FINE_DESTINAZIONE,SYSDATE) BETWEEN F.DATA_INIZIO_VALIDITA AND NVL(F.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy'))  AND    dDataConfCorrettiva     IS NULL
                                OR    (F.DATA_INIZIO_VALIDITA <=    dDataConfCorrettiva AND    dDataConfCorrettiva IS NOT NULL AND    NVL(F.DATA_FINE_VALIDITA,dDataConfCorrettiva) >= dDataConfCorrettiva)))
                         AND UP.ID_CONDUZIONE_PARTICELLA = DC.ID_CONDUZIONE_PARTICELLA
                         AND DC.ID_CONDUZIONE_PARTICELLA = A.ID_CONDUZIONE_PARTICELLA  
                         AND F.EXT_ID_DOCUMENTO=Z.ID_DOCUMENTO
                         AND Z.ID_DOCUMENTO=Y.ID_DOCUMENTO
                         AND Y.ID_CATEGORIA_DOCUMENTO=X.ID_CATEGORIA_DOCUMENTO
                         AND X.TIPO_IDENTIFICATIVO='TP'
                         AND X.IDENTIFICATIVO=N_IDENTIFICATIVO
                        ); -- NON è UN DOCUMENTO DI ........
BEGIN

    /* determino l'identificativo in base all'id_controllo */
    IF P_ID_CONTROLLO=506 THEN
       N_IDENTIFICATIVO:=2;
    ELSIF P_ID_CONTROLLO=508 THEN
       N_IDENTIFICATIVO:=4;
    ELSIF P_ID_CONTROLLO=507 THEN
       N_IDENTIFICATIVO:=3;
    ELSIF P_ID_CONTROLLO=528 THEN
       N_IDENTIFICATIVO:=5;
    END IF;

    /* creo il messaggio */
    S_ELENCO_DESCR:='';
    N_CONT:=0;
    FOR REC_DESCR_DOC IN C_DESCR_DOC LOOP
        N_CONT:=N_CONT+1;
        S_ELENCO_DESCR:=S_ELENCO_DESCR||TO_CHAR(N_CONT)||') '||REC_DESCR_DOC.DESCRIZIONE||'; ';
    END LOOP;

    FOR REC_DOCUMENTO IN C_DOCUMENTO LOOP
        SELECT DECODE(REC_DOCUMENTO.SEZIONE, NULL, '', ' Sz: '|| REC_DOCUMENTO.SEZIONE)
        INTO S_SEZIONE FROM DUAL;
        SELECT DECODE(REC_DOCUMENTO.subalterno, NULL, '', ' Sub: '|| REC_DOCUMENTO.SUBALTERNO)
        INTO s_sub FROM dual;

        S_DESCRIZIONE := '[' || REC_DOCUMENTO.DESCOM || s_sezione ||
          ' Fgl:' || REC_DOCUMENTO.FOGLIO ||' Part:' ||
          REC_DOCUMENTO.PARTICELLA ||s_sub    ||
          ']. Non e'' stato associato il corretto documento giustificativo della conduzione per il periodo di destinazione indicato sulla particella. Documenti associabili: '||
          S_ELENCO_DESCR;

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, REC_DOCUMENTO.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
        END IF;
        IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
               P_BLOCCANTE, REC_DOCUMENTO.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
        END IF;
    END LOOP;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE DOCUMENTO_FORME_COND: ' || SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END DOCUMENTO_FORME_COND;

FUNCTION DOCUMENTI_SENZA_PARTICELLE (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                         P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        P_BLOCCANTE     IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                         P_MSGERR       IN OUT VARCHAR2,
                                        P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_NUMERO             NUMBER;
N_ID_DOCUMENTO               DB_DOCUMENTO.ID_DOCUMENTO%TYPE;

CURSOR C_DOCUMENTO_SENZA_PARTICELLE IS
    SELECT C.DESCRIZIONE, a.NUMERO_PROTOCOLLO, A.DATA_PROTOCOLLO, A.ID_DOCUMENTO
    FROM DB_DOCUMENTO A, DB_DOCUMENTO_CONDUZIONE B, DB_TIPO_DOCUMENTO C
    WHERE A.ID_DOCUMENTO = B.ID_DOCUMENTO (+)
      AND A.EXT_ID_DOCUMENTO = C.ID_DOCUMENTO
      AND C.ID_TIPOLOGIA_DOCUMENTO = 2 --SOLO TERRITORIALI
      AND A.ID_STATO_DOCUMENTO IS NULL
      AND TO_CHAR(NVL(A.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') >= TO_CHAR(SYSDATE,'YYYYMMDD')
      AND B.ID_DOCUMENTO IS NULL
      AND A.ID_AZIENDA = P_ID_AZIENDA;

BEGIN
    FOR REC_DOCUMENTO_SENZA_PARTICELLE IN C_DOCUMENTO_SENZA_PARTICELLE LOOP
        S_DESCRIZIONE := ' Il documento ' || REC_DOCUMENTO_SENZA_PARTICELLE.DESCRIZIONE ||' Prot.'|| REC_DOCUMENTO_SENZA_PARTICELLE.NUMERO_PROTOCOLLO|| ' del ' ||
                            TO_CHAR(REC_DOCUMENTO_SENZA_PARTICELLE.DATA_PROTOCOLLO,'DD/MM/YYYY') ||' non risulta associato ad alcuna conduzione';
        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
        /* documento */
        IF NOT SCRIVI_SEGNALAZIONE_DOCUMENTO (P_ID_CONTROLLO, S_DESCRIZIONE,
                 P_BLOCCANTE, REC_DOCUMENTO_SENZA_PARTICELLE.ID_DOCUMENTO, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
        END IF;
    END LOOP;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE DOCUMENTI_SENZA_PARTICELLE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END DOCUMENTI_SENZA_PARTICELLE;

FUNCTION DOCUMENTI_UNIVOCI (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                         P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        P_BLOCCANTE     IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                         P_MSGERR       IN OUT VARCHAR2,
                                        P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_NUMERO             NUMBER;
N_ID_DOCUMENTO               DB_DOCUMENTO.ID_DOCUMENTO%TYPE;

CURSOR C_DOCUMENTO IS
    SELECT C.DESCRIZIONE, a.NUMERO_PROTOCOLLO, A.DATA_PROTOCOLLO, A.ID_DOCUMENTO
    FROM DB_DOCUMENTO A, DB_TIPO_DOCUMENTO C
    WHERE A.EXT_ID_DOCUMENTO = C.ID_DOCUMENTO
      AND A.EXT_ID_DOCUMENTO = N_ID_DOCUMENTO
      AND A.ID_STATO_DOCUMENTO IS NULL
      AND A.ID_AZIENDA = P_ID_AZIENDA;

CURSOR C_DOCUMENTO_NON_UNIVOCO IS
    SELECT A.EXT_ID_DOCUMENTO, COUNT(*)
      FROM DB_DOCUMENTO A, DB_TIPO_DOCUMENTO C
     WHERE A.EXT_ID_DOCUMENTO = C.ID_DOCUMENTO
       AND C.FLAG_UNIVOCITA = 'S'
       AND A.ID_STATO_DOCUMENTO IS NULL
       AND A.ID_AZIENDA = P_ID_AZIENDA
       AND TO_CHAR(NVL(A.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') >= TO_CHAR(SYSDATE,'YYYYMMDD')
     GROUP BY A.EXT_ID_DOCUMENTO
     HAVING COUNT(*) > 1;

BEGIN
    FOR REC_DOCUMENTO_NON_UNIVOCO IN C_DOCUMENTO_NON_UNIVOCO LOOP
        N_ID_DOCUMENTO := REC_DOCUMENTO_NON_UNIVOCO.EXT_ID_DOCUMENTO;
        FOR REC_DOCUMENTO IN C_DOCUMENTO LOOP
            S_DESCRIZIONE := 'Il documento ' || REC_DOCUMENTO.DESCRIZIONE ||' Prot.'|| REC_DOCUMENTO.NUMERO_PROTOCOLLO|| ' del ' ||
                    TO_CHAR(REC_DOCUMENTO.DATA_PROTOCOLLO,'DD/MM/YYYY') ||' è un documento univoco e risulta presente più volte legato all''azienda';
            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
            /* documento */
            IF NOT SCRIVI_SEGNALAZIONE_DOCUMENTO (P_ID_CONTROLLO, S_DESCRIZIONE,
                     P_BLOCCANTE, REC_DOCUMENTO.ID_DOCUMENTO, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
            END IF;
        END LOOP;
    END LOOP;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE DOCUMENTI_UNIVOCI: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END DOCUMENTI_UNIVOCI;

/* Questo controllo sostituirà:
DOCUMENTO_CASO_PARTICOLARE_1
DOCUMENTO_CASO_PARTICOLARE_4
DOCUMENTO_CASO_PARTICOLARE_2
DOCUMENTO_CASO_PARTICOLARE_5
DOCUMENTO_CASO_PARTICOLARE_7
DOCUMENTO_CASO_PARTICOLARE_3

(N.B.:RESTA ESCLUSO IL CASO PARTICOLARE 6)
*/
FUNCTION DOCUMENTO_CASO_PARTICOLARE (    P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                    P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                    P_BLOCCANTE         IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                    P_MSGERR       IN OUT VARCHAR2,
                                                    P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_NUMERO             NUMBER;
N_ID_DOCUMENTO               DB_DOCUMENTO.ID_DOCUMENTO%TYPE;
s_sezione            VARCHAR2(20);
s_sub                VARCHAR2(20);
n_conta                NUMBER(10);

N_IDENTIFICATIVO    DB_TIPO_CATEGORIA_DOCUMENTO.IDENTIFICATIVO%TYPE;
S_ELENCO_DESCR        VARCHAR2(2000);
N_CONT                INTEGER;

S_DESCR_CP            VARCHAR2(100);

FLAG_ERR            BOOLEAN;

s_identificativo             VARCHAR2(10);

CURSOR C_DESCR_DOC IS
    SELECT Z.DESCRIZIONE
    FROM DB_TIPO_DOCUMENTO Z, DB_DOCUMENTO_CATEGORIA Y, DB_TIPO_CATEGORIA_DOCUMENTO X
    WHERE Z.ID_DOCUMENTO=Y.ID_DOCUMENTO
    AND Y.ID_CATEGORIA_DOCUMENTO=X.ID_CATEGORIA_DOCUMENTO
    AND X.TIPO_IDENTIFICATIVO='CP'
    AND X.IDENTIFICATIVO=N_IDENTIFICATIVO;

CURSOR C_DOCUMENTO_CASO_PARTICOLARE IS
   SELECT DISTINCT D.COMUNE, D.SEZIONE, D.FOGLIO, D.PARTICELLA, D.SUBALTERNO, A.ID_TITOLO_POSSESSO , E.DESCOM,
           d.id_storico_particella, a.id_conduzione_particella
     FROM DB_CONDUZIONE_PARTICELLA A, DB_UTE C, DB_STORICO_PARTICELLA D,
           COMUNE E
    WHERE A.DATA_FINE_CONDUZIONE IS NULL
      AND C.ID_AZIENDA = P_ID_AZIENDA
      AND C.ID_UTE = A.ID_UTE
      AND A.ID_PARTICELLA = D.ID_PARTICELLA
      AND D.DATA_FINE_VALIDITA IS NULL
      AND NVL(D.ID_CASO_PARTICOLARE,99) = N_IDENTIFICATIVO
      AND E.ISTAT_COMUNE = D.COMUNE
      AND A.ID_TITOLO_POSSESSO    != 5;

CURSOR C_ID_DOC IS
    SELECT Z.ID_DOCUMENTO
    FROM DB_TIPO_DOCUMENTO Z, DB_DOCUMENTO_CATEGORIA Y, DB_TIPO_CATEGORIA_DOCUMENTO X
    WHERE Z.ID_DOCUMENTO=Y.ID_DOCUMENTO
    AND Y.ID_CATEGORIA_DOCUMENTO=X.ID_CATEGORIA_DOCUMENTO
    AND X.TIPO_IDENTIFICATIVO='CP'
    AND X.IDENTIFICATIVO=N_IDENTIFICATIVO;

BEGIN

     /* determino l'identificativo in base all'id_controllo */
    IF P_ID_CONTROLLO=510 THEN
       N_IDENTIFICATIVO:=1;
    ELSIF P_ID_CONTROLLO=511 THEN
       N_IDENTIFICATIVO:=2;
    ELSIF P_ID_CONTROLLO=512 THEN
       N_IDENTIFICATIVO:=3;
    ELSIF P_ID_CONTROLLO=513 THEN
       N_IDENTIFICATIVO:=4;
    ELSIF P_ID_CONTROLLO=514 THEN
       N_IDENTIFICATIVO:=5;
    ELSIF P_ID_CONTROLLO=516 THEN
       N_IDENTIFICATIVO:=7;
    END IF;

    /* creo il messaggio */
    S_ELENCO_DESCR:='';
    N_CONT:=0;
    FOR REC_DESCR_DOC IN C_DESCR_DOC LOOP
        N_CONT:=N_CONT+1;
        S_ELENCO_DESCR:=S_ELENCO_DESCR||TO_CHAR(N_CONT)||') '||REC_DESCR_DOC.DESCRIZIONE||'; ';
    END LOOP;


    s_identificativo := TO_NUMBER(N_IDENTIFICATIVO);

    /* descrizione caso particolare */
    SELECT s_IDENTIFICATIVO||' ('||K.DESCRIZIONE||')'
    INTO S_DESCR_CP
    FROM DB_TIPO_CASO_PARTICOLARE K
    WHERE K.ID_CASO_PARTICOLARE=N_IDENTIFICATIVO;

    N_CONTA:=0;
    FLAG_ERR:=FALSE;
    FOR REC_DOCUMENTO_CASO_PARTICOLARE IN C_DOCUMENTO_CASO_PARTICOLARE LOOP
        IF N_IDENTIFICATIVO IN (1,2,4) THEN -- AND!!!

           /* ciclo per cercare tutti i doc */
           FOR REC_ID_DOC IN C_ID_DOC LOOP

                SELECT COUNT(1)
                INTO N_CONTA
                FROM DB_DOCUMENTO_CONDUZIONE DC, DB_DOCUMENTO F
               WHERE DC.ID_DOCUMENTO = F.ID_DOCUMENTO
               AND (     (            F.ID_STATO_DOCUMENTO IS NULL
                        AND     TO_CHAR(NVL(F.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') >= TO_CHAR(SYSDATE,'YYYYMMDD')
                        AND    dDataConfCorrettiva     IS NULL
                    )
                OR    (            F.DATA_INIZIO_VALIDITA <=    dDataConfCorrettiva
                         AND    dDataConfCorrettiva IS NOT NULL
                        AND    NVL(F.DATA_FINE_VALIDITA,dDataConfCorrettiva) >= dDataConfCorrettiva
                    )
                )
                AND DC.ID_CONDUZIONE_PARTICELLA = REC_DOCUMENTO_CASO_PARTICOLARE.ID_CONDUZIONE_PARTICELLA
                 AND F.EXT_ID_DOCUMENTO = REC_ID_DOC.ID_DOCUMENTO;

                 IF N_CONTA=0 THEN
                     FLAG_ERR:=TRUE;
                    /* esco dal ciclo */
                    EXIT;
                 END IF;
            END LOOP;

        ELSIF N_IDENTIFICATIVO IN (5,7,3) THEN -- OR!!!!

                /* ciclo se c'è almeno un doc */
                SELECT COUNT(1)
                INTO N_CONTA
                FROM DB_DOCUMENTO_CONDUZIONE DC, DB_DOCUMENTO F
               WHERE DC.ID_DOCUMENTO = F.ID_DOCUMENTO
               AND (     (            F.ID_STATO_DOCUMENTO IS NULL
                        AND     TO_CHAR(NVL(F.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') >= TO_CHAR(SYSDATE,'YYYYMMDD')
                        AND    dDataConfCorrettiva     IS NULL
                    )
                OR    (            F.DATA_INIZIO_VALIDITA <=    dDataConfCorrettiva
                         AND    dDataConfCorrettiva IS NOT NULL
                        AND    NVL(F.DATA_FINE_VALIDITA,dDataConfCorrettiva) >= dDataConfCorrettiva
                    )
                )
                 AND DC.ID_CONDUZIONE_PARTICELLA = REC_DOCUMENTO_CASO_PARTICOLARE.ID_CONDUZIONE_PARTICELLA
                 AND F.EXT_ID_DOCUMENTO IN
                    (SELECT Z.ID_DOCUMENTO
                    FROM DB_TIPO_DOCUMENTO Z, DB_DOCUMENTO_CATEGORIA Y, DB_TIPO_CATEGORIA_DOCUMENTO X
                    WHERE Z.ID_DOCUMENTO=Y.ID_DOCUMENTO
                    AND Y.ID_CATEGORIA_DOCUMENTO=X.ID_CATEGORIA_DOCUMENTO
                    AND X.TIPO_IDENTIFICATIVO='CP'
                    AND X.IDENTIFICATIVO=N_IDENTIFICATIVO
                    );

                 IF N_CONTA=0 THEN
                     FLAG_ERR:=TRUE;
                END IF;

        END IF;

        IF FLAG_ERR THEN
            FLAG_ERR:=FALSE;
            SELECT DECODE(REC_DOCUMENTO_CASO_PARTICOLARE.SEZIONE, NULL, '', ' Sz: '|| REC_DOCUMENTO_CASO_PARTICOLARE.SEZIONE)
            INTO S_SEZIONE FROM DUAL;
            SELECT DECODE(REC_DOCUMENTO_CASO_PARTICOLARE.subalterno, NULL, '', ' Sub: '|| REC_DOCUMENTO_CASO_PARTICOLARE.SUBALTERNO)
            INTO s_sub FROM dual;
            S_DESCRIZIONE := '[' || REC_DOCUMENTO_CASO_PARTICOLARE.DESCOM || s_sezione ||
              ' Fgl:' || REC_DOCUMENTO_CASO_PARTICOLARE.foglio ||' Part:' ||
              REC_DOCUMENTO_CASO_PARTICOLARE.particella||s_sub    || ']. Non è stato associato il corretto documento giustificativo del caso particolare '||S_DESCR_CP||'. DOCUMENTI OBBLIGATORI:'||
              S_ELENCO_DESCR;

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_DOCUMENTO_CASO_PARTICOLARE.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
            END IF;
            IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_DOCUMENTO_CASO_PARTICOLARE.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
            END IF;

        END IF;

    END LOOP; --REC_DOCUMENTO_CASO_PARTICOLARE

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE DOCUMENTO_CASO_PARTICOLARE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END DOCUMENTO_CASO_PARTICOLARE;

FUNCTION DOCUMENTO_CASO_PARTICOLARE_6 (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                        P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE     IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                        P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR            IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_NUMERO             NUMBER;
N_ID_DOCUMENTO               DB_DOCUMENTO.ID_DOCUMENTO%TYPE;
s_sezione            VARCHAR2(20);
s_sub                VARCHAR2(20);
n_conta_1            NUMBER(10);
n_conta_2            NUMBER(10);
n_conta_3            NUMBER(10);

CURSOR C_DOCUMENTO_CASO_PARTICOLARE IS
   SELECT DISTINCT D.COMUNE, D.SEZIONE, D.FOGLIO, D.PARTICELLA, D.SUBALTERNO, A.ID_TITOLO_POSSESSO , E.DESCOM,
           d.id_storico_particella, a.id_conduzione_particella
     FROM DB_CONDUZIONE_PARTICELLA A, DB_UTE C, DB_STORICO_PARTICELLA D,
           COMUNE E
    WHERE A.DATA_FINE_CONDUZIONE IS NULL
      AND C.ID_AZIENDA = P_ID_AZIENDA
      AND C.ID_UTE = A.ID_UTE
      AND A.ID_PARTICELLA = D.ID_PARTICELLA
      AND D.DATA_FINE_VALIDITA IS NULL
      AND NVL(D.ID_CASO_PARTICOLARE,99) = 6
      AND E.ISTAT_COMUNE = D.COMUNE;

BEGIN
    FOR REC_DOCUMENTO_CASO_PARTICOLARE IN C_DOCUMENTO_CASO_PARTICOLARE LOOP
        SELECT COUNT(*)
        INTO N_CONTA_1
                FROM DB_DOCUMENTO_CONDUZIONE DC, DB_DOCUMENTO F
       WHERE DC.ID_DOCUMENTO = F.ID_DOCUMENTO
         AND (     (            F.ID_STATO_DOCUMENTO IS NULL
                        AND     TO_CHAR(NVL(F.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') >= TO_CHAR(SYSDATE,'YYYYMMDD')
                        AND    dDataConfCorrettiva     IS NULL
                    )
                OR    (            F.DATA_INIZIO_VALIDITA <=    dDataConfCorrettiva
                         AND    dDataConfCorrettiva IS NOT NULL
                        AND    NVL(F.DATA_FINE_VALIDITA,dDataConfCorrettiva) >= dDataConfCorrettiva
                    )
                )
--                        AND    F.ID_STATO_DOCUMENTO IS NULL
--                        AND     TO_CHAR(NVL(F.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') >= TO_CHAR(SYSDATE,'YYYYMMDD')
         AND DC.ID_CONDUZIONE_PARTICELLA = REC_DOCUMENTO_CASO_PARTICOLARE.ID_CONDUZIONE_PARTICELLA
         AND (F.EXT_ID_DOCUMENTO = 146 OR EXT_ID_DOCUMENTO = 471 ); -- rc 20/07/2016

        SELECT COUNT(*)
        INTO N_CONTA_2
                FROM DB_DOCUMENTO_CONDUZIONE DC, DB_DOCUMENTO F
       WHERE DC.ID_DOCUMENTO = F.ID_DOCUMENTO
         AND (     (            F.ID_STATO_DOCUMENTO IS NULL
                        AND TO_CHAR(NVL(F.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') >= TO_CHAR(SYSDATE,'YYYYMMDD')
                        AND    dDataConfCorrettiva     IS NULL
                    )
                OR    (            F.DATA_INIZIO_VALIDITA <=    dDataConfCorrettiva
                         AND    dDataConfCorrettiva IS NOT NULL
                        AND    NVL(F.DATA_FINE_VALIDITA,dDataConfCorrettiva) >= dDataConfCorrettiva
                    )
                )
--            AND    F.ID_STATO_DOCUMENTO IS NULL
--            AND     TO_CHAR(NVL(F.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','dd/mm/yyyy')),'YYYYMMDD') >= TO_CHAR(SYSDATE,'YYYYMMDD')
         AND DC.ID_CONDUZIONE_PARTICELLA = REC_DOCUMENTO_CASO_PARTICOLARE.ID_CONDUZIONE_PARTICELLA
         AND (F.EXT_ID_DOCUMENTO = 138 OR F.EXT_ID_DOCUMENTO = 38 OR EXT_ID_DOCUMENTO = 466); -- rc 20/07/2016

         IF N_CONTA_1 <= 0 OR N_CONTA_2 <= 0 THEN
            SELECT DECODE(REC_DOCUMENTO_CASO_PARTICOLARE.SEZIONE, NULL, '', ' Sz: '|| REC_DOCUMENTO_CASO_PARTICOLARE.SEZIONE)
            INTO S_SEZIONE FROM DUAL;
            SELECT DECODE(REC_DOCUMENTO_CASO_PARTICOLARE.subalterno, NULL, '', ' Sub: '|| REC_DOCUMENTO_CASO_PARTICOLARE.SUBALTERNO)
            INTO s_sub FROM dual;
            S_DESCRIZIONE := '[' || REC_DOCUMENTO_CASO_PARTICOLARE.DESCOM || s_sezione ||
              ' Fgl:' || REC_DOCUMENTO_CASO_PARTICOLARE.foglio ||' Part:' ||
              REC_DOCUMENTO_CASO_PARTICOLARE.particella||s_sub    || ']. Non è stato associato il corretto documento giustificativo del caso particolare 6 (Ex catasto austroungarico). DOCUMENTI OBBLIGATORI:' ||
              '1) Stralcio planimetrico aggiornato o attualizzato rilasciato e timbrato dal catasto - 2.a) Dich. sost. agricoltore con conferma attualita'' intestazione visura tavolare OPPURE 2.b) Certificazione rilasciata dall''ente competente per particelle del catasto austro-ungarico';

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_DOCUMENTO_CASO_PARTICOLARE.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
            END IF;
            IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                   P_BLOCCANTE, REC_DOCUMENTO_CASO_PARTICOLARE.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
            END IF;
         END IF;
    END LOOP;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE DOCUMENTO_CASO_PARTICOLARE_6: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END DOCUMENTO_CASO_PARTICOLARE_6;

-- Function che per ogni particella in P26 dell'azienda
-- verifica che gli eventuali documenti di istanza di riesame siano
-- stati inseriti nei tempi stabiliti
FUNCTION DOC_RIESAME_MULTIPLI (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                               P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                               P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                               P_MSGERR       IN OUT VARCHAR2,
                               P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

    CURSOR curPartInP26 (pNumMinGG IN INTEGER, pPercP26 IN NUMBER ) IS
    SELECT A.COMUNE, G.DESCOM, A.SEZIONE, A.FOGLIO, A.PARTICELLA, A.SUBALTERNO,
           A.ID_STORICO_PARTICELLA, B.ID_CONDUZIONE_PARTICELLA
      FROM DB_ISTANZA_RIESAME IR, 
           DB_STORICO_PARTICELLA A,
           DB_CONDUZIONE_PARTICELLA B,
           DB_PARTICELLA_CERTIFICATA X,
           DB_UTE F,
           COMUNE G,
           DB_TIPO_CASO_PARTICOLARE CP
     WHERE A.DATA_FINE_VALIDITA IS NULL
       AND NVL(A.ID_CASO_PARTICOLARE,99 )= CP.ID_CASO_PARTICOLARE
       AND CP.EFFETTUA_CONTROLLI_GIS = 'S' 
       AND A.ID_PARTICELLA = B.ID_PARTICELLA
       AND B.ID_TITOLO_POSSESSO <> 5 
       AND B.DATA_FINE_CONDUZIONE IS NULL
       AND B.ID_UTE = F.ID_UTE
       AND F.DATA_FINE_ATTIVITA IS NULL
       AND F.ID_AZIENDA = P_ID_AZIENDA
       AND A.COMUNE = G.ISTAT_COMUNE
       AND A.ID_PARTICELLA = IR.ID_PARTICELLA
       AND A.ID_PARTICELLA = X.ID_PARTICELLA
       AND X.DATA_FINE_VALIDITA IS NULL
       AND IR.ID_AZIENDA = P_ID_AZIENDA
       AND IR.ID_FASE_ISTANZA_RIESAME = knIdFaseIstRiesameInLav
       AND IR.DATA_RICHIESTA = (SELECT MAX(DATA_RICHIESTA)
                                  FROM DB_ISTANZA_RIESAME
                                 WHERE ID_AZIENDA = IR.ID_AZIENDA
                                   AND ID_FASE_ISTANZA_RIESAME = knIdFaseIstRiesameInLav
                                   AND ID_PARTICELLA = IR.ID_PARTICELLA
                                   AND DATA_ANNULLAMENTO IS NULL)
       AND SYSDATE - IR.DATA_EVASIONE > pNumMinGG 
       AND PCK_SMRGAA_LIBRERIA.CALCOLA_P26_CON_TOLLERANZA
                                          (P_ID_AZIENDA,
                                           B.ID_PARTICELLA,
                                           X.ID_PARTICELLA_CERTIFICATA,
                                           pPercP26) > 0
       AND EXISTS (SELECT DC.ID_DOCUMENTO_CONDUZIONE 
                     FROM DB_DOCUMENTO_CONDUZIONE DC,
                          DB_TIPO_CATEGORIA_DOCUMENTO TCD,
                          DB_DOCUMENTO_CATEGORIA DCT,
                          DB_DOCUMENTO D
                    WHERE TCD.IDENTIFICATIVO = knIdentificativoDocRiesame
                      AND TCD.TIPO_IDENTIFICATIVO = 'TC'
                      AND TCD.ID_CATEGORIA_DOCUMENTO = DCT.ID_CATEGORIA_DOCUMENTO
                      AND DCT.ID_DOCUMENTO = D.EXT_ID_DOCUMENTO
                      AND D.EXT_ID_DOCUMENTO IN (SELECT ID_DOCUMENTO
                                                   FROM DB_R_FASE_RIESAME_TP_DOCUMENTO
                                                  WHERE ID_FASE_ISTANZA_RIESAME = knIdFaseIstRiesameInLav
                                                    AND DATA_FINE_VALIDITA IS NULL) 
                      AND SYSDATE BETWEEN D.DATA_INIZIO_VALIDITA AND NVL(D.DATA_FINE_VALIDITA,SYSDATE)
                      AND D.ID_AZIENDA = P_ID_AZIENDA
                      AND D.ID_STATO_DOCUMENTO IS NULL
                      AND D.ID_DOCUMENTO = DC.ID_DOCUMENTO
                      AND DC.ID_CONDUZIONE_PARTICELLA = B.ID_CONDUZIONE_PARTICELLA
                      AND SYSDATE BETWEEN DC.DATA_INIZIO_VALIDITA AND NVL(DC.DATA_FINE_VALIDITA,SYSDATE))
    ORDER BY A.ID_STORICO_PARTICELLA;

    vDescrizione        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
    vChiaveCatastale    VARCHAR2(100);
    nNumMinGG           INTEGER:=0;
    nNumGG              INTEGER:=0;
    dDataPrimoDoc       DATE;
    dDataUltimoDoc      DATE;
    nIdUltimoDoc        DB_DOCUMENTO.ID_DOCUMENTO%TYPE;
    bAnomalia           BOOLEAN:=FALSE;
    nIdOldStorico       DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE:=0;
    nPercP26            NUMBER:=0;
BEGIN
    nNumMinGG := SelectValoreParametro (kvCodParNumMinGGDocRiesame);
    nPercP26 := MY_TO_NUMBER(SelectValoreParametro(kvIdParamPercP26),'999D9999');
    vDescrizione := 'Non è possibile inserire tale particella in un nuovo documento di istanza di riesame in quanto  sono trascorsi ' || nNumMinGG || ' giorni dalla data di ultima lavorazione GIS richesta';

    FOR recPartInP26 IN curPartInP26 (nNumMinGG,nPercP26) LOOP

        vChiaveCatastale := '[' || recPartInP26.DESCOM || ' - Sez : '
                                || recPartInP26.SEZIONE || ' - Fgl : '
                                || recPartInP26.FOGLIO || ' - Part : '
                                || recPartInP26.PARTICELLA || ' - Sub : '
                                || recPartInP26.SUBALTERNO || ' ]';

        IF nIdOldStorico <> recPartInP26.ID_STORICO_PARTICELLA THEN
           nIdOldStorico := recPartInP26.ID_STORICO_PARTICELLA;
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vChiaveCatastale || ' ' || vDescrizione,
                                       P_BLOCCANTE, recPartInP26.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, vChiaveCatastale || ' ' || vDescrizione,
                                               P_BLOCCANTE, recPartInP26.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

    END LOOP;

    RETURN (TRUE);
EXCEPTION
    WHEN OTHERS THEN
        p_MsgErr   := 'ERRORE DOC_RIESAME_MULTIPLI: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
END DOC_RIESAME_MULTIPLI;


FUNCTION DOCUMENTO_PROPRIETARI_VALIDATI (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                          P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                         P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                          P_MSGERR       IN OUT VARCHAR2,
                                         P_CODERR             IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_NUMERO             NUMBER;
N_ID_DOCUMENTO               DB_DOCUMENTO.ID_DOCUMENTO%TYPE;
s_sezione            VARCHAR2(20);
s_sub                VARCHAR2(20);
n_conta_1            NUMBER(10);
n_conta_2            NUMBER(10);
n_conta_3            NUMBER(10);

CURSOR C_PROPRIETARI IS
   SELECT A.CUAA, B.ID_DOCUMENTO, A.FLAG_VALIDATO, C.DESCRIZIONE, B.NUMERO_PROTOCOLLO, B.DATA_PROTOCOLLO
     FROM DB_DOCUMENTO_PROPRIETARIO A, DB_DOCUMENTO B, DB_TIPO_DOCUMENTO C
    WHERE A.ID_DOCUMENTO = B.ID_DOCUMENTO
      AND B.ID_STATO_DOCUMENTO IS NULL
      AND TO_CHAR(NVL(B.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','DD/MM/YYYY')),'YYYYMMDD') > TO_CHAR(SYSDATE,'YYYYMMDD')
      AND B.ID_AZIENDA = P_ID_AZIENDA
      AND C.ID_DOCUMENTO = B.EXT_ID_DOCUMENTO
      AND C.DATA_FINE_VALIDITA IS NULL; --CONTROLLO DEI PROPRIETARI SOLO SU TIPOLOGIE NON SCADUTE. RICHIESTA OPR 27/07/2007

BEGIN
   FOR REC_PROPRIETARI IN C_PROPRIETARI LOOP
          IF NVL(REC_PROPRIETARI.FLAG_VALIDATO,'N') = 'N' THEN
             S_DESCRIZIONE := 'PROPRIETARIO NON VALIDATO SU ANAGRAFE TRIBUTARIA: ' || REC_PROPRIETARI.CUAA;
           IF NOT SCRIVI_SEGNALAZIONE_DOCUMENTO (P_ID_CONTROLLO, S_DESCRIZIONE,
                     P_BLOCCANTE, REC_PROPRIETARI.ID_DOCUMENTO, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;

           S_DESCRIZIONE := S_DESCRIZIONE || ' Doc: '|| REC_PROPRIETARI.DESCRIZIONE || ' Prot. ' || REC_PROPRIETARI.NUMERO_PROTOCOLLO ||
                            ' del ' || TO_CHAR(REC_PROPRIETARI.DATA_PROTOCOLLO,'DD/MM/YYYY');
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
       END IF;
   END LOOP;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE DOCUMENTO_PROPRIETARI_VALIDATI: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END DOCUMENTO_PROPRIETARI_VALIDATI;

FUNCTION DOC_PROPR_DIVERSI_DA_CUAA (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                              P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                             P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                              P_MSGERR       IN OUT VARCHAR2,
                                             P_CODERR             IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_NUMERO             NUMBER;
N_ID_DOCUMENTO               DB_DOCUMENTO.ID_DOCUMENTO%TYPE;
s_sezione            VARCHAR2(20);
s_sub                VARCHAR2(20);
n_conta_1            NUMBER(10);
n_conta_2            NUMBER(10);
n_conta_3            NUMBER(10);

CURSOR C_PROPRIETARI IS
   SELECT A.CUAA, B.ID_DOCUMENTO, A.FLAG_VALIDATO, C.DESCRIZIONE, B.NUMERO_PROTOCOLLO, B.DATA_PROTOCOLLO
     FROM DB_DOCUMENTO_PROPRIETARIO A, DB_DOCUMENTO B, DB_TIPO_DOCUMENTO C, DB_DOCUMENTO_CATEGORIA DC,
           DB_TIPO_CATEGORIA_DOCUMENTO TCD
    WHERE A.ID_DOCUMENTO = B.ID_DOCUMENTO
      AND B.ID_STATO_DOCUMENTO IS NULL
      AND TO_CHAR(NVL(B.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','DD/MM/YYYY')),'YYYYMMDD') > TO_CHAR(SYSDATE,'YYYYMMDD')
      AND B.ID_AZIENDA = P_ID_AZIENDA
      AND C.ID_DOCUMENTO = B.EXT_ID_DOCUMENTO
      AND A.CUAA = B.CUAA
      AND C.DATA_FINE_VALIDITA IS NULL --CONTROLLO DEI PROPRIETARI SOLO SU TIPOLOGIE NON SCADUTE. RICHIESTA OPR 27/07/2007
      AND DC.ID_DOCUMENTO = C.ID_DOCUMENTO
      AND TCD.ID_CATEGORIA_DOCUMENTO IN (1,2,3) --CONTROLLO SOLO I DOC. GIUSTIFICATIVI DELLA CONDUZIONE
      AND TCD.ID_CATEGORIA_DOCUMENTO = DC.ID_CATEGORIA_DOCUMENTO
    GROUP BY A.CUAA, B.ID_DOCUMENTO, A.FLAG_VALIDATO, C.DESCRIZIONE, B.NUMERO_PROTOCOLLO, B.DATA_PROTOCOLLO;

BEGIN
   FOR REC_PROPRIETARI IN C_PROPRIETARI LOOP
       S_DESCRIZIONE := 'Il documento ' || REC_PROPRIETARI.DESCRIZIONE || ' Prot. ' || REC_PROPRIETARI.NUMERO_PROTOCOLLO ||
                        ' del ' || TO_CHAR(REC_PROPRIETARI.DATA_PROTOCOLLO,'DD/MM/YYYY') || ' ha come proprietario il CUAA dell''azienda';

          IF NOT SCRIVI_SEGNALAZIONE_DOCUMENTO (P_ID_CONTROLLO, S_DESCRIZIONE,
                 P_BLOCCANTE, REC_PROPRIETARI.ID_DOCUMENTO, P_MSGERR, P_CODERR) THEN
          RETURN (FALSE);
       END IF;

       IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
          RETURN (FALSE);
       END IF;

   END LOOP;

   RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE DOC_PROPR_DIVERSI_DA_CUAA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END DOC_PROPR_DIVERSI_DA_CUAA;




FUNCTION VALIDA_PROPRIETARI_DOCUMENTO (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                        P_CUAA_PROPRIETARIO IN DB_DOCUMENTO_PROPRIETARIO.CUAA%TYPE,
                                       P_ID_DOCUMENTO_PROPR IN DB_DOCUMENTO_PROPRIETARIO.ID_DOCUMENTO_PROPRIETARIO%TYPE,
                                          P_MSGERR       IN OUT VARCHAR2,
                                          P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

S_CUAA_AT  DB_AZIENDA_TRIBUTARIA.CUAA_ANAGRAFE_TRIBUTARIA%TYPE;
S_FLAG_VALIDATO DB_DOCUMENTO_PROPRIETARIO.FLAG_VALIDATO%TYPE;

BEGIN
    S_FLAG_VALIDATO := NULL;
    S_CUAA_AT        := NULL;

     BEGIN
           SELECT CUAA_ANAGRAFE_TRIBUTARIA
            INTO S_CUAA_AT
            FROM DB_AZIENDA_TRIBUTARIA
           WHERE CUAA = P_CUAA_PROPRIETARIO;
     EXCEPTION
     WHEN NO_DATA_FOUND THEN
           S_CUAA_AT := NULL;
     WHEN OTHERS THEN
           p_MsgErr   := 'ERRORE VALIDA_PROPRIETARI_DOCUMENTO: ' || SQLERRM;
          p_CodErr   := SQLCODE;
           RETURN FALSE;
     END;

     IF S_CUAA_AT IS NOT NULL THEN
         IF S_CUAA_AT = P_CUAA_PROPRIETARIO THEN
           S_FLAG_VALIDATO := 'S';
        ELSE
           S_FLAG_VALIDATO := 'N';
        END IF;
     ELSE
        S_FLAG_VALIDATO := 'N';
     END IF;

     UPDATE DB_DOCUMENTO_PROPRIETARIO SET FLAG_VALIDATO = S_FLAG_VALIDATO
      WHERE ID_DOCUMENTO_PROPRIETARIO = P_ID_DOCUMENTO_PROPR;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'VALIDA_PROPRIETARI_DOCUMENTO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END VALIDA_PROPRIETARI_DOCUMENTO;

FUNCTION DICHIARAZIONI_OBBLIGATORIE (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                       P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DESCRIZIONE        DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
N_CONTATORE            NUMBER(10);
N_CONTATORE_ALLEVAMENTI           NUMBER(10);
N_CONTATORE_TERRENI               NUMBER(10);

BEGIN
     S_DESCRIZIONE := NULL;
     N_CONTATORE_ALLEVAMENTI := 0;
     N_CONTATORE_TERRENI     := 0;

     BEGIN
       SELECT COUNT(*)
        INTO N_CONTATORE_TERRENI
        FROM DB_CONDUZIONE_PARTICELLA CP, DB_UTE U
       WHERE U.ID_AZIENDA = P_ID_AZIENDA
         AND U.ID_UTE = CP.ID_UTE
         AND CP.DATA_FINE_CONDUZIONE IS NULL;
     EXCEPTION
     WHEN OTHERS THEN
           p_MsgErr   := 'ERRORE DICHIARAZIONI_OBBLIGATORIE CONTA TERRENI: ' || SQLERRM;
          p_CodErr   := SQLCODE;
           RETURN FALSE;
     END;

          BEGIN
       SELECT COUNT(*)
        INTO N_CONTATORE_ALLEVAMENTI
        FROM DB_ALLEVAMENTO A, DB_UTE U
       WHERE U.ID_AZIENDA = P_ID_AZIENDA
         AND U.ID_UTE = A.ID_UTE
         AND A.DATA_FINE IS NULL;
     EXCEPTION
     WHEN OTHERS THEN
           p_MsgErr   := 'ERRORE DICHIARAZIONI_OBBLIGATORIE CONTA ALLEVAMENTI: ' || SQLERRM;
          p_CodErr   := SQLCODE;
           RETURN FALSE;
     END;

     BEGIN

        SELECT COUNT(*)
        INTO N_CONTATORE
        FROM     DB_ATTESTAZIONE_AZIENDA    ATT,
                DB_TIPO_ATTESTAZIONE        TIP
        WHERE ATT.ID_AZIENDA                     =     P_ID_AZIENDA
        AND    TIP.ID_ATTESTAZIONE                =    ATT.ID_ATTESTAZIONE
        AND    TIP.CODICE_ATTESTAZIONE            = 'COND'
        AND    TIP.DATA_FINE_VALIDITA            IS NULL;

     EXCEPTION
     WHEN OTHERS THEN
           p_MsgErr   := 'ERRORE DICHIARAZIONI_OBBLIGATORIE: ' || SQLERRM;
          p_CodErr   := SQLCODE;
           RETURN FALSE;
     END;

     IF N_CONTATORE <= 0 THEN
         IF N_CONTATORE_ALLEVAMENTI > 0 OR N_CONTATORE_TERRENI > 0 THEN
          S_DESCRIZIONE := 'NON E'' STATO COMPILATO IL QUADRO DELLE DICHIARAZIONI';
         IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, S_DESCRIZIONE,
                 P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
         END IF;
        END IF;
     END IF;

     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'DICHIARAZIONI_OBBLIGATORIE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END DICHIARAZIONI_OBBLIGATORIE;

-- inizio --

FUNCTION IS_VITIGNO_VARIETA_IN_COMUNE (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                       P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS


v_descom                          COMUNE.DESCOM%TYPE;
v_conta                            NUMBER;
v_descrizione_errore            VARCHAR2(1000);
v_elenco_varieta_altri_vitigni    VARCHAR2(4000);


  vCodUtilizzo      DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;
  vCodDestinazione  DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;
/*
CURSOR cur_unita_vitate IS
SELECT SUA.ID_STORICO_UNITA_ARBOREA, SUA.PROGR_UNAR, SUA.ID_VARIETA, TV.DESCRIZIONE,
       SP.COMUNE, P.ID_PARTICELLA, SP.ID_STORICO_PARTICELLA,
       DECODE(SP.SEZIONE,NULL,NULL,'Sez: '||SP.SEZIONE||' ') SEZIONE,
       DECODE(SP.FOGLIO,NULL,NULL,'Fgl: '||SP.FOGLIO||' ') FOGLIO,
       DECODE(SP.PARTICELLA,NULL,NULL,'Part: '||SP.PARTICELLA||' ') PARTICELLA ,
       DECODE(SP.SUBALTERNO,NULL,NULL,'Sub: '||SP.SUBALTERNO||' ') SUBALTERNO
FROM   DB_STORICO_UNITA_ARBOREA SUA, DB_PARTICELLA P, DB_STORICO_PARTICELLA SP, DB_TIPO_VARIETA TV
WHERE  SUA.ID_PARTICELLA = P.ID_PARTICELLA
AND       P.ID_PARTICELLA = SP.ID_PARTICELLA
AND       SUA.ID_VARIETA = TV.ID_VARIETA
AND       SP.DATA_FINE_VALIDITA IS NULL
AND       SUA.DATA_FINE_VALIDITA IS NULL
AND       SUA.ID_AZIENDA = p_id_azienda
AND       SUA.ID_TIPOLOGIA_UNAR = 2
AND    SUA.ID_UTILIZZO=487;
Considero solamente i comuni piemontesi
*/

CURSOR cur_unita_vitate IS
SELECT SUA.ID_STORICO_UNITA_ARBOREA, SUA.PROGR_UNAR, CMA.ID_VARIETA, TV.DESCRIZIONE,
       SP.COMUNE, P.ID_PARTICELLA, SP.ID_STORICO_PARTICELLA,
       DECODE(SP.SEZIONE,NULL,NULL,'Sez: '||SP.SEZIONE||' ') SEZIONE,
       DECODE(SP.FOGLIO,NULL,NULL,'Fgl: '||SP.FOGLIO||' ') FOGLIO,
       DECODE(SP.PARTICELLA,NULL,NULL,'Part: '||SP.PARTICELLA||' ') PARTICELLA ,
       DECODE(SP.SUBALTERNO,NULL,NULL,'Sub: '||SP.SUBALTERNO||' ') SUBALTERNO
FROM    DB_STORICO_UNITA_ARBOREA SUA, DB_PARTICELLA P, DB_STORICO_PARTICELLA SP,
        DB_TIPO_VARIETA TV, DB_CONDUZIONE_PARTICELLA CO, DB_UTE U, COMUNE CM, PROVINCIA PR,
        DB_R_CATALOGO_MATRICE CMA,DB_TIPO_UTILIZZO TU,DB_TIPO_DESTINAZIONE TD
WHERE  SUA.ID_PARTICELLA = P.ID_PARTICELLA
AND       P.ID_PARTICELLA = SP.ID_PARTICELLA
AND       CMA.ID_VARIETA = TV.ID_VARIETA
AND       SP.DATA_FINE_VALIDITA IS NULL
AND       SUA.DATA_FINE_VALIDITA IS NULL
AND       SUA.ID_AZIENDA = p_id_azienda
AND       SUA.ID_TIPOLOGIA_UNAR = 2
--AND    SUA.ID_UTILIZZO=487
AND    SUA.ID_CATALOGO_MATRICE = CMA.ID_CATALOGO_MATRICE 
AND    CO.ID_PARTICELLA=P.ID_PARTICELLA
AND    CMA.ID_UTILIZZO = TU.ID_UTILIZZO 
AND    TU.CODICE = vCodUtilizzo 
AND    CMA.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE 
AND    TD.CODICE_DESTINAZIONE = vCodDestinazione 
AND       CO.DATA_FINE_CONDUZIONE IS NULL
AND    CO.ID_UTE=U.ID_UTE
AND    U.ID_AZIENDA=SUA.ID_AZIENDA
AND    U.DATA_FINE_ATTIVITA IS NULL
AND    CM.ISTAT_COMUNE = SP.COMUNE
AND    CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
AND    PR.ID_REGIONE = '01' -- SOLO PIEMONTE
GROUP BY SUA.ID_STORICO_UNITA_ARBOREA, SUA.PROGR_UNAR, CMA.ID_VARIETA, TV.DESCRIZIONE,
       SP.COMUNE, P.ID_PARTICELLA, SP.ID_STORICO_PARTICELLA,
       DECODE(SP.SEZIONE,NULL,NULL,'Sez: '||SP.SEZIONE||' '),
       DECODE(SP.FOGLIO,NULL,NULL,'Fgl: '||SP.FOGLIO||' '),
       DECODE(SP.PARTICELLA,NULL,NULL,'Part: '||SP.PARTICELLA||' '),
       DECODE(SP.SUBALTERNO,NULL,NULL,'Sub: '||SP.SUBALTERNO||' ');

CURSOR cur_unita_vitate_altro(p_id_storico_unita_arborea DB_STORICO_UNITA_ARBOREA.ID_STORICO_UNITA_ARBOREA%TYPE) IS
SELECT DISTINCT AV.ID_VARIETA, TV.DESCRIZIONE
FROM   DB_ALTRO_VITIGNO AV, DB_TIPO_VARIETA TV
WHERE  AV.ID_VARIETA = TV.ID_VARIETA
AND       ID_STORICO_UNITA_ARBOREA = p_id_storico_unita_arborea;

CURSOR cur_conduzioni_particella(p_id_particella DB_PARTICELLA.ID_PARTICELLA%TYPE) IS
SELECT CP.ID_CONDUZIONE_PARTICELLA
  FROM DB_CONDUZIONE_PARTICELLA CP, DB_UTE U
 WHERE CP.ID_PARTICELLA = p_id_particella
   AND CP.DATA_FINE_CONDUZIONE IS NULL
   AND CP.ID_UTE = U.ID_UTE
   AND U.DATA_FINE_ATTIVITA IS NULL
   AND U.ID_AZIENDA = P_ID_AZIENDA
   AND CP.ID_TITOLO_POSSESSO NOT IN (5,6);

BEGIN
  SELECT VALORE_STRINGA,VALORE_STRINGA1
  INTO   vCodUtilizzo,vCodDestinazione
  FROM   DB_TIPO_CONTROLLO_PARAMETRO
  WHERE  ID_CONTROLLO = P_ID_CONTROLLO
  AND    SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);

    FOR rec_unita_vitate IN cur_unita_vitate LOOP

        v_descom := NULL;

        BEGIN

            SELECT DESCOM
            INTO   v_descom
            FROM   COMUNE
            WHERE  ISTAT_COMUNE = rec_unita_vitate.COMUNE
            AND       FLAG_ESTINTO = 'N';

        EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
        WHEN TOO_MANY_ROWS THEN
            RETURN NULL;

        END;

        SELECT COUNT(*)
        INTO   v_conta
        FROM   DB_TIPO_VARIETA TV, DB_TIPO_VINO_VARIETA TVV, DB_TIPO_TIPOLOGIA_VINO TTV, DB_TIPO_VINIDOC_COMUNI TVC
        WHERE  TV.ID_VARIETA = TVV.ID_VARIETA
        AND       TVV.ID_TIPOLOGIA_VINO = TTV.ID_TIPOLOGIA_VINO
        AND       TTV.ID_TIPOLOGIA_VINO = TVC.ID_TIPOLOGIA_VINO
        AND       TV.ANNO_FINE_VALIDITA IS NULL
        AND       TTV.DATA_FINE_VALIDITA IS NULL
        AND       TV.ID_VARIETA = rec_unita_vitate.ID_VARIETA
        AND       TVC.ISTAT_COMUNE = rec_unita_vitate.COMUNE;

        IF v_conta = 0 THEN

            v_descrizione_errore := 'Il vitigno principale '||rec_unita_vitate.DESCRIZIONE||
                                      ' dell''unità vitata comune: '||v_descom||', '||
                                      rec_unita_vitate.SEZIONE||rec_unita_vitate.FOGLIO||rec_unita_vitate.PARTICELLA||rec_unita_vitate.SUBALTERNO||
                                      'Progr: '||rec_unita_vitate.PROGR_UNAR||' non è ammesso nel comune della particella ';

            FOR rec_conduzioni_particella IN cur_conduzioni_particella(rec_unita_vitate.ID_PARTICELLA) LOOP
                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                          P_BLOCCANTE, rec_conduzioni_particella.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
                  END IF;
            END LOOP;

            IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                     P_BLOCCANTE, rec_unita_vitate.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
            END IF;

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                   P_BLOCCANTE, rec_unita_vitate.ID_STORICO_PARTICELLA, rec_unita_vitate.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
            END IF;

        END IF;

        v_elenco_varieta_altri_vitigni := NULL;
        FOR rec_unita_vitate_altro IN cur_unita_vitate_altro(rec_unita_vitate.ID_STORICO_UNITA_ARBOREA) LOOP

            SELECT COUNT(*)
            INTO   v_conta
            FROM   DB_TIPO_VARIETA TV, DB_TIPO_VINO_VARIETA TVV, DB_TIPO_TIPOLOGIA_VINO TTV, DB_TIPO_VINIDOC_COMUNI TVC
            WHERE  TV.ID_VARIETA = TVV.ID_VARIETA
            AND       TVV.ID_TIPOLOGIA_VINO = TTV.ID_TIPOLOGIA_VINO
            AND       TTV.ID_TIPOLOGIA_VINO = TVC.ID_TIPOLOGIA_VINO
            AND       TV.ANNO_FINE_VALIDITA IS NULL
            AND       TTV.DATA_FINE_VALIDITA IS NULL
            AND       TV.ID_VARIETA = rec_unita_vitate.ID_VARIETA
            AND       TVC.ISTAT_COMUNE = rec_unita_vitate.COMUNE;

            IF v_conta = 0 THEN

                v_elenco_varieta_altri_vitigni := v_elenco_varieta_altri_vitigni||' '||rec_unita_vitate_altro.DESCRIZIONE;

            END IF;

        END LOOP;

        IF v_elenco_varieta_altri_vitigni IS NOT NULL THEN
            v_descrizione_errore := 'I vitigni secondari '||v_elenco_varieta_altri_vitigni||
                        ' dell''unità vitata comune: '||v_descom||', '||
                        rec_unita_vitate.SEZIONE||rec_unita_vitate.FOGLIO||rec_unita_vitate.PARTICELLA||rec_unita_vitate.SUBALTERNO||
                        'Progr: '||rec_unita_vitate.PROGR_UNAR||' non sono ammessi nel comune della particella';

            FOR rec_conduzioni_particella IN cur_conduzioni_particella(rec_unita_vitate.ID_PARTICELLA) LOOP
                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                          P_BLOCCANTE, rec_conduzioni_particella.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
                  END IF;
            END LOOP;

            IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                     P_BLOCCANTE, rec_unita_vitate.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
            END IF;

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                   P_BLOCCANTE, rec_unita_vitate.ID_STORICO_PARTICELLA, rec_unita_vitate.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
            END IF;

        END IF;

    END LOOP;

    RETURN TRUE;

EXCEPTION

WHEN OTHERS THEN
    p_MsgErr   := 'IS_VITIGNO_VARIETA_IN_COMUNE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN FALSE;

END IS_VITIGNO_VARIETA_IN_COMUNE;
-- fine --

FUNCTION SCHEDARIO_UV_SENZA_VINO (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                       P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

v_descrizione_errore            VARCHAR2(1000);

  vCodUtilizzo      DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;
  vCodDestinazione  DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;

/*
    Considero solamente le schede agronomiche di tipo UV solo piemontesi ed inoltre quelle il cui utilizzo e''  "Uva da vino" che non hanno l'indicazione del vino
*/

CURSOR cur_unita_vitate IS
SELECT     SUA.ID_STORICO_UNITA_ARBOREA,
            SUA.PROGR_UNAR, CMA.ID_VARIETA,
            SP.COMUNE, P.ID_PARTICELLA, SP.ID_STORICO_PARTICELLA, CM.DESCOM,
            DECODE(SP.SEZIONE,NULL,NULL,'Sez: '||SP.SEZIONE||' ') SEZIONE,
            DECODE(SP.FOGLIO,NULL,NULL,'Fgl: '||SP.FOGLIO||' ') FOGLIO,
            DECODE(SP.PARTICELLA,NULL,NULL,'Part: '||SP.PARTICELLA||' ') PARTICELLA ,
            DECODE(SP.SUBALTERNO,NULL,NULL,'Sub: '||SP.SUBALTERNO||' ') SUBALTERNO
FROM     DB_STORICO_UNITA_ARBOREA SUA,
            DB_PARTICELLA P,
            DB_STORICO_PARTICELLA SP,
            DB_CONDUZIONE_PARTICELLA CO,
            DB_UTE U,
            COMUNE CM,
            PROVINCIA PR,DB_R_CATALOGO_MATRICE CMA,DB_TIPO_UTILIZZO TU,DB_TIPO_DESTINAZIONE TD
WHERE      SUA.ID_PARTICELLA = P.ID_PARTICELLA
            AND       P.ID_PARTICELLA = SP.ID_PARTICELLA
            AND       SP.DATA_FINE_VALIDITA IS NULL
            AND       SUA.DATA_FINE_VALIDITA IS NULL
            AND       SUA.ID_AZIENDA = p_id_azienda
            AND       SUA.ID_TIPOLOGIA_UNAR = 2
            AND    SUA.ID_CATALOGO_MATRICE = CMA.ID_CATALOGO_MATRICE 
            AND    CMA.ID_UTILIZZO = TU.ID_UTILIZZO 
            AND    TU.CODICE = vCodUtilizzo 
            AND    CMA.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE 
            AND    TD.CODICE_DESTINAZIONE = vCodDestinazione  
            --AND        SUA.ID_UTILIZZO=487
            AND        CO.ID_PARTICELLA=P.ID_PARTICELLA
            AND       CO.DATA_FINE_CONDUZIONE IS NULL
            AND        CO.ID_UTE=U.ID_UTE
            AND        U.ID_AZIENDA=SUA.ID_AZIENDA
            AND        U.DATA_FINE_ATTIVITA IS NULL
            AND        CM.ISTAT_COMUNE = SP.COMUNE
            AND        CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
            AND        PR.ID_REGIONE = '01' -- SOLO PIEMONTE
            AND        (SUA.id_tipologia_vino IS NULL OR NVL(SUA.SUPERFICIE_DA_ISCRIVERE_ALBO,0) =0)
            GROUP BY SUA.ID_STORICO_UNITA_ARBOREA, SUA.PROGR_UNAR, CMA.ID_VARIETA,
                   SP.COMUNE, P.ID_PARTICELLA, SP.ID_STORICO_PARTICELLA, CM.DESCOM,
                   DECODE(SP.SEZIONE,NULL,NULL,'Sez: '||SP.SEZIONE||' '),
                   DECODE(SP.FOGLIO,NULL,NULL,'Fgl: '||SP.FOGLIO||' '),
                   DECODE(SP.PARTICELLA,NULL,NULL,'Part: '||SP.PARTICELLA||' '),
                   DECODE(SP.SUBALTERNO,NULL,NULL,'Sub: '||SP.SUBALTERNO||' ');

CURSOR cur_conduzioni_particella(p_id_particella DB_PARTICELLA.ID_PARTICELLA%TYPE) IS
SELECT CP.ID_CONDUZIONE_PARTICELLA
  FROM DB_CONDUZIONE_PARTICELLA CP,
       DB_UTE U
 WHERE CP.ID_PARTICELLA = p_id_particella
   AND CP.DATA_FINE_CONDUZIONE IS NULL
   AND CP.ID_UTE = U.ID_UTE
   AND U.DATA_FINE_ATTIVITA IS NULL
   AND U.id_azienda = p_id_azienda
   AND CP.ID_TITOLO_POSSESSO NOT IN (5,6);

BEGIN
  SELECT VALORE_STRINGA,VALORE_STRINGA1
  INTO   vCodUtilizzo,vCodDestinazione
  FROM   DB_TIPO_CONTROLLO_PARAMETRO
  WHERE  ID_CONTROLLO = P_ID_CONTROLLO
  AND    SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);

    FOR rec_unita_vitate IN cur_unita_vitate LOOP

            v_descrizione_errore := '[' || rec_unita_vitate.descom ||', '||
                                      rec_unita_vitate.SEZIONE||rec_unita_vitate.FOGLIO||rec_unita_vitate.PARTICELLA||rec_unita_vitate.SUBALTERNO||
                                      'Progr: '||rec_unita_vitate.PROGR_UNAR||']. Non e'' stata specificata la tipologa di vino oppure la sup.Iscritta all''interno dei dati di iscrizione albo vigneti';

            FOR rec_conduzioni_particella IN cur_conduzioni_particella(rec_unita_vitate.ID_PARTICELLA) LOOP
                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                          P_BLOCCANTE, rec_conduzioni_particella.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
                  END IF;
            END LOOP;

            IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                     P_BLOCCANTE, rec_unita_vitate.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
            END IF;

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                   P_BLOCCANTE, rec_unita_vitate.ID_STORICO_PARTICELLA, rec_unita_vitate.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
            END IF;

    END LOOP;

    RETURN TRUE;

EXCEPTION

WHEN OTHERS THEN
    p_MsgErr   := 'SCHEDARIO_UV_SENZA_VINO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN FALSE;

END SCHEDARIO_UV_SENZA_VINO;
-- fine --

FUNCTION SCHEDARIO_UV_INCOMPLETO (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                       P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

    v_descrizione_errore    VARCHAR2(1000);
    nAnnoApp                INTEGER;

  vCodUtilizzo      DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;
  vCodDestinazione  DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;
    /*
    Considero solamente le schede agronomiche di tipo UV solo piemontesi ed inoltre quelle il cui utilizzo e''  "Uva da vino" che non hanno l'indicazione del vino DOC
    e che risultano mancanti iseguenti dati:Matricola CCIAA, anno Iscrizione Albo, superficie iscritta
    */

     CURSOR cur_unita_vitate IS
     SELECT SUA.ID_STORICO_UNITA_ARBOREA,
            SUA.PROGR_UNAR,
            cmA.ID_VARIETA,
            SP.COMUNE,
            P.ID_PARTICELLA,
            SP.ID_STORICO_PARTICELLA,
            CM.DESCOM,
            DECODE(SP.SEZIONE,NULL,NULL,'Sez: '||SP.SEZIONE||' ') SEZIONE,
            DECODE(SP.FOGLIO,NULL,NULL,'Fgl: '||SP.FOGLIO||' ') FOGLIO,
            DECODE(SP.PARTICELLA,NULL,NULL,'Part: '||SP.PARTICELLA||' ') PARTICELLA ,
            DECODE(SP.SUBALTERNO,NULL,NULL,'Sub: '||SP.SUBALTERNO||' ') SUBALTERNO,
            SUA.ANNO_ISCRIZIONE_ALBO,
            SUA.SUPERFICIE_DA_ISCRIVERE_ALBO,
            TRIM(SUA.MATRICOLA_CCIAA) AS MATRICOLA_CCIAA,
            TCM.ALTRO_PROCEDIMENTO
       FROM DB_STORICO_UNITA_ARBOREA SUA,
            DB_PARTICELLA P,
            DB_STORICO_PARTICELLA SP,
            DB_CONDUZIONE_PARTICELLA CO,
            DB_UTE U,
            COMUNE CM,
            PROVINCIA PR,
            DB_TIPO_TIPOLOGIA_VINO TV,
            DB_TIPO_CAUSALE_MODIFICA TCM,DB_R_CATALOGO_MATRICE CMA,DB_TIPO_UTILIZZO TU,
            DB_TIPO_DESTINAZIONE TD
      WHERE SUA.ID_PARTICELLA = P.ID_PARTICELLA
        AND    P.ID_PARTICELLA = SP.ID_PARTICELLA
        AND    SP.DATA_FINE_VALIDITA IS NULL
        AND SUA.ID_CAUSALE_MODIFICA = TCM.ID_CAUSALE_MODIFICA
        AND    SUA.DATA_FINE_VALIDITA IS NULL
        AND    SUA.ID_AZIENDA = p_id_azienda
        AND    SUA.ID_TIPOLOGIA_UNAR = 2
        --AND SUA.ID_UTILIZZO=487
        AND    SUA.ID_CATALOGO_MATRICE = CMA.ID_CATALOGO_MATRICE 
        AND    CMA.ID_UTILIZZO = TU.ID_UTILIZZO 
        AND    TU.CODICE = vCodUtilizzo 
        AND    CMA.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE 
        AND    TD.CODICE_DESTINAZIONE = vCodDestinazione 
        AND CO.ID_PARTICELLA=P.ID_PARTICELLA
        AND    CO.DATA_FINE_CONDUZIONE IS NULL
        AND CO.ID_UTE=U.ID_UTE
        AND U.ID_AZIENDA=SUA.ID_AZIENDA
        AND U.DATA_FINE_ATTIVITA IS NULL
        AND CM.ISTAT_COMUNE = SP.COMUNE
        AND CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
        AND PR.ID_REGIONE = '01' -- SOLO PIEMONTE
        AND SUA.id_tipologia_vino=TV.id_tipologia_vino
        AND TV.VINO_DOC='S'
        AND (NVL (SUA.ANNO_ISCRIZIONE_ALBO, 0) = 0 OR
             -- NVL (SUA.SUPERFICIE_DA_ISCRIVERE_ALBO, 0) = 0 OR
             (SUA.ANNO_ISCRIZIONE_ALBO <= nAnnoApp AND
              TRIM(SUA.MATRICOLA_CCIAA) IS NULL AND
              TCM.ALTRO_PROCEDIMENTO <> 'S')) --MS 29/06/2011
   GROUP BY SUA.ID_STORICO_UNITA_ARBOREA, SUA.PROGR_UNAR, cmA.ID_VARIETA,SP.COMUNE, P.ID_PARTICELLA,
            SP.ID_STORICO_PARTICELLA, CM.DESCOM,DECODE(SP.SEZIONE,NULL,NULL,'Sez: '||SP.SEZIONE||' '),
            DECODE(SP.FOGLIO,NULL,NULL,'Fgl: '||SP.FOGLIO||' '),DECODE(SP.PARTICELLA,NULL,NULL,'Part: '||SP.PARTICELLA||' '),
            DECODE(SP.SUBALTERNO,NULL,NULL,'Sub: '||SP.SUBALTERNO||' '),SUA.ANNO_ISCRIZIONE_ALBO, SUA.SUPERFICIE_DA_ISCRIVERE_ALBO,
            TRIM(SUA.MATRICOLA_CCIAA),TCM.ALTRO_PROCEDIMENTO;

    CURSOR cur_conduzioni_particella(p_id_particella DB_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT CP.ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA CP,
           DB_UTE U
     WHERE CP.ID_PARTICELLA = P_ID_PARTICELLA
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_UTE = U.ID_UTE
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND U.ID_AZIENDA = P_ID_AZIENDA
       AND CP.ID_TITOLO_POSSESSO NOT IN (5,6);

BEGIN

  SELECT VALORE_STRINGA,VALORE_STRINGA1
   INTO   vCodUtilizzo,vCodDestinazione
   FROM   DB_TIPO_CONTROLLO_PARAMETRO
   WHERE  ID_CONTROLLO = P_ID_CONTROLLO
   AND    SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);

    BEGIN
        nAnnoApp := SelectValoreParametro(kvIdParamAnnoUV11);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             nAnnoApp := TO_CHAR(SYSDATE,'YYYY');
    END;

    FOR rec_unita_vitate IN cur_unita_vitate LOOP

        v_descrizione_errore := '[' || rec_unita_vitate.descom ||', '||
                                       rec_unita_vitate.SEZIONE||rec_unita_vitate.FOGLIO||rec_unita_vitate.PARTICELLA||rec_unita_vitate.SUBALTERNO||
                                      'Progr: '||rec_unita_vitate.PROGR_UNAR||']  Non sono presenti, all''interno dei dati di iscrizione albo vigneti, le seguenti informazioni : ';

        -- se l'anno iscrizione albo è a null do apposita anomalia
        IF rec_unita_vitate.ANNO_ISCRIZIONE_ALBO IS NULL THEN
           v_descrizione_errore := v_descrizione_errore || ' anno iscrizione albo ,';
        ELSE
            -- se è valorizzato controllo la matricola
            IF rec_unita_vitate.MATRICOLA_CCIAA IS NULL AND rec_unita_vitate.ALTRO_PROCEDIMENTO <> 'S' THEN
               v_descrizione_errore := v_descrizione_errore || ' Matricola CCIAA ,';
            END IF;
        END IF;


        /*
        IF rec_unita_vitate.SUPERFICIE_DA_ISCRIVERE_ALBO IS NULL THEN
           v_descrizione_errore := v_descrizione_errore || ' superficie iscritta';
        END IF;
        */
        v_descrizione_errore := SUBSTR(v_descrizione_errore,1,LENGTH(v_descrizione_errore) -1 );

            FOR rec_conduzioni_particella IN cur_conduzioni_particella(rec_unita_vitate.ID_PARTICELLA) LOOP
                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                          P_BLOCCANTE, rec_conduzioni_particella.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
                  END IF;
            END LOOP;

            IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                     P_BLOCCANTE, rec_unita_vitate.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
            END IF;

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                   P_BLOCCANTE, rec_unita_vitate.ID_STORICO_PARTICELLA, rec_unita_vitate.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
            END IF;

    END LOOP;

    RETURN TRUE;

EXCEPTION

WHEN OTHERS THEN
    p_MsgErr   := 'SCHEDARIO_UV_INCOMPLETO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN FALSE;

END SCHEDARIO_UV_INCOMPLETO;
-- fine --

FUNCTION SCHEDARIO_UV_SUP_ISCRITTA (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                       P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

v_descrizione_errore            VARCHAR2(1000);

vCodUtilizzo      DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;
   vCodDestinazione  DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;
/*
    Verifica che la superficie iscritta all'albo sia  minore o uguale  alla relativa sep. vitata.
    Considero solamente le schede agronomiche di tipo UV solo piemontesi ed inoltre quelle il cui utilizzo e''  "Uva da vino"
*/

CURSOR cur_unita_vitate IS
SELECT     SUA.ID_STORICO_UNITA_ARBOREA,
            SUA.PROGR_UNAR, cmA.ID_VARIETA,
            SP.COMUNE, P.ID_PARTICELLA, SP.ID_STORICO_PARTICELLA, CM.DESCOM,
            DECODE(SP.SEZIONE,NULL,NULL,'Sez: '||SP.SEZIONE||' ') SEZIONE,
            DECODE(SP.FOGLIO,NULL,NULL,'Fgl: '||SP.FOGLIO||' ') FOGLIO,
            DECODE(SP.PARTICELLA,NULL,NULL,'Part: '||SP.PARTICELLA||' ') PARTICELLA ,
            DECODE(SP.SUBALTERNO,NULL,NULL,'Sub: '||SP.SUBALTERNO||' ') SUBALTERNO
   FROM     DB_STORICO_UNITA_ARBOREA SUA,
            DB_PARTICELLA P,
            DB_STORICO_PARTICELLA SP,
            DB_CONDUZIONE_PARTICELLA CO,
            DB_UTE U,
            COMUNE CM,
            PROVINCIA PR,DB_R_CATALOGO_MATRICE CMA,DB_TIPO_UTILIZZO TU,DB_TIPO_DESTINAZIONE TD
  WHERE    SUA.ID_PARTICELLA = P.ID_PARTICELLA
    AND       P.ID_PARTICELLA = SP.ID_PARTICELLA
    AND       SP.DATA_FINE_VALIDITA IS NULL
    AND       SUA.DATA_FINE_VALIDITA IS NULL
    AND       SUA.ID_AZIENDA = p_id_azienda
    AND       SUA.ID_TIPOLOGIA_UNAR = 2
    --AND    SUA.ID_UTILIZZO=487
    AND    SUA.ID_CATALOGO_MATRICE = CMA.ID_CATALOGO_MATRICE 
    AND    CMA.ID_UTILIZZO = TU.ID_UTILIZZO 
    AND    TU.CODICE = vCodUtilizzo 
    AND    CMA.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE 
    AND    TD.CODICE_DESTINAZIONE = vCodDestinazione 
    AND    CO.ID_TITOLO_POSSESSO NOT IN (5,6) 
    AND    CO.ID_PARTICELLA=P.ID_PARTICELLA
    AND       CO.DATA_FINE_CONDUZIONE IS NULL
    AND    CO.ID_UTE=U.ID_UTE
    AND    U.ID_AZIENDA=SUA.ID_AZIENDA
    AND    U.DATA_FINE_ATTIVITA IS NULL
    AND    CM.ISTAT_COMUNE = SP.COMUNE
    AND    CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
    AND    PR.ID_REGIONE = '01' -- SOLO PIEMONTE
    AND       NVL (SUA.SUPERFICIE_DA_ISCRIVERE_ALBO, 0) >NVL(SUA.AREA,0)
    GROUP BY SUA.ID_STORICO_UNITA_ARBOREA, SUA.PROGR_UNAR, cmA.ID_VARIETA,
           SP.COMUNE, P.ID_PARTICELLA, SP.ID_STORICO_PARTICELLA, CM.DESCOM,
           DECODE(SP.SEZIONE,NULL,NULL,'Sez: '||SP.SEZIONE||' '),
           DECODE(SP.FOGLIO,NULL,NULL,'Fgl: '||SP.FOGLIO||' '),
           DECODE(SP.PARTICELLA,NULL,NULL,'Part: '||SP.PARTICELLA||' '),
           DECODE(SP.SUBALTERNO,NULL,NULL,'Sub: '||SP.SUBALTERNO||' ');

CURSOR cur_conduzioni_particella(p_id_particella DB_PARTICELLA.ID_PARTICELLA%TYPE) IS
SELECT CP.ID_CONDUZIONE_PARTICELLA
  FROM DB_CONDUZIONE_PARTICELLA CP,
       DB_UTE U
 WHERE CP.ID_PARTICELLA = p_id_particella
   AND CP.DATA_FINE_CONDUZIONE IS NULL
   AND CP.ID_UTE = U.ID_UTE
   AND U.DATA_FINE_ATTIVITA IS NULL
   AND U.ID_AZIENDA = p_id_azienda
   AND CP.ID_TITOLO_POSSESSO NOT IN (5,6);

BEGIN

SELECT VALORE_STRINGA,VALORE_STRINGA1
   INTO   vCodUtilizzo,vCodDestinazione
   FROM   DB_TIPO_CONTROLLO_PARAMETRO
   WHERE  ID_CONTROLLO = P_ID_CONTROLLO
   AND    SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);

    FOR rec_unita_vitate IN cur_unita_vitate LOOP

            v_descrizione_errore := '[' || rec_unita_vitate.descom ||', '||
                                      rec_unita_vitate.SEZIONE||rec_unita_vitate.FOGLIO||rec_unita_vitate.PARTICELLA||rec_unita_vitate.SUBALTERNO||
                                      'Progr: '||rec_unita_vitate.PROGR_UNAR||']. La superficie iscritta all''Albo risulta maggiore di quella vitata.';

            FOR rec_conduzioni_particella IN cur_conduzioni_particella(rec_unita_vitate.ID_PARTICELLA) LOOP
                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                          P_BLOCCANTE, rec_conduzioni_particella.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
                  END IF;
            END LOOP;

            IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                     P_BLOCCANTE, rec_unita_vitate.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
            END IF;

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                   P_BLOCCANTE, rec_unita_vitate.ID_STORICO_PARTICELLA, rec_unita_vitate.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
            END IF;

    END LOOP;

    RETURN TRUE;

EXCEPTION

WHEN OTHERS THEN
    p_MsgErr   := 'SCHEDARIO_UV_SUP_ISCRITTA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN FALSE;

END SCHEDARIO_UV_SUP_ISCRITTA;
-- fine --


FUNCTION SCHEDARIO_UV_ALBO_CCIAA (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                       P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

v_descrizione_errore            VARCHAR2(1000);

vCodUtilizzo      DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;
   vCodDestinazione  DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;

/*
    Verifica che le uv DOC presenti a schedario siano presenti anche all'Albo vigneti CCIAA per idati catastali, albo, anno impianto, superficie iscritta.
    Considero solamente le schede agronomiche di tipo UV DOC solo piemontesi ed inoltre quelle il cui utilizzo e''  "Uva da vino"
*/


CURSOR cur_unita_vitate IS
SELECT     SUA.ID_STORICO_UNITA_ARBOREA,
        SUA.PROGR_UNAR, CMA.ID_VARIETA,
        SP.COMUNE, P.ID_PARTICELLA, SP.ID_STORICO_PARTICELLA, CM.DESCOM,
        DECODE(SP.SEZIONE,NULL,NULL,'Sez: '||SP.SEZIONE||' ') SEZIONE,
        DECODE(SP.FOGLIO,NULL,NULL,'Fgl: '||SP.FOGLIO||' ') FOGLIO,
        DECODE(SP.PARTICELLA,NULL,NULL,'Part: '||SP.PARTICELLA||' ') PARTICELLA ,
        DECODE(SP.SUBALTERNO,NULL,NULL,'Sub: '||SP.SUBALTERNO||' ') SUBALTERNO,
        VA.DESCRIZIONE VITIGNO,
        tv.DESCRIZIONE ALBO
FROM    DB_STORICO_UNITA_ARBOREA SUA,
        DB_PARTICELLA P,
        DB_STORICO_PARTICELLA SP,
        DB_CONDUZIONE_PARTICELLA CO,
        DB_UTE U,
        COMUNE CM,
        PROVINCIA PR,
        DB_TIPO_TIPOLOGIA_VINO TV,
        DB_TIPO_VINO_CCIAA_SIAP CS,
        DB_TIPO_CCIAA_ALBO_VIGNETO CA,
        DB_TIPO_VARIETA                VA,
      (
      SELECT
            CA.DESCRIZIONE AS ALBO,
            SUA.ANNO_IMPIANTO AS ANNO,
            SUA.SUPERFICIE_DA_ISCRIVERE_ALBO SUPERFICIE,
            SP.COMUNE,
            SP.SEZIONE,
            SP.FOGLIO,
            SP.PARTICELLA,
            SP.SUBALTERNO
      FROM
            DB_STORICO_UNITA_ARBOREA SUA,
            DB_PARTICELLA P,
            DB_STORICO_PARTICELLA SP,
            DB_CONDUZIONE_PARTICELLA CO,
            DB_UTE U,
            COMUNE CM,
            PROVINCIA PR,
            DB_TIPO_TIPOLOGIA_VINO TV,
            DB_TIPO_VINO_CCIAA_SIAP CS,
            DB_TIPO_CCIAA_ALBO_VIGNETO CA,DB_R_CATALOGO_MATRICE CMA,DB_TIPO_UTILIZZO TU,
            DB_TIPO_DESTINAZIONE TD
      WHERE    SUA.ID_PARTICELLA = P.ID_PARTICELLA
        AND       P.ID_PARTICELLA = SP.ID_PARTICELLA
        AND       SP.DATA_FINE_VALIDITA IS NULL
        AND       SUA.DATA_FINE_VALIDITA IS NULL
        AND       SUA.ID_AZIENDA = p_id_azienda
        AND       SUA.ID_TIPOLOGIA_UNAR = 2
        --AND    SUA.ID_UTILIZZO=487
        AND    SUA.ID_CATALOGO_MATRICE = CMA.ID_CATALOGO_MATRICE 
        AND    CMA.ID_UTILIZZO = TU.ID_UTILIZZO 
        AND    TU.CODICE = vCodUtilizzo 
        AND    CMA.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE 
        AND    TD.CODICE_DESTINAZIONE = vCodDestinazione 
        AND    CO.ID_TITOLO_POSSESSO NOT IN (5,6) 
        AND    CO.ID_PARTICELLA=P.ID_PARTICELLA
        AND       CO.DATA_FINE_CONDUZIONE IS NULL
        AND    CO.ID_UTE=U.ID_UTE
        AND    U.ID_AZIENDA=SUA.ID_AZIENDA
        AND    U.DATA_FINE_ATTIVITA IS NULL
        AND    CM.ISTAT_COMUNE = SP.COMUNE
        AND    CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
        AND    PR.ID_REGIONE = '01' -- SOLO PIEMONTE
        AND    SUA.id_tipologia_vino=TV.id_tipologia_vino
        AND    TV.VINO_DOC='S'
        AND    CS.ID_TIPOLOGIA_VINO =SUA.id_tipologia_vino
        AND    CS.DATA_FINE_VALIDITA  IS NULL
        AND    CS.ID_CCIAA_ALBO_VIGNETO=CA.ID_CCIAA_ALBO_VIGNETO
        AND    CA.DATA_FINE_VALIDITA IS NULL
    GROUP BY
      CA.DESCRIZIONE,
      SUA.ANNO_IMPIANTO,
      SUA.SUPERFICIE_DA_ISCRIVERE_ALBO,
      SP.COMUNE,
      SP.SEZIONE,
      SP.FOGLIO,
      SP.PARTICELLA,
      SP.SUBALTERNO
      MINUS
      SELECT
            CD.DESC_ALBO ALBO,
            CD.ANNO_IMPIANTO ANNO,
            CD.SUPERFICIE,
            CD.ISTAT_COMUNE COMUNE,
            CD.SEZIONE,
            CD.FOGLIO,
            CD.PARTICELLA,
            CD.SUBALTERNO
      FROM
              DB_CCIAA_ALBO_DETTAGLIO CD,
              DB_CCIAA_ALBO_VIGNETI AV
      WHERE   AV.id_azienda=p_id_azienda
              AND AV.id_cciaa_albo_vigneti=CD.id_cciaa_albo_vigneti
      GROUP BY      CD.DESC_ALBO ,
                    CD.ANNO_IMPIANTO ,
                    CD.SUPERFICIE,
                    CD.ISTAT_COMUNE ,
                    CD.SEZIONE,
                    CD.FOGLIO,
                    CD.PARTICELLA,
                    CD.SUBALTERNO
      ) UV_NO_ALBO,DB_R_CATALOGO_MATRICE CMA,DB_TIPO_UTILIZZO TU,DB_TIPO_DESTINAZIONE TD
WHERE      SUA.ID_PARTICELLA = P.ID_PARTICELLA
    AND       P.ID_PARTICELLA = SP.ID_PARTICELLA
    AND       SP.DATA_FINE_VALIDITA IS NULL
    AND       SUA.DATA_FINE_VALIDITA IS NULL
    AND       SUA.ID_AZIENDA = p_id_azienda
    AND       SUA.ID_TIPOLOGIA_UNAR = 2
    --AND    SUA.ID_UTILIZZO=487
    AND    SUA.ID_CATALOGO_MATRICE = CMA.ID_CATALOGO_MATRICE 
    AND    CMA.ID_UTILIZZO = TU.ID_UTILIZZO 
    AND    TU.CODICE = vCodUtilizzo 
    AND    CMA.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE 
    AND    TD.CODICE_DESTINAZIONE = vCodDestinazione 
    AND    CO.ID_TITOLO_POSSESSO NOT IN (5,6) 
    AND    CO.ID_PARTICELLA=P.ID_PARTICELLA
    AND       CO.DATA_FINE_CONDUZIONE IS NULL
    AND    CO.ID_UTE=U.ID_UTE
    AND    U.ID_AZIENDA=SUA.ID_AZIENDA
    AND    U.DATA_FINE_ATTIVITA IS NULL
    AND    CM.ISTAT_COMUNE = SP.COMUNE
    AND    CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
    AND    PR.ID_REGIONE = '01' -- SOLO PIEMONTE
    AND    SUA.id_tipologia_vino=TV.id_tipologia_vino
    AND    TV.VINO_DOC='S'
    AND    CS.ID_TIPOLOGIA_VINO =SUA.id_tipologia_vino
    AND    CS.DATA_FINE_VALIDITA  IS NULL
    AND    CS.ID_CCIAA_ALBO_VIGNETO=CA.ID_CCIAA_ALBO_VIGNETO
    AND    CA.DATA_FINE_VALIDITA IS NULL
    AND       UV_NO_ALBO.ALBO=CA.DESCRIZIONE
    AND    UV_NO_ALBO.ANNO=SUA.ANNO_IMPIANTO
    AND    UV_NO_ALBO.SUPERFICIE=SUA.SUPERFICIE_DA_ISCRIVERE_ALBO
    AND    UV_NO_ALBO.COMUNE=SP.COMUNE
    AND    NVL(UV_NO_ALBO.SEZIONE,' ')=NVL(SP.SEZIONE,' ')
    AND    UV_NO_ALBO.FOGLIO=SP.FOGLIO
    AND    UV_NO_ALBO.PARTICELLA=SP.PARTICELLA
    AND    NVL(UV_NO_ALBO.SUBALTERNO,' ')=NVL(SP.SUBALTERNO,' ')
    AND       VA.ID_VARIETA = CMA.ID_VARIETA
GROUP BY SUA.ID_STORICO_UNITA_ARBOREA, SUA.PROGR_UNAR, CMA.ID_VARIETA,
        SP.COMUNE, P.ID_PARTICELLA, SP.ID_STORICO_PARTICELLA, CM.DESCOM,
        DECODE(SP.SEZIONE,NULL,NULL,'Sez: '||SP.SEZIONE||' '),
        DECODE(SP.FOGLIO,NULL,NULL,'Fgl: '||SP.FOGLIO||' '),
        DECODE(SP.PARTICELLA,NULL,NULL,'Part: '||SP.PARTICELLA||' '),
        DECODE(SP.SUBALTERNO,NULL,NULL,'Sub: '||SP.SUBALTERNO||' '),
        VA.DESCRIZIONE,
        TV.DESCRIZIONE;

CURSOR cur_conduzioni_particella(p_id_particella DB_PARTICELLA.ID_PARTICELLA%TYPE) IS
SELECT CP.ID_CONDUZIONE_PARTICELLA
  FROM DB_CONDUZIONE_PARTICELLA CP,
       DB_UTE U
 WHERE CP.ID_PARTICELLA = p_id_particella
   AND CP.DATA_FINE_CONDUZIONE IS NULL
   AND CP.ID_UTE = U.ID_UTE
   AND U.DATA_FINE_ATTIVITA IS NULL
   AND U.ID_AZIENDA = p_id_azienda
   AND CP.ID_TITOLO_POSSESSO NOT IN (5,6);

BEGIN

    FOR rec_unita_vitate IN cur_unita_vitate LOOP

            v_descrizione_errore := '[' || rec_unita_vitate.descom ||', '||
                                      rec_unita_vitate.SEZIONE||rec_unita_vitate.FOGLIO||rec_unita_vitate.PARTICELLA||rec_unita_vitate.SUBALTERNO||
                                      'Progr: '||rec_unita_vitate.PROGR_UNAR||']. L''unita'' vitata con vitigno '||rec_unita_vitate.VITIGNO||' non risulta essere iscritta all''Albo viticolo del '||rec_unita_vitate.ALBO||'.';

            FOR rec_conduzioni_particella IN cur_conduzioni_particella(rec_unita_vitate.ID_PARTICELLA) LOOP
                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                          P_BLOCCANTE, rec_conduzioni_particella.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
                  END IF;
            END LOOP;

            IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                     P_BLOCCANTE, rec_unita_vitate.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
            END IF;

            IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                   P_BLOCCANTE, rec_unita_vitate.ID_STORICO_PARTICELLA, rec_unita_vitate.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
            END IF;

    END LOOP;

    RETURN TRUE;

EXCEPTION

WHEN OTHERS THEN
    p_MsgErr   := 'SCHEDARIO_UV_ALBO_CCIAA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN FALSE;

END SCHEDARIO_UV_ALBO_CCIAA;


FUNCTION ALBO_CCIAA_SCHEDARIO_UV (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                       P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

v_descrizione_errore            VARCHAR2(1000);
vCodUtilizzo      DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;
   vCodDestinazione  DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;
/*
    Verifica che le uv DOC presenti a schedario siano presenti anche all'Albo vigneti CCIAA per idati catastali, albo, anno impianto, superficie iscritta.
    Considero solamente le schede agronomiche di tipo UV DOC solo piemontesi ed inoltre quelle il cui utilizzo e''  "Uva da vino"
*/

CURSOR cur_albo_cciaa IS
SELECT
        CCIAA.ALBO,
        CCIAA.ANNO,
        CCIAA.SUPERFICIE,
        CCIAA.COMUNE,
        CCIAA.DESCOM,
        DECODE(CCIAA.SEZIONE,NULL,NULL,'Sez: '||CCIAA.SEZIONE||' ') SEZIONE,
        DECODE(CCIAA.FOGLIO,NULL,NULL,'Fgl: '||CCIAA.FOGLIO||' ') FOGLIO,
        DECODE(CCIAA.PARTICELLA,NULL,NULL,'Part: '||CCIAA.PARTICELLA||' ') PARTICELLA ,
        DECODE(CCIAA.SUBALTERNO,NULL,NULL,'Sub: '||CCIAA.SUBALTERNO||' ') SUBALTERNO,
    (
    SELECT     MAX(SP.ID_STORICO_PARTICELLA)
    FROM    DB_PARTICELLA P,
            DB_STORICO_PARTICELLA SP,
            DB_CONDUZIONE_PARTICELLA CO,
            DB_UTE U,
            COMUNE CM,
            PROVINCIA PR
    WHERE P.ID_PARTICELLA = SP.ID_PARTICELLA
          AND       SP.DATA_FINE_VALIDITA IS NULL
          AND        CO.ID_PARTICELLA=P.ID_PARTICELLA
          AND       CO.DATA_FINE_CONDUZIONE IS NULL
          AND        CO.ID_UTE=U.ID_UTE
          AND        U.DATA_FINE_ATTIVITA IS NULL
          AND     u.id_azienda=p_id_azienda
          AND        CM.ISTAT_COMUNE = SP.COMUNE
          AND        CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
          AND        PR.ID_REGIONE = '01' -- SOLO PIEMONTE;
          AND     sp.COMUNE=CCIAA.COMUNE
          AND     NVL(sp.sezione,' ')=NVL(CCIAA.SEZIONE, ' ')
          AND     sp.foglio=CCIAA.FOGLIO
          AND     SP.particella=CCIAA.PARTICELLA
          AND     NVL(SP.subalterno,' ')=NVL(CCIAA.SUBALTERNO,' ')
    ) AS ID_STORICO_PARTICELLA
FROM (
      SELECT
                CD.DESC_ALBO ALBO,
                CD.ANNO_IMPIANTO ANNO,
                CD.SUPERFICIE,
                CD.ISTAT_COMUNE COMUNE,
                CM.DESCOM,
                CD.SEZIONE,
                CD.FOGLIO,
                CD.PARTICELLA,
                CD.SUBALTERNO
      FROM
              DB_CCIAA_ALBO_DETTAGLIO CD,
              DB_CCIAA_ALBO_VIGNETI AV,
                  COMUNE CM
      WHERE   AV.id_azienda=p_id_azienda
              AND AV.id_cciaa_albo_vigneti=CD.id_cciaa_albo_vigneti
                  AND CM.ISTAT_COMUNE=CD.ISTAT_COMUNE
      GROUP BY          CD.DESC_ALBO ,
                            CD.ANNO_IMPIANTO ,
                            CD.SUPERFICIE,
                            CD.ISTAT_COMUNE ,
                            CM.DESCOM ,
                            CD.SEZIONE,
                            CD.FOGLIO,
                            CD.PARTICELLA,
                            CD.SUBALTERNO
      MINUS
      SELECT
        CA.DESCRIZIONE AS ALBO,
        SUA.ANNO_IMPIANTO AS ANNO,
        SUA.SUPERFICIE_DA_ISCRIVERE_ALBO SUPERFICIE,
        SP.COMUNE,
                CM.DESCOM,
                SP.SEZIONE,
                SP.FOGLIO,
                SP.PARTICELLA,
                SP.SUBALTERNO
      FROM
            DB_STORICO_UNITA_ARBOREA SUA,
            DB_PARTICELLA P,
            DB_STORICO_PARTICELLA SP,
            DB_CONDUZIONE_PARTICELLA CO,
            DB_UTE U,
            COMUNE CM,
            PROVINCIA PR,
            DB_TIPO_TIPOLOGIA_VINO TV,
            DB_TIPO_VINO_CCIAA_SIAP CS,
            DB_TIPO_CCIAA_ALBO_VIGNETO CA,DB_R_CATALOGO_MATRICE CMA,DB_TIPO_UTILIZZO TU,
            DB_TIPO_DESTINAZIONE TD
      WHERE      SUA.ID_PARTICELLA = P.ID_PARTICELLA
            AND       P.ID_PARTICELLA = SP.ID_PARTICELLA
            AND       SP.DATA_FINE_VALIDITA IS NULL
            AND       SUA.DATA_FINE_VALIDITA IS NULL
            AND       SUA.ID_AZIENDA = p_id_azienda
            AND       SUA.ID_TIPOLOGIA_UNAR = 2
            --AND    SUA.ID_UTILIZZO=487
             AND    SUA.ID_CATALOGO_MATRICE = CMA.ID_CATALOGO_MATRICE 
            AND    CMA.ID_UTILIZZO = TU.ID_UTILIZZO 
            AND    TU.CODICE = vCodUtilizzo 
            AND    CMA.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE 
            AND    TD.CODICE_DESTINAZIONE = vCodDestinazione 
            AND    CO.ID_PARTICELLA=P.ID_PARTICELLA
            AND       CO.DATA_FINE_CONDUZIONE IS NULL
            AND    CO.ID_UTE=U.ID_UTE
            AND    U.ID_AZIENDA=SUA.ID_AZIENDA
            AND    U.DATA_FINE_ATTIVITA IS NULL
            AND    CM.ISTAT_COMUNE = SP.COMUNE
            AND    CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
            AND    PR.ID_REGIONE = '01' -- SOLO PIEMONTE
            AND    SUA.id_tipologia_vino=TV.id_tipologia_vino
            AND      TV.VINO_DOC='S'
            AND    CS.ID_TIPOLOGIA_VINO =SUA.id_tipologia_vino
            AND    CS.DATA_FINE_VALIDITA  IS NULL
            AND    CS.ID_CCIAA_ALBO_VIGNETO=CA.ID_CCIAA_ALBO_VIGNETO
            AND    CA.DATA_FINE_VALIDITA IS NULL
            GROUP BY
                    CA.DESCRIZIONE,
                    SUA.ANNO_IMPIANTO,
                    SUA.SUPERFICIE_DA_ISCRIVERE_ALBO,
                    SP.COMUNE,
                    CM.DESCOM,
                    SP.SEZIONE,
                    SP.FOGLIO,
                    SP.PARTICELLA,
                    SP.SUBALTERNO) CCIAA;

CURSOR cur_conduzioni_particella(p_id_storico_particella DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE) IS
SELECT CP.ID_CONDUZIONE_PARTICELLA
  FROM DB_CONDUZIONE_PARTICELLA CP,
       DB_UTE U,
       DB_STORICO_PARTICELLA SP
 WHERE SP.ID_STORICO_PARTICELLA= p_id_storico_particella
   AND CP.ID_PARTICELLA =SP.ID_PARTICELLA
   AND CP.DATA_FINE_CONDUZIONE IS NULL
   AND CP.ID_UTE = U.ID_UTE
   AND U.DATA_FINE_ATTIVITA IS NULL
   AND U.ID_AZIENDA = p_id_azienda
   AND CP.ID_TITOLO_POSSESSO NOT IN (5,6);


CURSOR cur_unita_uv(p_id_storico_particella DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE) IS
SELECT SUA.ID_STORICO_UNITA_ARBOREA
FROM
        DB_STORICO_UNITA_ARBOREA SUA,
        DB_STORICO_PARTICELLA SP,
        DB_CONDUZIONE_PARTICELLA CO,
        DB_UTE U,
        COMUNE CM,
        PROVINCIA PR,DB_R_CATALOGO_MATRICE CMA,DB_TIPO_UTILIZZO TU,DB_TIPO_DESTINAZIONE TD
WHERE      SP.ID_STORICO_PARTICELLA = p_id_storico_particella
        AND       SUA.ID_PARTICELLA = SP.ID_PARTICELLA
        AND       SP.DATA_FINE_VALIDITA IS NULL
        AND       SUA.DATA_FINE_VALIDITA IS NULL
        AND       SUA.ID_AZIENDA = p_id_azienda
        AND       SUA.ID_TIPOLOGIA_UNAR = 2
        --AND    SUA.ID_UTILIZZO=487
        AND    SUA.ID_CATALOGO_MATRICE = CMA.ID_CATALOGO_MATRICE 
        AND    CMA.ID_UTILIZZO = TU.ID_UTILIZZO 
        AND    TU.CODICE = vCodUtilizzo 
        AND    CMA.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE 
        AND    TD.CODICE_DESTINAZIONE = vCodDestinazione 
        AND    CO.ID_PARTICELLA=SP.ID_PARTICELLA
        AND     CO.DATA_FINE_CONDUZIONE IS NULL
        AND    CO.ID_UTE=U.ID_UTE
        AND    U.ID_AZIENDA=SUA.ID_AZIENDA
        AND    U.DATA_FINE_ATTIVITA IS NULL
        AND    CM.ISTAT_COMUNE = SP.COMUNE
        AND    CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
        AND    PR.ID_REGIONE = '01'; -- SOLO PIEMONTE

BEGIN
SELECT VALORE_STRINGA,VALORE_STRINGA1
   INTO   vCodUtilizzo,vCodDestinazione
   FROM   DB_TIPO_CONTROLLO_PARAMETRO
   WHERE  ID_CONTROLLO = P_ID_CONTROLLO
   AND    SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);

    FOR rec_albo_cciaa IN cur_albo_cciaa LOOP

            v_descrizione_errore := '[' || rec_albo_cciaa.descom ||', ';
            v_descrizione_errore := v_descrizione_errore || rec_albo_cciaa.SEZIONE;
            v_descrizione_errore := v_descrizione_errore || rec_albo_cciaa.FOGLIO;
            v_descrizione_errore := v_descrizione_errore || rec_albo_cciaa.PARTICELLA;
            v_descrizione_errore := v_descrizione_errore || rec_albo_cciaa.SUBALTERNO;
            v_descrizione_errore := v_descrizione_errore || ']. L''unita vitata iscritta all''albo vigneti del ';
            v_descrizione_errore := v_descrizione_errore || rec_albo_cciaa.ALBO || ' con sup. Iscritta: ';
            v_descrizione_errore := v_descrizione_errore || TRIM(TO_CHAR(NVL(rec_albo_cciaa.SUPERFICIE,0),'999G990D9999')) || ' (ha), anno impianto: ';
            v_descrizione_errore := v_descrizione_errore || NVL(TO_CHAR(rec_albo_cciaa.ANNO),' ') ||', non risulta presente all''interno dello Schedario Viticolo';

            FOR rec_unita_uv IN cur_unita_uv(rec_albo_cciaa.ID_STORICO_PARTICELLA) LOOP
                IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                        P_BLOCCANTE, rec_albo_cciaa.ID_STORICO_PARTICELLA, rec_unita_uv.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
                END IF;

                IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                         P_BLOCCANTE, rec_unita_uv.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
                END IF;
            END LOOP;

            FOR rec_conduzioni_particella IN cur_conduzioni_particella(rec_albo_cciaa.ID_STORICO_PARTICELLA) LOOP
                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                          P_BLOCCANTE, rec_conduzioni_particella.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
                  END IF;
            END LOOP;

    END LOOP;

    RETURN TRUE;

EXCEPTION

WHEN OTHERS THEN
    p_MsgErr   := 'ALBO_CCIAA_SCHEDARIO_UV: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN FALSE;

END ALBO_CCIAA_SCHEDARIO_UV;


FUNCTION SCHEDARIO_UV_ALBO_SUP_ISCRITTA (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                       P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE      IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR           IN OUT VARCHAR2) RETURN BOOLEAN IS

v_descrizione_errore            VARCHAR2(1000);

nSuperficie_SIAP                DB_STORICO_UNITA_ARBOREA.SUPERFICIE_DA_ISCRIVERE_ALBO%TYPE;
vCodUtilizzo      DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;
   vCodDestinazione  DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;
/*
    Verifica che, per ogni albo, la somma della superficie iscritta dichiarata in SIAP sia uguale a quella presente sull'albo viticolo CCIAA
    Considero solamente le schede agronomiche di tipo UV DOC solo piemontesi ed inoltre quelle il cui utilizzo e''  "Uva da vino"
*/

CURSOR cur_albo_CCIAA IS
      SELECT     CD.DESC_ALBO,
                    NVL(SUM(NVL(CD.SUPERFICIE,0)),0) SUPERFICIE_CCIAA
      FROM    DB_CCIAA_ALBO_DETTAGLIO CD,
              DB_CCIAA_ALBO_VIGNETI AV
      WHERE   AV.id_azienda=p_id_azienda
              AND AV.id_cciaa_albo_vigneti=CD.id_cciaa_albo_vigneti
      GROUP BY   CD.DESC_ALBO
      ORDER BY DESC_ALBO;

BEGIN
SELECT VALORE_STRINGA,VALORE_STRINGA1
   INTO   vCodUtilizzo,vCodDestinazione
   FROM   DB_TIPO_CONTROLLO_PARAMETRO
   WHERE  ID_CONTROLLO = P_ID_CONTROLLO
   AND    SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);

    FOR rec_albo_cciaa IN cur_albo_CCIAA LOOP
            BEGIN
                SELECT NVL(SUM(NVL(SUA.SUPERFICIE_DA_ISCRIVERE_ALBO,0)),0)
                        INTO nSuperficie_SIAP
              FROM
                    DB_STORICO_UNITA_ARBOREA SUA,
                    DB_STORICO_PARTICELLA SP,
                    DB_CONDUZIONE_PARTICELLA CO,
                    DB_UTE U,
                    COMUNE CM,
                    PROVINCIA PR,
                    DB_TIPO_TIPOLOGIA_VINO TV,
                    DB_TIPO_VINO_CCIAA_SIAP CS,
                    DB_TIPO_CCIAA_ALBO_VIGNETO CA,DB_R_CATALOGO_MATRICE CMA,DB_TIPO_UTILIZZO TU,
                    DB_TIPO_DESTINAZIONE TD
              WHERE      SUA.ID_PARTICELLA = SP.ID_PARTICELLA
                    AND       SP.DATA_FINE_VALIDITA IS NULL
                    AND       SUA.DATA_FINE_VALIDITA IS NULL
                    AND       SUA.ID_AZIENDA = p_id_azienda
                    AND       SUA.ID_TIPOLOGIA_UNAR = 2
                    --AND    SUA.ID_UTILIZZO=487
                    AND    SUA.ID_CATALOGO_MATRICE = CMA.ID_CATALOGO_MATRICE 
                    AND    CMA.ID_UTILIZZO = TU.ID_UTILIZZO 
                    AND    TU.CODICE = vCodUtilizzo 
                    AND    CMA.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE 
                    AND    TD.CODICE_DESTINAZIONE = vCodDestinazione 
                    AND    CO.ID_PARTICELLA=SP.ID_PARTICELLA
                    AND       CO.DATA_FINE_CONDUZIONE IS NULL
                    AND    CO.ID_UTE=U.ID_UTE
                    AND    U.ID_AZIENDA=SUA.ID_AZIENDA
                    AND    U.DATA_FINE_ATTIVITA IS NULL
                    AND    CM.ISTAT_COMUNE = SP.COMUNE
                    AND    CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
                    AND    PR.ID_REGIONE = '01' -- SOLO PIEMONTE
                    AND    SUA.id_tipologia_vino=TV.id_tipologia_vino
                    AND      TV.VINO_DOC='S'
                    AND    CS.ID_TIPOLOGIA_VINO =SUA.id_tipologia_vino
                    AND    CS.DATA_FINE_VALIDITA  IS NULL
                    AND    CS.ID_CCIAA_ALBO_VIGNETO=CA.ID_CCIAA_ALBO_VIGNETO
                    AND    CA.DATA_FINE_VALIDITA IS NULL
                    AND    ca.descrizione=rec_albo_cciaa.DESC_ALBO;

            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    nSuperficie_SIAP:=0;
            END;

            IF rec_albo_cciaa.SUPERFICIE_CCIAA<>nSuperficie_SIAP THEN

                v_descrizione_errore :='La superficie in Schedario iscritta all''Albo Viticolo del ' || rec_albo_cciaa.DESC_ALBO || ' risulta essere di ' ||
                        TRIM(TO_CHAR(NVL(rec_albo_cciaa.SUPERFICIE_CCIAA,0),'999G990D9999')) || ' (ha), mentre per il medesimo Albo CCIAA risultano iscritti ' ||
                        TRIM(TO_CHAR(NVL(nSuperficie_SIAP,0),'999G990D9999')) || ' (ha).';

                IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, v_descrizione_errore,
                        P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                    RETURN (FALSE);
                END IF;
            END IF;

    END LOOP;

    RETURN TRUE;

EXCEPTION

WHEN OTHERS THEN
    p_MsgErr   := 'SCHEDARIO_UV_ALBO_SUP_ISCRITTA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN FALSE;

END SCHEDARIO_UV_ALBO_SUP_ISCRITTA;

FUNCTION CONGRUENZA_VINO_VITIGNO (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                  P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                  P_BLOCCANTE    IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                  P_MSGERR       IN OUT VARCHAR2,
                                  P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

vCodUtilizzo      DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;
   vCodDestinazione  DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;

     -- cursore delle unità vitate a vini doc per le quali il vino
     -- non è producibile per la varietà (vitigno) nel comune della UV
     CURSOR curUVIncongruenti IS
     SELECT SUA.ID_STORICO_UNITA_ARBOREA,
            SUA.ID_PARTICELLA,
            SP.ID_STORICO_PARTICELLA,
            CM.DESCOM,
            SP.COMUNE,
            SP.SEZIONE,
            SP.FOGLIO,
            SP.PARTICELLA,
            SP.SUBALTERNO,
            SUA.PROGR_UNAR,
            TV.DESCRIZIONE AS DESC_VITIGNO,
            TTV.DESCRIZIONE AS DESC_VINO
       FROM DB_STORICO_UNITA_ARBOREA SUA,
            DB_STORICO_PARTICELLA SP,
            COMUNE CM,
            PROVINCIA PR,
            DB_TIPO_TIPOLOGIA_VINO TTV,
            DB_TIPO_VARIETA TV,DB_R_CATALOGO_MATRICE CMA,DB_TIPO_UTILIZZO TU,DB_TIPO_DESTINAZIONE TD
      WHERE SUA.ID_PARTICELLA = SP.ID_PARTICELLA
        AND SP.DATA_FINE_VALIDITA IS NULL
        AND SUA.DATA_FINE_VALIDITA IS NULL
        AND SUA.ID_AZIENDA = P_ID_AZIENDA
        AND SUA.ID_TIPOLOGIA_UNAR = 2
        --AND SUA.ID_UTILIZZO= 487
        AND    SUA.ID_CATALOGO_MATRICE = CMA.ID_CATALOGO_MATRICE 
        AND    CMA.ID_UTILIZZO = TU.ID_UTILIZZO 
        AND    TU.CODICE = vCodUtilizzo 
        AND    CMA.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE 
        AND    TD.CODICE_DESTINAZIONE = vCodDestinazione 
        AND CMA.ID_VARIETA = TV.ID_VARIETA
        AND CM.ISTAT_COMUNE = SP.COMUNE
        AND CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
        AND PR.ID_REGIONE = '01' -- SOLO PIEMONTE
        AND SUA.ID_TIPOLOGIA_VINO = TTV.ID_TIPOLOGIA_VINO
        AND TTV.VINO_DOC='S' 
        AND EXISTS (SELECT CP.ID_CONDUZIONE_PARTICELLA
                      FROM DB_CONDUZIONE_PARTICELLA CP,
                           DB_UTE U
                     WHERE CP.DATA_FINE_CONDUZIONE IS NULL
                       AND CP.ID_TITOLO_POSSESSO NOT IN (5,6)
                       AND CP.ID_UTE = U.ID_UTE
                       AND U.ID_AZIENDA = P_ID_AZIENDA
                       AND U.DATA_FINE_ATTIVITA IS NULL
                       AND CP.ID_PARTICELLA = SUA.ID_PARTICELLA)
        AND NOT EXISTS (SELECT ID_VINO_VARIETA
                          FROM DB_TIPO_VINO_VARIETA TVV,
                               DB_TIPO_VINIDOC_COMUNI TVC
                         WHERE TVV.ID_TIPOLOGIA_VINO = TTV.ID_TIPOLOGIA_VINO
                           AND TVC.ID_TIPOLOGIA_VINO = TVV.ID_TIPOLOGIA_VINO
                           AND TVC.ISTAT_COMUNE = SP.COMUNE
                           AND TVV.ID_VARIETA = CMA.ID_VARIETA)
     ORDER BY CM.DESCOM,SP.COMUNE,SP.SEZIONE,SP.FOGLIO,SP.PARTICELLA,SP.SUBALTERNO,SUA.PROGR_UNAR;

    -- conduzione della particella dell'unità arborea in esame
    CURSOR curConduzioniParticella(pIdParticella IN DB_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT CP.ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA CP, DB_UTE U
     WHERE CP.ID_PARTICELLA = pIdParticella
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_UTE = U.ID_UTE
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND U.id_azienda = P_ID_AZIENDA
       AND cp.ID_TITOLO_POSSESSO NOT IN (5,6);

    vDescAnomalia    DB_ESITO_CONTROLLO_PARTICELLA.DESCRIZIONE%TYPE;

BEGIN
SELECT VALORE_STRINGA,VALORE_STRINGA1
   INTO   vCodUtilizzo,vCodDestinazione
   FROM   DB_TIPO_CONTROLLO_PARAMETRO
   WHERE  ID_CONTROLLO = P_ID_CONTROLLO
   AND    SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);

    FOR recUVIncongruenti IN curUVIncongruenti LOOP

        vDescAnomalia :=  '[' || recUVIncongruenti.DESCOM || ' Sez:'
                              || NVL(recUVIncongruenti.SEZIONE,'N.V.') ||' Fgl:'
                              || recUVIncongruenti.FOGLIO || ' Part:'
                              || recUVIncongruenti.PARTICELLA || ' Sub:'
                              || NVL(recUVIncongruenti.SUBALTERNO,'N.V') || ' Progr: '
                              || recUVIncongruenti.PROGR_UNAR || '] il vino : ' || recUVIncongruenti.DESC_VINO || ' non è tra quelli producibili per il vitigno : ' || recUVIncongruenti.DESC_VITIGNO || ' nel comune';

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,P_BLOCCANTE, recUVIncongruenti.ID_STORICO_PARTICELLA, recUVIncongruenti.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,P_BLOCCANTE, recUVIncongruenti.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;

        FOR recConduzioniParticella IN curConduzioniParticella(recUVIncongruenti.ID_PARTICELLA) LOOP
            IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,
                                                   P_BLOCCANTE, recConduzioniParticella.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
        END LOOP;

    END LOOP;

    RETURN TRUE;

EXCEPTION

WHEN OTHERS THEN
    p_MsgErr   := 'CONGRUENZA_VINO_VITIGNO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN FALSE;

END CONGRUENZA_VINO_VITIGNO;


FUNCTION UV_DOC_IN_CCIAA_MASSIVO (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                  P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                  P_BLOCCANTE    IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                  P_MSGERR       IN OUT VARCHAR2,
                                  P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

  vCodUtilizzo      DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;
   vCodDestinazione  DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;

     -- cursore delle unità vitate a vini doc per le quali il vino
     -- non è presente sullo scarico massivo da CCIAA (DB_CCIAA_ALBO_VIGNETI_MASSIVO)
     -- per la matricola
     CURSOR curUVIncongruenti IS
     SELECT SUA.ID_STORICO_UNITA_ARBOREA,
            SUA.ID_PARTICELLA,
            SP.ID_STORICO_PARTICELLA,
            CM.DESCOM,
            SP.COMUNE,
            SP.SEZIONE,
            SP.FOGLIO,
            SP.PARTICELLA,
            SP.SUBALTERNO,
            SUA.PROGR_UNAR,
            SUA.MATRICOLA_CCIAA,
            SUA.PROVINCIA_CCIAA,
            TTV.DESCRIZIONE AS DESC_VINO
       FROM DB_STORICO_UNITA_ARBOREA SUA,
            DB_STORICO_PARTICELLA SP,
            COMUNE CM,
            PROVINCIA PR,
            DB_TIPO_TIPOLOGIA_VINO TTV,DB_R_CATALOGO_MATRICE CMA,DB_TIPO_UTILIZZO TU,
            DB_TIPO_DESTINAZIONE TD
      WHERE SUA.ID_PARTICELLA = SP.ID_PARTICELLA
        AND SP.DATA_FINE_VALIDITA IS NULL
        AND SUA.DATA_FINE_VALIDITA IS NULL
        AND SUA.MATRICOLA_CCIAA IS NOT NULL
        AND SUA.PROVINCIA_CCIAA IS NOT NULL
        AND SUA.ID_TIPOLOGIA_VINO IS NOT NULL
        AND SUA.ID_AZIENDA = P_ID_AZIENDA
        AND SUA.ID_TIPOLOGIA_UNAR = 2
        --AND SUA.ID_UTILIZZO= 487
        AND    SUA.ID_CATALOGO_MATRICE = CMA.ID_CATALOGO_MATRICE 
        AND    CMA.ID_UTILIZZO = TU.ID_UTILIZZO 
        AND    TU.CODICE = vCodUtilizzo 
        AND    CMA.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE 
        AND    TD.CODICE_DESTINAZIONE = vCodDestinazione 
        AND CM.ISTAT_COMUNE = SP.COMUNE
        AND CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
        AND PR.ID_REGIONE = '01' -- SOLO PIEMONTE
        AND SUA.ID_TIPOLOGIA_VINO = TTV.ID_TIPOLOGIA_VINO
        AND TTV.VINO_DOC = 'S' 
        AND EXISTS (SELECT CP.ID_CONDUZIONE_PARTICELLA
                      FROM DB_CONDUZIONE_PARTICELLA CP,
                           DB_UTE U
                     WHERE CP.DATA_FINE_CONDUZIONE IS NULL
                       AND CP.ID_TITOLO_POSSESSO NOT IN (5,6)
                       AND CP.ID_UTE = U.ID_UTE
                       AND CP.ID_PARTICELLA = SUA.ID_PARTICELLA
                       AND U.ID_AZIENDA = P_ID_AZIENDA
                       AND U.DATA_FINE_ATTIVITA IS NULL)
        AND NOT EXISTS (SELECT AVM.ID_CCIAA_ALBOVIGNETI_MASSIVO
                          FROM DB_CCIAA_ALBO_VIGNETI_MASSIVO AVM,
                               DB_TIPO_VINO_CCIAA_SIAP VCS
                         WHERE VCS.ID_TIPOLOGIA_VINO = SUA.ID_TIPOLOGIA_VINO
                           AND VCS.DATA_FINE_VALIDITA IS NULL
                           AND VCS.ID_CCIAA_ALBO_VIGNETO = AVM.ID_CCIAA_ALBO_VIGNETO
                           AND AVM.MATRICOLA = SUA.MATRICOLA_CCIAA
                           AND AVM.SIGLA_PROVINCIA = SUA.PROVINCIA_CCIAA) 
     ORDER BY CM.DESCOM,SP.COMUNE,SP.SEZIONE,SP.FOGLIO,SP.PARTICELLA,SP.SUBALTERNO,SUA.PROGR_UNAR;

    -- conduzione della particella dell'unità arborea in esame
    CURSOR curConduzioniParticella(pIdParticella IN DB_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT CP.ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA CP, DB_UTE U
     WHERE CP.ID_PARTICELLA = pIdParticella
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_UTE = U.ID_UTE
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND U.ID_AZIENDA = P_ID_AZIENDA
       AND CP.ID_TITOLO_POSSESSO NOT IN (5,6);

    vDescAnomalia    DB_ESITO_CONTROLLO_PARTICELLA.DESCRIZIONE%TYPE;

BEGIN
  SELECT VALORE_STRINGA,VALORE_STRINGA1
   INTO   vCodUtilizzo,vCodDestinazione
   FROM   DB_TIPO_CONTROLLO_PARAMETRO
   WHERE  ID_CONTROLLO = P_ID_CONTROLLO
   AND    SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);

    FOR recUVIncongruenti IN curUVIncongruenti LOOP

        vDescAnomalia :=  '[' || recUVIncongruenti.DESCOM || ' Sez:'
                              || NVL(recUVIncongruenti.SEZIONE,'N.V.') ||' Fgl:'
                              || recUVIncongruenti.FOGLIO || ' Part:'
                              || recUVIncongruenti.PARTICELLA || ' Sub:'
                              || NVL(recUVIncongruenti.SUBALTERNO,'N.V') || ' Progr: '
                              || recUVIncongruenti.PROGR_UNAR || '] il vino : ' || recUVIncongruenti.DESC_VINO || ' non è presente su schedario CCIAA con matricola : ' || recUVIncongruenti.MATRICOLA_CCIAA;

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,P_BLOCCANTE, recUVIncongruenti.ID_STORICO_PARTICELLA, recUVIncongruenti.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,P_BLOCCANTE, recUVIncongruenti.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;

        FOR recConduzioniParticella IN curConduzioniParticella(recUVIncongruenti.ID_PARTICELLA) LOOP
            IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,
                                                   P_BLOCCANTE, recConduzioniParticella.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
        END LOOP;

    END LOOP;

    RETURN TRUE;

EXCEPTION

WHEN OTHERS THEN
    p_MsgErr   := 'UV_DOC_IN_CCIAA_MASSIVO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN FALSE;

END UV_DOC_IN_CCIAA_MASSIVO;

FUNCTION SUPERFICIE_UV_DOC_IN_CCIAA_OK (P_ID_AZIENDA  IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                       P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                       P_BLOCCANTE    IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                       P_MSGERR       IN OUT VARCHAR2,
                                       P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

vCodUtilizzo      DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;
   vCodDestinazione  DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;

     -- cursore delle unità vitate a vini doc per le quali la superficie
     -- iscritta nell'albo CCIAA risulta minore dell'area della U.V
     CURSOR curUVIncongruenti (pPercTolleranza IN INTEGER) IS
     SELECT SUA.ID_STORICO_UNITA_ARBOREA,
            SUA.ID_PARTICELLA,
            SP.ID_STORICO_PARTICELLA,
            CM.DESCOM,
            SP.COMUNE,
            SP.SEZIONE,
            SP.FOGLIO,
            SP.PARTICELLA,
            SP.SUBALTERNO,
            SUA.PROGR_UNAR,
            SUA.MATRICOLA_CCIAA,
            SUA.PROVINCIA_CCIAA,
            SUA.AREA,
            AVM.SUPERFICIE_ISCRITTA,
            TTV.DESCRIZIONE AS DESC_VINO
       FROM DB_STORICO_UNITA_ARBOREA SUA,
            DB_STORICO_PARTICELLA SP,
            COMUNE CM,
            PROVINCIA PR,
            DB_TIPO_TIPOLOGIA_VINO TTV,
            DB_TIPO_VINO_CCIAA_SIAP TVCS,
            DB_CCIAA_ALBO_VIGNETI_MASSIVO AVM,DB_R_CATALOGO_MATRICE CMA,DB_TIPO_UTILIZZO TU,
            DB_TIPO_DESTINAZIONE TD
      WHERE SUA.ID_PARTICELLA = SP.ID_PARTICELLA
        AND SP.DATA_FINE_VALIDITA IS NULL
        AND SUA.DATA_FINE_VALIDITA IS NULL
        AND SUA.MATRICOLA_CCIAA IS NOT NULL
        AND SUA.PROVINCIA_CCIAA IS NOT NULL
        AND SUA.ID_TIPOLOGIA_VINO IS NOT NULL
        AND SUA.ID_AZIENDA = P_ID_AZIENDA
        AND SUA.ID_TIPOLOGIA_UNAR = 2
        --AND SUA.ID_UTILIZZO= 487
        AND    SUA.ID_CATALOGO_MATRICE = CMA.ID_CATALOGO_MATRICE 
        AND    CMA.ID_UTILIZZO = TU.ID_UTILIZZO 
        AND    TU.CODICE = vCodUtilizzo 
        AND    CMA.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE 
        AND    TD.CODICE_DESTINAZIONE = vCodDestinazione 
        AND CM.ISTAT_COMUNE = SP.COMUNE
        AND CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
        AND PR.ID_REGIONE = '01' -- SOLO PIEMONTE
        AND SUA.ID_TIPOLOGIA_VINO = TTV.ID_TIPOLOGIA_VINO
        AND TTV.VINO_DOC = 'S'
        AND TVCS.ID_TIPOLOGIA_VINO = SUA.ID_TIPOLOGIA_VINO
        AND TVCS.DATA_FINE_VALIDITA IS NULL 
        AND TVCS.ID_CCIAA_ALBO_VIGNETO = AVM.ID_CCIAA_ALBO_VIGNETO
        AND AVM.MATRICOLA = SUA.MATRICOLA_CCIAA
        AND AVM.SIGLA_PROVINCIA = SUA.PROVINCIA_CCIAA
        AND SUA.AREA > AVM.SUPERFICIE_ISCRITTA +
                     ((AVM.SUPERFICIE_ISCRITTA * pPercTolleranza) / 100) 
        AND EXISTS (SELECT CP.ID_CONDUZIONE_PARTICELLA
                      FROM DB_CONDUZIONE_PARTICELLA CP, 
                           DB_UTE U
                     WHERE CP.DATA_FINE_CONDUZIONE IS NULL
                       AND CP.ID_TITOLO_POSSESSO NOT IN (5,6)
                       AND CP.ID_UTE = U.ID_UTE
                       AND CP.ID_PARTICELLA = SUA.ID_PARTICELLA
                       AND U.ID_AZIENDA = P_ID_AZIENDA
                       AND U.DATA_FINE_ATTIVITA IS NULL)
    ORDER BY CM.DESCOM,SP.COMUNE,SP.SEZIONE,SP.FOGLIO,SP.PARTICELLA,SP.SUBALTERNO,SUA.PROGR_UNAR;

    -- conduzione della particella dell'unità arborea in esame
    CURSOR curConduzioniParticella(pIdParticella IN DB_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT CP.ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA CP, DB_UTE U
     WHERE CP.ID_PARTICELLA = pIdParticella
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_UTE = U.ID_UTE
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND U.ID_AZIENDA = P_ID_AZIENDA
       AND CP.ID_TITOLO_POSSESSO NOT IN (5,6);

    vDescAnomalia    DB_ESITO_CONTROLLO_PARTICELLA.DESCRIZIONE%TYPE;
    nPercTolleranza  INTEGER;

BEGIN

SELECT VALORE_STRINGA,VALORE_STRINGA1
   INTO   vCodUtilizzo,vCodDestinazione
   FROM   DB_TIPO_CONTROLLO_PARAMETRO
   WHERE  ID_CONTROLLO = P_ID_CONTROLLO
   AND    SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);

    BEGIN
        nPercTolleranza := SelectValoreParametro(kvIdParamPercTollUV21);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             nPercTolleranza := 10;
    END;
    -- scorro le unità vitate a vini doc di SMRGAA con MATRICOLA_CCIAA, PROVINCIA_CCIAA valorizzati
    -- dove l'area è minore della superficie ISCRITTA al CCIAA
    FOR recUVIncongruenti IN curUVIncongruenti (nPercTolleranza) LOOP

        vDescAnomalia :=  '[' || recUVIncongruenti.DESCOM || ' Sez:'
                              || NVL(recUVIncongruenti.SEZIONE,'N.V.') ||' Fgl:'
                              || recUVIncongruenti.FOGLIO || ' Part:'
                              || recUVIncongruenti.PARTICELLA || ' Sub:'
                              || NVL(recUVIncongruenti.SUBALTERNO,'N.V') || ' Progr: '
                              || recUVIncongruenti.PROGR_UNAR || '] l''unità vitata a : '
                              || recUVIncongruenti.DESC_VINO || ' MATRICOLA : '
                              || recUVIncongruenti.MATRICOLA_CCIAA || ' con superficie = '
                              || TO_CHAR(recUVIncongruenti.AREA,'999G990D9999') || ' risulta avere superficie maggiore rispetto all''iscrizione CCIAA : '
                              || TO_CHAR(recUVIncongruenti.SUPERFICIE_ISCRITTA,'999G990D9999');

        IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,P_BLOCCANTE, recUVIncongruenti.ID_STORICO_PARTICELLA, recUVIncongruenti.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,P_BLOCCANTE, recUVIncongruenti.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;

        FOR recConduzioniParticella IN curConduzioniParticella(recUVIncongruenti.ID_PARTICELLA) LOOP
            IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,
                                                   P_BLOCCANTE, recConduzioniParticella.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
        END LOOP;

    END LOOP;

    RETURN TRUE;

EXCEPTION

WHEN OTHERS THEN
    p_MsgErr   := 'SUPERFICIE_UV_DOC_IN_CCIAA_OK: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN FALSE;
END SUPERFICIE_UV_DOC_IN_CCIAA_OK;

FUNCTION SFORAMENTO_VINO_PER_PROVINCIA (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                        P_ID_CONTROLLO IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        P_BLOCCANTE    IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                        P_MSGERR       IN OUT VARCHAR2,
                                        P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

vCodUtilizzo      DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;
   vCodDestinazione  DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;

     -- estraggo il totale di superficie per il vino doc per la provincia
     -- di ubicazione unità vitata
     CURSOR curTotSupVinoProvincia IS
     SELECT SUA.ID_TIPOLOGIA_VINO,
            PR.DESCRIZIONE AS DESC_PROV,
            PR.ISTAT_PROVINCIA,
            TTV.DESCRIZIONE,
            SUA.PROVINCIA_CCIAA,
            SUM(SUA.SUPERFICIE_DA_ISCRIVERE_ALBO) AS TOT_AREA
       FROM DB_STORICO_UNITA_ARBOREA SUA,
            DB_STORICO_PARTICELLA SP,
            COMUNE CM,
            PROVINCIA PR,
            DB_TIPO_TIPOLOGIA_VINO TTV,DB_R_CATALOGO_MATRICE CMA,DB_TIPO_UTILIZZO TU,
            DB_TIPO_DESTINAZIONE TD
      WHERE SUA.ID_PARTICELLA = SP.ID_PARTICELLA
        AND SP.DATA_FINE_VALIDITA IS NULL
        AND SUA.DATA_FINE_VALIDITA IS NULL
        AND SUA.MATRICOLA_CCIAA IS NOT NULL
        AND SUA.PROVINCIA_CCIAA IS NOT NULL
        AND SUA.ID_TIPOLOGIA_VINO IS NOT NULL
        AND SUA.ID_AZIENDA = P_ID_AZIENDA
        AND SUA.ID_TIPOLOGIA_UNAR = 2
        --AND SUA.ID_UTILIZZO= 487
        AND    SUA.ID_CATALOGO_MATRICE = CMA.ID_CATALOGO_MATRICE 
        AND    CMA.ID_UTILIZZO = TU.ID_UTILIZZO 
        AND    TU.CODICE = vCodUtilizzo 
        AND    CMA.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE 
        AND    TD.CODICE_DESTINAZIONE = vCodDestinazione 
        AND CM.ISTAT_COMUNE = SP.COMUNE
        AND CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
        AND PR.ID_REGIONE = '01' -- SOLO PIEMONTE
        AND SUA.ID_TIPOLOGIA_VINO = TTV.ID_TIPOLOGIA_VINO
        AND TTV.VINO_DOC = 'S' 
        AND EXISTS (SELECT CP.ID_CONDUZIONE_PARTICELLA
                      FROM DB_CONDUZIONE_PARTICELLA CP,
                           DB_UTE U
                     WHERE CP.DATA_FINE_CONDUZIONE IS NULL
                       AND CP.ID_TITOLO_POSSESSO NOT IN (5,6)
                       AND CP.ID_UTE = U.ID_UTE
                       AND CP.ID_PARTICELLA = SUA.ID_PARTICELLA
                       AND U.ID_AZIENDA = P_ID_AZIENDA
                       AND U.DATA_FINE_ATTIVITA IS NULL)
 GROUP BY SUA.ID_TIPOLOGIA_VINO, TTV.DESCRIZIONE, SUA.PROVINCIA_CCIAA, PR.ISTAT_PROVINCIA, PR.DESCRIZIONE;

    vDescAnomalia           DB_ESITO_CONTROLLO_PARTICELLA.DESCRIZIONE%TYPE;
    nTotVinoAltreAziende    DB_STORICO_UNITA_ARBOREA.SUPERFICIE_DA_ISCRIVERE_ALBO%TYPE;
    nTotVinoCCIAA           DB_CCIAA_ALBO_VIGNETI_MASSIVO.SUPERFICIE_ISCRITTA%TYPE;
    nPercTolleranza         INTEGER;
BEGIN

  SELECT VALORE_STRINGA,VALORE_STRINGA1
   INTO   vCodUtilizzo,vCodDestinazione
   FROM   DB_TIPO_CONTROLLO_PARAMETRO
   WHERE  ID_CONTROLLO = P_ID_CONTROLLO
   AND    SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);

    BEGIN
        nPercTolleranza := SelectValoreParametro(kvIdParamPercTollUV22);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             nPercTolleranza := 10;
    END;

    -- scorro il totale del vino per provincia
    FOR recTotSupVinoProvincia IN curTotSupVinoProvincia LOOP
        -- sommo il totale di superficie vitata sul vino e sulla provincia per altre aziende
        -- presenti in SMRGAA
        nTotVinoAltreAziende := SelTotVinoPerProvAltreAziende(recTotSupVinoProvincia.ID_TIPOLOGIA_VINO,
                                                              recTotSupVinoProvincia.ISTAT_PROVINCIA,
                                                              recTotSupVinoProvincia.PROVINCIA_CCIAA,
                                                              P_ID_AZIENDA);

        -- sommo il totale di superficie vitata sul vino e sulla provincia iscritti CCIAA
        nTotVinoCCIAA := SelTotVinoCCIAAPerProvincia ( recTotSupVinoProvincia.ID_TIPOLOGIA_VINO,
                                                       recTotSupVinoProvincia.PROVINCIA_CCIAA);
        -- se la superficie totale per il vino nella provincia sul SIAP è maggiore di quella iscritta al CCIAA do anomalia
        IF recTotSupVinoProvincia.TOT_AREA + nTotVinoAltreAziende > nTotVinoCCIAA + ((nTotVinoCCIAA * nPercTolleranza) / 100) THEN
           vDescAnomalia :=  'Vino : ' || recTotSupVinoProvincia.DESCRIZIONE ||
                             ' , Provincia : ' || recTotSupVinoProvincia.DESC_PROV ||
                             ' totale superficie IN SIAP : ' || TO_CHAR(recTotSupVinoProvincia.TOT_AREA + nTotVinoAltreAziende,'999G990D9999') ||
                             ' maggiore del totale superficie Iscritta in CCIAA : ' || TO_CHAR(nTotVinoCCIAA,'999G990D9999');
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;

    END LOOP;

    RETURN TRUE;

EXCEPTION

WHEN OTHERS THEN
    p_MsgErr   := 'SFORAMENTO_VINO_PER_PROVINCIA: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN FALSE;
END SFORAMENTO_VINO_PER_PROVINCIA;

FUNCTION SUP_ISCRITTA_IN_CCIAA_OK (P_ID_AZIENDA   IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                   P_ID_CONTROLLO IN DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                   P_BLOCCANTE    IN DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                   P_MSGERR       IN OUT VARCHAR2,
                                   P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

  vCodUtilizzo      DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;
   vCodDestinazione  DB_TIPO_CONTROLLO_PARAMETRO.VALORE_STRINGA1%TYPE;

     -- cursore che estrare la superficie iscritta nel registro CCIAA
     -- raggruppata per matricola, provincia e tipologia vino ed l'area totale
     -- delle unità arborea presenti per i trio su DB_STORICO_UNITA_ARBOREA
     -- solamente in caso quest'area superi la superficie iscritta più
     -- una percentuale di tolleranza
     CURSOR curUVIncongruenti (pAnnoA          IN INTEGER,
                               pPercTolleranza IN INTEGER
                               ) IS
     SELECT SUA.MATRICOLA_CCIAA,
            SUA.PROVINCIA_CCIAA,
            SUM(SUA.AREA) AS TOT_AREA,
            AVM.SUPERFICIE_ISCRITTA,
            TTV.ID_TIPOLOGIA_VINO,
            TTV.DESCRIZIONE AS DESC_VINO
       FROM DB_STORICO_UNITA_ARBOREA SUA,
            DB_STORICO_PARTICELLA SP,
            COMUNE CM,
            PROVINCIA PR,
            DB_TIPO_TIPOLOGIA_VINO TTV,
            DB_TIPO_VINO_CCIAA_SIAP TVCS,
            DB_CCIAA_ALBO_VIGNETI_MASSIVO AVM,DB_R_CATALOGO_MATRICE CMA,DB_TIPO_UTILIZZO TU,
            DB_TIPO_DESTINAZIONE TD
      WHERE SUA.ID_PARTICELLA = SP.ID_PARTICELLA
        AND NVL(SUA.ANNO_ISCRIZIONE_ALBO,pAnnoA) <= pAnnoA 
        AND SP.DATA_FINE_VALIDITA IS NULL
        AND SUA.DATA_FINE_VALIDITA IS NULL
        AND SUA.MATRICOLA_CCIAA IS NOT NULL
        AND SUA.PROVINCIA_CCIAA IS NOT NULL
        AND SUA.ID_TIPOLOGIA_VINO IS NOT NULL
        AND SUA.ID_AZIENDA = P_ID_AZIENDA
        AND SUA.ID_TIPOLOGIA_UNAR = 2
        --AND SUA.ID_UTILIZZO= 487
        AND    SUA.ID_CATALOGO_MATRICE = CMA.ID_CATALOGO_MATRICE 
        AND    CMA.ID_UTILIZZO = TU.ID_UTILIZZO 
        AND    TU.CODICE = vCodUtilizzo 
        AND    CMA.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE 
        AND    TD.CODICE_DESTINAZIONE = vCodDestinazione 
        AND CM.ISTAT_COMUNE = SP.COMUNE
        AND CM.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
        AND PR.ID_REGIONE = '01' -- SOLO PIEMONTE
        AND SUA.ID_TIPOLOGIA_VINO = TTV.ID_TIPOLOGIA_VINO
        AND TTV.VINO_DOC = 'S'
        AND TVCS.ID_TIPOLOGIA_VINO = SUA.ID_TIPOLOGIA_VINO
        AND TVCS.DATA_FINE_VALIDITA IS NULL 
        AND TVCS.ID_CCIAA_ALBO_VIGNETO = AVM.ID_CCIAA_ALBO_VIGNETO
        AND AVM.MATRICOLA = SUA.MATRICOLA_CCIAA
        AND AVM.SIGLA_PROVINCIA = SUA.PROVINCIA_CCIAA
        AND EXISTS (SELECT CP.ID_CONDUZIONE_PARTICELLA
                      FROM DB_CONDUZIONE_PARTICELLA CP, 
                           DB_UTE U
                     WHERE CP.DATA_FINE_CONDUZIONE IS NULL
                       AND CP.ID_TITOLO_POSSESSO NOT IN (5,6)
                       AND CP.ID_UTE = U.ID_UTE
                       AND CP.ID_PARTICELLA = SUA.ID_PARTICELLA
                       AND U.ID_AZIENDA = P_ID_AZIENDA
                       AND U.DATA_FINE_ATTIVITA IS NULL)
   GROUP BY SUA.MATRICOLA_CCIAA, SUA.PROVINCIA_CCIAA, AVM.SUPERFICIE_ISCRITTA, ttv.ID_TIPOLOGIA_VINO, TTV.DESCRIZIONE
   HAVING SUM(SUA.AREA) > AVM.SUPERFICIE_ISCRITTA + ((AVM.SUPERFICIE_ISCRITTA * pPercTolleranza) / 100);

    CURSOR curUnitaArborea (pMatricolaCCIAA IN DB_STORICO_UNITA_ARBOREA.MATRICOLA_CCIAA%TYPE,
                            pProvinciaCCIAA IN DB_STORICO_UNITA_ARBOREA.PROVINCIA_CCIAA%TYPE,
                            pIdTpVino       IN DB_STORICO_UNITA_ARBOREA.ID_TIPOLOGIA_VINO%TYPE,
                            pAnnoA          IN INTEGER
                            ) IS
    SELECT SUA.ID_STORICO_UNITA_ARBOREA,
           SP.ID_STORICO_PARTICELLA,
           SUA.ID_PARTICELLA,
           SP.COMUNE,
           SP.SEZIONE,
           SP.FOGLIO,
           SP.PARTICELLA,
           SP.SUBALTERNO,
           SUA.PROGR_UNAR,
           CM.DESCOM
      FROM DB_STORICO_UNITA_ARBOREA SUA,
           DB_STORICO_PARTICELLA SP,
           COMUNE CM,DB_R_CATALOGO_MATRICE CMA,DB_TIPO_UTILIZZO TU,DB_TIPO_DESTINAZIONE TD
     WHERE SUA.DATA_FINE_VALIDITA IS NULL
       AND SUA.ID_AZIENDA = P_ID_AZIENDA
       AND NVL(SUA.ANNO_ISCRIZIONE_ALBO,pAnnoA) <= pAnnoA 
       AND SUA.ID_TIPOLOGIA_UNAR = 2
       --AND SUA.ID_UTILIZZO = 487
       AND    SUA.ID_CATALOGO_MATRICE = CMA.ID_CATALOGO_MATRICE 
        AND    CMA.ID_UTILIZZO = TU.ID_UTILIZZO 
        AND    TU.CODICE = vCodUtilizzo 
        AND    CMA.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE 
        AND    TD.CODICE_DESTINAZIONE = vCodDestinazione 
       AND SUA.MATRICOLA_CCIAA = pMatricolaCCIAA
       AND SUA.PROVINCIA_CCIAA = pProvinciaCCIAA
       AND SUA.ID_TIPOLOGIA_VINO = pIdTpVino
       AND SUA.ID_PARTICELLA = SP.ID_PARTICELLA
       AND SP.DATA_FINE_VALIDITA IS NULL
       AND SP.COMUNE = CM.ISTAT_COMUNE
    ORDER BY SUA.ID_PARTICELLA;

    -- conduzione della particella dell'unità arborea in esame
    CURSOR curConduzioniParticella(pIdParticella IN DB_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT CP.ID_CONDUZIONE_PARTICELLA
      FROM DB_CONDUZIONE_PARTICELLA CP, DB_UTE U
     WHERE CP.ID_PARTICELLA = pIdParticella
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_UTE = U.ID_UTE
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND U.ID_AZIENDA = P_ID_AZIENDA
       AND CP.ID_TITOLO_POSSESSO NOT IN (5,6);

    vDescAnomalia    DB_ESITO_CONTROLLO_PARTICELLA.DESCRIZIONE%TYPE;
    nPercTolleranza  INTEGER;
    nOldIdPart       DB_STORICO_PARTICELLA.ID_PARTICELLA%TYPE:=0;
    nAnnoApp         INTEGER;
BEGIN

  SELECT VALORE_STRINGA,VALORE_STRINGA1
   INTO   vCodUtilizzo,vCodDestinazione
   FROM   DB_TIPO_CONTROLLO_PARAMETRO
   WHERE  ID_CONTROLLO = P_ID_CONTROLLO
   AND    SYSDATE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);

    BEGIN
        nPercTolleranza := SelectValoreParametro(kvIdParamPercTollUV21);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             nPercTolleranza := 10;
    END;

    BEGIN
        nAnnoApp := SelectValoreParametro(kvIdParamAnnoUV23);
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             nAnnoApp := TO_CHAR(SYSDATE,'YYYY');
    END;

    -- scorro le unità vitate a vini doc di SMRGAA con MATRICOLA_CCIAA, PROVINCIA_CCIAA valorizzati
    -- dove l'area è minore della superficie ISCRITTA al CCIAA
    FOR recUVIncongruenti IN curUVIncongruenti (nAnnoApp,
                                                nPercTolleranza) LOOP

        FOR recUnitaArborea IN curUnitaArborea (recUVIncongruenti.MATRICOLA_CCIAA,
                                                recUVIncongruenti.PROVINCIA_CCIAA,
                                                recUVIncongruenti.ID_TIPOLOGIA_VINO,
                                                nAnnoApp
                                                ) LOOP

               vDescAnomalia :=  '[' || recUnitaArborea.DESCOM || ' Sez:'
                                     || NVL(recUnitaArborea.SEZIONE,'N.V.') ||' Fgl:'
                                     || recUnitaArborea.FOGLIO || ' Part:'
                                     || recUnitaArborea.PARTICELLA || ' Sub:'
                                     || NVL(recUnitaArborea.SUBALTERNO,'N.V') || ' Progr: '
                                     || recUnitaArborea.PROGR_UNAR || '] l''unità vitata a : '
                                     || recUVIncongruenti.DESC_VINO || ' MATRICOLA : '
                                     || recUVIncongruenti.MATRICOLA_CCIAA || ' con superficie = '
                                     || TO_CHAR(recUVIncongruenti.TOT_AREA,'999G990D9999') || ' risulta avere superficie maggiore rispetto all''iscrizione CCIAA : '
                                     || TO_CHAR(recUVIncongruenti.SUPERFICIE_ISCRITTA,'999G990D9999');

               IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,P_BLOCCANTE, recUnitaArborea.ID_STORICO_PARTICELLA, recUnitaArborea.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                  RETURN (FALSE);
               END IF;

               IF NOT SCRIVI_SEGNALAZIONE_UNAR (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,P_BLOCCANTE, recUnitaArborea.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
                  RETURN (FALSE);
               END IF;

               IF recUnitaArborea.ID_PARTICELLA <> nOldIdPart THEN
                  FOR recConduzioniParticella IN curConduzioniParticella(recUnitaArborea.ID_PARTICELLA) LOOP
                      IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (P_ID_AZIENDA, P_ID_CONTROLLO, vDescAnomalia,
                                                   P_BLOCCANTE, recConduzioniParticella.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                         RETURN (FALSE);
                      END IF;
                  END LOOP;
                  nOldIdPart := recUnitaArborea.ID_PARTICELLA;
               END IF;

        END LOOP;
    END LOOP;

    RETURN TRUE;

EXCEPTION

WHEN OTHERS THEN
    p_MsgErr   := 'SUP_ISCRITTA_IN_CCIAA_OK: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN FALSE;
END SUP_ISCRITTA_IN_CCIAA_OK;

FUNCTION CONTROLLA_SUPERO_ASSERVIMENTO (p_id_azienda       IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                                     p_id_controllo     IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                                    p_bloccante        IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                                     p_msgerr           IN OUT VARCHAR2,
                                                    p_coderr                IN OUT VARCHAR2) RETURN BOOLEAN IS

v_superficie_condotta_az            DB_CONDUZIONE_PARTICELLA.SUPERFICIE_CONDOTTA%TYPE;
v_superficie_agronomica_az            DB_CONDUZIONE_PARTICELLA.SUPERFICIE_AGRONOMICA%TYPE;
v_superficie_condotta                 DB_CONDUZIONE_DICHIARATA.SUPERFICIE_CONDOTTA%TYPE;
v_superficie_agronomica                DB_CONDUZIONE_DICHIARATA.SUPERFICIE_AGRONOMICA%TYPE;
v_descrizione_errore                    DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
v_messaggio_conduzione                VARCHAR2(100);
v_sezione                                VARCHAR2(20);
v_subalterno                            VARCHAR2(20);

v_cuaa_azienda_principale            DB_ANAGRAFICA_AZIENDA.CUAA%TYPE;
v_denominaz_azienda_principale    DB_ANAGRAFICA_AZIENDA.DENOMINAZIONE%TYPE;
v_cod_fisc_azienda_principale        DB_INTERMEDIARIO.CODICE_FISCALE%TYPE;

CURSOR cur_particelle IS
SELECT NVL(SUM(DECODE(CP.ID_TITOLO_POSSESSO,5,NVL(CP.SUPERFICIE_AGRONOMICA,0)+NVL(CP.SUPERFICIE_CONDOTTA,0),0)),0) SUPERFICIE_CONDOTTA,
       NVL(SUM(DECODE(CP.ID_TITOLO_POSSESSO,5,0,NVL(CP.SUPERFICIE_AGRONOMICA,0))),0) SUPERFICIE_AGRONOMICA,
       SP.ID_PARTICELLA,
       CASE WHEN FO.FLAG_STABILIZZAZIONE = 0 THEN
          DECODE(SP.SUPERFICIE_GRAFICA,0,SP.SUP_CATASTALE, SP.SUPERFICIE_GRAFICA)
       ELSE
          GREATEST(DECODE(SP.SUPERFICIE_GRAFICA,0,SP.SUP_CATASTALE,SP.SUPERFICIE_GRAFICA),
                   DECODE(SP.SUP_CATASTALE,0,SP.SUPERFICIE_GRAFICA,SP.SUP_CATASTALE))
       END AS SUP_RIFERIMENTO,
       SP.SUPERFICIE_GRAFICA,
       SP.SUP_CATASTALE,
       SP.ID_STORICO_PARTICELLA,
       C.DESCOM,
       SP.SEZIONE,
       SP.FOGLIO,
       SP.PARTICELLA,
       SP.SUBALTERNO
  FROM DB_STORICO_PARTICELLA SP, DB_CONDUZIONE_PARTICELLA CP, DB_UTE U, COMUNE C, DB_FOGLIO FO
 WHERE SP.ID_PARTICELLA = CP.ID_PARTICELLA
   AND CP.ID_UTE = U.ID_UTE
   AND SP.COMUNE = C.ISTAT_COMUNE
   AND SP.DATA_FINE_VALIDITA IS NULL
   AND CP.DATA_FINE_CONDUZIONE IS NULL
   AND U.DATA_FINE_ATTIVITA IS NULL
   AND U.ID_AZIENDA = p_id_azienda
   AND SP.PARTICELLA IS NOT NULL 
   AND SP.COMUNE = FO.COMUNE (+) 
   AND SP.FOGLIO = FO.FOGLIO (+) 
   AND NVL(SP.SEZIONE,'#') = NVL(FO.SEZIONE (+),'#')
GROUP BY SP.ID_PARTICELLA,
         SP.SUP_CATASTALE,
         SP.SUPERFICIE_GRAFICA,
         FO.FLAG_STABILIZZAZIONE,
         SP.ID_STORICO_PARTICELLA,
         C.DESCOM,
         SP.SEZIONE,
         SP.FOGLIO,
         SP.PARTICELLA,
         SP.SUBALTERNO;



CURSOR cur_aziende_supero (p_id_particella DB_PARTICELLA.ID_PARTICELLA%TYPE) IS
SELECT AA.CUAA, AA.DENOMINAZIONE, DECODE(CD.ID_TITOLO_POSSESSO,5,NVL(CD.SUPERFICIE_CONDOTTA,0)+NVL(CD.SUPERFICIE_AGRONOMICA,0),NVL(CD.SUPERFICIE_AGRONOMICA,0)) SUPERFICIE,
       I.CODICE_FISCALE AS CAA, DC.ID_AZIENDA, CD.ID_TITOLO_POSSESSO
FROM   DB_CONDUZIONE_DICHIARATA CD, DB_DICHIARAZIONE_CONSISTENZA DC, DB_ANAGRAFICA_AZIENDA AA, DB_AZIENDA A, DB_DELEGA D, DB_INTERMEDIARIO I
WHERE  A.ID_AZIENDA = AA.ID_AZIENDA
AND    AA.ID_AZIENDA = DC.ID_AZIENDA
AND     A.ID_AZIENDA = D.ID_AZIENDA
AND    CD.CODICE_FOTOGRAFIA_TERRENI = DC.CODICE_FOTOGRAFIA_TERRENI
AND    I.ID_INTERMEDIARIO = D.ID_INTERMEDIARIO
AND     CD.ID_PARTICELLA = p_id_particella
AND      cd.ID_TITOLO_POSSESSO  != 6
AND    AA.DATA_FINE_VALIDITA IS NULL
AND    AA.DATA_CESSAZIONE IS NULL
AND    D.DATA_FINE IS NULL
AND    D.ID_PROCEDIMENTO = 7
AND     A.ID_AZIENDA <> p_id_azienda
AND     DC.ID_MOTIVO_DICHIARAZIONE <> 7
AND     DC.DATA_INSERIMENTO_DICHIARAZIONE =     (    SELECT MAX(DCX.DATA_INSERIMENTO_DICHIARAZIONE)
                                                                FROM  DB_DICHIARAZIONE_CONSISTENZA DCX,
                                                                        DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                                WHERE  DCX.ID_AZIENDA = DC.ID_AZIENDA
                                                                AND     DCX.ID_MOTIVO_DICHIARAZIONE <> 7
                                                                AND    TI.ID_MOTIVO_DICHIARAZIONE = DCX.ID_MOTIVO_DICHIARAZIONE
                                                                AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                                            )
UNION
SELECT AA.CUAA, AA.DENOMINAZIONE, DECODE(CD.ID_TITOLO_POSSESSO,5,NVL(CD.SUPERFICIE_CONDOTTA,0)+NVL(CD.SUPERFICIE_AGRONOMICA,0),NVL(CD.SUPERFICIE_AGRONOMICA,0)) SUPERFICIE,
       'ASSENTE' AS CAA, DC.ID_AZIENDA, CD.ID_TITOLO_POSSESSO
FROM   DB_CONDUZIONE_DICHIARATA CD, DB_DICHIARAZIONE_CONSISTENZA DC, DB_ANAGRAFICA_AZIENDA AA, DB_AZIENDA A
WHERE  A.ID_AZIENDA = AA.ID_AZIENDA
AND       AA.ID_AZIENDA = DC.ID_AZIENDA
AND       DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
AND       CD.ID_PARTICELLA = p_id_particella
AND      cd.ID_TITOLO_POSSESSO  != 6
AND    AA.DATA_FINE_VALIDITA IS NULL
AND    AA.DATA_CESSAZIONE IS NULL
AND       A.ID_AZIENDA <> p_id_azienda
AND    NOT EXISTS (SELECT ID_AZIENDA FROM DB_DELEGA WHERE ID_AZIENDA = A.ID_AZIENDA AND DATA_FINE IS NULL AND ID_PROCEDIMENTO = 7)
AND       DC.ID_MOTIVO_DICHIARAZIONE <> 7
AND       DC.DATA_INSERIMENTO_DICHIARAZIONE = (    SELECT MAX(DCX.DATA_INSERIMENTO_DICHIARAZIONE)
                                                                FROM  DB_DICHIARAZIONE_CONSISTENZA DCX,
                                                                        DB_TIPO_MOTIVO_DICHIARAZIONE TI
                                                                WHERE      DCX.ID_AZIENDA = DC.ID_AZIENDA
                                                                AND         DCX.ID_MOTIVO_DICHIARAZIONE <> 7
                                                                AND        TI.ID_MOTIVO_DICHIARAZIONE = DCX.ID_MOTIVO_DICHIARAZIONE
                                                                AND        TI.TIPO_DICHIARAZIONE        != 'C'
                                                            );

CURSOR cur_conduzioni_attive(p_id_particella DB_PARTICELLA.ID_PARTICELLA%TYPE) IS
SELECT CP.ID_CONDUZIONE_PARTICELLA
FROM   DB_CONDUZIONE_PARTICELLA CP, DB_UTE U
WHERE  CP.ID_UTE = U.ID_UTE
AND    CP.DATA_FINE_CONDUZIONE IS NULL
AND    CP.ID_PARTICELLA = p_id_particella
AND       U.DATA_FINE_ATTIVITA IS NULL
AND      CP.ID_TITOLO_POSSESSO  != 6
AND    U.ID_AZIENDA = p_id_azienda;

BEGIN

    -- dati dell'azienda principale
    SELECT CUAA, DENOMINAZIONE
    INTO   v_cuaa_azienda_principale, v_denominaz_azienda_principale
    FROM   DB_ANAGRAFICA_AZIENDA
    WHERE  ID_AZIENDA = p_id_azienda
    AND       DATA_FINE_VALIDITA IS NULL
    AND       DATA_CESSAZIONE IS NULL;

    BEGIN

        SELECT I.CODICE_FISCALE
        INTO   v_cod_fisc_azienda_principale
        FROM   DB_DELEGA D, DB_INTERMEDIARIO I
        WHERE  D.ID_INTERMEDIARIO = I.ID_INTERMEDIARIO
        AND       D.DATA_FINE IS NULL
        AND       D.ID_AZIENDA = p_id_azienda
        AND       D.ID_PROCEDIMENTO = 7;

    EXCEPTION
    WHEN NO_DATA_FOUND THEN
        v_cod_fisc_azienda_principale := 'ASSENTE';
    WHEN OTHERS THEN
        RAISE;
    END;

    FOR rec_particelle IN cur_particelle LOOP
        v_superficie_condotta_az := rec_particelle.SUPERFICIE_CONDOTTA;
        v_superficie_agronomica_az := rec_particelle.SUPERFICIE_AGRONOMICA;
        v_descrizione_errore := '';

        SELECT  NVL(SUM(NVL(CD.SUPERFICIE_CONDOTTA,0)+NVL(CD.SUPERFICIE_AGRONOMICA,0)),0)
        INTO    v_superficie_condotta
        FROM    DB_DICHIARAZIONE_CONSISTENZA DC, DB_CONDUZIONE_DICHIARATA CD,
                DB_ANAGRAFICA_AZIENDA AA, DB_AZIENDA A
        WHERE    A.ID_AZIENDA = AA.ID_AZIENDA
        AND        AA.ID_AZIENDA = DC.ID_AZIENDA
        AND        DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
        AND        CD.ID_PARTICELLA= rec_particelle.ID_PARTICELLA
        AND     CD.ID_TITOLO_POSSESSO = 5
        AND     DC.id_azienda <> p_id_azienda
        AND     AA.DATA_FINE_VALIDITA IS NULL
        AND     AA.DATA_CESSAZIONE IS NULL
        AND     (A.FLAG_AZIENDA_PROVVISORIA IS NULL OR A.FLAG_AZIENDA_PROVVISORIA = 'N')
        AND           DC.ID_MOTIVO_DICHIARAZIONE <> 7
        AND           DC.DATA_INSERIMENTO_DICHIARAZIONE = (    SELECT MAX(DCX.DATA_INSERIMENTO_DICHIARAZIONE)
                                                                            FROM       DB_DICHIARAZIONE_CONSISTENZA    DCX,
                                                                                        DB_TIPO_MOTIVO_DICHIARAZIONE     TI
                                                                            WHERE DCX.ID_AZIENDA = DC.ID_AZIENDA
                                                                            AND    DCX.ID_MOTIVO_DICHIARAZIONE <> 7
                                                                            AND    TI.ID_MOTIVO_DICHIARAZIONE = DCX.ID_MOTIVO_DICHIARAZIONE
                                                                            AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                                                        );

        SELECT  NVL(SUM(CD.SUPERFICIE_AGRONOMICA),0)
        INTO    v_superficie_agronomica
        FROM    DB_DICHIARAZIONE_CONSISTENZA DC, DB_CONDUZIONE_DICHIARATA CD,
                DB_ANAGRAFICA_AZIENDA AA, DB_AZIENDA A
        WHERE    A.ID_AZIENDA = AA.ID_AZIENDA
        AND        AA.ID_AZIENDA = DC.ID_AZIENDA
        AND        DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
        AND        CD.ID_PARTICELLA=rec_particelle.ID_PARTICELLA
--        AND     CD.ID_TITOLO_POSSESSO <> 5
          AND     CD.ID_TITOLO_POSSESSO  NOT IN (5,6)
        AND     DC.id_azienda <> p_id_azienda
        AND     AA.DATA_FINE_VALIDITA IS NULL
        AND     AA.DATA_CESSAZIONE IS NULL
        AND     (A.FLAG_AZIENDA_PROVVISORIA IS NULL OR A.FLAG_AZIENDA_PROVVISORIA = 'N')
        AND     DC.ID_MOTIVO_DICHIARAZIONE <> 7
        AND           DC.DATA_INSERIMENTO_DICHIARAZIONE = (    SELECT MAX(DCX.DATA_INSERIMENTO_DICHIARAZIONE)
                                                                            FROM  DB_DICHIARAZIONE_CONSISTENZA    DCX,
                                                                                    DB_TIPO_MOTIVO_DICHIARAZIONE     TI
                                                                            WHERE DCX.ID_AZIENDA = DC.ID_AZIENDA
                                                                            AND    DCX.ID_MOTIVO_DICHIARAZIONE <> 7
                                                                            AND    TI.ID_MOTIVO_DICHIARAZIONE = DCX.ID_MOTIVO_DICHIARAZIONE
                                                                            AND    TI.TIPO_DICHIARAZIONE        != 'C'
                                                                        );


        v_sezione := '';
        v_subalterno := '';

        IF rec_particelle.SUP_RIFERIMENTO < v_superficie_agronomica_az + v_superficie_condotta_az + v_superficie_condotta + v_superficie_agronomica THEN

            IF rec_particelle.SEZIONE IS NOT NULL THEN

                v_sezione := ' Sz: '||rec_particelle.SEZIONE;

            END IF;

            IF rec_particelle.SUBALTERNO IS NOT NULL THEN

                v_subalterno := ' Sub: '||rec_particelle.SUBALTERNO;

            END IF;

            -- cerco i dati dell'azienda parametro della function da inserire nel messaggio

            v_descrizione_errore := '[' || rec_particelle.DESCOM ||v_sezione||
                              ' Fgl:' || rec_particelle.FOGLIO ||' Part:' || rec_particelle.PARTICELLA ||
                            v_subalterno || '] ';

            -- differenzio il messaggio in base
            -- al fatto che la superficie di riferimento sia la grafica
            -- o la catastale
            IF rec_particelle.SUP_RIFERIMENTO = rec_particelle.SUPERFICIE_GRAFICA THEN
                v_descrizione_errore := v_descrizione_errore || 'Sup.grafica.: '|| TRIM(TO_CHAR(NVL(rec_particelle.SUPERFICIE_GRAFICA,0),'999G990D9999')) || ' (ha). ';
            ELSE
                v_descrizione_errore := v_descrizione_errore || 'Sup.cat.: '|| TRIM(TO_CHAR(NVL(rec_particelle.SUP_CATASTALE,0),'999G990D9999')) || ' (ha). ';
            END IF;
            v_descrizione_errore := v_descrizione_errore ||
                                     ' Azienda: '||v_cuaa_azienda_principale||'-'||SUBSTR(v_denominaz_azienda_principale,1,50)||
                                    ' (CAA: '||v_cod_fisc_azienda_principale||')';

            IF v_superficie_agronomica_az > 0 THEN
                v_descrizione_errore := v_descrizione_errore ||' superficie agronomica '||
                                         TRIM(TO_CHAR(v_superficie_agronomica_az,'999G990D9999'))||' (ha). ';
            END IF;

            IF v_superficie_condotta_az > 0 THEN
                v_descrizione_errore := v_descrizione_errore ||' superficie condotta '||
                                         TRIM(TO_CHAR(v_superficie_condotta_az,'999G990D9999'))||' (ha). ';
            END IF;

            FOR rec_aziende_supero IN cur_aziende_supero(rec_particelle.ID_PARTICELLA) LOOP
                v_messaggio_conduzione := '';

                IF rec_aziende_supero.SUPERFICIE > 0 THEN

                    IF rec_aziende_supero.ID_TITOLO_POSSESSO = 5 THEN
                        v_messaggio_conduzione := ' conduce in asservimento ';
                    ELSE
                        v_messaggio_conduzione := ' superficie agronomica ';
                    END IF;
                    v_descrizione_errore := v_descrizione_errore ||
                                             ' Azienda: '||rec_aziende_supero.CUAA||'-'||SUBSTR(rec_aziende_supero.DENOMINAZIONE,1,50)||
                                            ' (CAA: '||rec_aziende_supero.CAA||')'||
                                            v_messaggio_conduzione||TRIM(TO_CHAR(NVL(rec_aziende_supero.SUPERFICIE,0),'999G990D9999'))||' (ha). ';
                END IF;

            END LOOP;

            IF NOT SCRIVI_SEGNALAZIONE (p_id_azienda, p_id_controllo, v_descrizione_errore, p_bloccante,
                                              rec_particelle.ID_STORICO_PARTICELLA, NULL, P_MSGERR, P_CODERR) THEN
                RETURN FALSE;
            END IF;


            FOR rec_particelle_attive IN cur_conduzioni_attive(rec_particelle.ID_PARTICELLA) LOOP
                IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (p_id_azienda, p_id_controllo, v_descrizione_errore, p_bloccante,
                                                             rec_particelle_attive.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                    RETURN FALSE;
                END IF;
            END LOOP;

        END IF;

    END LOOP;

    RETURN TRUE;

EXCEPTION

WHEN OTHERS THEN
    p_MsgErr   := 'CONTROLLA_SUPERO_ASSERVIMENTO: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN FALSE;

END CONTROLLA_SUPERO_ASSERVIMENTO;


FUNCTION CONTROLLA_UV_ASSERV_CONFERIM (p_id_azienda   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                         p_id_controllo IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        p_bloccante    IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                         p_msgerr       IN OUT VARCHAR2,
                                        p_coderr            IN OUT VARCHAR2) RETURN BOOLEAN IS

v_conta                    NUMBER;
v_descrizione_errore    DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;

CURSOR  cur_conduzioni_uv_asservite IS
SELECT  DISTINCT CP.ID_PARTICELLA, SP.ID_STORICO_PARTICELLA, SUA.ID_STORICO_UNITA_ARBOREA,C.DESCOM,
                    DECODE(SP.SEZIONE,NULL,'',' Sz: '||SP.SEZIONE) SEZIONE,
                     DECODE(SP.FOGLIO,NULL,'',' Fgl: '||SP.FOGLIO) FOGLIO,
                    DECODE(SP.PARTICELLA,NULL,'',' Part: '||SP.PARTICELLA) PARTICELLA,
                    DECODE(SP.SUBALTERNO,NULL,'',' Sub: '||SP.SUBALTERNO) SUBALTERNO
FROM    DB_CONDUZIONE_PARTICELLA CP, DB_STORICO_UNITA_ARBOREA SUA, DB_STORICO_PARTICELLA SP, DB_UTE U, COMUNE C
WHERE    U.ID_AZIENDA = SUA.ID_AZIENDA
AND        U.ID_UTE = CP.ID_UTE
AND        SP.ID_PARTICELLA = CP.ID_PARTICELLA
AND        CP.ID_PARTICELLA = SUA.ID_PARTICELLA
AND        SP.COMUNE = C.ISTAT_COMUNE
AND        CP.DATA_FINE_CONDUZIONE IS NULL
AND        SP.DATA_FINE_VALIDITA IS NULL
AND        U.DATA_FINE_ATTIVITA IS NULL
AND        SUA.DATA_CESSAZIONE IS NULL
AND        SUA.DATA_FINE_VALIDITA IS NULL
--AND        CP.ID_TITOLO_POSSESSO = 5
AND        CP.ID_TITOLO_POSSESSO IN (5,6)
AND        SUA.ID_AZIENDA = p_id_azienda;

-- cursore di tutte le conduzioni legate alle particella di una azienda
CURSOR     cur_conduzioni_particella(p_id_particella DB_PARTICELLA.ID_PARTICELLA%TYPE) IS
SELECT    DISTINCT CP.ID_CONDUZIONE_PARTICELLA
FROM    DB_UTE U, DB_CONDUZIONE_PARTICELLA CP
WHERE    U.ID_UTE = CP.ID_UTE
AND        U.DATA_FINE_ATTIVITA IS NULL
AND        CP.DATA_FINE_CONDUZIONE IS NULL
AND        U.ID_AZIENDA = p_id_azienda
AND        CP.ID_PARTICELLA = p_id_particella;

BEGIN

FOR rec_conduzioni_uv_asservite IN cur_conduzioni_uv_asservite LOOP

    SELECT COUNT(*)
    INTO   v_conta
    FROM   DB_CONDUZIONE_PARTICELLA CP, DB_UTE U, DB_STORICO_UNITA_ARBOREA SUA
    WHERE U.ID_AZIENDA = p_id_azienda 
    AND   U.ID_AZIENDA = SUA.ID_AZIENDA
    AND      U.ID_UTE = CP.ID_UTE
    AND      CP.ID_PARTICELLA = SUA.ID_PARTICELLA
    AND      CP.DATA_FINE_CONDUZIONE IS NULL
    AND      U.DATA_FINE_ATTIVITA IS NULL
    AND      SUA.DATA_CESSAZIONE IS NULL
    AND      SUA.DATA_FINE_VALIDITA IS NULL
--    AND   CP.ID_TITOLO_POSSESSO <> 5
    AND   CP.ID_TITOLO_POSSESSO NOT IN (5,6)
    AND      CP.ID_PARTICELLA = rec_conduzioni_uv_asservite.ID_PARTICELLA;

    IF v_conta = 0 THEN

        v_descrizione_errore := '[' ||
                                 rec_conduzioni_uv_asservite.DESCOM||
                                rec_conduzioni_uv_asservite.SEZIONE||
                                rec_conduzioni_uv_asservite.FOGLIO||
                                rec_conduzioni_uv_asservite.PARTICELLA||
                                rec_conduzioni_uv_asservite.SUBALTERNO||
                                 '] Impossibile inserire unità vitate su conduzioni asservimento o conferimento';

        IF NOT SCRIVI_SEGNALAZIONE (p_id_azienda, p_id_controllo, v_descrizione_errore,P_BLOCCANTE, rec_conduzioni_uv_asservite.ID_STORICO_PARTICELLA, rec_conduzioni_uv_asservite.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
            RETURN FALSE;
        END IF;

        IF NOT SCRIVI_SEGNALAZIONE_UNAR (p_id_azienda, p_id_controllo, v_descrizione_errore,
                                         P_BLOCCANTE, rec_conduzioni_uv_asservite.ID_STORICO_UNITA_ARBOREA, P_MSGERR, P_CODERR) THEN
            RETURN FALSE;
        END IF;

        FOR rec_conduzioni_particella IN cur_conduzioni_particella(rec_conduzioni_uv_asservite.ID_PARTICELLA) LOOP
            IF NOT SCRIVI_SEGNALAZIONE_PARTICELLA (p_id_azienda, p_id_controllo, v_descrizione_errore,
                                                        P_BLOCCANTE, rec_conduzioni_particella.ID_CONDUZIONE_PARTICELLA, P_MSGERR, P_CODERR) THEN
                RETURN FALSE;
            END IF;
        END LOOP;

    END IF;

END LOOP;

RETURN TRUE;

EXCEPTION

WHEN OTHERS THEN
    p_MsgErr   := 'CONTROLLA_UV_ASSERV_CONFERIM: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN FALSE;
END CONTROLLA_UV_ASSERV_CONFERIM;


-- controlla che non esistano dichiarazioni di consistenza di un'azienda
-- non protocollate
-- inizio --
FUNCTION VALIDA_NUOVA_DICHIARAZIONE(p_id_azienda   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                         p_id_controllo IN      DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                                        p_bloccante    IN      DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                                         p_msgerr       IN OUT VARCHAR2,
                                        p_coderr            IN OUT VARCHAR2) RETURN BOOLEAN IS

v_conta_procedimenti NUMBER;

CURSOR cur_dichiaraz_consist IS
SELECT ID_DICHIARAZIONE_CONSISTENZA
FROM   DB_DICHIARAZIONE_CONSISTENZA
WHERE  ID_AZIENDA = p_id_azienda
AND       ANNO = TO_NUMBER(TO_CHAR(SYSDATE,'YYYY'))-1
AND       NUMERO_PROTOCOLLO IS NULL
AND       DATA_PROTOCOLLO IS NULL
AND    ID_MOTIVO_DICHIARAZIONE NOT IN (SELECT ID_MOTIVO_DICHIARAZIONE
                                         FROM DB_TIPO_MOTIVO_DICHIARAZIONE
                                        WHERE ID_FASE = knIdFaseGenIsoleParcelle); 

BEGIN
    v_conta_procedimenti := 1;
    FOR rec_dichiaraz_consist IN cur_dichiaraz_consist LOOP
        IF v_conta_procedimenti != 0 THEN
            SELECT COUNT(*)
            INTO    v_conta_procedimenti
            FROM     DB_PROCEDIMENTO_AZIENDA
            WHERE     ID_DICHIARAZIONE_CONSISTENZA = rec_dichiaraz_consist.ID_DICHIARAZIONE_CONSISTENZA
            AND    ID_AZIENDA = p_id_azienda;
        END IF;
    END LOOP;

    IF v_conta_procedimenti = 0 THEN

        IF NOT SCRIVI_SEGNALAZIONE (p_id_azienda, p_id_controllo, 'Esistono delle dichiarazioni di consistenza nell''anno precedente non protocollate ne'' legate ad alcuna pratica. Procedere con l''eliminazione.',
                                            P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
            RETURN FALSE;

        END IF;
    END IF;

RETURN TRUE;

EXCEPTION

WHEN OTHERS THEN
    p_MsgErr   := 'VALIDA_NUOVA_DICHIARAZIONE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN FALSE;

END VALIDA_NUOVA_DICHIARAZIONE;
-- fine --

-- aggiunto parametro P_ID_UTENTE_IRIDE
FUNCTION ESEGUI_CONTROLLI(P_ID_CONTROLLO               DB_TIPO_CONTROLLO.ID_CONTROLLO%TYPE,
                          P_ID_GRUPPO_CONTROLLO        DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE,
                          P_ID_AZIENDA                 DB_AZIENDA.ID_AZIENDA%TYPE,
                          P_ANNO_RIF                   DB_UTILIZZO_PARTICELLA.ANNO%TYPE,
                          P_BLOCCANTE                  DB_TIPO_CONTROLLO_FASE.BLOCCANTE%TYPE,
                          P_SCRIVI_POSITIVI            BOOLEAN,
                          P_FASE                       DB_TIPO_CONTROLLO_FASE.FASE%TYPE,
                          P_ID_UTENTE_LOGIN            PAPUA_V_UTENTE_LOGIN.ID_UTENTE_LOGIN%TYPE, 
                          P_ID_DICHIARAZIONE           DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                          P_MSGERR              IN OUT VARCHAR2,
                          P_CODERR              IN OUT VARCHAR2) RETURN BOOLEAN IS
var_result VARCHAR2(10);
var_id_err NUMBER;
var_descrizione_msg_errore DB_DICHIARAZIONE_SEGNALAZIONE.DESCRIZIONE%TYPE;
nPercP26   NUMBER:=0;

BEGIN


    IF nAnnoCampagna IS NOT NULL THEN
        SELECT TO_DATE(valore||TO_CHAR(nAnnoCampagna),'DD/MM/YYYY') INTO dDataConfCorrettiva  FROM  DB_PARAMETRO  WHERE  id_parametro='DTCO';
    ELSE
        dDataConfCorrettiva := NULL;
    END IF;
    /************ GRUPPO 1 - ANAGRAFICA ***********/

     IF P_ID_CONTROLLO = 10 AND
        (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)       THEN

        Pack_Controlli.ANA03 (P_ID_AZIENDA, var_result,
            var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
        ELSE
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   'P' , NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;
     END IF;


     IF P_ID_CONTROLLO = 20 AND  (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe) THEN
            IF NOT UNIVOCITA_CUAA (P_ID_AZIENDA, VAR_CUAA,P_ID_CONTROLLO, P_BLOCCANTE, P_SCRIVI_POSITIVI, p_fase,
               P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
     END IF;

    /******** ANAGRAFE TRIBUTARIA **************/



     IF P_ID_CONTROLLO = 177 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

        Pack_Controlli.TRB05 (VAR_CUAA, var_result,
            var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
        ELSE
            VAR_PRESENZA_TRIBUTARIA :=TRUE;
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 160  AND VAR_PRESENZA_TRIBUTARIA AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

        Pack_Controlli.TRB01 (P_ID_AZIENDA, VAR_CUAA, var_result,
            var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
        ELSE
--            VAR_PRESENZA_TRIBUTARIA :=TRUE;
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 174 AND VAR_PRESENZA_TRIBUTARIA AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

        Pack_Controlli.TRB03 (VAR_CUAA, var_result,
            var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
        ELSE
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 173 AND VAR_PRESENZA_TRIBUTARIA AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

        Pack_Controlli.TRB02 ( P_ID_AZIENDA, VAR_CUAA, var_result,
            var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
        ELSE
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 175 AND VAR_PRESENZA_TRIBUTARIA AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

        Pack_Controlli.TRB04 ( P_ID_AZIENDA, VAR_CUAA, var_result,
            var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
        ELSE
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 178 AND VAR_PRESENZA_TRIBUTARIA AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

        Pack_Controlli.TRB06 (P_ID_AZIENDA, S_CODICE_FISCALE, var_result, var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
          IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
               P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;
        ELSE
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 179 AND VAR_PRESENZA_TRIBUTARIA AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

        Pack_Controlli.TRB07 (P_ID_AZIENDA, S_CODICE_FISCALE, var_result, var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
          IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
               P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;
        ELSE
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 180 AND VAR_PRESENZA_TRIBUTARIA AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

        Pack_Controlli.TRB08 (P_ID_AZIENDA, VAR_CUAA, var_result, var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
          IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
               P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;
        ELSE
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;
     END IF;

     -- richiamo una prima volta il TRB09 passando il cuaa e il flag persona fisica ad S
     IF P_ID_CONTROLLO = 184 AND VAR_PRESENZA_TRIBUTARIA AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

        Pack_Controlli.TRB09 (P_ID_AZIENDA,var_result, var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
          IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
               P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;
        ELSE
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;
     END IF;

/*
     -- richiamo una seconda volta il TRB09 passando il cuaa e il flag persona fisica ad N
     IF P_ID_CONTROLLO = 185 AND VAR_PRESENZA_TRIBUTARIA AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

        Pack_Controlli.TRB09 (VAR_CUAA, 'N',var_result, var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
          IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
               P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;
        ELSE
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;
     END IF;
*/
     -- verifica presenza recapiti mail
     IF P_ID_CONTROLLO = 186 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe) AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        Pack_Controlli.ANA19 ( P_ID_AZIENDA, var_result, var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;
     END IF;

     -- verifica presenza PEC
     IF P_ID_CONTROLLO = 187 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe) AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        Pack_Controlli.ANA20 ( P_ID_AZIENDA, var_result, var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;
     END IF;

     -- verifica presenza recapiti telefonici
     IF P_ID_CONTROLLO = 189 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe) AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        Pack_Controlli.ANA22 ( P_ID_AZIENDA, var_result, var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;
     END IF;

     -- aggiunto nuovo controllo ANA23
     -- verifica che non siano indicati i dati relativi
     -- all'iscrizione in camera di commercio sul fascicolo se
     -- l¿azienda in oggetto non risulta iscritta in CCIAA (fonte Infocamere),
     IF P_ID_CONTROLLO = 191 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe) AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        Pack_Controlli.ANA23 ( P_ID_AZIENDA, VAR_CUAA, var_result, var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 194 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe) AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        Pack_Controlli.ANA24 ( P_ID_AZIENDA, var_result, var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;
     END IF;

     --------
     IF P_ID_CONTROLLO = 182 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDichiarazioni)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

         IF NOT Controlla_Iban (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     -- aggiunto controllo per verificare invalidazione conto corrente da parte di SIGOP
     IF P_ID_CONTROLLO = 183
     AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoConti)
     AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        IF NOT Conto_Corrente_Invalidato (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     /******** AAEP **************/
     IF P_ID_CONTROLLO = 161 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

        Pack_Controlli.AEP01 (VAR_CUAA, var_result,
            var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
        ELSE
            VAR_PRESENZA_AAEP :=TRUE;
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;
     END IF;

     -- sostituisce AEP01 ed AEP02 dal 2014 ma le altre chiamate
     -- restano semplicemente i controlli non saranno configurati come da eseguire
     IF P_ID_CONTROLLO = 169 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

        -- passo null ovvero attiva in sysdate
        Pack_Controlli.AEP09 (P_ID_AZIENDA, NULL,var_result,var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
        ELSE
            IF var_descrizione_msg_errore NOT LIKE '%esente%' THEN
               VAR_PRESENZA_AAEP :=TRUE;
            END IF;
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;

     END IF;


     IF var_PRESENZA_AAEP AND P_ID_CONTROLLO = 162 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN


            Pack_Controlli.AEP02 (VAR_CUAA, var_result,
                var_descrizione_msg_errore, var_id_err);

            IF var_result <> '0' THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            ELSIF P_SCRIVI_POSITIVI THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            END IF;
     END IF;

     IF var_PRESENZA_AAEP AND P_ID_CONTROLLO = 163 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

            Pack_Controlli.AEP03 (P_ID_AZIENDA,VAR_CUAA, var_result,
                var_descrizione_msg_errore, var_id_err);

            IF var_result <> '0' THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;

            ELSIF P_SCRIVI_POSITIVI THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            END IF;
     END IF;

     IF var_PRESENZA_AAEP AND P_ID_CONTROLLO = 164 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

            Pack_Controlli.AEP04 (P_ID_AZIENDA,VAR_CUAA, var_result,
                var_descrizione_msg_errore, var_id_err);

            IF var_result <> '0' THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            ELSIF P_SCRIVI_POSITIVI THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            END IF;
     END IF;

     IF var_PRESENZA_AAEP AND P_ID_CONTROLLO = 165 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

            Pack_Controlli.AEP05 (P_ID_AZIENDA,VAR_CUAA, var_result,
                var_descrizione_msg_errore, var_id_err);

            IF var_result <> '0' THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            ELSIF P_SCRIVI_POSITIVI THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            END IF;
     END IF;

     IF var_PRESENZA_AAEP AND P_ID_CONTROLLO = 166 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

            Pack_Controlli.AEP06 (P_ID_AZIENDA,VAR_CUAA, var_result,
                var_descrizione_msg_errore, var_id_err);

            IF var_result <> '0' THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            ELSIF P_SCRIVI_POSITIVI THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            END IF;
     END IF;

     IF var_PRESENZA_AAEP AND P_ID_CONTROLLO = 167 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

            Pack_Controlli.AEP07 (P_ID_AZIENDA,VAR_CUAA, var_result,
                var_descrizione_msg_errore, var_id_err);

            IF var_result <> '0' THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            ELSIF P_SCRIVI_POSITIVI THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            END IF;
     END IF;

     IF var_PRESENZA_AAEP AND P_ID_CONTROLLO = 168 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

            Pack_Controlli.AEP08 (P_ID_AZIENDA,VAR_CUAA, var_result,
                var_descrizione_msg_errore, var_id_err);

            IF var_result <> '0' THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       P_BLOCCANTE, NULL,NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            ELSIF P_SCRIVI_POSITIVI THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            END IF;
     END IF;

     -- AEP10
     IF var_PRESENZA_AAEP AND P_ID_CONTROLLO = 192 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

            Pack_Controlli.AEP10 (P_ID_AZIENDA,VAR_CUAA, var_result,
                var_descrizione_msg_errore, var_id_err);

            IF var_result <> '0' THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       P_BLOCCANTE, NULL,NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            ELSIF P_SCRIVI_POSITIVI THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            END IF;
     END IF;

     -- AEP11
     IF var_PRESENZA_AAEP AND P_ID_CONTROLLO = 193 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

            Pack_Controlli.AEP11 (P_ID_AZIENDA,VAR_CUAA, var_result,
                var_descrizione_msg_errore, var_id_err);

            IF var_result <> '0' THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       P_BLOCCANTE, NULL,NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            ELSIF P_SCRIVI_POSITIVI THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       'P', NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            END IF;
     END IF;

       /************ PARTITA IVA***********/
     IF P_ID_CONTROLLO = 112 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)  THEN

        Pack_Controlli.ANA04 (P_ID_AZIENDA, var_result,
            var_descrizione_msg_errore, var_id_err);
        -- MANCA PARTITA IVA
        IF var_result <> '0' THEN
           -- MANCA PARTITA IVA
           IF (var_flag_provvisoria IS NULL OR var_flag_provvisoria <>'S') AND var_flag_partitaiva='S' THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            END IF;
            IF var_flag_provvisoria ='S'  AND  P_FASE= costanteFaseInsediamento THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            END IF;
        ELSE
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   'P' , NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;
    END IF;
    IF P_ID_CONTROLLO = 102 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)  THEN
        IF var_piva IS NOT NULL THEN
            Pack_Controlli.ANA05 (P_ID_AZIENDA, var_result,
                var_descrizione_msg_errore, var_id_err);

            IF var_result <> '0' THEN
                   IF (var_flag_provvisoria IS NULL OR var_flag_provvisoria <>'S') AND var_flag_partitaiva='S' THEN
                      IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                           P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                         RETURN (FALSE);
                      END IF;
                   END IF;
                   IF var_flag_provvisoria = 'S' AND P_FASE= costanteFaseInsediamento THEN
                      IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                           P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                         RETURN (FALSE);
                      END IF;
                   END IF;
            ELSE
                IF P_SCRIVI_POSITIVI THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       'P' , NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
                END IF;
            END IF;
        END IF;
     END IF;
     --UNIVOCITA' PARTITA IVA
     IF P_ID_CONTROLLO = 171 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)  THEN
         IF VAR_PIVA IS NOT NULL AND NOT (var_flag_provvisoria = 'S' AND P_FASE<> costanteFaseInsediamento) THEN
                  IF NOT univocita_piva (P_ID_AZIENDA, VAR_PIVA, p_id_controllo,
                       P_BLOCCANTE, P_SCRIVI_POSITIVI,P_FASe,P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
        END IF;
     END IF;


    /*************** SEDE LEG *********************/
     IF P_ID_CONTROLLO = 103 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

        Pack_Controlli.ANA07 (P_ID_AZIENDA, var_result,
            var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
        ELSE
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   'P' , NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;
     END IF;

     /*************** TITOLARE *********************/
     IF P_ID_CONTROLLO = 113 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN
         Pack_Controlli.TIT01 (P_ID_AZIENDA, var_result,
            var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
        ELSE
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   'P' , NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;

     END IF;

     IF P_ID_CONTROLLO = 114 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN
        Pack_Controlli.TIT02 (P_ID_AZIENDA, var_result,
            var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 105 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN
        Pack_Controlli.TIT04 (P_ID_AZIENDA, var_result,
            var_descrizione_msg_errore, var_id_err);
        IF var_result <> '0' THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
        END IF;
     END IF;

     /*************** cciaa *********************/
     IF P_ID_CONTROLLO = 104 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN

        IF var_flag_cciaa='S' THEN

            Pack_Controlli.ANA10 (P_ID_AZIENDA, var_result, var_descrizione_msg_errore, var_id_err);
            IF (var_flag_provvisoria IS NULL OR var_flag_provvisoria = 'N') OR p_fase=costanteFaseInsediamento   THEN
                  IF var_result <> '0' THEN
                      IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                           P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                         RETURN (FALSE);
                      END IF;
                  ELSE
                        IF P_SCRIVI_POSITIVI THEN
                          IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                               'P' , NULL, NULL, P_MSGERR, P_CODERR) THEN
                             RETURN (FALSE);
                          END IF;
                        END IF;
                  END IF;
           END IF;
        END IF;

     END IF;

     IF P_ID_CONTROLLO = 110 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN
         IF NOT CONTROLLA_INSEDIAMENTO_GIOVANI (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE,VAR_AZIENDA_GIOVANE,
           P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 111 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)   THEN
         IF var_data_fine_fg IS NOT NULL THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, 'Forma giuridica non più valida',
                       P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
        END IF;
        IF NOT COERENZA_TIPO_FG(P_ID_AZIENDA,var_forma_giuridica, var_tipo_azienda, P_ID_CONTROLLO, P_BLOCCANTE,
           P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     /***************** UNIVOCITà RAPPRESENTENTANTE LEGALE ***********/
     IF P_ID_CONTROLLO = 172 AND  (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe) THEN
            IF NOT UNIVOCITA_RAPPLEG (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE,P_SCRIVI_POSITIVI, P_FASE,P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
     END IF;
     /***************** azienda cedente ***********/
     IF P_ID_CONTROLLO = 170 AND  (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe) THEN
            IF NOT azienda_cedente (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE,P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
     END IF;
/*************** SOGGETTI COLLEGATI  *********************/
     IF P_ID_CONTROLLO = 150 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoSoggetti)   THEN

        IF NOT CONTROLLO_RUOLO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE,
           P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     /*************** UTE *********************/
     IF P_ID_CONTROLLO = 106 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoUte)   THEN

        Pack_Controlli.ute01 (P_ID_AZIENDA, var_result,
            var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
         ELSE
              Pack_Controlli.ute03 (P_ID_AZIENDA, var_result,
                var_descrizione_msg_errore, var_id_err);

            IF var_result <> '0' THEN
                  IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                       P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                     RETURN (FALSE);
                  END IF;
            END IF;
        END IF;


     END IF;

     IF P_ID_CONTROLLO = 109 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoUte) THEN

        IF NOT CONTROLLA_UNIVOCITA_UTE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE,
           P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

/*
    IF P_ID_CONTROLLO = 115
    AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)
    AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
        IF NOT CONTROLLO_INDICATORI_AZIENDALI (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;
    END IF;
*/
    IF P_ID_CONTROLLO = 116
    AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)
    AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
        IF NOT CONTROLLO_CODICE_ATECO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;
    END IF;

    IF P_ID_CONTROLLO = 117
    AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)
    AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
        IF NOT CONTROLLO_CODICE_ATECO_UTE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;
    END IF;


    IF P_ID_CONTROLLO = 118
    AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)
    AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
        IF NOT DATI_ANAGRAFICI_SOGGETTO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;
    END IF;

    IF P_ID_CONTROLLO = 119
    AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)
    AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
        IF NOT CODICE_FISCALE_SOGGETTO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;
    END IF;

    IF P_ID_CONTROLLO = 120
    AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAnagrafe)
    AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
        IF NOT RESIDENZA_SOGGETTO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;
    END IF;


      /*************** ALTRI *********************/
     IF P_ID_CONTROLLO = 107 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoConti)   THEN
         IF NOT PRESENZA_CONTO_CORRENTE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE,
           P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

      IF P_ID_CONTROLLO = 176 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoConti)   THEN
         IF NOT INTESTATARIO_CONTO_CORRENTE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE,
           P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 108 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoManodopera)   THEN
         IF NOT PRESENZA_MANODOPERA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE,
           P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     /******************** CONTI CORRENTI ****************************/
     IF P_ID_CONTROLLO = 517 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoConti)   THEN

        Pack_Controlli.CNC01 (P_ID_AZIENDA, NULL, var_result,
            var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
        ELSE
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   'P' , NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;

     END IF;

     IF P_ID_CONTROLLO = 519 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoConti)   THEN

        Pack_Controlli.CNC02 (P_ID_AZIENDA, var_result,
            var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
        ELSE
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   'P' , NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;

     END IF;

     IF P_ID_CONTROLLO = 181 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoConti)   THEN

        Pack_Controlli.CNC03 (P_ID_AZIENDA, var_result,
            var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
        ELSE
            IF P_SCRIVI_POSITIVI THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   'P' , NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
            END IF;
        END IF;

     END IF;

     /********************* CONTROLLI TERRENI *******************/
     IF P_ID_CONTROLLO = 200 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
         IF NOT PRESENZA_TERRENI (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE,
           P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
     IF nAnnoCampagna IS NULL THEN
         IF P_ID_CONTROLLO = 201 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
             IF NOT CONTROLLA_CONTENZIOSO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE,
               P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
         END IF;
     END IF;
     IF P_ID_CONTROLLO = 202 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
         IF NOT VAR_AZIENDA_GIOVANE THEN
           IF NOT CONTROLLA_SUPERO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE,
                 P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
           END IF;
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 2021 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
       IF NOT CONTROLLA_SUPERO_CATASTALE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE,
             P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
       END IF;
     END IF;

      IF P_ID_CONTROLLO = 203 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
         IF NOT USO_DEL_SUOLO_MANCANTE (P_ID_AZIENDA, P_ID_CONTROLLO,
               P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
     IF nAnnoCampagna IS NULL THEN
          IF P_ID_CONTROLLO = 204 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
             IF NOT USO_DEL_SUOLO_NON_VALIDO (P_ID_AZIENDA, P_ID_CONTROLLO,
               P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
         END IF;
     END IF;
     IF P_ID_CONTROLLO = 205 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni) THEN
         IF NOT SUPERO_USO_DEL_SUOLO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE,
           P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 206 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
         IF NOT INCOERENZA_SUP_FABBRICATO (P_ID_AZIENDA, P_ID_CONTROLLO,
           P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 208 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
         IF NOT controlla_presenza_agea (P_ID_AZIENDA, P_ID_CONTROLLO,
           P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 209 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
         IF NOT controlla_superficie_agea (P_ID_AZIENDA, P_ID_CONTROLLO,
           P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 210 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
          IF NOT CONTROLLO_PARTICELLE_PIEMONTE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
         END IF;
     END IF;

     IF P_ID_CONTROLLO = 211 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
          IF NOT CONTROLLO_PARTICELLE_A_GIS (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
         END IF;
     END IF;

     IF P_ID_CONTROLLO = 219 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
          IF NOT MACRO_USO_INCONGRUENTE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR)  THEN
             RETURN (FALSE);
         END IF;
     END IF;

     IF P_ID_CONTROLLO = 220 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
          IF NOT USO_VITE_AUTOCONSUMO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR)  THEN
             RETURN (FALSE);
         END IF;
     END IF;

     IF P_ID_CONTROLLO = 221 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
          IF NOT CONFERIMENTO_DA_SOCI (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR)  THEN
             RETURN (FALSE);
         END IF;
     END IF;

     IF P_ID_CONTROLLO = 222 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
          IF NOT CONFERIMENTO_ULTIMA_DC_DA_SOCI (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR)  THEN
             RETURN (FALSE);
         END IF;
     END IF;

     IF P_ID_CONTROLLO = 223 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
          IF NOT SUPERO_CONFERIMENTO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR)  THEN
             RETURN (FALSE);
         END IF;
     END IF;

     IF P_ID_CONTROLLO = 224 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
          IF NOT VARIETA_CONFERITA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR)  THEN
             RETURN (FALSE);
         END IF;
     END IF;

     IF P_ID_CONTROLLO = 225 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
        IF NOT VAR_AZIENDA_GIOVANE THEN
           IF NOT SUPERO_PERCENTUALE_FASCICOLI (P_ID_AZIENDA, P_ID_CONTROLLO,P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 226 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
        IF NOT USO_DEL_SUOLO_NON_SPECIFICATO (P_ID_AZIENDA, P_ID_CONTROLLO,P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 236 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
        IF NOT USO_DEL_SUOLO_NON_ESISTENTE (P_ID_AZIENDA, P_ID_CONTROLLO,P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 227 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
        IF NOT SUPERO_USO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR)  THEN
           RETURN (FALSE);
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 228 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
        IF NOT SUPERO_SUP_GRAFICA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR)  THEN
           RETURN (FALSE);
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 229 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
        IF NOT SUPERO_TRA_AZIENDE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR)  THEN
           RETURN (FALSE);
        END IF;
     END IF;

     -- aggiunto controllo sulla presenza di un solo documento istanza di riesame
     -- per particella (in un range di date, che secondo me però è da fare da on-line)
     IF nAnnoCampagna IS NULL THEN
         IF P_ID_CONTROLLO = 230 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                                 AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
             IF NOT PART_CON_DOC_RIESAME_MULTIPLI (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
             END IF;
         END IF;
     END IF;


     -- verifica specificazione sezione ammessa x il comune
     IF nAnnoCampagna IS NULL THEN
         IF P_ID_CONTROLLO = 233 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
            IF NOT SEZIONE_NON_VALIDA (P_ID_AZIENDA,P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
         END IF;
     END IF;

     -- nuovo controllo di supero tra il fascicolo viticolo dell'azienda
     -- ed eventuali altri fascicoli con comproprietà di stesse particelle
     IF nAnnoCampagna IS NULL THEN
         IF P_ID_CONTROLLO = 234 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
            IF NOT SUPERO_PERC_FASCICOLI_VITICOLI (P_ID_AZIENDA,P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
         END IF;
     END IF;

     -- Verifica per ogni particella in conduzione all'azienda , avente almeno un'unità vitata associata,
     -- che la superficie utilizzata totale sommata all'eventuale superficie utilizzata
     -- totale di altre aziende, se la particella è condivisa, non superi la massima tra la superficie catastale
     -- e quella grafica
     IF nAnnoCampagna IS NULL THEN
         IF P_ID_CONTROLLO = 235 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
            IF NOT SUPERO_TRA_AZIENDE_VITICOLE (P_ID_AZIENDA,P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
         END IF;
     END IF;

     -- verifica che le particella a fag abbiano tutte le informazioni necessarie
     IF P_ID_CONTROLLO = 237 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
        IF NOT VERIFICA_INFORMAZIONI_FAG (P_ID_AZIENDA,P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 520 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
          IF NOT CONTROLLO_ZONA_ALTIM (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR)  THEN
             RETURN (FALSE);
         END IF;
     END IF;

     -- eleggibilità
     -- controllo da effettuarsi solo per le dichiarazioni non di tipo correttivo
     -- siccome la variabile nAnnoCampagna è valorizzata solo per le correttive posso utilizzarla
     -- per discriminare quando lanciare la function
     IF nAnnoCampagna IS NULL THEN
         IF P_ID_CONTROLLO = 518 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
            nPercP26 := MY_TO_NUMBER(SelectValoreParametro(kvIdParamPercP26),'999D9999');
            IF NOT CONTROLLA_ELEGGIBILITA (P_ID_AZIENDA,'N',nPercP26, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
         END IF;
     END IF;

     IF P_ID_CONTROLLO = 522 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
          IF NOT CONTROLLA_CATASTO_ATTIVO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR)  THEN
             RETURN (FALSE);
         END IF;
     END IF;

     /* sup.cond > 0 */
     IF P_ID_CONTROLLO = 524 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
          IF NOT CONTROLLA_SUP_CONDOTTA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR)  THEN
             RETURN (FALSE);
         END IF;
     END IF;

    -- ASSERVIMENTO
    IF P_ID_CONTROLLO = 218 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
        IF NOT PRESENZA_USO_SUOLO_ASSERVIM (    P_ID_AZIENDA,P_ID_CONTROLLO,P_BLOCCANTE,P_MSGERR,P_CODERR) THEN
            RETURN (FALSE);
        END IF;
    END IF;

    /********************* CONTROLLI FABBRICATI *******************/
     IF P_ID_CONTROLLO = 300 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoFabbricati)   THEN
         IF NOT PRESENZA_FABBRICATI (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 301 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoFabbricati)   THEN
         IF NOT FABBRICATO_SENZA_PARTICELLE(P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE,  P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 302 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoFabbricati)   THEN
         IF NOT FABBRICATI_SU_UTE_SCADUTE(P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE,  P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;


     IF P_ID_CONTROLLO = 303 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoFabbricati)   THEN
         IF NOT STRU_STOC_PARTICELLARE(P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE,  P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;


     /********************* CONTROLLI ALLEVAMENTI *******************/
     IF P_ID_CONTROLLO = 400 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)   THEN
         IF NOT PRESENZA_ALLEVAMENTI (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 401
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT CONTROLLA_CODICE_ALLEVAMENTO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

      IF P_ID_CONTROLLO = 402
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT CONTROLLA_CONSIST_ALLEVAMENTO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

      IF P_ID_CONTROLLO = 403
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT ALLEVAMENTI_SU_UTE_SCADUTE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;


      IF P_ID_CONTROLLO = 404
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        Pack_Controlli.ALL05 (P_ID_AZIENDA, VAR_CUAA, var_result,var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
              IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore,
                   P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
                 RETURN (FALSE);
              END IF;
        END IF;

     END IF;

      IF P_ID_CONTROLLO = 405
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        Pack_Controlli.ALL06 (P_ID_AZIENDA, VAR_CUAA, var_result, var_descrizione_msg_errore, var_id_err);

        IF var_result <> '0' THEN
           IF NOT SCRIVI_SEGNALAZIONE (P_ID_AZIENDA, P_ID_CONTROLLO, var_descrizione_msg_errore, P_BLOCCANTE, NULL, NULL, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;

     END IF;


      IF P_ID_CONTROLLO = 406
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT ALLEVAMENTI_SENZA_PESO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

      IF P_ID_CONTROLLO = 407
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT ALLEVAMENTI_PESO_ERRATO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

      IF P_ID_CONTROLLO = 408
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT ALLEVAMENTO_STA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
      IF P_ID_CONTROLLO = 409
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT SUPERFICIE_PREVISTA_SPECIE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
      IF P_ID_CONTROLLO = 410
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT ALLEVAMENTO_SOCCIDA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     -- nuovo controllo soccida incongruente
     IF P_ID_CONTROLLO = 411 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        IF NOT SOCCIDA_INCONGRUENTE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

     END IF;

     -- proprietario / detentore SIAP <> BDN
     IF P_ID_CONTROLLO = 412 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        IF NOT DET_PROP_ALLEV_SIAP_EQUAL_BDN (P_ID_AZIENDA,VAR_CUAA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     -- coordinate geografiche allevamento SIAP <> BDN
     IF P_ID_CONTROLLO = 413 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        IF NOT CORDINATE_ALLEV_SIAP_EQUAL_BDN (P_ID_AZIENDA,VAR_CUAA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     -- denominazione allevamento SIAP non valorizzata
     IF P_ID_CONTROLLO = 414 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        IF NOT PRESENTE_DENOMINAZIONE_ALLEV (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

     END IF;

     -- orientamento produttivo allevamento SIAP non valorizzato
     IF P_ID_CONTROLLO = 415 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        IF NOT ORIENTAMENTO_PRODUTTIVO_ALLEV (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

     END IF;

     -- se allevamento solo in proprieta' capi in detenzione = 0
     IF P_ID_CONTROLLO = 416 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        IF NOT CAPI_ALLEVAMENTO_IN_DETENZIONE (P_ID_AZIENDA, VAR_CUAA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

     END IF;

     -- se allevamento in soccida con proprietario <> da detentore
     -- deve esserci apposito documento su DB_DOCUMENTO
     IF P_ID_CONTROLLO = 417 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        IF NOT ALLEVAMENTO_SOCCIDA_SENZA_DOC (P_ID_AZIENDA, VAR_CUAA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

     END IF;

     -- nuovo controllo che verifica la presenza di allevamenti duplicati
     -- stessa specie, stesso codice azienda zootecnica, stesso cuaa detentore , stesso cuaa proprietario
     IF P_ID_CONTROLLO = 418 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        IF NOT ALLEVAMENTO_DUPLICATO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

     END IF;

     -- controlla se l'allevamento presente in anagrafe
     -- per il cuaa e' presente in BDN con stessa specie (o specie BDN compatibile)
     IF P_ID_CONTROLLO = 419 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        IF NOT ALLEVAMENTO_ASSENTE_IN_BDN (P_ID_AZIENDA, VAR_CUAA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;

     END IF;

     /********************* CONTROLLI DOCUMENTALE *******************/
      IF P_ID_CONTROLLO = 500
    AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDocumenti)
    AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
           IF N_DELEGA > 0 THEN --CONTROLLO SOLO SE C'è UNA DELEGA ATTIVA
             IF NOT PRESENZA_CARTA_IDENTITA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
         END IF;
    END IF;

      IF P_ID_CONTROLLO = 499 AND NVL(VAR_PRESENZA_DOC_IDENTITA,TRUE)
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDocumenti)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF N_DELEGA > 0 THEN --CONTROLLO SOLO SE C'è UNA DELEGA ATTIVA
             IF NOT VALIDITA_CARTA_IDENTITA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
        END IF;
     END IF;

      IF P_ID_CONTROLLO = 527 AND NVL(VAR_PRESENZA_DOC_IDENTITA,TRUE)
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDocumenti)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT PRESENZA_ESTREMI_DOC_IDENTITA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

      IF P_ID_CONTROLLO = 501
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDocumenti)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT DOCUMENTI_CONDUZIONI_SCADUTE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
      IF P_ID_CONTROLLO = 502
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDocumenti)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT DOCUMENTI_SCADUTI_ANNO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     IF nAnnoCampagna IS NULL THEN
          IF P_ID_CONTROLLO = 503
            AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDocumenti)
            AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
             IF NOT DOCUMENTI_PARTICELLA_DOPPIA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
         END IF;
    END IF;
    IF nAnnoCampagna IS NULL THEN
         IF P_ID_CONTROLLO = 504
       AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDocumenti)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
             IF NOT DOCUMENTI_SENZA_PARTICELLE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
        END IF;
    END IF;
     IF nAnnoCampagna IS NULL THEN
        IF P_ID_CONTROLLO = 505
       AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDocumenti)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
             IF NOT DOCUMENTI_UNIVOCI (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
        END IF;
    END IF;

     /* nuovo controllo riassuntivo */
      IF P_ID_CONTROLLO IN (506,507,508,528)
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT DOCUMENTO_FORME_COND (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

       IF P_ID_CONTROLLO = 509
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT PARTICELLE_SENZA_DOCUMENTO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE,'N', P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     /* nuovo controllo riassuntivo */
       IF P_ID_CONTROLLO IN (510,511,512,513,514,516)
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT DOCUMENTO_CASO_PARTICOLARE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;


       IF P_ID_CONTROLLO = 515
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT DOCUMENTO_CASO_PARTICOLARE_6 (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

       IF P_ID_CONTROLLO = 525
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDocumenti)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT DOCUMENTO_PROPRIETARI_VALIDATI (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

       IF P_ID_CONTROLLO = 526
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDocumenti)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT DOC_PROPR_DIVERSI_DA_CUAA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     -- aggiunto controllo sul nuovo documento istanza di riesame
     -- (che secondo me però è da fare lato on-line)
     IF nAnnoCampagna IS NULL THEN
         IF P_ID_CONTROLLO = 529 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                                 AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
             IF NOT DOC_RIESAME_MULTIPLI (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
                RETURN (FALSE);
             END IF;
         END IF;
     END IF;

     -- eleggibilità
     -- controllo da effettuarsi solo per le dichiarazioni non di tipo correttivo
     -- siccome la variabile nAnnoCampagna è valorizzata solo per le correttive posso utilizzarla
     -- per discriminare quando lanciare la function
     IF nAnnoCampagna IS NULL THEN
         IF P_ID_CONTROLLO = 530 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)   THEN
            nPercP26 := MY_TO_NUMBER(SelectValoreParametro(kvIdParamPercP26),'999D9999');
            IF NOT CONTROLLA_ELEGGIBILITA (P_ID_AZIENDA,'S',nPercP26, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
               RETURN (FALSE);
            END IF;
         END IF;
     END IF;

     -- aggiunto controllo per verificare presenza documento per conti correnti validi
     IF P_ID_CONTROLLO = 531 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoConti)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        IF NOT Conto_Corrente_NoDocumenti (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     -- aggiunto controllo per verificare se l''azienda che ha aderito alla deroga dei nitrati
     -- ha effettivamente inserito l'apposito documento
     IF P_ID_CONTROLLO = 532 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDocumenti)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

        IF NOT Deroga_Nitrati (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     -- controllo se le particelle aventi unità vitate sono senza documento
     -- passando il parametro P_SOLO_UNITA_VITATE ad 'S'
     IF P_ID_CONTROLLO = 533
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT PARTICELLE_SENZA_DOCUMENTO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE,'S', P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     -- nuovo controllo che verifica che i documenti validi con tipologia documento
     -- che prevede l'upload su DB_ALLEGATO del file allegato abbiano effettivamente l'allegato
     IF P_ID_CONTROLLO = 535 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDocumenti)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
        IF NOT Upload_Documento (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     -- controlla se ci sono documenti territoriali
     -- con i flags flag_anag_terr = T e flag_obbligo_proprietario S
     -- per i quali il proprietario presente su DB_DOCUMENTO_PROPRIETARIO
     -- risulta deceduto su anagrafe tributaria
     IF P_ID_CONTROLLO = 536 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDocumenti)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
        IF NOT Proprietario_Deceduto (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     -- verifica che i proprietari presenti
     -- sui documenti territoriali attivi
     -- siano anche presenti e proprietari sul catasto
     -- per almeno una delle particelle associate al documento
     IF P_ID_CONTROLLO = 537 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDocumenti)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
        IF NOT Prop_Doc_EQ_Prop_Part_Catasto (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     -- Verifica che il proprietario indicato sul documento attivo
     -- sia effettivamente presente anche sul catasto per ogni particella
     -- associata al documento
     IF P_ID_CONTROLLO = 538 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDocumenti)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
        IF NOT Prop_Doc_EQ_Prop_All_Part_Cat (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, 'S' ,P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     -- Per i documenti territoriali attivi che prevedono l'indicazione del proprietario
     -- controlla prendendo l'eventuale proprietario di ogni particella associata al documento
     -- dal catasto (DB_PROPRIETA_CERTIFICATA) che esso sia anche presente su
     -- DB_DOCUMENTO_PROPRIETARIO
     IF P_ID_CONTROLLO = 539 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDocumenti)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
        IF NOT Prop_Part_Cat_Eq_Prop_Doc_Part (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     -- Verifica che il proprietario indicato sul documento attivo
     -- sia effettivamente presente anche sul catasto per ogni particella
     -- associata al documento
     IF P_ID_CONTROLLO = 540 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDocumenti)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
        IF NOT Prop_Doc_EQ_Prop_All_Part_Cat (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, 'N' ,P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

       IF P_ID_CONTROLLO = 601
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni )
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT  CONGRUENZA_UV_E_USO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

       IF P_ID_CONTROLLO = 602
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT  CONGRUENZA_SUP_UTIL_VITATA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

       IF P_ID_CONTROLLO = 603
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT  PRESENZA_UV_SU_USO_VINO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

       IF P_ID_CONTROLLO = 604
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT  CONTROLLA_SUP_UV_CATASTALE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

       IF P_ID_CONTROLLO = 605
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT  COMPLETEZZA_SCHEDA_AGRONOMICA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

       IF P_ID_CONTROLLO = 606
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT CONTROLLO_DATI_SCHEDARIO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

       IF P_ID_CONTROLLO = 213
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT CONTROLLO_PART_GIS_SENZA_USO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

       IF P_ID_CONTROLLO = 607
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT PRESENZA_USO_VINO_SU_UV (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

       IF P_ID_CONTROLLO = 608
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT SCHEDA_AGRONOMICA_ERRATA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

       IF P_ID_CONTROLLO = 609
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT IS_VITIGNO_VARIETA_IN_COMUNE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;


  IF nAnnoCampagna IS NULL THEN
       IF P_ID_CONTROLLO = 610 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                               AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
          IF NOT SCHEDARIO_UV_SENZA_VINO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;
       END IF;
  END IF;

  IF nAnnoCampagna IS NULL THEN
       IF P_ID_CONTROLLO = 611 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                               AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT SCHEDARIO_UV_INCOMPLETO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
         RETURN (FALSE);
      END IF;
     END IF;
  END IF;

  IF nAnnoCampagna IS NULL THEN
       IF P_ID_CONTROLLO = 612 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                               AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
          IF NOT SCHEDARIO_UV_SUP_ISCRITTA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;
     END IF;
  END IF;

  IF nAnnoCampagna IS NULL THEN
       IF P_ID_CONTROLLO = 613 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                               AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
          IF NOT SCHEDARIO_UV_ALBO_CCIAA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;
     END IF;
  END IF;

  IF nAnnoCampagna IS NULL THEN
       IF P_ID_CONTROLLO = 614
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
      AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT ALBO_CCIAA_SCHEDARIO_UV (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
         RETURN (FALSE);
      END IF;
     END IF;
  END IF;

  IF nAnnoCampagna IS NULL THEN
       IF P_ID_CONTROLLO = 615
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
      AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT SCHEDARIO_UV_ALBO_SUP_ISCRITTA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
         RETURN (FALSE);
      END IF;
     END IF;
  END IF;

    IF nAnnoCampagna IS NULL THEN
         IF P_ID_CONTROLLO = 617
            AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
          AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
          IF NOT VALIDITA_TIPOLOGIA_VINI (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
             RETURN (FALSE);
          END IF;
         END IF;
    END IF;

    IF P_ID_CONTROLLO = 618 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                            AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT DATI_UV_ERRATI (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
         RETURN (FALSE);
      END IF;
    END IF;
    IF P_ID_CONTROLLO = 619 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                            AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT CONGRUENZA_VINO_VITIGNO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
         RETURN (FALSE);
      END IF;
    END IF;

    IF P_ID_CONTROLLO = 620 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                            AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT UV_DOC_IN_CCIAA_MASSIVO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
         RETURN (FALSE);
      END IF;
    END IF;

    IF P_ID_CONTROLLO = 621 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                            AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT SUPERFICIE_UV_DOC_IN_CCIAA_OK (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
         RETURN (FALSE);
      END IF;
    END IF;

    IF P_ID_CONTROLLO = 622 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                            AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT SFORAMENTO_VINO_PER_PROVINCIA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
         RETURN (FALSE);
      END IF;
    END IF;

    IF P_ID_CONTROLLO = 623 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                            AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT SUP_ISCRITTA_IN_CCIAA_OK (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
         RETURN (FALSE);
      END IF;
    END IF;

    -- Nuovo controllo che verifica che la superficie vitata sia minore della superficie eleggibile
    -- a vite incrementata di una quota percentuale
    IF P_ID_CONTROLLO = 624 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                            AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT UV_MAGGIORE_ELEGGIBILE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
         RETURN (FALSE);
      END IF;
    END IF;

    -- Nuovo controllo che verifica che la superficie vitata sia maggiore della superficie eleggibile a vite
    -- decurtata di una quota percentuale
    IF P_ID_CONTROLLO = 625 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                            AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT UV_MINORE_ELEGGIBILE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
         RETURN (FALSE);
      END IF;
    END IF;

    -- se un'azienda ha effettuato la compensazione delle UV
    -- allora deve aver fatto anche il consolidamento a GIS
    IF P_ID_CONTROLLO = 626 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                            AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT IfCompensataThenConsolidata (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
         RETURN (FALSE);
      END IF;
    END IF;

    -- se UV con anno_idoneita >= 2010 allora UV deve essere
    -- stata inserita / modificata da VITI
    IF P_ID_CONTROLLO = 627 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                            AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT UV_IDONEITA_CONFERITA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
         RETURN (FALSE);
      END IF;
    END IF;

    -- Verifica che le particelle dell'azienda con titolo possesso proprieta' in anagrafe
    -- abbiano proprieta' anche su sigmater
/*
    IF P_ID_CONTROLLO = 628 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                            AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
       IF NOT VERIFICA_TITOLARITA_SIGMATER (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
          RETURN (FALSE);
       END IF;
    END IF;
*/
    -- Verifica che le particelle dell'azienda con titolo possesso proprieta' in anagrafe
    -- abbiamo proprieta anche su fonte dati castasto
    IF P_ID_CONTROLLO = 630 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                            AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
       IF NOT PART_PROPRIETA_GAA_CATASTO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
          RETURN (FALSE);
       END IF;
    END IF;

    -- Verifica che le particelle dell'azienda con titolo possesso <> proprieta' in anagrafe
    -- non abbiamo proprieta su fonte dati castasto
    IF P_ID_CONTROLLO = 631 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                            AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
       IF NOT PART_NO_PROPRIETA_GAA_CATASTO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
          RETURN (FALSE);
       END IF;
    END IF;

    -- nuovo controllo che verifica per le
    -- unita' arboree che hanno altri vitigni
    -- che essi non siano della stessa varieta' e che la percentuale totale (varieta' principale + altri vitigni)
    -- non superi il 100%
    IF P_ID_CONTROLLO = 632 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                            AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
       IF NOT INDICAZIONE_ALTRI_VITIGNI_OK (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
          RETURN (FALSE);
       END IF;
    END IF;

    -- nuovo controllo rispetto della percentuale fallanza
    IF P_ID_CONTROLLO = 633 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                            AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

       IF NOT CONTROLLO_PERCENTUALE_FALLANZA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
          RETURN (FALSE);
       END IF;
    END IF;

    -- nuovo controllo per il rispetto dei prati permanenti
    IF P_ID_CONTROLLO = 634 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                            AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

       IF NOT MANTENIMENTO_PRATI_PERMANENTI (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
          RETURN (FALSE);
       END IF;
    END IF;

    -- dopo piccola citta' di guccini
    -- dopo piccolo fiore bugiardo di fabio de luigi
    -- ecco a voi piccola particella montana
    IF P_ID_CONTROLLO = 635 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                            AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

       IF NOT PICCOLA_PARTICELLA_MONTANA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
          RETURN (FALSE);
       END IF;
    END IF;

    -- verifica che gli eventuali dettagli uso
    -- (ulteriore dettaglio della varieta' di coltura)
    -- specificati siano validi solo per validazioni non correttive
    IF nAnnoCampagna IS NULL THEN
        IF P_ID_CONTROLLO = 636 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                                AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

           IF NOT USO_NON_VALIDO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;
    END IF;

    -- verifica che gli eventuali dettagli uso
    -- (ulteriore dettaglio della varieta' di coltura)
    -- specificati siano validi solo per validazioni non correttive
    IF nAnnoCampagna IS NULL THEN
       IF P_ID_CONTROLLO = 637 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                                AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
           IF NOT EPOCA_DI_SEMINA_CORRETTA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
       END IF;
    END IF;

    -- TER56 verifica che non siano stati impostati
    -- sulle particelle eventuali dettaglio uso
    -- previsti solo al di sopra dei 2.000 metri sul livello del mare
    -- se la particella non ha un'altitudine media sopra i 2.000 metri
    IF nAnnoCampagna IS NULL THEN
       IF P_ID_CONTROLLO = 638 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                                AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
           IF NOT USO_NON_AMMESSO_SOTTO_I_2000M (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
       END IF;
    END IF;

    -- TER57 verifica che non siano stati impostati
    -- sulle particelle eventuali dettaglio uso
    -- non ammessi per il Piemonte
    IF nAnnoCampagna IS NULL THEN
       IF P_ID_CONTROLLO = 639 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                                AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
           IF NOT USO_NON_CONSENTITO_PIEMONTE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
       END IF;
    END IF;


    -- TER58 verifica che non siano stati impostati
    -- sulle particelle eventuali dettaglio uso
    -- non congruenti che le varieta'
    IF nAnnoCampagna IS NULL THEN
       IF P_ID_CONTROLLO = 640 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                                AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
           IF NOT USO_NON_CONGRUENTE_VARIETA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
       END IF;
    END IF;

  -- TER59: controllo presenza particelle con uso civico
  IF nAnnoCampagna IS NULL THEN
    IF P_ID_CONTROLLO = 641 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                                 AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT PresPartUsoCivico(P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
        RETURN (FALSE);
      END IF;
    END IF;
  END IF;

  -- TER60: controllo presenza particelle condivise
  IF nAnnoCampagna IS NULL THEN
    IF P_ID_CONTROLLO = 642 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                                 AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT PresPartCondivise(P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
        RETURN (FALSE);
      END IF;
    END IF;
  END IF;

  -- TER61: controllo date destinazione colturali corrette
  IF nAnnoCampagna IS NULL THEN
    IF P_ID_CONTROLLO = 643 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                                 AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT DateDestColtCorrette(P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
        RETURN (FALSE);
      END IF;
    END IF;
  END IF;

  -- TER62: presenza particelle condivise alla validazione
  IF nAnnoCampagna IS NULL THEN
    IF P_ID_CONTROLLO = 644 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                                 AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT TER62(P_ID_AZIENDA, P_ID_DICHIARAZIONE,P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
        RETURN (FALSE);
      END IF;
    END IF;
  END IF;

  -- TER63: PARTICELLE CON P26 ANCORA ACCESE DOPO ISTANZE
  IF nAnnoCampagna IS NULL THEN
    IF P_ID_CONTROLLO = 645 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                                 AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

      IF NOT TER63(P_ID_AZIENDA, P_ID_DICHIARAZIONE,'N',P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
        RETURN (FALSE);
      END IF;
    END IF;
  END IF;

  -- TER64: PARTICELLE CON P26 ANCORA ACCESE DOPO ISTANZE
  -- richiamo sempre il controllo TER63 cambiando il valore del parametro pVite
  IF nAnnoCampagna IS NULL THEN
    IF P_ID_CONTROLLO = 646 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                                 AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT TER63(P_ID_AZIENDA, P_ID_DICHIARAZIONE,'S',P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
        RETURN (FALSE);
      END IF;
    END IF;
  END IF;

  -- TER65:  controllo VERIFICA UGUAGLIANZA CON ELEGGIBILITA¿ GIS
  IF nAnnoCampagna IS NULL THEN
    IF P_ID_CONTROLLO = 647 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                                 AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT TER65(P_ID_AZIENDA,P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
        RETURN (FALSE);
      END IF;
    END IF;
  END IF;

  -- TER66:  controllo VERIFICA UGUAGLIANZA CON ELEGGIBILITA¿ GIS ALLA VALIDAZIONE
  IF nAnnoCampagna IS NULL THEN
    IF P_ID_CONTROLLO = 648 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                                 AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
      IF NOT TER66(P_ID_AZIENDA, P_ID_DICHIARAZIONE,P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
        RETURN (FALSE);
      END IF;
    END IF;
  END IF;

    -- Uguale al controlla_eleggibilita_vite ma viene richiamata
    -- una function che in caso di particelle miste (ovvero sia con utilizzi a vite che
    -- non ) calcola la P26 solo per la parte di utilizzi a VITE
     IF nAnnoCampagna IS NULL THEN
        IF P_ID_CONTROLLO = 629 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
                                AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
           nPercP26 := MY_TO_NUMBER(SelectValoreParametro(kvIdParamPercP26),'999D9999');
           IF NOT VERIFICA_ELEGGIBILITA_VITE (P_ID_AZIENDA, nPercP26 ,P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
              RETURN (FALSE);
           END IF;
        END IF;
     END IF;

---        ATTESTAZIONI
       IF P_ID_CONTROLLO = 700
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDichiarazioni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

         IF NOT DICHIARAZIONI_OBBLIGATORIE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;


 IF nAnnoCampagna IS NULL THEN
     IF P_ID_CONTROLLO = 701
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDichiarazioni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

         IF NOT Congruenza_Matrice_Norme (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
    END IF;

 IF nAnnoCampagna IS NULL THEN
     IF P_ID_CONTROLLO = 702
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDichiarazioni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

         IF NOT Condizionalita_Norme (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
    END IF;

 IF nAnnoCampagna IS NULL THEN
     IF P_ID_CONTROLLO = 703
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoDichiarazioni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN

         IF NOT Condizionalita_Piano_Colturale (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
    END IF;


       IF P_ID_CONTROLLO = 215
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT CONTROLLA_PARTICELLE_DOPPIE (P_ID_AZIENDA , P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

       IF P_ID_CONTROLLO = 216
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT CONTROLLA_SUPERO_ASSERVIMENTO (P_ID_AZIENDA , P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

       IF P_ID_CONTROLLO = 217
        AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoTerreni)
        AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S')   THEN
         IF NOT CONTROLLA_UV_ASSERV_CONFERIM (P_ID_AZIENDA , P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

       IF P_ID_CONTROLLO = 800 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoValidazioni)
                                 AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S') THEN
         IF NOT VALIDA_NUOVA_DICHIARAZIONE (P_ID_AZIENDA , P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 801 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoValidazioni)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S') THEN
         IF NOT CONTROLLO_FERMO_OROLOGI (P_ID_AZIENDA , P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;
     END IF;


     -- controllo se l'utente iride passato in input al package
     -- ha dei conflitti di interesse con l'azienda per la quale sono eseguiti i controlli
     IF P_ID_CONTROLLO = 803 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoValidazioni)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S') THEN
         IF NOT UTENTE_BIRBONE (P_ID_AZIENDA , var_cuaa, P_ID_UTENTE_LOGIN, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;
     END IF;


     IF P_ID_CONTROLLO = 804 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoValidazioni)
                             AND (var_flag_provvisoria IS NULL OR var_flag_provvisoria <> 'S') THEN
         IF NOT RESPONSABILE_BIRBONE (P_ID_AZIENDA , var_cuaa, P_ID_UTENTE_LOGIN, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
            RETURN (FALSE);
        END IF;
     END IF;

    /********************* CONTROLLI COMUNICAZIONE 10R *******************/
     IF P_ID_CONTROLLO = 900 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoComunicazione10R)   THEN
         IF NOT RICALCOLA_COMUNICAZIONE_10R (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     IF P_ID_CONTROLLO = 901 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoComunicazione10R)   THEN
         IF NOT AZOTO_PRODOTTO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
     IF P_ID_CONTROLLO = 902 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoComunicazione10R)   THEN
         IF NOT RICETTIVITA_AZOTO_TERRENI(P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
     IF P_ID_CONTROLLO = 910 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoComunicazione10R)   THEN
         IF NOT RICETTIVITA_AZOTO_TERRENI_UTE(P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
     IF P_ID_CONTROLLO = 903 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoComunicazione10R)   THEN
         IF NOT STOC_INSUFFICIENTE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
     IF P_ID_CONTROLLO = 911 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoComunicazione10R)   THEN
         IF NOT STOC_INSUFFICIENTE_UTE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
     IF P_ID_CONTROLLO = 904 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoComunicazione10R)   THEN
         IF NOT SUPERFICIE_AGRONOMIC_SAU (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
     IF P_ID_CONTROLLO = 913 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoComunicazione10R)   THEN
         IF NOT SUPERFICIE_AGRO_SAU_NO_CONGRUO (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
     IF P_ID_CONTROLLO = 912 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoComunicazione10R)   THEN
         IF NOT SUPERFICIE_AGRONOMIC_SAU_UTE (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
     IF P_ID_CONTROLLO = 914 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoComunicazione10R)   THEN
         IF NOT NOTE_EFFLUENTI_NULL (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
     IF P_ID_CONTROLLO = 905 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoComunicazione10R)   THEN
         IF NOT ACQUISIZIONE_CES_DICHIARATA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
     IF P_ID_CONTROLLO = 906 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoComunicazione10R)   THEN
         IF NOT ACQUISIZIONE_CES_QTA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
     IF P_ID_CONTROLLO = 907 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoComunicazione10R)   THEN
         IF NOT CESSIONE_ACQ_DICHIARATA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
     IF P_ID_CONTROLLO = 908 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoComunicazione10R)   THEN
         IF NOT CESSIONE_ACQ_QTA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;
     IF P_ID_CONTROLLO = 909 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoComunicazione10R)   THEN
         IF NOT CESSIONE_QTA_PRODOTTA (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

     -- aggiunto nuovo controllo sull'univocità
     -- dei soci dell'azienda
     IF P_ID_CONTROLLO = 1000 AND (P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = constantGruppoElencoSoci) THEN
        IF NOT CONTROLLA_SOCI_DOPPI (P_ID_AZIENDA, P_ID_CONTROLLO, P_BLOCCANTE, P_MSGERR, P_CODERR) THEN
           RETURN (FALSE);
        END IF;
     END IF;

      RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE ESEGUI_CONTROLLI: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END ESEGUI_CONTROLLI;


FUNCTION CANCELLA_ANOMALIE (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                             P_ID_GRUPPO_CONTROLLO IN DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE,
                            P_MSGERR       IN OUT VARCHAR2,
                            P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS
BEGIN
     DELETE FROM DB_DICHIARAZIONE_SEGNALAZIONE
     WHERE ID_AZIENDA = P_ID_AZIENDA
       AND ID_DICHIARAZIONE_CONSISTENZA IS NULL;

     /* terreni */
     IF P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO=costanteGruppoTerreni THEN

        UPDATE DB_CONDUZIONE_PARTICELLA SET ESITO_CONTROLLO=NULL
           WHERE --DATA_FINE_CONDUZIONE IS NULL
    --       AND
           ID_CONDUZIONE_PARTICELLA IN (SELECT ID_CONDUZIONE_PARTICELLA
                                                    FROM DB_CONDUZIONE_PARTICELLA A, DB_UTE B
                                               WHERE A.ID_UTE=B.ID_UTE AND B.ID_AZIENDA=P_ID_AZIENDA) ;

         DELETE FROM DB_ESITO_CONTROLLO_PARTICELLA WHERE id_conduzione_particella IN
         ( SELECT D.ID_CONDUZIONE_PARTICELLA
             FROM DB_UTE A, DB_CONDUZIONE_PARTICELLA D
             WHERE A.ID_UTE = D.ID_UTE
               AND A.ID_AZIENDA = P_ID_AZIENDA);

        UPDATE DB_STORICO_UNITA_ARBOREA UA SET UA.ESITO_CONTROLLO = NULL
        WHERE ID_AZIENDA = P_ID_AZIENDA;
/*
        WHERE ID_STORICO_UNITA_ARBOREA IN (SELECT ID_STORICO_UNITA_ARBOREA
                                             FROM DB_STORICO_UNITA_ARBOREA A, DB_CONDUZIONE_PARTICELLA B, DB_UTE C
                                            WHERE A.ID_PARTICELLA = B.ID_PARTICELLA
                                              AND B.DATA_FINE_CONDUZIONE IS NULL
                                              AND C.ID_UTE = B.ID_UTE
                                              AND C.DATA_FINE_ATTIVITA IS NULL
                                              AND A.DATA_FINE_VALIDITA IS NULL
                                              AND C.ID_AZIENDA = P_ID_AZIENDA);
*/
        DELETE FROM DB_ESITO_CONTROLLO_UNAR WHERE ID_STORICO_UNITA_ARBOREA IN
        (SELECT ID_STORICO_UNITA_ARBOREA FROM DB_STORICO_UNITA_ARBOREA WHERE ID_AZIENDA = P_ID_AZIENDA);
/*
        where Id_STORICO_UNITA_ARBOREA in
                                                    (SELECT ID_STORICO_UNITA_ARBOREA
                                             FROM DB_STORICO_UNITA_ARBOREA A, DB_CONDUZIONE_PARTICELLA B, DB_UTE C
                                            WHERE A.ID_PARTICELLA = B.ID_PARTICELLA
                                              AND B.DATA_FINE_CONDUZIONE IS NULL
                                              AND C.ID_UTE = B.ID_UTE
                                              AND C.DATA_FINE_ATTIVITA IS NULL
                                              AND A.DATA_FINE_VALIDITA IS NULL
                                              AND C.ID_AZIENDA = P_ID_AZIENDA);
*/
     END IF;

     /* documenti */
     IF P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO=costanteGruppoDocumenti THEN

        UPDATE DB_DOCUMENTO DD SET DD.ESITO_CONTROLLO = NULL
        WHERE ID_AZIENDA=P_ID_AZIENDA;

        DELETE FROM DB_ESITO_CONTROLLO_DOCUMENTO WHERE Id_DOCUMENTO IN
         (SELECT ID_DOCUMENTO FROM DB_DOCUMENTO WHERE ID_AZIENDA=P_ID_AZIENDA);
     END IF;

     -- devo cancellare anche le eventuali anomalie
     -- legate agli allevamenti
     IF P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO=costanteGruppoAllevamenti THEN

        DELETE
          FROM DB_ESITO_CONTROLLO_ALLEVAMENTO
         WHERE ID_ALLEVAMENTO IN (SELECT A.ID_ALLEVAMENTO
                                    FROM DB_UTE UT, DB_ALLEVAMENTO A
                                   WHERE UT.ID_UTE = A.ID_UTE
                                     AND UT.ID_AZIENDA = P_ID_AZIENDA);

     END IF;


     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE CANCELLA_ANOMALIE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END CANCELLA_ANOMALIE;

FUNCTION AGGIORNAMENTO_FINALE (P_ID_AZIENDA   IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                P_ID_GRUPPO_CONTROLLO IN DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE,
                               P_MSGERR       IN OUT VARCHAR2,
                               P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

S_BLOCCANTE                    DB_ESITO_CONTROLLO_PARTICELLA.BLOCCANTE%TYPE;

CURSOR C_CONDUZIONE_ANOMALA IS
    SELECT A.ID_CONDUZIONE_PARTICELLA
    FROM DB_CONDUZIONE_PARTICELLA A, DB_ESITO_CONTROLLO_PARTICELLA C, DB_UTE B
    WHERE A.ID_UTE                  = B.ID_UTE
      AND B.ID_AZIENDA               = P_ID_AZIENDA
      AND B.DATA_FINE_ATTIVITA       IS NULL
      AND A.ID_CONDUZIONE_PARTICELLA=C.ID_CONDUZIONE_PARTICELLA
--      AND A.DATA_FINE_CONDUZIONE  IS NULL
      AND A.ESITO_CONTROLLO          IS NULL
      AND C.BLOCCANTE              = S_BLOCCANTE;

CURSOR C_CONDUZIONE_CORRETTA IS
    SELECT A.ID_CONDUZIONE_PARTICELLA
    FROM DB_CONDUZIONE_PARTICELLA A, DB_ESITO_CONTROLLO_PARTICELLA C, DB_UTE B
    WHERE A.ID_UTE                      = B.ID_UTE
      AND B.ID_AZIENDA                   = P_ID_AZIENDA
      AND B.DATA_FINE_ATTIVITA            IS NULL
      AND A.ID_CONDUZIONE_PARTICELLA=C.ID_CONDUZIONE_PARTICELLA(+)
      AND C.ID_CONDUZIONE_PARTICELLA IS NULL
      AND A.ESITO_CONTROLLO               IS NULL
      AND A.DATA_FINE_CONDUZIONE       IS NULL;

CURSOR C_DOCUMENTO_ANOMALO IS
    SELECT D.ID_DOCUMENTO
    FROM DB_DOCUMENTO D, DB_ESITO_CONTROLLO_DOCUMENTO E
    WHERE D.ID_AZIENDA               = P_ID_AZIENDA
      AND D.ID_DOCUMENTO=E.ID_DOCUMENTO
      AND D.ESITO_CONTROLLO          IS NULL
      AND E.BLOCCANTE              = S_BLOCCANTE;

CURSOR C_DOCUMENTO_CORRETTO IS
    SELECT D.ID_DOCUMENTO
    FROM DB_DOCUMENTO D, DB_ESITO_CONTROLLO_DOCUMENTO E
    WHERE D.ID_AZIENDA               = P_ID_AZIENDA
      AND D.ID_DOCUMENTO=E.ID_DOCUMENTO(+)
      AND E.ID_DOCUMENTO          IS NULL
      AND D.ESITO_CONTROLLO          IS NULL;
--      AND E.BLOCCANTE              = S_BLOCCANTE;

CURSOR C_UNITA_VITATA_ANOMALA IS
    SELECT A.ID_STORICO_UNITA_ARBOREA
    FROM DB_STORICO_UNITA_ARBOREA A, DB_ESITO_CONTROLLO_UNAR E
    WHERE A.ID_AZIENDA = P_ID_AZIENDA
      AND A.ID_STORICO_UNITA_ARBOREA = E.ID_STORICO_UNITA_ARBOREA
      AND A.ESITO_CONTROLLO    IS NULL
      AND E.BLOCCANTE = S_BLOCCANTE;

CURSOR C_UNITA_VITATA_CORRETTA IS
    SELECT A.ID_STORICO_UNITA_ARBOREA
    FROM DB_STORICO_UNITA_ARBOREA A, DB_ESITO_CONTROLLO_UNAR E
    WHERE A.ID_AZIENDA = P_ID_AZIENDA
      AND A.ID_STORICO_UNITA_ARBOREA = E.ID_STORICO_UNITA_ARBOREA(+)
      AND A.ESITO_CONTROLLO IS NULL
      AND E.ID_STORICO_UNITA_ARBOREA IS NULL;

BEGIN

     /* terreni */
     IF P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO=costanteGruppoTerreni THEN

         S_BLOCCANTE := 'S';

          FOR REC_CONDUZIONE_ANOMALA IN C_CONDUZIONE_ANOMALA LOOP
              UPDATE DB_CONDUZIONE_PARTICELLA SET ESITO_CONTROLLO='B', DATA_ESECUZIONE = SYSDATE
               WHERE ID_CONDUZIONE_PARTICELLA = REC_CONDUZIONE_ANOMALA.ID_CONDUZIONE_PARTICELLA;
         END LOOP;

         S_BLOCCANTE := 'N';

          FOR REC_CONDUZIONE_ANOMALA IN C_CONDUZIONE_ANOMALA LOOP
              UPDATE DB_CONDUZIONE_PARTICELLA SET ESITO_CONTROLLO='W', DATA_ESECUZIONE = SYSDATE
               WHERE ID_CONDUZIONE_PARTICELLA = REC_CONDUZIONE_ANOMALA.ID_CONDUZIONE_PARTICELLA;
         END LOOP;

          FOR REC_CONDUZIONE_CORRETTA IN C_CONDUZIONE_CORRETTA LOOP
              UPDATE DB_CONDUZIONE_PARTICELLA SET ESITO_CONTROLLO='P', DATA_ESECUZIONE = SYSDATE
               WHERE ID_CONDUZIONE_PARTICELLA = REC_CONDUZIONE_CORRETTA.ID_CONDUZIONE_PARTICELLA;
         END LOOP;

          DELETE FROM DB_DICHIARAZIONE_CORREZIONE
          WHERE ID_AZIENDA = P_ID_AZIENDA
            AND ID_DICHIARAZIONE_CONSISTENZA IS NULL
            AND ID_STORICO_PARTICELLA IS NOT NULL
            AND (ID_CONTROLLO, ID_STORICO_PARTICELLA)NOT IN (SELECT ID_CONTROLLO, ID_STORICO_PARTICELLA
                                                                 FROM DB_DICHIARAZIONE_SEGNALAZIONE
                                                             WHERE ID_AZIENDA = P_ID_AZIENDA
                                                             AND ID_DICHIARAZIONE_CONSISTENZA IS NULL
                                                             AND ID_STORICO_PARTICELLA IS NOT NULL);
     /* UNITA VITATE */
         S_BLOCCANTE := 'S';

          FOR REC_UNITA_VITATA_ANOMALA IN C_UNITA_VITATA_ANOMALA LOOP
              UPDATE DB_STORICO_UNITA_ARBOREA SET ESITO_CONTROLLO='B', DATA_ESECUZIONE = SYSDATE
               WHERE ID_STORICO_UNITA_ARBOREA = REC_UNITA_VITATA_ANOMALA.ID_STORICO_UNITA_ARBOREA;
         END LOOP;

         S_BLOCCANTE := 'N';

          FOR REC_UNITA_VITATA_ANOMALA IN C_UNITA_VITATA_ANOMALA LOOP
              UPDATE DB_STORICO_UNITA_ARBOREA SET ESITO_CONTROLLO='W', DATA_ESECUZIONE = SYSDATE
               WHERE ID_STORICO_UNITA_ARBOREA = REC_UNITA_VITATA_ANOMALA.ID_STORICO_UNITA_ARBOREA;
         END LOOP;

          FOR REC_UNITA_VITATA_CORRETTA IN C_UNITA_VITATA_CORRETTA LOOP
              UPDATE DB_STORICO_UNITA_ARBOREA SET ESITO_CONTROLLO='P', DATA_ESECUZIONE = SYSDATE
               WHERE ID_STORICO_UNITA_ARBOREA = REC_UNITA_VITATA_CORRETTA.ID_STORICO_UNITA_ARBOREA;
         END LOOP;
     END IF;

     /* documenti */
     IF P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO=costanteGruppoDOCUMENTI THEN

         S_BLOCCANTE := 'S';

          FOR REC_DOCUMENTO_ANOMALO IN C_DOCUMENTO_ANOMALO LOOP
              UPDATE DB_DOCUMENTO SET ESITO_CONTROLLO='B', DATA_ESECUZIONE = SYSDATE
               WHERE ID_DOCUMENTO = REC_DOCUMENTO_ANOMALO.ID_DOCUMENTO;
         END LOOP;

         S_BLOCCANTE := 'N';

          FOR REC_DOCUMENTO_ANOMALO IN C_DOCUMENTO_ANOMALO LOOP
              UPDATE DB_DOCUMENTO SET ESITO_CONTROLLO='W', DATA_ESECUZIONE = SYSDATE
               WHERE ID_DOCUMENTO = REC_DOCUMENTO_ANOMALO.ID_DOCUMENTO;
         END LOOP;

          FOR REC_DOCUMENTO_CORRETTO IN C_DOCUMENTO_CORRETTO LOOP
              UPDATE DB_DOCUMENTO SET ESITO_CONTROLLO='P', DATA_ESECUZIONE = SYSDATE
               WHERE ID_DOCUMENTO = REC_DOCUMENTO_CORRETTO.ID_DOCUMENTO;
         END LOOP;

     END IF;

     -- gestione valorizzazione DATA_CONTROLLI_ALLEVAMENTI
     IF P_ID_GRUPPO_CONTROLLO IS NULL OR P_ID_GRUPPO_CONTROLLO = costanteGruppoAllevamenti THEN

        UPDATE DB_AZIENDA
           SET DATA_CONTROLLI_ALLEVAMENTI = SYSDATE
         WHERE ID_AZIENDA = P_ID_AZIENDA;

     END IF;


      DELETE FROM DB_DICHIARAZIONE_CORREZIONE
      WHERE ID_AZIENDA = P_ID_AZIENDA
        AND ID_DICHIARAZIONE_CONSISTENZA IS NULL
        AND ID_STORICO_PARTICELLA IS NULL
        AND ID_CONTROLLO NOT IN (SELECT ID_CONTROLLO
                                     FROM DB_DICHIARAZIONE_SEGNALAZIONE
                                 WHERE ID_AZIENDA = P_ID_AZIENDA
                                 AND ID_DICHIARAZIONE_CONSISTENZA IS NULL
                                 AND ID_STORICO_PARTICELLA IS NULL);



     RETURN (TRUE);

EXCEPTION WHEN OTHERS THEN
    p_MsgErr   := 'ERRORE AGGIORNAMENTO_FINALE: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END AGGIORNAMENTO_FINALE;

-- aggiunto parametro P_ID_UTENTE_IRIDE
PROCEDURE CONTROLLI_DICHIARAZIONE(P_ID_AZIENDA              IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                  P_ANNO_RIF                IN DB_UTILIZZO_PARTICELLA.ANNO%TYPE,
                                  P_ID_MOTIVO_DICHIARAZIONE IN DB_TIPO_MOTIVO_DICHIARAZIONE.ID_MOTIVO_DICHIARAZIONE%TYPE,
                                  P_ID_UTENTE_LOGIN         IN PAPUA_V_UTENTE_LOGIN.ID_UTENTE_LOGIN%TYPE, 
                                  P_ESITO_CONTR            OUT VARCHAR2,
                                  P_MSGERR              IN OUT VARCHAR2,
                                  P_CODERR              IN OUT VARCHAR2) IS

nIdFase NUMBER;
BEGIN

     N_COUNT_BLOCCANTI:= 0;
     N_COUNT_ANOMALIE := 0;
     P_ESITO_CONTR      := 'N';

     IF NOT CANCELLA_ANOMALIE (P_ID_AZIENDA, NULL, P_MSGERR, P_CODERR) THEN
         RAISE ERRORE;
     END IF;

    -- prelevo le caratteristiche dell'azienda
    -- var_flag_provvisoria='S' azienda provvisoria, altrimenti è definitiva
    -- var_tipo_azienda id della tipologia
    -- var_forma_giuridica id della forma giuridica
    -- var_flag_partitaiva'S' se è obbligatoria
    -- var_flag_cciaa 'S' se i dati cciaa sono obbligatori
    -- var_data_fine_fg valorizzata se la formagiuridica è scaduta
    SELECT b.cuaa, b.PARTITA_IVA,a.FLAG_AZIENDA_PROVVISORIA, b.id_tipologia_azienda, b.id_forma_giuridica, c.FLAG_PARTITA_IVA, c.FLAG_CCIAA, c.DATA_FINE_FORMA_GIURIDICA
    INTO var_cuaa, var_PIVA,var_flag_provvisoria, var_tipo_azienda, var_forma_giuridica, var_flag_partitaiva, var_flag_cciaa, var_data_fine_fg
    FROM SMRGAA.DB_AZIENDA A, SMRGAA.DB_ANAGRAFICA_AZIENDA B, SMRGAA.DB_TIPO_FORMA_GIURIDICA C
    WHERE A.ID_AZIENDA=P_ID_AZIENDA AND A.ID_AZIENDA=B.ID_AZIENDA AND B.DATA_FINE_VALIDITA IS NULL
    AND B.ID_FORMA_GIURIDICA=C.ID_FORMA_GIURIDICA(+);

    SELECT B.CODICE_FISCALE
      INTO S_CODICE_FISCALE
      FROM DB_CONTITOLARE A, DB_PERSONA_FISICA B
      WHERE A.ID_SOGGETTO = B.ID_SOGGETTO
        AND A.ID_RUOLO = 1
        AND A.DATA_FINE_RUOLO IS NULL
        AND A.ID_AZIENDA = P_ID_AZIENDA;

        SELECT COUNT(1)
         INTO N_DELEGA
         FROM DB_DELEGA
         WHERE ID_AZIENDA = P_ID_AZIENDA AND DATA_FINE IS NULL AND ID_PROCEDIMENTO = 7;

     -- Ricavo la fase utilizzata dal cursore in base alla motivazione scelta
    SELECT ID_FASE INTO nIdFase FROM DB_TIPO_MOTIVO_DICHIARAZIONE WHERE ID_MOTIVO_DICHIARAZIONE = P_ID_MOTIVO_DICHIARAZIONE;

    BEGIN
        SELECT ANNO_CAMPAGNA INTO nAnnoCampagna FROM DB_TIPO_MOTIVO_DICHIARAZIONE
        WHERE ID_MOTIVO_DICHIARAZIONE = P_ID_MOTIVO_DICHIARAZIONE
        AND    TIPO_DICHIARAZIONE        = 'C';
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            nAnnoCampagna := NULL;
    END;


  FOR REC_CONTROLLI_VER IN C_CONTROLLI_VER(nIdFase, P_ID_AZIENDA) LOOP
    IF REC_CONTROLLI_VER.CONTROLLO_EMERGENZA IS NULL THEN
      -- DBMS_OUTPUT.PUT_LINE(REC_CONTROLLI_VER.ID_CONTROLLO || ' - Inizio : ' || TO_CHAR(SYSDATE,'DD/MM/YYYY HH24:MI:SS'));
      IF NOT ESEGUI_CONTROLLI(REC_CONTROLLI_VER.ID_CONTROLLO, NULL, P_ID_AZIENDA,P_ANNO_RIF, REC_CONTROLLI_VER.BLOCCANTE, FALSE, nIdFase, P_ID_UTENTE_LOGIN, NULL,P_MSGERR, P_CODERR) THEN
        RAISE ERRORE;
      END IF;
    ELSE
      EXECUTE IMMEDIATE DBMS_LOB.SUBSTR(REC_CONTROLLI_VER.CONTROLLO_EMERGENZA,32765,1)
      USING IN P_ID_AZIENDA,IN nIdFase,OUT P_MSGERR, OUT P_CODERR;
    END IF;
          -- DBMS_OUTPUT.PUT_LINE(REC_CONTROLLI_VER.ID_CONTROLLO || ' - Fine : ' || TO_CHAR(SYSDATE,'DD/MM/YYYY HH24:MI:SS'));
  END LOOP;

     DELETE FROM DB_DICHIARAZIONE_SEGNALAZIONE
     WHERE ID_AZIENDA = P_ID_AZIENDA
       AND ID_DICHIARAZIONE_CONSISTENZA IS NULL AND BLOCCANTE='P';

     UPDATE DB_AZIENDA SET DATA_CONTROLLO = SYSDATE WHERE ID_AZIENDA = P_ID_AZIENDA;

     IF NOT AGGIORNAMENTO_FINALE (P_ID_AZIENDA, NULL, P_MSGERR, P_CODERR) THEN
        RAISE ERRORE;
     END IF;

     IF N_COUNT_BLOCCANTI > 0 THEN
          P_ESITO_CONTR := 'E';      --- ERRORI BLOCCANTI
     ELSIF N_COUNT_ANOMALIE > 0 THEN
          P_ESITO_CONTR := 'E';    ---- ANOMALIE
     ELSE
          P_ESITO_CONTR := 'N'; --NESSUN ERRORE
     END IF;

   COMMIT;

EXCEPTION
 WHEN ERRORE THEN
     IF P_CODERR IS NULL THEN
       P_CODERR := SQLCODE;
       P_MSGERR := SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    END IF;
 WHEN OTHERS THEN
     IF P_CODERR IS NULL THEN
       P_CODERR := SQLCODE;
       P_MSGERR := SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    END IF;
END CONTROLLI_DICHIARAZIONE;

-- nuova procedure per eseguire i controlli per un certo ID_FASE
-- attualmente utilizzata in fase di consolidamento delle unità vitate
-- aggiunto parametro P_ID_UTENTE_IRIDE
PROCEDURE CONTROLLI_FASE(P_ID_AZIENDA           IN DB_AZIENDA.ID_AZIENDA%TYPE,
                         P_ID_FASE              IN DB_TIPO_FASE.ID_FASE%TYPE,
                         P_ID_UTENTE_LOGIN      IN PAPUA_V_UTENTE_LOGIN.ID_UTENTE_LOGIN%TYPE, 
                         P_PRESENZA_ANOM        OUT VARCHAR2,
                         P_MSGERR               IN OUT VARCHAR2,
                         P_CODERR               IN OUT VARCHAR2) IS

    CURSOR C_PROPRIETARI_DOC IS
    SELECT A.CUAA, A.ID_DOCUMENTO_PROPRIETARIO
      FROM DB_DOCUMENTO_PROPRIETARIO A, DB_DOCUMENTO B
     WHERE A.ID_DOCUMENTO = B.ID_DOCUMENTO
       AND B.ID_AZIENDA = P_ID_AZIENDA;

BEGIN

     N_COUNT_BLOCCANTI := 0;
     N_COUNT_ANOMALIE := 0;

     IF NOT CANCELLA_ANOMALIE (P_ID_AZIENDA, NULL, P_MSGERR, P_CODERR) THEN
        RAISE ERRORE;
     END IF;

    -- prelevo le caratteristiche dell'azienda
    -- var_flag_provvisoria='S' azienda provvisoria, altrimenti è definitiva
    -- var_tipo_azienda id della tipologia
    -- var_forma_giuridica id della forma giuridica
    -- var_flag_partitaiva'S' se è obbligatoria
    -- var_flag_cciaa 'S' se i dati cciaa sono obbligatori
    -- var_data_fine_fg valorizzata se la formagiuridica è scaduta
    SELECT b.cuaa,
           b.PARTITA_IVA,
           a.FLAG_AZIENDA_PROVVISORIA,
           b.id_tipologia_azienda,
           b.id_forma_giuridica,
           c.FLAG_PARTITA_IVA,
           c.FLAG_CCIAA,
           c.DATA_FINE_FORMA_GIURIDICA
      INTO var_cuaa,
           var_PIVA,
           var_flag_provvisoria,
           var_tipo_azienda,
           var_forma_giuridica,
           var_flag_partitaiva,
           var_flag_cciaa,
           var_data_fine_fg
      FROM DB_AZIENDA A,
           DB_ANAGRAFICA_AZIENDA B,
           DB_TIPO_FORMA_GIURIDICA C
     WHERE A.ID_AZIENDA = P_ID_AZIENDA
       AND A.ID_AZIENDA = B.ID_AZIENDA
       AND B.DATA_FINE_VALIDITA IS NULL
       AND B.ID_FORMA_GIURIDICA = C.ID_FORMA_GIURIDICA(+);

    SELECT COUNT(1)
      INTO N_DELEGA
      FROM DB_DELEGA
     WHERE ID_AZIENDA = P_ID_AZIENDA AND DATA_FINE IS NULL AND ID_PROCEDIMENTO = 7;

     -- FARE TUTTI I CONTROLLI
  FOR REC_CONTROLLI_VER IN C_CONTROLLI_VER(P_ID_FASE, P_ID_AZIENDA) LOOP
    IF REC_CONTROLLI_VER.CONTROLLO_EMERGENZA IS NULL THEN
      IF NOT ESEGUI_CONTROLLI(REC_CONTROLLI_VER.ID_CONTROLLO,NULL, P_ID_AZIENDA, NULL, REC_CONTROLLI_VER.BLOCCANTE, FALSE,P_ID_FASE,
                              P_ID_UTENTE_LOGIN, NULL,P_MSGERR, P_CODERR) THEN
        RAISE ERRORE;
      END IF;
    ELSE
      EXECUTE IMMEDIATE DBMS_LOB.SUBSTR(REC_CONTROLLI_VER.CONTROLLO_EMERGENZA,32765,1)
      USING IN P_ID_AZIENDA,IN P_ID_FASE,OUT P_MSGERR, OUT P_CODERR;
    END IF;
  END LOOP;

     DELETE
       FROM DB_DICHIARAZIONE_SEGNALAZIONE
      WHERE ID_AZIENDA = P_ID_AZIENDA
        AND ID_DICHIARAZIONE_CONSISTENZA IS NULL
        AND BLOCCANTE = 'P';

     IF NOT AGGIORNAMENTO_FINALE (P_ID_AZIENDA, NULL, P_MSGERR, P_CODERR) THEN
        RAISE ERRORE;
     END IF;


     IF N_COUNT_BLOCCANTI > 0 OR N_COUNT_ANOMALIE > 0 THEN
        P_PRESENZA_ANOM := 'S'; -- SONO PRESENTI ANOMALIE
     ELSE
        P_PRESENZA_ANOM := 'N'; -- NESSUN ERRORE
     END IF;

     COMMIT;

EXCEPTION
 WHEN ERRORE THEN
     IF P_CODERR IS NULL THEN
        P_CODERR := SQLCODE;
        P_MSGERR := SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
     END IF;
 WHEN OTHERS THEN
     IF P_CODERR IS NULL THEN
        P_CODERR := SQLCODE;
        P_MSGERR := SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
     END IF;
END CONTROLLI_FASE;

PROCEDURE CONTROLLI_VERIFICA(P_ID_AZIENDA          IN DB_AZIENDA.ID_AZIENDA%TYPE,
                             P_ANNO_RIF            IN DB_UTILIZZO_PARTICELLA.ANNO%TYPE,
                             P_ID_GRUPPO_CONTROLLO IN DB_TIPO_GRUPPO_CONTROLLO.ID_GRUPPO_CONTROLLO%TYPE,
                             P_ID_UTENTE_LOGIN     IN PAPUA_V_UTENTE_LOGIN.ID_UTENTE_LOGIN%TYPE, 
                             P_PRESENZA_ANOM      OUT VARCHAR2,
                             P_MSGERR          IN OUT VARCHAR2,
                             P_CODERR          IN OUT VARCHAR2) IS
CURSOR C_PROPRIETARI_DOC IS
    SELECT A.CUAA, A.ID_DOCUMENTO_PROPRIETARIO
      FROM DB_DOCUMENTO_PROPRIETARIO A, DB_DOCUMENTO B
     WHERE A.ID_DOCUMENTO = B.ID_DOCUMENTO
       AND B.ID_AZIENDA = P_ID_AZIENDA;

nIdFase NUMBER;
BEGIN
     -- Forzo la fase a uno
     nIdFase := 1;

     N_COUNT_BLOCCANTI     := 0;
     N_COUNT_ANOMALIE        := 0;
     N_ID_GRUPPO_CONTROLLO := P_ID_GRUPPO_CONTROLLO;

     IF NOT CANCELLA_ANOMALIE (P_ID_AZIENDA, P_ID_GRUPPO_CONTROLLO, P_MSGERR, P_CODERR) THEN
         RAISE ERRORE;
     END IF;

    -- prelevo le caratteristiche dell'azienda
    -- var_flag_provvisoria='S' azienda provvisoria, altrimenti è definitiva
    -- var_tipo_azienda id della tipologia
    -- var_forma_giuridica id della forma giuridica
    -- var_flag_partitaiva'S' se è obbligatoria
    -- var_flag_cciaa 'S' se i dati cciaa sono obbligatori
    -- var_data_fine_fg valorizzata se la formagiuridica è scaduta
    SELECT b.cuaa, b.PARTITA_IVA, a.FLAG_AZIENDA_PROVVISORIA, b.id_tipologia_azienda, b.id_forma_giuridica, c.FLAG_PARTITA_IVA, c.FLAG_CCIAA, c.DATA_FINE_FORMA_GIURIDICA
    INTO var_cuaa, var_PIVA, var_flag_provvisoria, var_tipo_azienda, var_forma_giuridica, var_flag_partitaiva, var_flag_cciaa, var_data_fine_fg
    FROM SMRGAA.DB_AZIENDA A, SMRGAA.DB_ANAGRAFICA_AZIENDA B, SMRGAA.DB_TIPO_FORMA_GIURIDICA C
    WHERE A.ID_AZIENDA=P_ID_AZIENDA AND A.ID_AZIENDA=B.ID_AZIENDA AND B.DATA_FINE_VALIDITA IS NULL
    AND B.ID_FORMA_GIURIDICA=C.ID_FORMA_GIURIDICA(+);

    SELECT COUNT(1)
      INTO N_DELEGA
      FROM DB_DELEGA
     WHERE ID_AZIENDA = P_ID_AZIENDA AND DATA_FINE IS NULL AND ID_PROCEDIMENTO = 7;

     IF N_ID_GRUPPO_CONTROLLO IS NULL THEN
         -- FARE TUTTI I CONTROLLI
         FOR REC_CONTROLLI_VER IN C_CONTROLLI_VER(nIdFase, P_ID_AZIENDA) LOOP
           IF REC_CONTROLLI_VER.CONTROLLO_EMERGENZA IS NULL THEN
               IF NOT ESEGUI_CONTROLLI(REC_CONTROLLI_VER.ID_CONTROLLO,NULL, P_ID_AZIENDA, P_ANNO_RIF, REC_CONTROLLI_VER.BLOCCANTE, FALSE,nIdFase,
                                       P_ID_UTENTE_LOGIN, NULL,P_MSGERR, P_CODERR) THEN
                   RAISE ERRORE;
              END IF;
           ELSE
             EXECUTE IMMEDIATE DBMS_LOB.SUBSTR(REC_CONTROLLI_VER.CONTROLLO_EMERGENZA,32765,1)
             USING IN P_ID_AZIENDA, IN nIdFase,OUT P_MSGERR, OUT P_CODERR;
           END IF;
         END LOOP;
     ELSE
          IF N_ID_GRUPPO_CONTROLLO = 11 THEN --CONTROLLI SUI DOCUMENTI
             FOR REC_PROPRIETARI_DOC IN C_PROPRIETARI_DOC LOOP
                IF NOT VALIDA_PROPRIETARI_DOCUMENTO (P_ID_AZIENDA, REC_PROPRIETARI_DOC.CUAA,
                   REC_PROPRIETARI_DOC.ID_DOCUMENTO_PROPRIETARIO, P_MSGERR, P_CODERR) THEN
                   RAISE ERRORE;
                END IF;
            END LOOP;
         END IF;

         FOR REC_CONTROLLI_VER_CONTR IN C_CONTROLLI_VER_CONTR(nIdFase,P_ID_AZIENDA) LOOP
           IF REC_CONTROLLI_VER_CONTR.CONTROLLO_EMERGENZA IS NULL THEN
               IF NOT ESEGUI_CONTROLLI(REC_CONTROLLI_VER_CONTR.ID_CONTROLLO,P_ID_GRUPPO_CONTROLLO, P_ID_AZIENDA,
                                       P_ANNO_RIF,REC_CONTROLLI_VER_CONTR.BLOCCANTE,FALSE,nIdFase, P_ID_UTENTE_LOGIN, NULL,P_MSGERR, P_CODERR) THEN
                   RAISE ERRORE;
              END IF;
           ELSE
             EXECUTE IMMEDIATE DBMS_LOB.SUBSTR(REC_CONTROLLI_VER_CONTR.CONTROLLO_EMERGENZA,32765,1)
             USING IN P_ID_AZIENDA, IN nIdFase,OUT P_MSGERR, OUT P_CODERR;
           END IF;
         END LOOP;
     END IF;

     DELETE FROM DB_DICHIARAZIONE_SEGNALAZIONE
     WHERE ID_AZIENDA = P_ID_AZIENDA
       AND ID_DICHIARAZIONE_CONSISTENZA IS NULL AND BLOCCANTE='P';

        IF NOT AGGIORNAMENTO_FINALE (P_ID_AZIENDA, P_ID_GRUPPO_CONTROLLO, P_MSGERR, P_CODERR) THEN
        RAISE ERRORE;
     END IF;


     IF N_COUNT_BLOCCANTI > 0 OR N_COUNT_ANOMALIE > 0 THEN
          P_PRESENZA_ANOM := 'S';    ---- SONO PRESENTI ANOMALIE
     ELSE
          P_PRESENZA_ANOM := 'N'; --NESSUN ERRORE
     END IF;

   COMMIT;

EXCEPTION
 WHEN ERRORE THEN
     IF P_CODERR IS NULL THEN
       P_CODERR := SQLCODE;
       P_MSGERR := SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    END IF;
 WHEN OTHERS THEN
     IF P_CODERR IS NULL THEN
       P_CODERR := SQLCODE;
       P_MSGERR := SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    END IF;
END CONTROLLI_VERIFICA;

PROCEDURE CONTROLLI_INSEDIAMENTO(P_ID_AZIENDA        IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                 P_ID_UTENTE_LOGIN IN PAPUA_V_UTENTE_LOGIN.ID_UTENTE_LOGIN%TYPE, 
                                 P_ESITO_CONTR     OUT VARCHAR2,
                                 P_MSGERR       IN OUT VARCHAR2,
                                 P_CODERR       IN OUT VARCHAR2) IS

nIdFase NUMBER;
BEGIN
     -- Fase due con id_fase=1 Dichiarazione di insediamento
     nIdFase := 2;


     N_COUNT_BLOCCANTI:= 0;
     N_COUNT_ANOMALIE := 0;
     P_ESITO_CONTR      := 'N';
     -- prelevo le caratteristiche dell'azienda
    -- var_flag_provvisoria='S' azienda provvisoria, altrimenti è definitiva
    -- var_tipo_azienda id della tipologia
    -- var_forma_giuridica id della forma giuridica
    -- var_flag_partitaiva'S' se è obbligatoria
    -- var_flag_cciaa 'S' se i dati cciaa sono obbligatori
    -- var_data_fine_fg valorizzata se la formagiuridica è scaduta
    SELECT b.cuaa, b.PARTITA_IVA, a.FLAG_AZIENDA_PROVVISORIA, b.id_tipologia_azienda, b.id_forma_giuridica, c.FLAG_PARTITA_IVA, c.FLAG_CCIAA, c.DATA_FINE_FORMA_GIURIDICA
    INTO var_cuaa, var_PIVA, var_flag_provvisoria, var_tipo_azienda, var_forma_giuridica, var_flag_partitaiva, var_flag_cciaa, var_data_fine_fg
    FROM SMRGAA.DB_AZIENDA A, SMRGAA.DB_ANAGRAFICA_AZIENDA B, SMRGAA.DB_TIPO_FORMA_GIURIDICA C
    WHERE A.ID_AZIENDA=P_ID_AZIENDA AND A.ID_AZIENDA=B.ID_AZIENDA AND B.DATA_FINE_VALIDITA IS NULL
    AND B.ID_FORMA_GIURIDICA=C.ID_FORMA_GIURIDICA(+);

     IF NOT CANCELLA_ANOMALIE (P_ID_AZIENDA, NULL, P_MSGERR, P_CODERR) THEN
         RAISE ERRORE;
     END IF;

     FOR REC_CONTROLLI_INSEDIAMENTO IN C_CONTROLLI_INSEDIAMENTO(nIdFase,P_ID_AZIENDA) LOOP
       
       IF REC_CONTROLLI_INSEDIAMENTO.CONTROLLO_EMERGENZA IS NULL THEN
           IF NOT ESEGUI_CONTROLLI(REC_CONTROLLI_INSEDIAMENTO.ID_CONTROLLO, NULL, P_ID_AZIENDA,
                                   TO_NUMBER(TO_CHAR(SYSDATE,'YYYY')), REC_CONTROLLI_INSEDIAMENTO.BLOCCANTE, TRUE, nIdFase,P_ID_UTENTE_LOGIN, NULL,P_MSGERR, P_CODERR) THEN
               RAISE ERRORE;
           END IF;
       ELSE
         EXECUTE IMMEDIATE DBMS_LOB.SUBSTR(REC_CONTROLLI_INSEDIAMENTO.CONTROLLO_EMERGENZA,32765,1)
         USING IN P_ID_AZIENDA, IN nIdFase,OUT P_MSGERR, OUT P_CODERR;
       END IF;
     END LOOP;

     SELECT COUNT(*) INTO N_COUNT_BLOCCANTI
     FROM DB_DICHIARAZIONE_SEGNALAZIONE
     WHERE ID_AZIENDA=P_ID_AZIENDA AND ID_DICHIARAZIONE_CONSISTENZA IS NULL AND BLOCCANTE = 'S';

     IF N_COUNT_BLOCCANTI > 0 THEN
          P_ESITO_CONTR := 'E';      --- ERRORI BLOCCANTI
     ELSE
          P_ESITO_CONTR := 'N';    --- NESSUN ERRORE BLOCCANTE
     END IF;

   --COMMIT;

EXCEPTION
 WHEN ERRORE THEN
     IF P_CODERR IS NULL THEN
       P_CODERR := SQLCODE;
       P_MSGERR := SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    END IF;
 WHEN OTHERS THEN
     IF P_CODERR IS NULL THEN
       P_CODERR := SQLCODE;
       P_MSGERR := SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    END IF;
END CONTROLLI_INSEDIAMENTO;


PROCEDURE INSERIMENTO_TERRENI(P_ID_AZIENDA              IN DB_AZIENDA.ID_AZIENDA%TYPE,
                              P_ANNO_RIF                IN DB_UTILIZZO_PARTICELLA.ANNO%TYPE,
                              P_CODICE_FOTO             IN DB_DICHIARAZIONE_CONSISTENZA.CODICE_FOTOGRAFIA_TERRENI%TYPE,
                              P_ID_UTENTE_AGGIORNAMENTO IN DB_CONDUZIONE_DICHIARATA.ID_UTENTE_AGGIORNAMENTO%TYPE,
                              P_MSGERR                    OUT VARCHAR2,
                              P_CODERR                     OUT VARCHAR2) IS

N_CONDUZIONE_DICHIARATA  DB_CONDUZIONE_DICHIARATA.ID_CONDUZIONE_DICHIARATA%TYPE;
N_CONDUZIONE_PARTICELLA  DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
N_UTILIZZO_PARTICELLA    DB_UTILIZZO_PARTICELLA.ID_UTILIZZO_PARTICELLA%TYPE;
N_UTILIZZO_DICHIARATO    DB_UTILIZZO_DICHIARATO.ID_UTILIZZO_DICHIARATO%TYPE;
N_UTILIZZO_CONSOCIATO_DICH DB_UTILIZZO_CONSOCIATO_DICH.ID_UTILIZZO_CONSOCIATO_DICH%TYPE;
N_ID_VARIETA            DB_UTILIZZO_PARTICELLA.ID_VARIETA%TYPE;
N_ID_VARIETA_SECONDARIA DB_UTILIZZO_PARTICELLA.ID_VARIETA_SECONDARIA%TYPE;
N_ID_PARTICELLA            DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE;
N_ID_STORICO_UNITA_ARBOREA DB_STORICO_UNITA_ARBOREA.ID_STORICO_UNITA_ARBOREA%TYPE;
N_ID_UNITA_ARBOREA_DICHIARATA DB_UNITA_ARBOREA_DICHIARATA.ID_UNITA_ARBOREA_DICHIARATA%TYPE;
N_ID_ATTESTAZIONE_DICHIARATA DB_ATTESTAZIONE_DICHIARATA.ID_ATTESTAZIONE_DICHIARATA%TYPE;

  nIdCatalogoMatrice  DB_R_CATALOGO_MATRICE.ID_CATALOGO_MATRICE%TYPE;
CURSOR C_CONDUZIONE IS
        SELECT CP.ID_UTE, CP.ID_TITOLO_POSSESSO, CP.SUPERFICIE_CONDOTTA,
        CP.NOTE,CP.DATA_INIZIO_CONDUZIONE,    CP.ID_PARTICELLA,
        CP.ID_CONDUZIONE_PARTICELLA, SP.ID_STORICO_PARTICELLA,
        CP.ESITO_CONTROLLO, CP.DATA_ESECUZIONE, CP.SUPERFICIE_AGRONOMICA,
        CP.PERCENTUALE_POSSESSO
        FROM DB_CONDUZIONE_PARTICELLA CP, DB_UTE U, DB_STORICO_PARTICELLA SP
        WHERE CP.DATA_FINE_CONDUZIONE IS NULL
        AND CP.ID_UTE = U.ID_UTE
        AND CP.ID_PARTICELLA=SP.ID_PARTICELLA AND SP.DATA_FINE_VALIDITA IS NULL
        AND U.ID_AZIENDA = P_ID_AZIENDA
        ORDER BY CP.ID_PARTICELLA;


        CURSOR C_UTILIZZI IS
        SELECT P_ANNO_RIF, UP.*
          FROM DB_UTILIZZO_PARTICELLA UP
         WHERE UP.ID_CONDUZIONE_PARTICELLA= N_CONDUZIONE_PARTICELLA;



        CURSOR C_UTILIZZO_CONSOCIATO IS
        SELECT UC.ID_PIANTE_CONSOCIATE, UC.NUMERO_PIANTE
        FROM DB_UTILIZZO_PARTICELLA UP, DB_UTILIZZO_CONSOCIATO UC
        WHERE UP.ID_UTILIZZO_PARTICELLA = N_UTILIZZO_PARTICELLA
          AND UP.ID_UTILIZZO_PARTICELLA = UC.ID_UTILIZZO_PARTICELLA;

        CURSOR C_UNITA_VITATE IS
        SELECT ID_STORICO_UNITA_ARBOREA, ID_UNITA_ARBOREA, ID_PARTICELLA, PROGR_UNAR, DATA_INIZIO_VALIDITA,
               DATA_FINE_VALIDITA, DATA_LAVORAZIONE, ID_TIPOLOGIA_UNAR, AREA, SESTO_SU_FILA, SESTO_TRA_FILE,
               NUM_CEPPI, ANNO_IMPIANTO, ANNO_REINNESTO, ID_FORMA_ALLEVAMENTO, ID_IRRIGAZIONE_UNAR,
               ID_COLTIVAZIONE_UNAR, CODICE_TIPO_VARIETA, PRESENZA_ALTRI_VITIGNI, NUMERO_PIANTE_PRODUTTIVO,
               NUMERO_ALTRE_PIANTE, CAMPAGNA, ID_TIPOLOGIA_VIGNETO, TIPO_IMPIANTO, NUMERO_CASTAGNI, GRUPPO,
               RICADUTA, ID_GIACITURA_UNAR, ID_ROCCIA_UNAR, ID_SCHELETRO_UNAR, ID_STATO_VEGETATIVO_UNAR,
               ID_POTATURA_UNAR, ID_GIUDIZIO_UNAR, SUPPLEMENTARI, MECCANIZZABILE, DIMENSIONE_CHIOMA,
               ID_ETA_IMPIANTO_UNAR, PROVINCIA_CCIAA, MATRICOLA_CCIAA, CONFERMA_PREC_ISCRIZIONE_ALBO,
               RICHIESTA_NUOVA_ISCR_ALBO, CONFERMA_RICH_NUOVA_ISCR_ALBO, SUPERFICIE_DA_ISCRIVERE_ALBO,
               ANNO_ISCRIZIONE_ALBO, ID_FONTE, ID_VARIAZIONE_UNAR, NOTE, DATA_AGGIORNAMENTO, ID_UTENTE_AGGIORNAMENTO,
               ID_VARIETA, ID_UTILIZZO, PERCENTUALE_VARIETA, ID_VINO, RECORD_MODIFICATO, DATA_ESECUZIONE,
               ESITO_CONTROLLO, ID_AZIENDA, DATA_CESSAZIONE, ID_CESSAZIONE_UNAR, ID_CAUSALE_MODIFICA, ID_TIPOLOGIA_VINO,
               STATO_UNITA_ARBOREA, ANNO_RIFERIMENTO, COLTURA_SPECIALIZZATA, DATA_ISCRIZIONE_ALBO,
               ANNO_PRIMA_PRODUZIONE,VIGNA,ID_GENERE_ISCRIZIONE, 
               DATA_IMPIANTO, DATA_PRIMA_PRODUZIONE, 
               ID_VIGNA, ETICHETTA , ID_MENZIONE_GEOGRAFICA, 
               -- rc
                NULL AS ESITO_TOLLERANZA_UV, 
               FLAG_IMPRODUTTIVA, PERCENTUALE_FALLANZA, 
               ID_TIPO_INTERVENTO_VITICOLO, DATA_INTERVENTO, DATA_SOVRAINNESTO, 
               ID_FILO_SOSTEGNO, ID_PALO_TESTATA, ID_PALO_TESSITURA, ID_ANCORAGGIO_UNAR, 
               ID_STATO_COLTIVAZIONE_UNAR, DISTANZA_PALI, ALTITUDINE_SLM, AREA_SERVIZIO, 
               id_catAlogo_matrice
        FROM DB_STORICO_UNITA_ARBOREA SUA
        WHERE SUA.ID_PARTICELLA = N_ID_PARTICELLA
          AND SUA.ID_AZIENDA     = P_ID_AZIENDA
          AND SUA.DATA_FINE_VALIDITA IS NULL;

CURSOR C_ALTRO_VITIGNO IS
        SELECT ID_ALTRO_VITIGNO, ID_STORICO_UNITA_ARBOREA, PERCENTUALE_VITIGNO, ID_VARIETA
        FROM DB_ALTRO_VITIGNO AV
        WHERE AV.ID_STORICO_UNITA_ARBOREA = N_ID_STORICO_UNITA_ARBOREA;

CURSOR C_ATTESTAZIONI_AZIENDA IS
        SELECT AA.ID_ATTESTAZIONE, AA.ID_ATTESTAZIONE_AZIENDA
        FROM DB_ATTESTAZIONE_AZIENDA AA
        WHERE AA.ID_AZIENDA  = P_ID_AZIENDA;

BEGIN

    -- Modifica del 05/09/2008
    /*     Nul caso in cui si ripristina una d.c. e succ. si storicizza una conduzione nella generazione della nuova d.c.
        non si azzeravano gli ID_DICHIARAZIONE_CONSISTENZA sulle  conduzioni storicizzate
        Quindi durante la cancellazione della d.c veniva lanciata un' eccezione per presenza legame f.k.
        Si procede quindi a cancellare i legami con la d.c. ripristinata sulle conduzioni storicizzate.
    */
     UPDATE DB_CONDUZIONE_PARTICELLA A
     SET     A.DICHIARAZIONE_RIPRISTINATA = NULL,
            A.ID_DICHIARAZIONE_CONSISTENZA = NULL
     WHERE A.ID_UTE IN (SELECT ID_UTE FROM DB_UTE WHERE ID_AZIENDA=P_ID_AZIENDA) AND
     A.DATA_FINE_CONDUZIONE IS NOT NULL;

     -- mi salvo i dati della eleggibilità
     -- più aggiornati al momento della dichiarazione di consistenza
     INSERT INTO DB_ELEGGIBILITA_DICHIARATA
             (
             ID_ELEGGIBILITA_DICHIARATA,
             CODICE_FOTOGRAFIA_TERRENI,
             ID_PARTICELLA,
             ID_PARTICELLA_CERTIFICATA,
             ID_ELEGGIBILITA,
             ID_ELEGGIBILITA_FIT,
             DATA_FOTOINTERPRETAZIONE,
             SUPERFICIE,
             SUPERFICIE_TARA,
             PIANTE_PROD,
             PIANTE_TOT,
             PERCENTUALE_UTILIZZO 
             )
     SELECT /*+rule*/
            SEQ_DB_ELEGGIBILITA_DICHIARATA.nextval,
            CODICE_FOTO,
            ID_PARTICELLA,
            ID_PARTICELLA_CERTIFICATA,
            ID_ELEGGIBILITA,
            ID_ELEGGIBILITA_FIT,
            DATA_FOTOINTERPRETAZIONE,
            SUPERFICIE,
            SUPERFICIE_TARA,
            PIANTE_PROD,
            PIANTE_TOT,
            PERCENTUALE_UTILIZZO 
       FROM (
     SELECT DISTINCT
            P_CODICE_FOTO AS CODICE_FOTO,
            PC.ID_PARTICELLA,
            PC.ID_PARTICELLA_CERTIFICATA,
            CE.ID_ELEGGIBILITA,
            CE.ID_ELEGGIBILITA_FIT,
            CE.DATA_FOTOINTERPRETAZIONE,
            CE.SUPERFICIE,CE.SUPERFICIE_TARA,
            CE.PIANTE_PROD,
            CE.PIANTE_TOT,
           (SELECT SUM(PERCENTUALE_UTILIZZO)
              FROM DB_CONDUZIONE_ELEGGIBILITA CDE
             WHERE CDE.ID_AZIENDA = P_ID_AZIENDA
               AND CDE.ID_PARTICELLA = CP.ID_PARTICELLA
               AND CDE.ID_ELEGGIBILITA_FIT = CE.ID_ELEGGIBILITA_FIT
               AND CDE.DATA_FINE_VALIDITA IS NULL) AS PERCENTUALE_UTILIZZO
       FROM DB_PARTICELLA_CERTIFICATA PC,
            DB_PARTICELLA_CERT_ELEG CE,
            DB_CONDUZIONE_PARTICELLA CP,
            DB_UTE U
      WHERE U.ID_AZIENDA = P_ID_AZIENDA
        AND CP.ID_UTE = U.ID_UTE
        AND CP.DATA_FINE_CONDUZIONE IS NULL
        AND CP.ID_PARTICELLA = PC.ID_PARTICELLA
        AND PC.DATA_FINE_VALIDITA IS NULL
        AND PC.ID_PARTICELLA_CERTIFICATA = CE.ID_PARTICELLA_CERTIFICATA
        AND CE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                  FROM DB_PARTICELLA_CERT_ELEG
                                 WHERE ID_PARTICELLA_CERTIFICATA = PC.ID_PARTICELLA_CERTIFICATA));


     FOR REC_CONDUZIONE IN C_CONDUZIONE LOOP
         UPDATE DB_CONDUZIONE_PARTICELLA SET DICHIARAZIONE_RIPRISTINATA = NULL,
                                               ID_DICHIARAZIONE_CONSISTENZA = NULL,
                                             RECORD_MODIFICATO               = NULL
         WHERE ID_CONDUZIONE_PARTICELLA = REC_CONDUZIONE.ID_CONDUZIONE_PARTICELLA;

          SELECT SEQ_CONDUZIONE_DICHIARATA.NEXTVAL INTO N_CONDUZIONE_DICHIARATA FROM DUAL;

           INSERT INTO DB_CONDUZIONE_DICHIARATA(ID_CONDUZIONE_DICHIARATA,
                                               CODICE_FOTOGRAFIA_TERRENI,
                                              ID_UTE,
                                              ID_TITOLO_POSSESSO,
                                                SUPERFICIE_CONDOTTA,
                                              NOTE,
                                              DATA_INIZIO_CONDUZIONE,
                                              DATA_AGGIORNAMENTO,
                                              ID_UTENTE_AGGIORNAMENTO,
                                              ID_PARTICELLA,
                                              ID_STORICO_PARTICELLA,
                                              ID_CONDUZIONE_PARTICELLA,
                                              ESITO_CONTROLLO,
                                              DATA_ESECUZIONE,
                                              SUPERFICIE_AGRONOMICA,
                                              PERCENTUALE_POSSESSO) VALUES
                                             (N_CONDUZIONE_DICHIARATA,
                                              P_CODICE_FOTO,
                                              REC_CONDUZIONE.ID_UTE,
                                              REC_CONDUZIONE.ID_TITOLO_POSSESSO,
                                              REC_CONDUZIONE.SUPERFICIE_CONDOTTA,
                                              REC_CONDUZIONE.NOTE,
                                              REC_CONDUZIONE.DATA_INIZIO_CONDUZIONE,
                                              SYSDATE,
                                              P_ID_UTENTE_AGGIORNAMENTO,
                                              REC_CONDUZIONE.ID_PARTICELLA,
                                              REC_CONDUZIONE.ID_STORICO_PARTICELLA,
                                              REC_CONDUZIONE.ID_CONDUZIONE_PARTICELLA,
                                               REC_CONDUZIONE.ESITO_CONTROLLO,
                                              REC_CONDUZIONE.DATA_ESECUZIONE,
                                              REC_CONDUZIONE.SUPERFICIE_AGRONOMICA,
                                              REC_CONDUZIONE.PERCENTUALE_POSSESSO);

         N_CONDUZIONE_PARTICELLA := REC_CONDUZIONE.ID_CONDUZIONE_PARTICELLA;

         FOR REC_UTILIZZI IN C_UTILIZZI LOOP
             SELECT SEQ_UTILIZZO_DICHIARATO.NEXTVAL INTO N_UTILIZZO_DICHIARATO FROM DUAL;
            IF REC_UTILIZZI.ID_VARIETA IS NULL THEN
                 SELECT ID_VARIETA INTO N_ID_VARIETA
                FROM DB_TIPO_VARIETA
                WHERE ID_UTILIZZO = REC_UTILIZZI.ID_UTILIZZO
                AND CODICE_VARIETA = '000';
            ELSE
                N_ID_VARIETA := REC_UTILIZZI.ID_VARIETA;
            END IF;
            IF REC_UTILIZZI.ID_VARIETA_SECONDARIA IS NULL AND REC_UTILIZZI.ID_UTILIZZO_SECONDARIO IS NOT NULL THEN
                 SELECT ID_VARIETA INTO N_ID_VARIETA_SECONDARIA
                FROM DB_TIPO_VARIETA
                WHERE ID_UTILIZZO = REC_UTILIZZI.ID_UTILIZZO_SECONDARIO
                AND CODICE_VARIETA = '000';
            ELSE
                N_ID_VARIETA_SECONDARIA := REC_UTILIZZI.ID_VARIETA_SECONDARIA;
            END IF;

            INSERT INTO DB_UTILIZZO_DICHIARATO(ID_UTILIZZO_DICHIARATO,
                                               CODICE_FOTOGRAFIA_TERRENI,
                                               ID_CONDUZIONE_DICHIARATA,
                                               ANNO,
                                               ID_UTILIZZO,
                                               ID_VARIETA,
                                               SUPERFICIE_UTILIZZATA,
                                               ID_UTILIZZO_SECONDARIO,
                                               ID_VARIETA_SECONDARIA,
                                               SUP_UTILIZZATA_SECONDARIA,
                                               NOTE,
                                               DATA_AGGIORNAMENTO,
                                               ID_UTENTE_AGGIORNAMENTO,
                                               ANNO_IMPIANTO,
                                               ID_IMPIANTO,
                                               SESTO_SU_FILE,
                                               SESTO_TRA_FILE,
                                               NUMERO_PIANTE_CEPPI,
                                               ID_TIPO_DETTAGLIO_USO, 
                                               ID_TIPO_DETT_USO_SECONDARIO, 
                                               ID_TIPO_EFA, 
                                               VALORE_ORIGINALE, 
                                               VALORE_DOPO_CONVERSIONE, 
                                               VALORE_DOPO_PONDERAZIONE, 
                                               ID_TIPO_PERIODO_SEMINA, 
                                               ID_TIPO_PERIODO_SEMINA_SECOND, 
                                               ID_SEMINA, ID_SEMINA_SECONDARIA, ID_CATALOGO_MATRICE, 
                                               DATA_INIZIO_DESTINAZIONE, DATA_FINE_DESTINAZIONE, 
                                               ID_FASE_ALLEVAMENTO, ID_PRATICA_MANTENIMENTO, 
                                               ID_CATALOGO_MATRICE_SECONDARIO, DATA_INIZIO_DESTINAZIONE_SEC,
                                               DATA_FINE_DESTINAZIONE_SEC, ID_ISOLA_GRAFICA, 
                                               ID_SHAPE, SHAPE
                                               ) VALUES
                               (N_UTILIZZO_DICHIARATO,
                                P_CODICE_FOTO,
                                N_CONDUZIONE_DICHIARATA,
                                P_ANNO_RIF,
                                REC_UTILIZZI.ID_UTILIZZO,
                                DECODE(REC_UTILIZZI.ID_VARIETA, NULL,N_ID_VARIETA, REC_UTILIZZI.ID_VARIETA),
                                REC_UTILIZZI.SUPERFICIE_UTILIZZATA,
                                REC_UTILIZZI.ID_UTILIZZO_SECONDARIO,
                                DECODE(REC_UTILIZZI.ID_VARIETA_SECONDARIA, NULL,N_ID_VARIETA_SECONDARIA, REC_UTILIZZI.ID_VARIETA_SECONDARIA),
                                REC_UTILIZZI.SUP_UTILIZZATA_SECONDARIA,
                                REC_UTILIZZI.NOTE,
                                SYSDATE,
                                P_ID_UTENTE_AGGIORNAMENTO,
                                REC_UTILIZZI.ANNO_IMPIANTO,
                                REC_UTILIZZI.ID_IMPIANTO,
                                REC_UTILIZZI.SESTO_SU_FILE,
                                REC_UTILIZZI.SESTO_TRA_FILE,
                                REC_UTILIZZI.NUMERO_PIANTE_CEPPI,
                                REC_UTILIZZI.ID_TIPO_DETTAGLIO_USO, 
                                REC_UTILIZZI.ID_TIPO_DETT_USO_SECONDARIO, 
                                REC_UTILIZZI.ID_TIPO_EFA,
                                REC_UTILIZZI.VALORE_ORIGINALE, 
                                REC_UTILIZZI.VALORE_DOPO_CONVERSIONE, 
                                REC_UTILIZZI.VALORE_DOPO_PONDERAZIONE, 
                                REC_UTILIZZI.ID_TIPO_PERIODO_SEMINA, 
                                REC_UTILIZZI.ID_TIPO_PERIODO_SEMINA_SECOND, 
                                REC_UTILIZZI.ID_SEMINA, REC_UTILIZZI.ID_SEMINA_SECONDARIA, REC_UTILIZZI.ID_CATALOGO_MATRICE, 
                               REC_UTILIZZI.DATA_INIZIO_DESTINAZIONE, REC_UTILIZZI.DATA_FINE_DESTINAZIONE, 
                               REC_UTILIZZI.ID_FASE_ALLEVAMENTO, REC_UTILIZZI.ID_PRATICA_MANTENIMENTO, 
                               REC_UTILIZZI.ID_CATALOGO_MATRICE_SECONDARIO, REC_UTILIZZI.DATA_INIZIO_DESTINAZIONE_SEC,
                               REC_UTILIZZI.DATA_FINE_DESTINAZIONE_SEC, REC_UTILIZZI.ID_ISOLA_GRAFICA, 
                               REC_UTILIZZI.ID_SHAPE, REC_UTILIZZI.SHAPE
                                );

            N_UTILIZZO_PARTICELLA := REC_UTILIZZI.ID_UTILIZZO_PARTICELLA;

            FOR REC_UTILIZZO_CONSOCIATO IN C_UTILIZZO_CONSOCIATO LOOP
                    SELECT SEQ_UTILIZZO_CONS_DICH.NEXTVAL INTO N_UTILIZZO_CONSOCIATO_DICH FROM DUAL;
                INSERT INTO DB_UTILIZZO_CONSOCIATO_DICH (ID_UTILIZZO_CONSOCIATO_DICH,
                    ID_UTILIZZO_DICHIARATO, ID_PIANTE_CONSOCIATE, NUMERO_PIANTE) VALUES
                    (N_UTILIZZO_CONSOCIATO_DICH, N_UTILIZZO_DICHIARATO,
                    REC_UTILIZZO_CONSOCIATO.ID_PIANTE_CONSOCIATE, REC_UTILIZZO_CONSOCIATO.NUMERO_PIANTE);
            END LOOP;
        END LOOP;
            IF NVL(N_ID_PARTICELLA,0) <> REC_CONDUZIONE.ID_PARTICELLA THEN
               N_ID_PARTICELLA := REC_CONDUZIONE.ID_PARTICELLA;
                FOR REC_UNITA_VITATE IN C_UNITA_VITATE LOOP
                    SELECT SEQ_UTILIZZO_CONS_DICH.NEXTVAL INTO N_UTILIZZO_CONSOCIATO_DICH FROM DUAL;
                    SELECT SEQ_UNITA_ARBOREA_DICHIARATA.NEXTVAL INTO N_ID_UNITA_ARBOREA_DICHIARATA FROM DUAL;
                    
                    INSERT INTO DB_UNITA_ARBOREA_DICHIARATA (ID_UNITA_ARBOREA_DICHIARATA, CODICE_FOTOGRAFIA_TERRENI,
                         ID_STORICO_UNITA_ARBOREA, ID_STORICO_PARTICELLA, PROGR_UNAR, DATA_INIZIO_VALIDITA,
                         DATA_FINE_VALIDITA, DATA_LAVORAZIONE, ID_TIPOLOGIA_UNAR, AREA, SESTO_SU_FILA, SESTO_TRA_FILE,
                         NUM_CEPPI, ANNO_IMPIANTO, ANNO_REINNESTO, ID_FORMA_ALLEVAMENTO, ID_IRRIGAZIONE_UNAR, ID_COLTIVAZIONE_UNAR,
                         CODICE_TIPO_VARIETA, PRESENZA_ALTRI_VITIGNI, NUMERO_PIANTE_PRODUTTIVO, NUMERO_ALTRE_PIANTE, CAMPAGNA,
                         ID_TIPOLOGIA_VIGNETO, TIPO_IMPIANTO, NUMERO_CASTAGNI, GRUPPO, RICADUTA, ID_GIACITURA_UNAR, ID_ROCCIA_UNAR,
                         ID_SCHELETRO_UNAR, ID_STATO_VEGETATIVO_UNAR, ID_POTATURA_UNAR, ID_GIUDIZIO_UNAR, SUPPLEMENTARI,
                         MECCANIZZABILE, DIMENSIONE_CHIOMA, ID_ETA_IMPIANTO_UNAR, PROVINCIA_CCIAA, MATRICOLA_CCIAA,
                         CONFERMA_PREC_ISCRIZIONE_ALBO, RICHIESTA_NUOVA_ISCR_ALBO, CONFERMA_RICH_NUOVA_ISCR_ALBO,
                         SUPERFICIE_DA_ISCRIVERE_ALBO, ANNO_ISCRIZIONE_ALBO, ID_FONTE, ID_VARIAZIONE_UNAR, NOTE, DATA_AGGIORNAMENTO,
                         ID_UTENTE_AGGIORNAMENTO, ID_VARIETA, ID_UTILIZZO, ID_VINO, ID_TIPOLOGIA_VINO, DATA_CESSAZIONE, ID_CESSAZIONE_UNAR,
                         ID_CAUSALE_MODIFICA, DATA_ESECUZIONE, ESITO_CONTROLLO, PERCENTUALE_VARIETA, ID_AZIENDA, STATO_UNITA_ARBOREA,
                         ANNO_RIFERIMENTO, COLTURA_SPECIALIZZATA, DATA_ISCRIZIONE_ALBO,ANNO_PRIMA_PRODUZIONE,VIGNA,ID_GENERE_ISCRIZIONE,
                         DATA_IMPIANTO, DATA_PRIMA_PRODUZIONE,ESITO_TOLLERANZA_GIS,ID_VIGNA, ETICHETTA,ID_MENZIONE_GEOGRAFICA, 
                         FLAG_IMPRODUTTIVA, PERCENTUALE_FALLANZA, 
                         ID_TIPO_INTERVENTO_VITICOLO, DATA_INTERVENTO, DATA_SOVRAINNESTO, 
                         ID_FILO_SOSTEGNO, ID_PALO_TESTATA, ID_PALO_TESSITURA, ID_ANCORAGGIO_UNAR, 
                         ID_STATO_COLTIVAZIONE_UNAR, DISTANZA_PALI, ALTITUDINE_SLM, AREA_SERVIZIO, 
                         id_catalogo_matrice) 
                    VALUES(N_ID_UNITA_ARBOREA_DICHIARATA, P_CODICE_FOTO, REC_UNITA_VITATE.ID_STORICO_UNITA_ARBOREA,
                         REC_CONDUZIONE.ID_STORICO_PARTICELLA, REC_UNITA_VITATE.PROGR_UNAR, REC_UNITA_VITATE.DATA_INIZIO_VALIDITA,
                         REC_UNITA_VITATE.DATA_FINE_VALIDITA, REC_UNITA_VITATE.DATA_LAVORAZIONE, REC_UNITA_VITATE.ID_TIPOLOGIA_UNAR,
                         REC_UNITA_VITATE.AREA, REC_UNITA_VITATE.SESTO_SU_FILA, REC_UNITA_VITATE.SESTO_TRA_FILE,REC_UNITA_VITATE.NUM_CEPPI,
                         REC_UNITA_VITATE.ANNO_IMPIANTO, REC_UNITA_VITATE.ANNO_REINNESTO, REC_UNITA_VITATE.ID_FORMA_ALLEVAMENTO,
                         REC_UNITA_VITATE.ID_IRRIGAZIONE_UNAR, REC_UNITA_VITATE.ID_COLTIVAZIONE_UNAR,
                         REC_UNITA_VITATE.CODICE_TIPO_VARIETA, REC_UNITA_VITATE.PRESENZA_ALTRI_VITIGNI, REC_UNITA_VITATE.NUMERO_PIANTE_PRODUTTIVO,
                         REC_UNITA_VITATE.NUMERO_ALTRE_PIANTE, REC_UNITA_VITATE.CAMPAGNA,REC_UNITA_VITATE.ID_TIPOLOGIA_VIGNETO,
                         REC_UNITA_VITATE.TIPO_IMPIANTO, REC_UNITA_VITATE.NUMERO_CASTAGNI, REC_UNITA_VITATE.GRUPPO, REC_UNITA_VITATE.RICADUTA,
                         REC_UNITA_VITATE.ID_GIACITURA_UNAR, REC_UNITA_VITATE.ID_ROCCIA_UNAR,REC_UNITA_VITATE.ID_SCHELETRO_UNAR,
                         REC_UNITA_VITATE.ID_STATO_VEGETATIVO_UNAR, REC_UNITA_VITATE.ID_POTATURA_UNAR, REC_UNITA_VITATE.ID_GIUDIZIO_UNAR,
                         REC_UNITA_VITATE.SUPPLEMENTARI,REC_UNITA_VITATE.MECCANIZZABILE, REC_UNITA_VITATE.DIMENSIONE_CHIOMA,
                         REC_UNITA_VITATE.ID_ETA_IMPIANTO_UNAR, REC_UNITA_VITATE.PROVINCIA_CCIAA, REC_UNITA_VITATE.MATRICOLA_CCIAA,
                         REC_UNITA_VITATE.CONFERMA_PREC_ISCRIZIONE_ALBO, REC_UNITA_VITATE.RICHIESTA_NUOVA_ISCR_ALBO, REC_UNITA_VITATE.CONFERMA_RICH_NUOVA_ISCR_ALBO,
                         REC_UNITA_VITATE.SUPERFICIE_DA_ISCRIVERE_ALBO, REC_UNITA_VITATE.ANNO_ISCRIZIONE_ALBO, REC_UNITA_VITATE.ID_FONTE,
                         REC_UNITA_VITATE.ID_VARIAZIONE_UNAR, REC_UNITA_VITATE.NOTE, SYSDATE,
                         P_ID_UTENTE_AGGIORNAMENTO, REC_UNITA_VITATE.ID_VARIETA, REC_UNITA_VITATE.ID_UTILIZZO, REC_UNITA_VITATE.ID_VINO,
                         REC_UNITA_VITATE.ID_TIPOLOGIA_VINO, REC_UNITA_VITATE.DATA_CESSAZIONE, REC_UNITA_VITATE.ID_CESSAZIONE_UNAR,
                         REC_UNITA_VITATE.ID_CAUSALE_MODIFICA, REC_UNITA_VITATE.DATA_ESECUZIONE, REC_UNITA_VITATE.ESITO_CONTROLLO,
                         REC_UNITA_VITATE.PERCENTUALE_VARIETA, REC_UNITA_VITATE.ID_AZIENDA, REC_UNITA_VITATE.STATO_UNITA_ARBOREA,
                         REC_UNITA_VITATE.ANNO_RIFERIMENTO, REC_UNITA_VITATE.COLTURA_SPECIALIZZATA, REC_UNITA_VITATE.DATA_ISCRIZIONE_ALBO,
                         REC_UNITA_VITATE.ANNO_PRIMA_PRODUZIONE,REC_UNITA_VITATE.VIGNA,REC_UNITA_VITATE.ID_GENERE_ISCRIZIONE, 
                         REC_UNITA_VITATE.DATA_IMPIANTO, REC_UNITA_VITATE.DATA_PRIMA_PRODUZIONE,REC_UNITA_VITATE.ESITO_TOLLERANZA_UV, 
                         REC_UNITA_VITATE.ID_VIGNA, REC_UNITA_VITATE.ETICHETTA, REC_UNITA_VITATE.ID_MENZIONE_GEOGRAFICA, 
                         REC_UNITA_VITATE.FLAG_IMPRODUTTIVA, REC_UNITA_VITATE.PERCENTUALE_FALLANZA, 
                         REC_UNITA_VITATE.ID_TIPO_INTERVENTO_VITICOLO, REC_UNITA_VITATE.DATA_INTERVENTO, REC_UNITA_VITATE.DATA_SOVRAINNESTO, 
                         REC_UNITA_VITATE.ID_FILO_SOSTEGNO, REC_UNITA_VITATE.ID_PALO_TESTATA, REC_UNITA_VITATE.ID_PALO_TESSITURA, REC_UNITA_VITATE.ID_ANCORAGGIO_UNAR, 
                         REC_UNITA_VITATE.ID_STATO_COLTIVAZIONE_UNAR, REC_UNITA_VITATE.DISTANZA_PALI, REC_UNITA_VITATE.ALTITUDINE_SLM, REC_UNITA_VITATE.AREA_SERVIZIO, 
                         REC_UNITA_VITATE.id_catAlogo_matrice); 

                UPDATE DB_STORICO_UNITA_ARBOREA SET RECORD_MODIFICATO = NULL
                WHERE ID_STORICO_UNITA_ARBOREA =  REC_UNITA_VITATE.ID_STORICO_UNITA_ARBOREA;

                N_ID_STORICO_UNITA_ARBOREA := REC_UNITA_VITATE.ID_STORICO_UNITA_ARBOREA;

                FOR REC_ALTRO_VITIGNO IN C_ALTRO_VITIGNO LOOP
                  SELECT CM1.ID_CATALOGO_MATRICE
                  INTO   nIdCatalogoMatrice
                  FROM   DB_R_CATALOGO_MATRICE CM,DB_R_CATALOGO_MATRICE CM1
                  WHERE  CM.ID_CATALOGO_MATRICE   = REC_UNITA_VITATE.ID_CATALOGO_MATRICE
                  AND    CM.ID_UTILIZZO           = CM1.ID_UTILIZZO
                  AND    CM.ID_TIPO_DESTINAZIONE  = CM1.ID_TIPO_DESTINAZIONE
                  AND    CM.ID_TIPO_DETTAGLIO_USO = CM1.ID_TIPO_DETTAGLIO_USO
                  AND    CM.ID_TIPO_QUALITA_USO   = CM1.ID_TIPO_QUALITA_USO
                  AND    CM1.ID_VARIETA           = REC_ALTRO_VITIGNO.ID_VARIETA
                  AND    CM1.DATA_FINE_VALIDITA   IS NULL;

                  INSERT INTO DB_ALTRO_VITIGNO_DICHIARATO
                  (ID_ALTRO_VITIGNO_DICHIARATO, ID_UNITA_ARBOREA_DICHIARATA, ID_VARIETA, PERCENTUALE_VITIGNO,
                   ID_CATALOGO_MATRICE)
                  VALUES
                  (SEQ_ALTRO_VITIGNO_DICHIARATO.NEXTVAL, N_ID_UNITA_ARBOREA_DICHIARATA, REC_ALTRO_VITIGNO.ID_VARIETA,
                   REC_ALTRO_VITIGNO.PERCENTUALE_VITIGNO,nIdCatalogoMatrice);
                END LOOP;

                END LOOP;
            END IF;

    END LOOP;

    -- Modifica del 05/09/2008
    /*     Nul caso in cui si ripristina una d.c. e succ. si storicizza nella generazione della nuova d.c.
        non si azzeravano gli ID_DICHIARAZIONE_CONSISTENZA
        Quindi durante la cancellazione della d.c veniva lanciata un' eccezione per presenza legame f.k.
        Si procede quindi a cancellare i legami con la d.c. ripristinata anche per gli elementi storicizzati
    */
    UPDATE DB_FABBRICATO SET DICHIARAZIONE_RIPRISTINATA = NULL, ID_DICHIARAZIONE_CONSISTENZA = NULL
    WHERE ID_UTE IN (SELECT ID_UTE FROM DB_UTE WHERE ID_AZIENDA = P_ID_AZIENDA);

    -- Modifica del 05/09/2008
    /*     Nul caso in cui si ripristina una d.c. e succ. si storicizza nella generazione della nuova d.c.
        non si azzeravano gli ID_DICHIARAZIONE_CONSISTENZA
        Quindi durante la cancellazione della d.c veniva lanciata un' eccezione per presenza legame f.k.
        Si procede quindi a cancellare i legami con la d.c. ripristinata anche per gli elementi storicizzati
    */
    UPDATE DB_ALLEVAMENTO SET DICHIARAZIONE_RIPRISTINATA = NULL, ID_DICHIARAZIONE_CONSISTENZA = NULL
    WHERE ID_UTE IN (SELECT ID_UTE FROM DB_UTE WHERE ID_AZIENDA = P_ID_AZIENDA);

    FOR REC_ATTESTAZIONI IN C_ATTESTAZIONI_AZIENDA LOOP
        SELECT SEQ_ATTESTAZIONE_DICHIARATA.NEXTVAL INTO N_ID_ATTESTAZIONE_DICHIARATA FROM DUAL;

        -- aggiunta gestione colonna DATA_INIZIO_VALIDITA
        INSERT INTO DB_ATTESTAZIONE_DICHIARATA (ID_ATTESTAZIONE_DICHIARATA, CODICE_FOTOGRAFIA_TERRENI, ID_ATTESTAZIONE,DATA_AGGIORNAMENTO,ID_UTENTE_AGGIORNAMENTO, DATA_INIZIO_VALIDITA)
        VALUES (N_ID_ATTESTAZIONE_DICHIARATA,  P_CODICE_FOTO, REC_ATTESTAZIONI.ID_ATTESTAZIONE,SYSDATE,P_ID_UTENTE_AGGIORNAMENTO, SYSDATE);

        FOR REC_PARAM_ATTESTAZIONI IN (SELECT ID_PARAMETRI_ATT_AZIENDA, ID_ATTESTAZIONE_AZIENDA, PARAMETRO_1, PARAMETRO_2, PARAMETRO_3, PARAMETRO_4, PARAMETRO_5
                                          FROM DB_PARAMETRI_ATT_AZIENDA PAA
                                          WHERE PAA.ID_ATTESTAZIONE_AZIENDA = REC_ATTESTAZIONI.ID_ATTESTAZIONE_AZIENDA) LOOP
            INSERT INTO DB_PARAMETRI_ATT_DICHIARATA (ID_PARAMETRI_ATT_DICHIARATA, ID_ATTESTAZIONE_DICHIARATA, PARAMETRO_1,
                      PARAMETRO_2, PARAMETRO_3, PARAMETRO_4, PARAMETRO_5)
            VALUES (SEQ_PARAMETRI_ATT_DICHIARATA.NEXTVAL, N_ID_ATTESTAZIONE_DICHIARATA, REC_PARAM_ATTESTAZIONI.PARAMETRO_1,
                   REC_PARAM_ATTESTAZIONI.PARAMETRO_2, REC_PARAM_ATTESTAZIONI.PARAMETRO_3, REC_PARAM_ATTESTAZIONI.PARAMETRO_4,
                   REC_PARAM_ATTESTAZIONI.PARAMETRO_5);
        END LOOP;



    END LOOP;

EXCEPTION
 WHEN ERRORE THEN
     IF P_CODERR IS NULL THEN
       P_CODERR := SQLCODE;
       P_MSGERR := SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    END IF;
 WHEN OTHERS THEN
     IF P_CODERR IS NULL THEN
       P_CODERR := SQLCODE;
       P_MSGERR := SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    END IF;
END INSERIMENTO_TERRENI;
  --P_OPERAZIONE PUO' VALERE U (UPDATE- SOVRASCRIVERE LA DICHIARAZIONE DEL GIONRO) O D (DELETE-ELIMINAZIONE DELLA DICHAIRAZIONE)



PROCEDURE  INDICATORI_AZIENDALI    (    P_ID_AZIENDA                 IN         DB_AZIENDA.ID_AZIENDA%TYPE,
                                      P_ID_UTENTE_AGGIORNAMENTO    IN         DB_CONDUZIONE_DICHIARATA.ID_UTENTE_AGGIORNAMENTO%TYPE,
                                       P_MSGERR                    OUT     VARCHAR2,
                                       P_CODERR                     OUT     VARCHAR2
                                            ) IS

nRls1                           NUMBER;
nUde1                               NUMBER;
nOte1                          NUMBER;

nRls2                           NUMBER;
nUde2                          NUMBER;
nOte2                              NUMBER;


nULU                                NUMBER(10,1);
--dDataInizioVal                    DATE;
nReturnVal                     NUMBER;
vDescErr                       VARCHAR2(500);

EXC_CALCOLO_INE    EXCEPTION;

RecANa    DB_ANAGRAFICA_AZIENDA%ROWTYPE;

  nPs  NUMBER;

BEGIN

    Pack_Inea.CALCOLO_INEA(P_ID_AZIENDA,NULL,NULL,nRls1,nUde1,nOte1,nPs,nReturnVal,vDescErr);

    IF nReturnVal = 1 THEN
        RAISE EXC_CALCOLO_INE;
    END IF;


    Pck_Calcolo_Ulu.MAIN ( P_ID_AZIENDA,nUde1,nULU,    nReturnVal,vDescErr);
    IF nReturnVal = 1 THEN
        RAISE EXC_CALCOLO_INE;
    END IF;


    SELECT *        --NVL(RLS,0), NVL(ID_UDE,0),NVL(ID_ATTIVITA_OTE,0), DATA_INIZIO_VALIDITA
    INTO RecAna    --nRls2,nUde2,nOte2,dDataInizioVal
    FROM DB_ANAGRAFICA_AZIENDA
    WHERE ID_AZIENDA = P_ID_AZIENDA
    AND    DATA_FINE_VALIDITA IS NULL;

--    nRls2 := NVL(RecAna.RLS,0);
--    nUde2 := NVL(RecAna.ID_UDE,0);
    nOte2    := NVL(RecAna.ID_ATTIVITA_OTE,0);


---    IF nRls1 != nRls2 OR  nUde1 != nUde2 OR nOte1 != nOte2 THEN

    IF nOte1 != nOte2  AND TRUNC(RecAna.DATA_INIZIO_VALIDITA) != TRUNC(SYSDATE) THEN

        UPDATE DB_ANAGRAFICA_AZIENDA
        SET DATA_FINE_VALIDITA =  TRUNC(SYSDATE-1)
        WHERE ID_ANAGRAFICA_AZIENDA = RecAna.ID_ANAGRAFICA_AZIENDA;

        INSERT INTO DB_ANAGRAFICA_AZIENDA
            (ID_ANAGRAFICA_AZIENDA,
             ID_AZIENDA,
             ID_TIPOLOGIA_AZIENDA,
             DATA_INIZIO_VALIDITA,
             DATA_FINE_VALIDITA,
             CUAA,
             PARTITA_IVA,
             DENOMINAZIONE,
             ID_FORMA_GIURIDICA,
             ID_ATTIVITA_ATECO,
             PROVINCIA_COMPETENZA,
             CCIAA_PROVINCIA_REA,
             CCIAA_NUMERO_REA,
             MAIL,
             SEDELEG_COMUNE,
             SEDELEG_INDIRIZZO,
             SITOWEB,
             SEDELEG_CITTA_ESTERO,
             SEDELEG_CAP,
             DATA_CESSAZIONE,
             CAUSALE_CESSAZIONE,
             NOTE,
             DATA_AGGIORNAMENTO,
             ID_UTENTE_AGGIORNAMENTO,
             ID_ATTIVITA_OTE,
             MOTIVO_MODIFICA,
             CCIAA_NUMERO_REGISTRO_IMPRESE,
             CCIAA_ANNO_ISCRIZIONE,
             MODIFICA_INTERMEDIARIO,
             NUMERO_AGEA,
             INTESTAZIONE_PARTITA_IVA,
             ID_CESSAZIONE,
             ID_DIMENSIONE_AZIENDA,
             ID_UDE,
             RLS,
             ULU,
             CODICE_AGRITURISMO,
             TELEFONO,
             FAX,
             PEC,
             ESONERO_PAGAMENTO_GF
             )
        VALUES (SEQ_ANAGRAFICA_AZIENDA.NEXTVAL,
                RecAna.ID_AZIENDA,
                RecAna.ID_TIPOLOGIA_AZIENDA,
                TRUNC(SYSDATE),
                NULL,
                RecAna.CUAA,
                RecAna.PARTITA_IVA,
                RecAna.DENOMINAZIONE,
                RecAna.ID_FORMA_GIURIDICA,
                RecAna.ID_ATTIVITA_ATECO,
                RecAna.PROVINCIA_COMPETENZA,
                RecAna.CCIAA_PROVINCIA_REA,
                RecAna.CCIAA_NUMERO_REA,
                RecAna.MAIL,
                RecAna.SEDELEG_COMUNE,
                RecAna.SEDELEG_INDIRIZZO,
                RecAna.SITOWEB,
                RecAna.SEDELEG_CITTA_ESTERO,
                RecAna.SEDELEG_CAP,
                RecAna.DATA_CESSAZIONE,
                RecAna.CAUSALE_CESSAZIONE,
                RecAna.NOTE,
                SYSDATE,
                P_ID_UTENTE_AGGIORNAMENTO,
                nOte1,
                'Ricalcolo indicatori aziendali',
                RecAna.CCIAA_NUMERO_REGISTRO_IMPRESE,
                RecAna.CCIAA_ANNO_ISCRIZIONE,
                RecAna.MODIFICA_INTERMEDIARIO,
                RecAna.NUMERO_AGEA,
                RecAna.INTESTAZIONE_PARTITA_IVA,
                RecAna.ID_CESSAZIONE,
                RecAna.ID_DIMENSIONE_AZIENDA,
                nUde1,
                nRls1,
                nULU,
                RecAna.CODICE_AGRITURISMO, 
                RecAna.TELEFONO, 
                RecAna.FAX, 
                RecAna.PEC, 
                RecAna.ESONERO_PAGAMENTO_GF 
                );

        UPDATE DB_AZIENDA
        SET DATA_INIZIO_VALIDITA = TRUNC(SYSDATE)
        WHERE ID_AZIENDA =    P_ID_AZIENDA;


    ELSE

        UPDATE DB_ANAGRAFICA_AZIENDA
        SET     RLS                                = nRls1,
                ID_UDE                            = nUde1,
                ID_ATTIVITA_OTE                 = nOte1,
                ULU                                = nULU,
                ID_UTENTE_AGGIORNAMENTO        = P_ID_UTENTE_AGGIORNAMENTO,
                DATA_AGGIORNAMENTO            = SYSDATE
        WHERE ID_ANAGRAFICA_AZIENDA = RecAna.ID_ANAGRAFICA_AZIENDA;

    END IF;

EXCEPTION
  WHEN EXC_CALCOLO_INE THEN
    P_CODERR := nReturnVal;
    P_MSGERR := vDescErr;
  WHEN OTHERS THEN
      P_CODERR := SQLCODE;
       P_MSGERR := 'Procedura INDICATORI AZIENDALI ERRORE ORACLE: '||SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;

END INDICATORI_AZIENDALI;

PROCEDURE CREA_ACCESSO_GRAFICO(P_ID_AZIENDA                      DB_AZIENDA.ID_AZIENDA%TYPE,
                               P_ANNO_RIF                        DB_UTILIZZO_PARTICELLA.ANNO%TYPE,
                               P_CODICE_FOTO                     DB_DICHIARAZIONE_CONSISTENZA.CODICE_FOTOGRAFIA_TERRENI%TYPE,
                               P_ID_UTENTE_AGGIORNAMENTO         DB_CONDUZIONE_DICHIARATA.ID_UTENTE_AGGIORNAMENTO%TYPE,
                               P_MSGERR                   IN OUT VARCHAR2,
                               P_CODERR                   IN OUT VARCHAR2) IS

  vValoreStringa          DB_ALTRI_DATI.VALORE_STRINGA%TYPE;
  nCont                   SIMPLE_INTEGER := 0;
  vCodiceUtilita          DB_ACCESSO_PIANO_GRAFICO.CODICE_UTILITA%TYPE;
  nIdEsitoGrafico         DB_ACCESSO_PIANO_GRAFICO.ID_ESITO_GRAFICO%TYPE;
  nIdAccessoPianoGrafico  DB_ACCESSO_PIANO_GRAFICO.ID_ACCESSO_PIANO_GRAFICO%TYPE := SEQ_DB_ACCESSO_PIANO_GRAFICO.NEXTVAL;
  vMessaggioErrore        DB_ACCESSO_PIANO_GRAFICO.MESSAGGIO_ERRORE%TYPE;
BEGIN
  SELECT VALORE_STRINGA
  INTO   vValoreStringa
  FROM   DB_ALTRI_DATI
  WHERE  CODICE             = 'GENERA_PIANO_VALIDAZ'
  AND    DATA_FINE_VALIDITA IS NULL;

  IF vValoreStringa = 'S' THEN
    SELECT COUNT(*)
    INTO   nCont
    FROM   DB_DICHIARAZIONE_SEGNALAZIONE DS,DB_DICHIARAZIONE_CONSISTENZA DC,DB_TIPO_CONTROLLO_FASE TCF
    WHERE  DC.CODICE_FOTOGRAFIA_TERRENI    = P_CODICE_FOTO
    AND    DS.ID_DICHIARAZIONE_CONSISTENZA = DC.ID_DICHIARAZIONE_CONSISTENZA
    AND    DS.ID_CONTROLLO                 = TCF.ID_CONTROLLO
    AND    TCF.ID_FASE                     = 10
    AND    TCF.BLOCCANTE                   = 'S';

    IF nCont != 0 THEN
      vCodiceUtilita   := '0';
      nIdEsitoGrafico  := 1;
      vMessaggioErrore := 'generazione non possibile per presenza di anomalie bloccanti';
    ELSE
      SELECT ORA_HASH(nIdAccessoPianoGrafico)
      INTO   vCodiceUtilita
      FROM   DUAL;

      nIdEsitoGrafico  := 0;
      vMessaggioErrore := NULL;
    END IF;

    INSERT INTO DB_ACCESSO_PIANO_GRAFICO
    (ID_ACCESSO_PIANO_GRAFICO, ID_AZIENDA, DATA_ACCESSO,CODICE_UTILITA, ID_ESITO_GRAFICO,
     ID_UTENTE, ID_GRAFICO,
     ID_DICHIARAZIONE_CONSISTENZA,MESSAGGIO_ERRORE)
    VALUES
    (nIdAccessoPianoGrafico,P_ID_AZIENDA,SYSDATE,vCodiceUtilita,nIdEsitoGrafico,
     P_ID_UTENTE_AGGIORNAMENTO,1,
     (SELECT ID_DICHIARAZIONE_CONSISTENZA
      FROM   DB_DICHIARAZIONE_CONSISTENZA
      WHERE  CODICE_FOTOGRAFIA_TERRENI = P_CODICE_FOTO),vMessaggioErrore);
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    P_CODERR := SQLCODE;
    P_MSGERR := 'Procedura CREA_ACCESSO_GRAFICO ERRORE ORACLE: '||SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
END CREA_ACCESSO_GRAFICO;

PROCEDURE SALVA_DICHIARAZIONE(P_ID_AZIENDA                      DB_AZIENDA.ID_AZIENDA%TYPE,
                              P_ANNO_RIF                        DB_UTILIZZO_PARTICELLA.ANNO%TYPE,
                              P_CODICE_FOTO                     DB_DICHIARAZIONE_CONSISTENZA.CODICE_FOTOGRAFIA_TERRENI%TYPE,
                              P_ID_UTENTE_AGGIORNAMENTO         DB_CONDUZIONE_DICHIARATA.ID_UTENTE_AGGIORNAMENTO%TYPE,
                              P_MSGERR                   IN OUT VARCHAR2,
                              P_CODERR                   IN OUT VARCHAR2) IS
BEGIN
  ImpostaGenIscrizUVAzienda (P_ID_AZIENDA,P_MSGERR,P_CODERR);
  INSERIMENTO_TERRENI(P_ID_AZIENDA, P_ANNO_RIF,P_CODICE_FOTO,P_ID_UTENTE_AGGIORNAMENTO ,P_MSGERR,P_CODERR);

  -- testo il P_CODERR e non il P_MSGERR che e' valorizzato anche quando le cose vanno bene
  IF P_CODERR IS NULL THEN
    CREA_ACCESSO_GRAFICO(P_ID_AZIENDA,P_ANNO_RIF,P_CODICE_FOTO,P_ID_UTENTE_AGGIORNAMENTO,P_MSGERR,P_CODERR);

    IF P_CODERR IS NULL THEN
      INDICATORI_AZIENDALI(P_ID_AZIENDA,P_ID_UTENTE_AGGIORNAMENTO,P_MSGERR,P_CODERR);
        -- controllo se la tipologia di validazione prevede la chiusura
        -- automatica della notifiche
      IF IsValidazioneWithCloseNotifica (P_CODICE_FOTO) THEN
        -- se si l'effettuo
        UPDATE DB_NOTIFICA N
        SET    DATA_CHIUSURA      = SYSDATE,
               ID_UTENTE_CHIUSURA = P_ID_UTENTE_AGGIORNAMENTO,
               NOTE_CHIUSURA      = 'Chiusa in validazione'
        WHERE  N.ID_AZIENDA       = P_ID_AZIENDA
        AND    N.DATA_CHIUSURA    IS NULL
        AND    EXISTS             (SELECT ID_CATEGORIA_NOTIFICA
                                   FROM   DB_TIPO_CATEGORIA_NOTIFICA
                                   WHERE  ID_CATEGORIA_NOTIFICA = N.ID_CATEGORIA_NOTIFICA
                                   AND    CHIUDI_IN_VALIDAZIONE = 'S');
      END IF;
    END IF;
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    P_CODERR := SQLCODE;
    P_MSGERR := SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
END SALVA_DICHIARAZIONE;

PROCEDURE OPERAZIONE_AMMESSA(P_ID_AZIENDA     IN DB_AZIENDA.ID_AZIENDA%TYPE,
                             P_ID            IN NUMBER, --DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                             P_OPERAZIONE      IN VARCHAR2,
                             P_ESITO        IN OUT VARCHAR2,
                             P_MSGERR        IN OUT VARCHAR2,
                             P_CODERR         IN OUT VARCHAR2) IS
N_NUM_PRATICHE NUMBER(3);
D_DATA_PROT       DB_DICHIARAZIONE_CONSISTENZA.DATA_PROTOCOLLO%TYPE;
N_NUMERO_PROT  DB_DICHIARAZIONE_CONSISTENZA.NUMERO_PROTOCOLLO%TYPE;
vFlagAggIsole  DB_DICHIARAZIONE_CONSISTENZA.FLAG_AGGIORNAMENTO_ISOLE%TYPE; 
N_FASCICOLI_INIVIO            NUMBER(3);

N_ALLEVAMENTO               NUMBER;
N_FABBRICATO                NUMBER;
N_CONDUZIONE_PARTICELLA     NUMBER;
N_ISOLE                     INTEGER;
N_VARIAZIONI                INTEGER;
N_COMPENSAZIONI             INTEGER;
nCountMot                    NUMBER;
nCountNot                   INTEGER;
nIdDichConsRicavato            NUMBER;
nAnno1                        NUMBER;
nAnno2                        NUMBER;

BEGIN
--    SE  P_OPERAZIONE = 'D' ALLORA P_ID E' ASSOCIATO A  ID_DICHIARAZIONE_CONSISTENZA
--    SE  P_OPERAZIONE = 'N' ALLORA P_ID E' ASSOCIATO A  ID_MOTIVO_DICHIARAZIONE

    IF P_OPERAZIONE = 'D' THEN
        P_ESITO               := 'N';
        N_NUM_PRATICHE      := 0;
        N_FASCICOLI_INIVIO := 0;

        Pack_Pratica_Azienda.AGGIORNA_PRATICA_AZIENDA(P_ID_AZIENDA,P_MSGERR,P_CODERR);

        IF P_MSGERR IS NULL THEN
            -- VERIFICO SE CI SONO DELLE PRATICHE LEGATE ALLA DICHIARAZIONE
            SELECT COUNT(*) INTO N_NUM_PRATICHE
            FROM DB_PROCEDIMENTO_AZIENDA
            WHERE ID_AZIENDA=P_ID_AZIENDA
            AND ID_DICHIARAZIONE_CONSISTENZA = P_ID;

            IF N_NUM_PRATICHE = 0 THEN
                P_ESITO := 'S';
            ELSE
                P_ESITO := 'N';
            END IF;

            -- VERIFICO SE LA DICHIARAZIONE è PROTOCOLLATA
            IF P_ESITO = 'S' THEN
                SELECT DATA_PROTOCOLLO, NUMERO_PROTOCOLLO, FLAG_AGGIORNAMENTO_ISOLE
                INTO D_DATA_PROT, N_NUMERO_PROT,vFlagAggIsole
                FROM DB_DICHIARAZIONE_CONSISTENZA
                WHERE ID_DICHIARAZIONE_CONSISTENZA = P_ID;

                IF D_DATA_PROT IS NOT NULL OR N_NUMERO_PROT IS NOT NULL THEN
                    P_ESITO := 'N';
                END IF;
            END IF;

            -- VERIFICO SE LA DICHIARAZIONE è IN FASE DI INVIO AL SIAN
            IF P_ESITO = 'S' THEN
                SELECT COUNT(*)
                INTO N_FASCICOLI_INIVIO
                FROM DB_FASCICOLI_NAZIONALE
                WHERE ID_DICHIARAZIONE_CONSISTENZA = P_ID;

                IF N_FASCICOLI_INIVIO > 0 THEN
                    P_ESITO := 'N';
                END IF;
            END IF;

            -- VERIFICO CHE LA DICHIARAZIONE DI CONSISTENZA NON SIA STATA RIPRISTINATA --
            -- QUESTA INFO SI TROVA IN UNA DELLE TABELLE DB_ALLEVAMENTO, DB_FABBRICATO, DB_CONDUZIONE_PARTICELLA --
            IF P_ESITO = 'S' THEN
                SELECT     COUNT(*)
                INTO     N_ALLEVAMENTO
                FROM    DB_ALLEVAMENTO
                WHERE     DATA_FINE IS NULL
                AND        ID_DICHIARAZIONE_CONSISTENZA = P_ID
                AND        DICHIARAZIONE_RIPRISTINATA = 'S';

                IF N_ALLEVAMENTO > 0 THEN
                    P_ESITO := 'N';
                END IF;
            END IF;

            IF P_ESITO = 'S' THEN
                SELECT COUNT(*)
                INTO     N_FABBRICATO
                FROM    DB_FABBRICATO
                WHERE    DATA_FINE_VALIDITA IS NULL
                AND     ID_DICHIARAZIONE_CONSISTENZA = P_ID
                AND        DICHIARAZIONE_RIPRISTINATA = 'S';

                IF N_FABBRICATO > 0 THEN
                    P_ESITO := 'N';
                END IF;
            END IF;

            IF P_ESITO = 'S' THEN
                SELECT     COUNT(*)
                INTO     N_CONDUZIONE_PARTICELLA
                FROM    DB_CONDUZIONE_PARTICELLA
                WHERE    DATA_FINE_CONDUZIONE IS NULL
                AND     ID_DICHIARAZIONE_CONSISTENZA = P_ID
                AND        DICHIARAZIONE_RIPRISTINATA = 'S';

                IF N_CONDUZIONE_PARTICELLA > 0 THEN
                    P_ESITO := 'N';
                END IF;
            END IF;

            -- aggiunta verifica isole
            IF P_ESITO = 'S' THEN
                -- è in fase di invio al sian per generazione isole
                IF vFlagAggIsole = 'I' THEN
                   P_ESITO := 'N';
                ELSE
                    -- altrimenti controllo direttamente se ci sono isole per la dichiarazione
                    SELECT COUNT(*)
                      INTO N_ISOLE
                      FROM DB_ISOLA_DICHIARATA
                     WHERE ID_DICHIARAZIONE_CONSISTENZA = P_ID;

                    IF N_ISOLE > 0 THEN
                       P_ESITO := 'N';
                    END IF;
                END IF;
            END IF;

            -- controllo se per l'azienda e la dichiarazione di consistenza
            -- in questione sono presenti delle compensazioni viticole aziendali
            IF P_ESITO = 'S' THEN

               SELECT COUNT(ID_COMPENSAZIONE_AZIENDA)
                 INTO N_COMPENSAZIONI
                 FROM DB_COMPENSAZIONE_AZIENDA
                WHERE ID_AZIENDA = P_ID_AZIENDA
                  AND ID_DICHIARAZIONE_CONSISTENZA = P_ID;
               -- se si non posso cancellare la dichiarazione di consistenza
               IF N_COMPENSAZIONI > 0 THEN
                  P_ESITO := 'N';
               END IF;
            END IF;

            IF P_ESITO = 'S' THEN
               -- controllo se sono presenti unita arboree dichiarate della dichiarazione di consistenza in esame
               -- sulla tabella DB_COMPENSAZIONE_UV
               SELECT COUNT(CUV.ID_COMPENSAZIONE_AZIENDA)
                 INTO N_COMPENSAZIONI
                 FROM DB_COMPENSAZIONE_UV CUV,
                      DB_UNITA_ARBOREA_DICHIARATA UAD,
                      DB_DICHIARAZIONE_CONSISTENZA DC
                WHERE CUV.ID_UNITA_ARBOREA_DICHIARATA = UAD.ID_UNITA_ARBOREA_DICHIARATA
                  AND UAD.CODICE_FOTOGRAFIA_TERRENI = DC.CODICE_FOTOGRAFIA_TERRENI
                  AND DC.ID_DICHIARAZIONE_CONSISTENZA = P_ID;
               -- se si non posso cancellare la dichiarazioen di consistenza
               IF N_COMPENSAZIONI > 0 THEN
                  P_ESITO := 'N';
               END IF;
            END IF;

            -- aggiunta verifica variazioni aziendali
            IF P_ESITO = 'S' THEN

                SELECT COUNT(*)
                  INTO N_VARIAZIONI
                  FROM DB_VARIAZIONE_AZIENDALE
                 WHERE ID_DICHIARAZIONE_CONSISTENZA_A = P_ID
                    OR ID_DICHIARAZIONE_CONSISTENZA_P = P_ID;

                IF N_VARIAZIONI > 0 THEN
                   P_ESITO := 'N';
                END IF;
            END IF;

            -- verifico se la dichiarazione e' presente in qualche notifica
            IF P_ESITO = 'S' THEN

               SELECT COUNT(ID_NOTIFICA_ENTITA)
                 INTO nCountNot
                 FROM DB_NOTIFICA_ENTITA
                WHERE ID_DICHIARAZIONE_CONSISTENZA = P_ID;

               IF nCountNot > 0 THEN
                  P_ESITO := 'N';
               END IF;

            END IF;

        END IF;
    ELSIF P_OPERAZIONE = 'N' THEN
        SELECT COUNT(*) INTO nCountMot
        FROM DB_TIPO_MOTIVO_DICHIARAZIONE
        WHERE ID_MOTIVO_DICHIARAZIONE = P_ID
        AND    TIPO_DICHIARAZIONE        ='C';

        IF nCountMot > 0 THEN

            BEGIN
                SELECT     DISTINCT ID_DICHIARAZIONE_CONSISTENZA INTO nIdDichConsRicavato
                FROM  DB_UTE UT,
                        DB_ALLEVAMENTO AL
                WHERE UT.ID_AZIENDA                         = P_ID_AZIENDA
                AND    UT.DATA_FINE_ATTIVITA             IS NULL
                AND    AL.DATA_FINE                         IS NULL
                AND    AL.ID_UTE                             = UT.ID_UTE
                AND    DICHIARAZIONE_RIPRISTINATA        = 'S';
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    BEGIN
                        SELECT     DISTINCT ID_DICHIARAZIONE_CONSISTENZA INTO nIdDichConsRicavato
                        FROM  DB_UTE UT,
                                DB_FABBRICATO FA
                        WHERE UT.ID_AZIENDA                         = P_ID_AZIENDA
                        AND    UT.DATA_FINE_ATTIVITA             IS NULL
                        AND    FA.DATA_FINE_VALIDITA            IS NULL
                        AND    FA.ID_UTE                             = UT.ID_UTE
                        AND    DICHIARAZIONE_RIPRISTINATA        = 'S';
                    EXCEPTION
                        WHEN NO_DATA_FOUND THEN
                            BEGIN
                                SELECT     DISTINCT ID_DICHIARAZIONE_CONSISTENZA INTO nIdDichConsRicavato
                                FROM  DB_UTE UT,
                                        DB_CONDUZIONE_PARTICELLA CO
                                WHERE UT.ID_AZIENDA                         = P_ID_AZIENDA
                                AND    UT.DATA_FINE_ATTIVITA             IS NULL
                                AND    CO.DATA_FINE_CONDUZIONE            IS NULL
                                AND    CO.ID_UTE                             = UT.ID_UTE
                                AND    DICHIARAZIONE_RIPRISTINATA        = 'S';
                            EXCEPTION
                                WHEN NO_DATA_FOUND THEN
                                    nIdDichConsRicavato := NULL;
                            END;
                    END;
            END;

            IF nIdDichConsRicavato IS NOT NULL THEN
               BEGIN
                    SELECT ANNO_CAMPAGNA INTO     nAnno1
                    FROM    DB_DICHIARAZIONE_CONSISTENZA
                    WHERE ID_DICHIARAZIONE_CONSISTENZA = nIdDichConsRicavato;
                EXCEPTION
                    WHEN OTHERS THEN
                        nAnno1 := 1;
                END;

               BEGIN
                    SELECT ANNO_CAMPAGNA INTO nAnno2
                    FROM DB_TIPO_MOTIVO_DICHIARAZIONE
                    WHERE ID_MOTIVO_DICHIARAZIONE = P_ID;
                EXCEPTION
                    WHEN OTHERS THEN
                        nAnno2 := 0;
                END;

                IF nAnno1 - nAnno2 = 0 THEN
                    P_ESITO := 'S';
                ELSE
                    P_ESITO := 'N';
                END IF;

            ELSE
                P_ESITO := 'S';
            END IF;

        ELSE
            P_ESITO := 'S';
        END IF;

    END IF;

EXCEPTION
    WHEN ERRORE THEN
        IF P_CODERR IS NULL THEN
            P_CODERR := SQLCODE;
            P_MSGERR := SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
        END IF;
    WHEN OTHERS THEN
        IF P_CODERR IS NULL THEN
            P_CODERR := SQLCODE;
            P_MSGERR := SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
        END IF;
END OPERAZIONE_AMMESSA;

PROCEDURE CONTROLLI_VALIDAZIONE(P_ID_AZIENDA               DB_AZIENDA.ID_AZIENDA%TYPE,
                                P_ID_FASE                  DB_TIPO_FASE.ID_FASE%TYPE,
                                P_ID_UTENTE_LOGIN          PAPUA_V_UTENTE_LOGIN.ID_UTENTE_LOGIN%TYPE, 
                                P_ID_DICHIARAZIONE         DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                P_PRESENZA_ANOM        OUT VARCHAR2,
                                P_MSGERR            IN OUT VARCHAR2,
                                P_CODERR            IN OUT VARCHAR2) IS

  vAggiornaDichiarazioneConsist  DB_TIPO_FASE.AGGIORNA_DICHIARAZIONE_CONSIST%TYPE;
BEGIN

  N_COUNT_BLOCCANTI := 0;
  N_COUNT_ANOMALIE  := 0;

  IF NOT CANCELLA_ANOMALIE (P_ID_AZIENDA, NULL, P_MSGERR, P_CODERR) THEN
    RAISE ERRORE;
  END IF;

  SELECT AGGIORNA_DICHIARAZIONE_CONSIST
  INTO   vAggiornaDichiarazioneConsist
  FROM   DB_TIPO_FASE
  WHERE  ID_FASE = P_ID_FASE;

  -- prelevo le caratteristiche dell'azienda
  -- var_flag_provvisoria='S' azienda provvisoria, altrimenti è definitiva
  -- var_tipo_azienda id della tipologia
  -- var_forma_giuridica id della forma giuridica
  -- var_flag_partitaiva'S' se è obbligatoria
  -- var_flag_cciaa 'S' se i dati cciaa sono obbligatori
  -- var_data_fine_fg valorizzata se la formagiuridica è scaduta
  SELECT AA.CUAA,AA.PARTITA_IVA,A.FLAG_AZIENDA_PROVVISORIA,AA.ID_TIPOLOGIA_AZIENDA,AA.ID_FORMA_GIURIDICA,
         TFG.FLAG_PARTITA_IVA,TFG.FLAG_CCIAA,TFG.DATA_FINE_FORMA_GIURIDICA
  INTO   var_cuaa,var_PIVA,var_flag_provvisoria,var_tipo_azienda,var_forma_giuridica,
         var_flag_partitaiva,var_flag_cciaa,var_data_fine_fg
  FROM   DB_AZIENDA A,DB_ANAGRAFICA_AZIENDA AA,DB_TIPO_FORMA_GIURIDICA TFG
  WHERE  A.ID_AZIENDA          = P_ID_AZIENDA
  AND    A.ID_AZIENDA          = AA.ID_AZIENDA
  AND    AA.DATA_FINE_VALIDITA IS NULL
  AND    AA.ID_FORMA_GIURIDICA = TFG.ID_FORMA_GIURIDICA(+);

  SELECT COUNT(*)
  INTO   N_DELEGA
  FROM   DB_DELEGA
  WHERE  ID_AZIENDA      = P_ID_AZIENDA
  AND    DATA_FINE       IS NULL
  AND    ID_PROCEDIMENTO = 7;

  -- FARE TUTTI I CONTROLLI
  FOR REC_CONTROLLI_VER IN C_CONTROLLI_VER(P_ID_FASE, P_ID_AZIENDA) LOOP
    IF REC_CONTROLLI_VER.CONTROLLO_EMERGENZA IS NULL THEN
      IF NOT ESEGUI_CONTROLLI(REC_CONTROLLI_VER.ID_CONTROLLO,NULL, P_ID_AZIENDA, NULL,
                              REC_CONTROLLI_VER.BLOCCANTE, FALSE,P_ID_FASE,
                              P_ID_UTENTE_LOGIN, P_ID_DICHIARAZIONE,P_MSGERR, P_CODERR) THEN
        RAISE ERRORE;
      END IF;
    ELSE
      EXECUTE IMMEDIATE DBMS_LOB.SUBSTR(REC_CONTROLLI_VER.CONTROLLO_EMERGENZA,32765,1)
      USING IN P_ID_AZIENDA,IN P_ID_FASE,IN P_ID_DICHIARAZIONE,OUT P_MSGERR, OUT P_CODERR;
    END IF;

    IF vAggiornaDichiarazioneConsist = 'S' THEN
      UPDATE DB_DICHIARAZIONE_SEGNALAZIONE
      SET    ID_DICHIARAZIONE_CONSISTENZA = P_ID_DICHIARAZIONE
      WHERE  ID_CONTROLLO                 = REC_CONTROLLI_VER.ID_CONTROLLO
      AND    ID_AZIENDA                   = P_ID_AZIENDA
      AND    ID_DICHIARAZIONE_CONSISTENZA IS NULL;
    END IF;
  END LOOP;

  IF NOT AGGIORNAMENTO_FINALE (P_ID_AZIENDA, NULL, P_MSGERR, P_CODERR) THEN
    RAISE ERRORE;
  END IF;


  IF N_COUNT_BLOCCANTI > 0 OR N_COUNT_ANOMALIE > 0 THEN
    P_PRESENZA_ANOM := 'S'; -- SONO PRESENTI ANOMALIE
  ELSE
    P_PRESENZA_ANOM := 'N'; -- NESSUN ERRORE
  END IF;

  COMMIT;

EXCEPTION
  WHEN ERRORE THEN
    IF P_CODERR IS NULL THEN
      P_CODERR := SQLCODE;
      P_MSGERR := SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    END IF;
  WHEN OTHERS THEN
    IF P_CODERR IS NULL THEN
      P_CODERR := SQLCODE;
      P_MSGERR := SQLERRM||' RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
    END IF;
END CONTROLLI_VALIDAZIONE;

END PACK_DICHIARAZIONE_CONSISTENZA;          -- Package

/
--------------------------------------------------------
--  DDL for Package Body PACK_INEA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PACK_INEA" AS

-- cancella le tabelle temporanee utili per il calcolo di ote, ude e rls --
/* Formatted on 29/05/2009 15.56.53 (QP5 v5.114.809.3010) */
PROCEDURE cancella_tabelle_temp (p_id_tmp_inea_azienda   IN DB_TMP_INEA_AZIENDA.ID_TMP_INEA_AZIENDA%TYPE) IS
  --PRAGMA   AUTONOMOUS_TRANSACTION;
BEGIN
   DELETE   DB_TMP_INEA_AZIENDA_DETT WHERE   ID_TMP_INEA_AZIENDA = p_id_tmp_inea_azienda;

   DELETE   DB_TMP_INEA_AZIENDA WHERE   ID_TMP_INEA_AZIENDA = p_id_tmp_inea_azienda;

   --commit;
EXCEPTION
   WHEN OTHERS
   THEN
      RAISE;
END cancella_tabelle_temp;

-- funzione che restituisce il valore di verità di un confronto tra due numeri, dove l'operatore di confronto può assumere i valori di
-- minore, minore o uguale, uguale, maggiore o uguale, maggiore, diverso --
FUNCTION CONFRONTA_VALORI    (    p_valore_sx IN    NUMBER,
                                        p_valore_dx IN    NUMBER,
                                        p_operatore IN    VARCHAR2
                                    ) RETURN BOOLEAN IS

BEGIN
    IF p_operatore = c_minore THEN
        RETURN p_valore_sx < p_valore_dx;
    ELSIF p_operatore = c_minore_uguale THEN
        RETURN p_valore_sx <= p_valore_dx;
    ELSIF p_operatore = c_uguale THEN
        RETURN p_valore_sx = p_valore_dx;
    ELSIF p_operatore = c_maggiore_uguale THEN
        RETURN p_valore_sx >= p_valore_dx;
    ELSIF p_operatore = c_maggiore THEN
        RETURN p_valore_sx > p_valore_dx;
    ELSIF p_operatore = c_diverso THEN
        RETURN p_valore_sx <> p_valore_dx;
    ELSE
        RETURN FALSE;
    END IF;
END CONFRONTA_VALORI;

-- a fronte di un gruppo inea, identificato dalla sua PK, e di un'azienda effettua il calcolo della somma degli rls corrispondenti
-- alle attività inea associate a quel particolare gruppo
-- le tabelle coinvolte sono DB_TMP_INEA_AZIENDA_DETT che è la tabella temporanea in cui sono salvati tutti i codici inea con i corrispondenti rls
-- e la tabella DB_GRUPPO_ATTIVITA_INEA
FUNCTION rls_gruppo_inea(p_id_gruppo_inea       DB_INEA_CONTROLLO_DETT_MEMBRO.ID_GRUPPO_INEA%TYPE,
                         p_id_tmp_inea_azienda  DB_TMP_INEA_AZIENDA.ID_TMP_INEA_AZIENDA%TYPE) RETURN NUMBER IS

  v_rls_gruppo_inea  DB_TMP_INEA_AZIENDA_DETT.RLS_ATTIVITA%TYPE := 0; -- PP 01/06/09 messo il type  NUMBER(10,4);
  nRlsAttivita       DB_TMP_INEA_AZIENDA_DETT.RLS_ATTIVITA%TYPE;
  nRlsAttivitaConfr  DB_TMP_INEA_AZIENDA_DETT.RLS_ATTIVITA%TYPE;
BEGIN
  FOR rec IN (SELECT *
              FROM   DB_GRUPPO_ATTIVITA_INEA
              WHERE  ID_GRUPPO_INEA     = p_id_gruppo_inea
              AND    DATA_FINE_VALIDITA IS NULL) LOOP

    IF rec.ID_GRUPPO_INEA_CONFRONTO IS NULL THEN
      BEGIN
        SELECT NVL(TIAD.RLS_ATTIVITA,0)
        INTO   nRlsAttivita
        FROM   DB_GRUPPO_ATTIVITA_INEA GAI, DB_TMP_INEA_AZIENDA_DETT TIAD
        WHERE  GAI.ID_ATTIVITA_INEA     = TIAD.ID_ATTIVITA_INEA
        AND    TIAD.ID_TMP_INEA_AZIENDA = p_id_tmp_inea_azienda
        AND    GAI.ID_GRUPPO_INEA       = rec.ID_GRUPPO_INEA
        AND    GAI.ID_ATTIVITA_INEA     = rec.ID_ATTIVITA_INEA;
      EXCEPTION
        WHEN NO_DATA_FOUND THEN
          nRlsAttivita := 0;
      END;
    ELSE
      SELECT NVL(SUM(NVL(TIAD.RLS_ATTIVITA,0)),0)
      INTO   nRlsAttivitaConfr
      FROM   DB_GRUPPO_ATTIVITA_INEA GAI, DB_TMP_INEA_AZIENDA_DETT TIAD
      WHERE  GAI.ID_ATTIVITA_INEA     = TIAD.ID_ATTIVITA_INEA
      AND    TIAD.ID_TMP_INEA_AZIENDA = p_id_tmp_inea_azienda
      AND    GAI.ID_GRUPPO_INEA       = rec.ID_GRUPPO_INEA_CONFRONTO;

      IF CONFRONTA_VALORI(nRlsAttivitaConfr,rec.VALORE_CONFRONTO,rec.OPERATORE_CONFRONTO) THEN
        BEGIN
          SELECT NVL(TIAD.RLS_ATTIVITA,0)
          INTO   nRlsAttivita
          FROM   DB_GRUPPO_ATTIVITA_INEA GAI, DB_TMP_INEA_AZIENDA_DETT TIAD
          WHERE  GAI.ID_ATTIVITA_INEA     = TIAD.ID_ATTIVITA_INEA
          AND    TIAD.ID_TMP_INEA_AZIENDA = p_id_tmp_inea_azienda
          AND    GAI.ID_GRUPPO_INEA       = rec.ID_GRUPPO_INEA
          AND    GAI.ID_ATTIVITA_INEA     = rec.ID_ATTIVITA_INEA;
        EXCEPTION
          WHEN NO_DATA_FOUND THEN
            nRlsAttivita := 0;
        END;
      ELSE
        nRlsAttivita := 0;
      END IF;
    END IF;

    v_rls_gruppo_inea := v_rls_gruppo_inea + nRlsAttivita;
  END LOOP;

  RETURN v_rls_gruppo_inea;

EXCEPTION

WHEN NO_DATA_FOUND THEN
    RETURN 0;
WHEN OTHERS THEN
   -- PP 01/06/09  RETURN v_rls_gruppo_inea;

    RAISE;

END rls_gruppo_inea;

FUNCTION rls_attivita_inea(    p_id_attivita_inea         IN    DB_INEA_CONTROLLO_DETT_MEMBRO.ID_ATTIVITA_INEA%TYPE,
                                        p_id_tmp_inea_azienda     IN    DB_TMP_INEA_AZIENDA.ID_TMP_INEA_AZIENDA%TYPE
                                    ) RETURN NUMBER IS

v_rls_attivita_inea DB_TMP_INEA_AZIENDA_DETT.RLS_ATTIVITA%TYPE; -- PP 01/06/09 messo il type  NUMBER(10,4);

BEGIN

    SELECT NVL(TIAD.RLS_ATTIVITA,0)
    INTO   v_rls_attivita_inea
    FROM   DB_TMP_INEA_AZIENDA_DETT TIAD
    WHERE  TIAD.ID_TMP_INEA_AZIENDA = p_id_tmp_inea_azienda
    AND       TIAD.ID_ATTIVITA_INEA = p_id_attivita_inea;

    RETURN v_rls_attivita_inea;

EXCEPTION

WHEN NO_DATA_FOUND THEN
    RETURN 0;
WHEN OTHERS THEN
   -- PP 01/06/09  RETURN v_rls_attivita_inea;
    RAISE;

END rls_attivita_inea;



PROCEDURE CALCOLO_INEA(p_id_azienda                        DB_AZIENDA.ID_AZIENDA%TYPE,
                       p_id_ute                            DB_UTE.ID_UTE%TYPE,
                       p_id_dichiarazione_consistenza      DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                       rls                             OUT NUMBER,
                       ude                             OUT DB_TIPO_UDE.ID_UDE%TYPE,
                       ote                             OUT DB_TIPO_ATTIVITA_OTE.CODICE%TYPE,
                       ps                              OUT NUMBER,
                       v_return_val                    OUT NUMBER,
                       v_DescErr                       OUT VARCHAR2) IS


-- estrae tutte le attività inea di un'azienda o di una UTE in base a quale parametro di input risulta valorizzato
CURSOR cur_attivita_inea_azienda_ute IS
/* Formatted on 29/05/2009 16.01.09 (QP5 v5.114.809.3010) */
 /* SELECT   ATTIVITA_INEA,
           CODICE_ATTIVITA_INEA,
           RLS,
           NVL (SUM (QUANTITA), 0) QUANTITA
    FROM   (SELECT   TU.ID_ATTIVITA_INEA ATTIVITA_INEA,
                     TAI.CODICE_ATTIVITA CODICE_ATTIVITA_INEA,
                     TAI.RLS_ANAGRAFE RLS,
                     NVL (UP.SUPERFICIE_UTILIZZATA, 0) QUANTITA --NVL(SUM(UP.SUPERFICIE_UTILIZZATA*TAI.RLS_ANAGRAFE),0) RLS,TAI.RLS_ANAGRAFE
              FROM   DB_UTE U,
                     DB_CONDUZIONE_PARTICELLA CP,
                     DB_UTILIZZO_PARTICELLA UP,
                     DB_TIPO_UTILIZZO TU,
                     DB_TIPO_ATTIVITA_INEA TAI
             WHERE   U.ID_UTE = CP.ID_UTE
                     AND CP.ID_CONDUZIONE_PARTICELLA =
                           UP.ID_CONDUZIONE_PARTICELLA
                     AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
                     AND TU.ID_ATTIVITA_INEA = TAI.ID_ATTIVITA_INEA
                     AND TAI.DATA_FINE_VALIDITA IS NULL
                     AND (U.ID_AZIENDA = p_id_azienda OR U.ID_UTE = p_id_ute)
                     AND U.DATA_FINE_ATTIVITA IS NULL
                     AND CP.DATA_FINE_CONDUZIONE IS NULL
                     AND TU.ANNO_FINE_VALIDITA IS NULL
            UNION
            SELECT   TCA.ID_ATTIVITA_INEA ATTIVITA_INEA,
                     TAI.CODICE_ATTIVITA CODICE_ATTIVITA_INEA,
                     TAI.RLS_ANAGRAFE RLS,
                     NVL (CA.QUANTITA, 0) QUANTITA
              FROM   DB_UTE U,
                     DB_ALLEVAMENTO A,
                     DB_CATEGORIE_ALLEVAMENTO CA,
                     DB_TIPO_CATEGORIA_ANIMALE TCA,
                     DB_TIPO_ATTIVITA_INEA TAI
             WHERE       U.ID_UTE = A.ID_UTE
                     AND A.ID_ALLEVAMENTO = CA.ID_ALLEVAMENTO
                     AND CA.ID_CATEGORIA_ANIMALE = TCA.ID_CATEGORIA_ANIMALE
                     AND TCA.ID_ATTIVITA_INEA = TAI.ID_ATTIVITA_INEA
                     AND TAI.DATA_FINE_VALIDITA IS NULL
                     AND (U.ID_AZIENDA = p_id_azienda OR U.ID_UTE = p_id_ute)
                     AND U.DATA_FINE_ATTIVITA IS NULL
                     AND A.DATA_FINE IS NULL
                     AND TCA.DATA_FINE_VALIDITA IS NULL)
GROUP BY   ATTIVITA_INEA, CODICE_ATTIVITA_INEA, RLS
ORDER BY   2;*/
(
SELECT
    CM.ID_ATTIVITA_INEA ATTIVITA_INEA, 
    TAI.CODICE_ATTIVITA CODICE_ATTIVITA_INEA,
    TAI.RLS_ANAGRAFE RLS,
    SUM(NVL (UP.SUPERFICIE_UTILIZZATA, 0)) QUANTITA --NVL(SUM(UP.SUPERFICIE_UTILIZZATA*TAI.RLS_ANAGRAFE),0) RLS,TAI.RLS_ANAGRAFE
FROM
    DB_UTE U,
    DB_CONDUZIONE_PARTICELLA CP,
    DB_UTILIZZO_PARTICELLA UP,
    DB_TIPO_UTILIZZO TU,
    DB_TIPO_ATTIVITA_INEA TAI,DB_R_CATALOGO_MATRICE CM  
WHERE
    U.ID_UTE = CP.ID_UTE
    AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
    AND CM.ID_UTILIZZO = TU.ID_UTILIZZO 
    AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
    AND CM.ID_ATTIVITA_INEA = TAI.ID_ATTIVITA_INEA 
    AND TAI.DATA_FINE_VALIDITA IS NULL
    AND (U.ID_AZIENDA = p_id_azienda OR U.ID_UTE = p_id_ute)
    AND U.DATA_FINE_ATTIVITA IS NULL
    AND CP.DATA_FINE_CONDUZIONE IS NULL
    AND TU.ANNO_FINE_VALIDITA IS NULL
GROUP BY
    CM.ID_ATTIVITA_INEA,
    TAI.CODICE_ATTIVITA,
    TAI.RLS_ANAGRAFE
)
UNION
(
SELECT
    TCA.ID_ATTIVITA_INEA ATTIVITA_INEA,
    TAI.CODICE_ATTIVITA CODICE_ATTIVITA_INEA,
    TAI.RLS_ANAGRAFE RLS,
    SUM(NVL (CA.QUANTITA, 0)) QUANTITA
FROM   DB_UTE U,
    DB_ALLEVAMENTO A,
    DB_CATEGORIE_ALLEVAMENTO CA,
    DB_TIPO_CATEGORIA_ANIMALE TCA,
    DB_TIPO_ATTIVITA_INEA TAI
WHERE
    U.ID_UTE = A.ID_UTE
    AND A.ID_ALLEVAMENTO = CA.ID_ALLEVAMENTO
    AND CA.ID_CATEGORIA_ANIMALE = TCA.ID_CATEGORIA_ANIMALE
    AND TCA.ID_ATTIVITA_INEA = TAI.ID_ATTIVITA_INEA
    AND TAI.DATA_FINE_VALIDITA IS NULL
    AND (U.ID_AZIENDA = p_id_azienda OR U.ID_UTE = p_id_ute)
    AND U.DATA_FINE_ATTIVITA IS NULL
    AND A.DATA_FINE IS NULL
    AND TCA.DATA_FINE_VALIDITA IS NULL
GROUP BY
    TCA.ID_ATTIVITA_INEA,
    TAI.CODICE_ATTIVITA,
    TAI.RLS_ANAGRAFE
)
ORDER BY 2;


v_rls_totale NUMBER;
v_ude_totale NUMBER;
v_id_ude     DB_TIPO_UDE.ID_UDE%TYPE;
v_id_attivita_ote        DB_TIPO_ATTIVITA_OTE.ID_ATTIVITA_OTE%TYPE;

-- se l'azienda o l'ute hanno uno o più utilizzi appartenenti all'attività J12 devo controllare che non ci siano anche
-- utilizzi che appartengano all'attività J11, se così fosse devo azzerare l'rls dell'attività J11 --
v_esiste_codice_suinetti BOOLEAN;
v_esiste_codice_suini BOOLEAN;
v_rls_suinetti NUMBER;
v_n_suinetti NUMBER;
v_id_attivita_inea_suinetti DB_TIPO_ATTIVITA_INEA.ID_ATTIVITA_INEA%TYPE;

v_id_tmp_inea_azienda DB_TMP_INEA_AZIENDA.ID_TMP_INEA_AZIENDA%TYPE;

v_valore_sx              NUMBER;
v_valore_dx              NUMBER;
v_valore_operatore      VARCHAR2(20);

v_controllo_ok          BOOLEAN;

-- questa parte serve per i 70 controlli censiti nella matrice dei criteri di assegnazione delle ote
-- vedi documento criteri_assegnazione_ote.txt nell'area condivisa --
CURSOR cur_controlli IS
SELECT *
FROM   DB_INEA_CONTROLLO
ORDER BY PRIORITA;

CURSOR cur_controlli_dett(p_id_inea_controllo DB_INEA_CONTROLLO.ID_INEA_CONTROLLO%TYPE) IS
SELECT ID_INEA_CONTROLLO_DETT
FROM   DB_INEA_CONTROLLO_DETT
WHERE  ID_INEA_CONTROLLO = p_id_inea_controllo
ORDER BY ORDINAMENTO;

CURSOR cur_controlli_dett_membro(p_id_inea_controllo_dett DB_INEA_CONTROLLO_DETT.ID_INEA_CONTROLLO_DETT%TYPE) IS
SELECT ICDM.ID_INEA_CONTROLLO_DETT_MEMBRO, ICDM.ID_INEA_TIPO_PARAMETRO,
       ICDM.ID_GRUPPO_INEA, ICDM.ID_ATTIVITA_INEA,
       IC.VALORE COEFFICIENTE, IO.DESCRIZIONE OPERATORE
FROM   DB_INEA_CONTROLLO_DETT_MEMBRO ICDM,
       DB_INEA_COEFFICIENTE IC,
       DB_INEA_OPERATORE IO
WHERE  ICDM.ID_INEA_COEFFICIENTE = IC.ID_INEA_COEFFICIENTE(+)
AND       ICDM.ID_INEA_OPERATORE = IO.ID_INEA_OPERATORE(+)
AND       ID_INEA_CONTROLLO_DETT = p_id_inea_controllo_dett
ORDER BY ICDM.ID_INEA_TIPO_PARAMETRO;

  nContPs                        SIMPLE_INTEGER := 0;
  dDataInserimentoDichiarazione  DB_DICHIARAZIONE_CONSISTENZA.DATA_INSERIMENTO_DICHIARAZIONE%TYPE;
  nRLS_ATTIVITA_J02              NUMBER;
  nRLS_ATTIVITA_J07              NUMBER;
  nRLS_ATTIVITA_J08              NUMBER;
    nNUM_ATTIVITA_J02              NUMBER;
  nNUM_ATTIVITA_J07              NUMBER;
  nNUM_ATTIVITA_J08              NUMBER;
BEGIN

    v_rls_totale := 0;
    v_ude_totale := 0;

    v_esiste_codice_suinetti := FALSE;
    v_esiste_codice_suini := FALSE;

  ps := 0;

  IF p_id_dichiarazione_consistenza IS NOT NULL THEN
    SELECT COUNT(*)
    INTO   nContPs
    FROM   DB_TIPO_GREENING TG,DB_DICHIARAZIONE_CONSISTENZA DC
    WHERE  TG.CODICE_TIPO_GREENING         = 'PS'
    AND    DC.ID_DICHIARAZIONE_CONSISTENZA = p_id_dichiarazione_consistenza
    AND    DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,SYSDATE);
  ELSE
    SELECT COUNT(*)
    INTO   nContPs
    FROM   DB_TIPO_GREENING TG
    WHERE  TG.CODICE_TIPO_GREENING = 'PS'
    AND    DATA_FINE_VALIDITA      IS NULL;
  END IF;



    SELECT SEQ_DB_TMP_INEA_AZIENDA.NEXTVAL
    INTO   v_id_tmp_inea_azienda
    FROM   DUAL;

    INSERT INTO DB_TMP_INEA_AZIENDA
    (ID_TMP_INEA_AZIENDA,ID_AZIENDA,ID_UTE,DATA_ELABORAZIONE)
    VALUES
    (v_id_tmp_inea_azienda, p_id_azienda, p_id_ute,SYSDATE);

  IF nContPs = 0 THEN
    FOR rec_attivita_inea_azienda_ute IN cur_attivita_inea_azienda_ute  LOOP
        IF rec_attivita_inea_azienda_ute.CODICE_ATTIVITA_INEA = c_codice_attivita_suinetti THEN
            v_esiste_codice_suinetti := TRUE;
            v_id_attivita_inea_suinetti := rec_attivita_inea_azienda_ute.ATTIVITA_INEA;

        END IF;
        IF rec_attivita_inea_azienda_ute.CODICE_ATTIVITA_INEA = c_codice_attivita_suini THEN
            v_esiste_codice_suini := TRUE;

        END IF;
        /* Formatted on 29/05/2009 16.04.19 (QP5 v5.114.809.3010) */
        INSERT INTO DB_TMP_INEA_AZIENDA_DETT (ID_TMP_INEA_AZIENDA_DETT,
                                      ID_TMP_INEA_AZIENDA,
                                      ID_ATTIVITA_INEA,
                                      RLS_ATTIVITA)
        (SELECT   SEQ_DB_TMP_INEA_AZIENDA_DETT.NEXTVAL,
             v_id_tmp_inea_azienda,
             rec_attivita_inea_azienda_ute.ATTIVITA_INEA,
             rec_attivita_inea_azienda_ute.RLS
             * rec_attivita_inea_azienda_ute.QUANTITA
        FROM   DUAL);
    END LOOP;


    IF v_esiste_codice_suinetti AND v_esiste_codice_suini THEN
        -- PP 01/06/09 codice inutile v_rls_totale := v_rls_totale - v_rls_suinetti;
        UPDATE DB_TMP_INEA_AZIENDA_DETT
        SET       RLS_ATTIVITA = 0
        WHERE  ID_TMP_INEA_AZIENDA = v_id_tmp_inea_azienda
        AND       ID_ATTIVITA_INEA = v_id_attivita_inea_suinetti;
    END IF;
  ELSE
    IF p_id_dichiarazione_consistenza IS NOT NULL THEN
      FOR REC IN (SELECT ATTIVITA_INEA,CODICE_ATTIVITA_INEA,RLS,NVL(SUM(QUANTITA),0) QUANTITA
                  FROM   (
                  SELECT TAI.ID_ATTIVITA_INEA ATTIVITA_INEA,NVL(UD.SUPERFICIE_UTILIZZATA,0) QUANTITA,
                         TAI.CODICE_ATTIVITA CODICE_ATTIVITA_INEA,NVL(TAI.PS_ANAG,0) RLS
                  FROM   DB_UTILIZZO_DICHIARATO UD,DB_CONDUZIONE_DICHIARATA CD,DB_DICHIARAZIONE_CONSISTENZA DC,
                         DB_TIPO_UTILIZZO TU,DB_TIPO_ATTIVITA_INEA TAI,DB_R_CATALOGO_MATRICE CM 
                  WHERE  UD.ID_CONDUZIONE_DICHIARATA      = CD.ID_CONDUZIONE_DICHIARATA
                  AND    DC.ID_DICHIARAZIONE_CONSISTENZA  = p_id_dichiarazione_consistenza
                  AND    CD.CODICE_FOTOGRAFIA_TERRENI     = DC.CODICE_FOTOGRAFIA_TERRENI
                  AND    UD.ID_CATALOGO_MATRICE           = CM.ID_CATALOGO_MATRICE 
                  AND    TU.ID_UTILIZZO                   = CM.ID_UTILIZZO 
                  AND    TU.TIPO                         != 'V'
                  AND    CM.ID_ATTIVITA_INEA              = TAI.ID_ATTIVITA_INEA 
                  AND    CD.ID_TITOLO_POSSESSO            NOT IN (5,6) 
                  )
                  GROUP BY   ATTIVITA_INEA, CODICE_ATTIVITA_INEA, RLS
                  ORDER BY   2) LOOP

        UPDATE DB_TMP_INEA_AZIENDA_DETT
        SET    RLS_ATTIVITA        = RLS_ATTIVITA + (rec.RLS * rec.QUANTITA)
        WHERE  ID_TMP_INEA_AZIENDA = v_id_tmp_inea_azienda
        AND    ID_ATTIVITA_INEA    = rec.ATTIVITA_INEA;

        IF SQL%NOTFOUND THEN
          INSERT INTO DB_TMP_INEA_AZIENDA_DETT
          (ID_TMP_INEA_AZIENDA_DETT, ID_TMP_INEA_AZIENDA, ID_ATTIVITA_INEA, RLS_ATTIVITA)
          VALUES
          (SEQ_DB_TMP_INEA_AZIENDA_DETT.NEXTVAL,v_id_tmp_inea_azienda,rec.ATTIVITA_INEA,
           rec.RLS * rec.QUANTITA);
        END IF;
      END LOOP;
      --------- VINO
            FOR REC IN (SELECT ATTIVITA_INEA,CODICE_ATTIVITA_INEA,RLS,NVL(SUM(QUANTITA),0) QUANTITA
                  FROM   (
                  SELECT TAI.ID_ATTIVITA_INEA ATTIVITA_INEA,NVL(UAD.AREA,0) QUANTITA,
                         TAI.CODICE_ATTIVITA CODICE_ATTIVITA_INEA,NVL(TAI.PS_ANAG,0) RLS
                  FROM   DB_DICHIARAZIONE_CONSISTENZA DC,DB_UNITA_ARBOREA_DICHIARATA UAD,
                         DB_TIPO_ATTIVITA_INEA TAI,DB_TIPO_TIPOLOGIA_VINO TTV,
                         DB_R_CATALOGO_MATRICE CM 
                  WHERE  DC.ID_DICHIARAZIONE_CONSISTENZA = p_id_dichiarazione_consistenza
                  AND    UAD.CODICE_FOTOGRAFIA_TERRENI   = DC.CODICE_FOTOGRAFIA_TERRENI
                  AND    CM.ID_CATALOGO_MATRICE          = UAD.ID_CATALOGO_MATRICE
                  AND    ((TAI.ID_ATTIVITA_INEA          = CM.ID_ATTIVITA_INEA AND TTV.VINO_DOC = 'N' AND TTV.ID_TIPOLOGIA_VINO IS NOT NULL) OR
                          (TAI.ID_ATTIVITA_INEA          = CM.ID_ATTIVITA_INEA_DOC AND TTV.VINO_DOC = 'S' AND TTV.ID_TIPOLOGIA_VINO IS NOT NULL) OR
                          (TAI.ID_ATTIVITA_INEA          = CM.ID_ATTIVITA_INEA AND TTV.ID_TIPOLOGIA_VINO IS NULL))
                  AND    UAD.ID_TIPOLOGIA_VINO           = TTV.ID_TIPOLOGIA_VINO(+)
                  )
                  GROUP BY   ATTIVITA_INEA, CODICE_ATTIVITA_INEA, RLS
                  ORDER BY   2) LOOP

        UPDATE DB_TMP_INEA_AZIENDA_DETT
        SET    RLS_ATTIVITA        = RLS_ATTIVITA + (rec.RLS * rec.QUANTITA)
        WHERE  ID_TMP_INEA_AZIENDA = v_id_tmp_inea_azienda
        AND    ID_ATTIVITA_INEA    = rec.ATTIVITA_INEA;

        IF SQL%NOTFOUND THEN
          INSERT INTO DB_TMP_INEA_AZIENDA_DETT
          (ID_TMP_INEA_AZIENDA_DETT, ID_TMP_INEA_AZIENDA, ID_ATTIVITA_INEA, RLS_ATTIVITA)
          VALUES
          (SEQ_DB_TMP_INEA_AZIENDA_DETT.NEXTVAL,v_id_tmp_inea_azienda,rec.ATTIVITA_INEA,
           rec.RLS * rec.QUANTITA);
        END IF;
      END LOOP;
      ------- ALLEVAMENTI
            FOR REC IN (SELECT ATTIVITA_INEA,CODICE_ATTIVITA_INEA,RLS,NVL(SUM(QUANTITA),0) QUANTITA
                  FROM   (
                  SELECT TCA.ID_ATTIVITA_INEA ATTIVITA_INEA,NVL(CA.QUANTITA_PROPRIETA,0) QUANTITA,TAI.CODICE_ATTIVITA CODICE_ATTIVITA_INEA,
                         NVL(TAI.PS_ANAG,0) RLS
                  FROM   DB_UTE U,DB_ALLEVAMENTO A,DB_CATEGORIE_ALLEVAMENTO CA,DB_TIPO_CATEGORIA_ANIMALE TCA,
                         DB_TIPO_ATTIVITA_INEA TAI,DB_DICHIARAZIONE_CONSISTENZA DC
                  WHERE  DC.ID_DICHIARAZIONE_CONSISTENZA   = p_id_dichiarazione_consistenza
                  AND    U.ID_UTE                          = A.ID_UTE
                  AND    A.ID_ALLEVAMENTO                  = CA.ID_ALLEVAMENTO
                  AND    CA.ID_CATEGORIA_ANIMALE           = TCA.ID_CATEGORIA_ANIMALE
                  AND    TCA.ID_ATTIVITA_INEA              = TAI.ID_ATTIVITA_INEA
                  AND    (U.ID_AZIENDA                     = p_id_azienda OR U.ID_UTE = p_id_ute)
                  AND    U.DATA_FINE_ATTIVITA              IS NULL
                  AND    DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN A.DATA_INIZIO AND NVL(A.DATA_FINE,SYSDATE))
                  GROUP BY   ATTIVITA_INEA, CODICE_ATTIVITA_INEA, RLS
                  ORDER BY   2) LOOP

        UPDATE DB_TMP_INEA_AZIENDA_DETT
        SET    RLS_ATTIVITA        = RLS_ATTIVITA + (rec.RLS * rec.QUANTITA)
        WHERE  ID_TMP_INEA_AZIENDA = v_id_tmp_inea_azienda
        AND    ID_ATTIVITA_INEA    = rec.ATTIVITA_INEA;

        IF SQL%NOTFOUND THEN
          INSERT INTO DB_TMP_INEA_AZIENDA_DETT
          (ID_TMP_INEA_AZIENDA_DETT, ID_TMP_INEA_AZIENDA, ID_ATTIVITA_INEA, RLS_ATTIVITA)
          VALUES
          (SEQ_DB_TMP_INEA_AZIENDA_DETT.NEXTVAL,v_id_tmp_inea_azienda,rec.ATTIVITA_INEA,
           rec.RLS * rec.QUANTITA);
        END IF;
      END LOOP;
    ELSE
      FOR REC IN (/*SELECT ATTIVITA_INEA,CODICE_ATTIVITA_INEA,RLS,NVL(SUM(QUANTITA),0) QUANTITA
                  FROM   (
                  SELECT TAI.ID_ATTIVITA_INEA ATTIVITA_INEA,NVL(UP.SUPERFICIE_UTILIZZATA,0) QUANTITA,
                         TAI.CODICE_ATTIVITA CODICE_ATTIVITA_INEA,NVL(TAI.PS_ANAG,0) RLS
                  FROM   DB_UTILIZZO_PARTICELLA UP,DB_CONDUZIONE_PARTICELLA CP,DB_UTE U,
                         DB_TIPO_UTILIZZO TU,DB_TIPO_ATTIVITA_INEA TAI
                  WHERE  UP.ID_CONDUZIONE_PARTICELLA  = CP.ID_CONDUZIONE_PARTICELLA
                  AND    TU.ID_UTILIZZO               = UP.ID_UTILIZZO
                  AND    TU.TIPO                     != 'V'
                  AND    TAI.ID_ATTIVITA_INEA         = TU.ID_ATTIVITA_INEA
                  AND    CP.ID_UTE                    = U.ID_UTE
                  AND    CP.DATA_FINE_CONDUZIONE      IS NULL
                  AND    (U.ID_AZIENDA                = p_id_azienda OR U.ID_UTE = p_id_ute)
                  UNION
                  SELECT TAI.ID_ATTIVITA_INEA ATTIVITA_INEA,NVL(SAD.AREA,0) QUANTITA,
                         TAI.CODICE_ATTIVITA CODICE_ATTIVITA_INEA,NVL(TAI.PS_ANAG,0) RLS
                  FROM   DB_STORICO_UNITA_ARBOREA SAD,DB_CONDUZIONE_PARTICELLA CP,DB_UTE U,
                         DB_TIPO_UTILIZZO TU,DB_TIPO_ATTIVITA_INEA TAI,DB_TIPO_TIPOLOGIA_VINO TTV
                  WHERE  TU.ID_UTILIZZO          = SAD.ID_UTILIZZO
                  AND    SAD.ID_PARTICELLA       = CP.ID_PARTICELLA
                  AND    CP.ID_UTE               = U.ID_UTE
                  AND    SAD.ID_AZIENDA          = p_id_azienda
                  AND    CP.DATA_FINE_CONDUZIONE IS NULL
                  AND    (U.ID_AZIENDA           = p_id_azienda OR U.ID_UTE = p_id_ute)
                  AND    ((TAI.ID_ATTIVITA_INEA  = TU.ID_ATTIVITA_INEA AND TTV.VINO_DOC = 'N' AND TTV.ID_TIPOLOGIA_VINO IS NOT NULL) OR
                          (TAI.ID_ATTIVITA_INEA  = TU.ID_ATTIVITA_INEA_DOC AND TTV.VINO_DOC = 'S' AND TTV.ID_TIPOLOGIA_VINO IS NOT NULL) OR
                          (TAI.ID_ATTIVITA_INEA  = TU.ID_ATTIVITA_INEA AND TTV.ID_TIPOLOGIA_VINO IS NULL))
                  AND    SAD.ID_TIPOLOGIA_VINO   = TTV.ID_TIPOLOGIA_VINO(+)
                  UNION
                  SELECT TCA.ID_ATTIVITA_INEA ATTIVITA_INEA,NVL(CA.QUANTITA,0) QUANTITA,TAI.CODICE_ATTIVITA CODICE_ATTIVITA_INEA,
                         NVL(TAI.PS_ANAG,0) RLS
                  FROM   DB_UTE U,DB_ALLEVAMENTO A,DB_CATEGORIE_ALLEVAMENTO CA,DB_TIPO_CATEGORIA_ANIMALE TCA,
                         DB_TIPO_ATTIVITA_INEA TAI
                  WHERE  U.ID_UTE                          = A.ID_UTE
                  AND    A.ID_ALLEVAMENTO                  = CA.ID_ALLEVAMENTO
                  AND    CA.ID_CATEGORIA_ANIMALE           = TCA.ID_CATEGORIA_ANIMALE
                  AND    TCA.ID_ATTIVITA_INEA              = TAI.ID_ATTIVITA_INEA
                  AND    (U.ID_AZIENDA                     = p_id_azienda OR U.ID_UTE = p_id_ute)
                  AND    U.DATA_FINE_ATTIVITA              IS NULL
                  AND    A.DATA_FINE              IS NULL)
                  GROUP BY   ATTIVITA_INEA, CODICE_ATTIVITA_INEA, RLS
                  ORDER BY   2*/
                    (
                  SELECT TAI.ID_ATTIVITA_INEA ATTIVITA_INEA,sum(NVL(UP.SUPERFICIE_UTILIZZATA,0)) QUANTITA,
                         TAI.CODICE_ATTIVITA CODICE_ATTIVITA_INEA,NVL(TAI.PS_ANAG,0) RLS
                  FROM   DB_UTILIZZO_PARTICELLA UP,DB_CONDUZIONE_PARTICELLA CP,DB_UTE U,
                         DB_TIPO_UTILIZZO TU,DB_TIPO_ATTIVITA_INEA TAI,DB_R_CATALOGO_MATRICE CM 
                  WHERE  UP.ID_CONDUZIONE_PARTICELLA  = CP.ID_CONDUZIONE_PARTICELLA
                  AND    UP.ID_CATALOGO_MATRICE       = CM.ID_CATALOGO_MATRICE 
                  AND    TU.ID_UTILIZZO               = CM.ID_UTILIZZO 
                  AND    TU.TIPO                     != 'V'
                  AND    TAI.ID_ATTIVITA_INEA         = CM.ID_ATTIVITA_INEA 
                  AND    CP.ID_UTE                    = U.ID_UTE
                  AND    CP.DATA_FINE_CONDUZIONE      IS NULL
                  AND    CP.ID_TITOLO_POSSESSO        NOT IN (5,6) 
                  AND    (U.ID_AZIENDA                = p_id_azienda OR U.ID_UTE = p_id_ute)
                  GROUP BY TAI.ID_ATTIVITA_INEA, TAI.CODICE_ATTIVITA , NVL(TAI.PS_ANAG,0)
                  )
                  UNION
                  (
                  SELECT TAI.ID_ATTIVITA_INEA ATTIVITA_INEA,SUM(NVL(SAD.AREA,0)) QUANTITA,
                         TAI.CODICE_ATTIVITA CODICE_ATTIVITA_INEA,NVL(TAI.PS_ANAG,0) RLS
                  FROM   DB_STORICO_UNITA_ARBOREA SAD,DB_CONDUZIONE_PARTICELLA CP,DB_UTE U,
                         DB_TIPO_ATTIVITA_INEA TAI,DB_TIPO_TIPOLOGIA_VINO TTV,
                         DB_R_CATALOGO_MATRICE CM 
                  WHERE  CM.ID_CATALOGO_MATRICE  = SAD.ID_CATALOGO_MATRICE 
                  AND    SAD.ID_PARTICELLA       = CP.ID_PARTICELLA
                  AND    CP.ID_UTE               = U.ID_UTE
                  AND    SAD.ID_AZIENDA          = p_id_azienda
                  AND    CP.DATA_FINE_CONDUZIONE IS NULL
                  AND    SAD.DATA_FINE_VALIDITA  IS NULL
                  AND    CP.ID_TITOLO_POSSESSO   NOT IN (5,6) 
                  AND    (U.ID_AZIENDA           = p_id_azienda OR U.ID_UTE = p_id_ute)
                  AND    ((TAI.ID_ATTIVITA_INEA  = CM.ID_ATTIVITA_INEA AND TTV.VINO_DOC = 'N' AND TTV.ID_TIPOLOGIA_VINO IS NOT NULL) OR
                          (TAI.ID_ATTIVITA_INEA  = CM.ID_ATTIVITA_INEA_DOC AND TTV.VINO_DOC = 'S' AND TTV.ID_TIPOLOGIA_VINO IS NOT NULL) OR
                          (TAI.ID_ATTIVITA_INEA  = CM.ID_ATTIVITA_INEA AND TTV.ID_TIPOLOGIA_VINO IS NULL))
                  AND    SAD.ID_TIPOLOGIA_VINO   = TTV.ID_TIPOLOGIA_VINO(+)
                  GROUP BY TAI.ID_ATTIVITA_INEA, TAI.CODICE_ATTIVITA , NVL(TAI.PS_ANAG,0)
                  )
                  UNION
                  (
                  SELECT TAI.ID_ATTIVITA_INEA ATTIVITA_INEA,SUM(NVL(CA.QUANTITA_PROPRIETA,0)) QUANTITA,TAI.CODICE_ATTIVITA CODICE_ATTIVITA_INEA,
                         NVL(TAI.PS_ANAG,0) RLS
                  FROM   DB_UTE U,DB_ALLEVAMENTO A,DB_CATEGORIE_ALLEVAMENTO CA,DB_TIPO_CATEGORIA_ANIMALE TCA,
                         DB_TIPO_ATTIVITA_INEA TAI
                  WHERE  U.ID_UTE                          = A.ID_UTE
                  AND    A.ID_ALLEVAMENTO                  = CA.ID_ALLEVAMENTO
                  AND    CA.ID_CATEGORIA_ANIMALE           = TCA.ID_CATEGORIA_ANIMALE
                  AND    TCA.ID_ATTIVITA_INEA              = TAI.ID_ATTIVITA_INEA
                  AND    (U.ID_AZIENDA                     = p_id_azienda OR U.ID_UTE = p_id_ute)
                  AND    U.DATA_FINE_ATTIVITA              IS NULL
                  AND    A.DATA_FINE              IS NULL
                  GROUP BY TAI.ID_ATTIVITA_INEA, TAI.CODICE_ATTIVITA , NVL(TAI.PS_ANAG,0)
                  )
                  ORDER BY   2) LOOP

        UPDATE DB_TMP_INEA_AZIENDA_DETT
        SET    RLS_ATTIVITA        = RLS_ATTIVITA + (rec.RLS * rec.QUANTITA)
        WHERE  ID_TMP_INEA_AZIENDA = v_id_tmp_inea_azienda
        AND    ID_ATTIVITA_INEA    = rec.ATTIVITA_INEA;

        IF SQL%NOTFOUND THEN
          INSERT INTO DB_TMP_INEA_AZIENDA_DETT
          (ID_TMP_INEA_AZIENDA_DETT, ID_TMP_INEA_AZIENDA, ID_ATTIVITA_INEA, RLS_ATTIVITA)
          VALUES
          (SEQ_DB_TMP_INEA_AZIENDA_DETT.NEXTVAL,v_id_tmp_inea_azienda,rec.ATTIVITA_INEA,
           rec.RLS * rec.QUANTITA);
        END IF;
      END LOOP;
    END IF;
  END IF;

  BEGIN
    SELECT NVL(SUM(RLS_ATTIVITA),0)/TA.PS_ANAG,  NVL(SUM(RLS_ATTIVITA),0)
    INTO   nNUM_ATTIVITA_J02, nRLS_ATTIVITA_J02
    FROM   DB_TMP_INEA_AZIENDA_DETT TI, DB_TIPO_aTTIVITA_INEA TA
    WHERE  ID_TMP_INEA_AZIENDA = v_id_tmp_inea_azienda
    AND    TI.ID_ATTIVITA_INEA = 110
    AND    TI.ID_aTTIVITA_INEA = TA.ID_ATTIVITA_INEA
    GROUP BY TA.ID_ATTIVITA_INEA,TA.PS_ANAG;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      nNUM_ATTIVITA_J02 := 0;
      nRLS_ATTIVITA_J02 := 0;
  END;

  BEGIN
    SELECT NVL(SUM(RLS_ATTIVITA),0)/TA.PS_ANAG, NVL(SUM(RLS_ATTIVITA),0)
    INTO   nNUM_ATTIVITA_J07, nRLS_ATTIVITA_J07
    FROM   DB_TMP_INEA_AZIENDA_DETT TI,  DB_TIPO_aTTIVITA_INEA TA
    WHERE  ID_TMP_INEA_AZIENDA = v_id_tmp_inea_azienda
    AND    TI.ID_ATTIVITA_INEA = 56
    AND    TI.ID_aTTIVITA_INEA = TA.ID_ATTIVITA_INEA
    GROUP BY TA.ID_ATTIVITA_INEA,TA.PS_ANAG;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      nNUM_ATTIVITA_J07 := 0;
      nRLS_ATTIVITA_J07 := 0;
  END;

  BEGIN
    SELECT NVL(SUM(RLS_ATTIVITA),0)/TA.PS_ANAG , NVL(SUM(RLS_ATTIVITA),0)
    INTO   nNUM_ATTIVITA_J08, nRLS_ATTIVITA_J08
    FROM   DB_TMP_INEA_AZIENDA_DETT TI,  DB_TIPO_aTTIVITA_INEA TA
    WHERE  ID_TMP_INEA_AZIENDA = v_id_tmp_inea_azienda
    AND    TI.ID_ATTIVITA_INEA = 57
    AND    TI.ID_aTTIVITA_INEA = TA.ID_ATTIVITA_INEA
    GROUP BY TA.ID_ATTIVITA_INEA,TA.PS_ANAG;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      nNUM_ATTIVITA_J08 := 0;
      nRLS_ATTIVITA_J08 := 0;
  END;

  -- bovini
  IF nNUM_ATTIVITA_J02 <= nNUM_ATTIVITA_J07 + nNUM_ATTIVITA_J08 THEN
    UPDATE DB_TMP_INEA_AZIENDA_DETT
    SET    RLS_ATTIVITA        = 0
    WHERE  ID_TMP_INEA_AZIENDA = v_id_tmp_inea_azienda
    AND    ID_ATTIVITA_INEA    = 110;
  ELSE
    UPDATE DB_TMP_INEA_AZIENDA_DETT
    SET    RLS_ATTIVITA        = nRLS_ATTIVITA_J02 - nRLS_ATTIVITA_J07 - nRLS_ATTIVITA_J08
    WHERE  ID_TMP_INEA_AZIENDA = v_id_tmp_inea_azienda
    AND    ID_ATTIVITA_INEA    = 110;
  END IF;

  -- ovini
  UPDATE DB_TMP_INEA_AZIENDA_DETT
  SET    RLS_ATTIVITA        = 0
  WHERE  ID_TMP_INEA_AZIENDA = v_id_tmp_inea_azienda
  AND    ID_ATTIVITA_INEA    = 59
  AND    0                   < (SELECT NVL(SUM(RLS_ATTIVITA),0)
                                FROM   DB_TMP_INEA_AZIENDA_DETT
                                WHERE  ID_TMP_INEA_AZIENDA = v_id_tmp_inea_azienda
                                AND    ID_ATTIVITA_INEA    = 58);

  -- caprini
  UPDATE DB_TMP_INEA_AZIENDA_DETT
  SET    RLS_ATTIVITA        = 0
  WHERE  ID_TMP_INEA_AZIENDA = v_id_tmp_inea_azienda
  AND    ID_ATTIVITA_INEA    = 61
  AND    0                   < (SELECT NVL(SUM(RLS_ATTIVITA),0)
                                FROM   DB_TMP_INEA_AZIENDA_DETT
                                WHERE  ID_TMP_INEA_AZIENDA = v_id_tmp_inea_azienda
                                AND    ID_ATTIVITA_INEA    = 60);

  -- suini
  UPDATE DB_TMP_INEA_AZIENDA_DETT
  SET    RLS_ATTIVITA        = 0
  WHERE  ID_TMP_INEA_AZIENDA = v_id_tmp_inea_azienda
  AND    ID_ATTIVITA_INEA    = 62
  AND    0                   < (SELECT NVL(SUM(RLS_ATTIVITA),0)
                                FROM   DB_TMP_INEA_AZIENDA_DETT
                                WHERE  ID_TMP_INEA_AZIENDA = v_id_tmp_inea_azienda
                                AND    ID_ATTIVITA_INEA    = 63);

    -- puo' valere RS o PS in base alle condizioni precedenti
    SELECT NVL(SUM(RLS_ATTIVITA),0)
    INTO   v_rls_totale
    FROM   DB_TMP_INEA_AZIENDA_DETT
    WHERE  ID_TMP_INEA_AZIENDA = v_id_tmp_inea_azienda;

    v_ude_totale := v_rls_totale*c_coefficiente_calcolo_ude;

    SELECT ID_UDE
    INTO   v_id_ude
    FROM   DB_TIPO_UDE
    WHERE  DATA_FINE_VALIDITA IS NULL
    AND       v_ude_totale >= LIM_INF_UDE
    AND       v_ude_totale < LIM_SUP_UDE;

    v_controllo_ok := FALSE;

  BEGIN
    SELECT DATA_INSERIMENTO_DICHIARAZIONE
    INTO   dDataInserimentoDichiarazione
    FROM   DB_DICHIARAZIONE_CONSISTENZA
    WHERE  ID_DICHIARAZIONE_CONSISTENZA = p_id_dichiarazione_consistenza;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      dDataInserimentoDichiarazione := NULL;
  END;

    FOR rec_controlli IN cur_controlli LOOP
      IF p_id_dichiarazione_consistenza IS NULL AND rec_controlli.DATA_FINE_VALIDITA IS NULL OR
         p_id_dichiarazione_consistenza IS NOT NULL AND dDataInserimentoDichiarazione BETWEEN rec_controlli.DATA_INIZIO_VALIDITA AND NVL(rec_controlli.DATA_FINE_VALIDITA,SYSDATE) THEN

        -- PP 01/06/09 questa assegnazione deve essere eseguita nella if v_id_attivita_ote := rec_controlli.ID_ATTIVITA_OTE;

        IF NOT v_controllo_ok THEN

            -- PP 01/06/09 assegnazione spostata qui da fuori if
            --v_id_attivita_ote := rec_controlli.ID_ATTIVITA_OTE;

            v_controllo_ok := TRUE;

            FOR rec_controlli_dett IN cur_controlli_dett(rec_controlli.ID_INEA_CONTROLLO) LOOP

                v_valore_sx    := 0;
                v_valore_dx    := 0;
                v_valore_operatore := '';

                FOR rec_controlli_dett_membro IN cur_controlli_dett_membro(rec_controlli_dett.ID_INEA_CONTROLLO_DETT) LOOP

                    IF rec_controlli_dett_membro.ID_INEA_TIPO_PARAMETRO = c_parametro_membro_sx THEN

                        IF rec_controlli_dett_membro.ID_GRUPPO_INEA IS NOT NULL THEN
                           IF rec_controlli_dett_membro.COEFFICIENTE IS NULL THEN
                             -- funzione che mi restituisce il valore dell'rls a fronte di un id gruppo inea --
                              v_valore_sx    := v_valore_sx + rls_gruppo_inea(rec_controlli_dett_membro.ID_GRUPPO_INEA, v_id_tmp_inea_azienda);
                           ELSE
                              v_valore_sx    := v_valore_sx + rls_gruppo_inea(rec_controlli_dett_membro.ID_GRUPPO_INEA, v_id_tmp_inea_azienda) * rec_controlli_dett_membro.COEFFICIENTE;
                           END IF;
                        ELSIF rec_controlli_dett_membro.ID_ATTIVITA_INEA IS NOT NULL THEN
                           IF rec_controlli_dett_membro.COEFFICIENTE IS NULL THEN
                           -- funzione che mi restituisce il valore dell'rls a fronte di un id attività inea --
                              v_valore_sx    := v_valore_sx + rls_attivita_inea(rec_controlli_dett_membro.ID_ATTIVITA_INEA, v_id_tmp_inea_azienda);
                           ELSE
                             v_valore_sx    := v_valore_sx + rls_attivita_inea(rec_controlli_dett_membro.ID_ATTIVITA_INEA, v_id_tmp_inea_azienda) * rec_controlli_dett_membro.COEFFICIENTE;
                           END IF;
                        ELSIF rec_controlli_dett_membro.COEFFICIENTE IS NOT NULL THEN

                            v_valore_sx := v_valore_sx + rec_controlli_dett_membro.COEFFICIENTE*v_rls_totale;

                        END IF;

                    ELSIF rec_controlli_dett_membro.ID_INEA_TIPO_PARAMETRO = c_parametro_membro_dx THEN

                        IF rec_controlli_dett_membro.ID_GRUPPO_INEA IS NOT NULL THEN

                           -- funzione che mi restituisce il valore dell'rls a fronte di un id gruppo inea--
                            IF rec_controlli_dett_membro.COEFFICIENTE IS NULL THEN
                             -- funzione che mi restituisce il valore dell'rls a fronte di un id gruppo inea --
                              v_valore_dx    := v_valore_dx + rls_gruppo_inea(rec_controlli_dett_membro.ID_GRUPPO_INEA, v_id_tmp_inea_azienda);
                           ELSE
                              v_valore_dx    := v_valore_dx + rls_gruppo_inea(rec_controlli_dett_membro.ID_GRUPPO_INEA, v_id_tmp_inea_azienda) * rec_controlli_dett_membro.COEFFICIENTE;
                           END IF;
                        ELSIF rec_controlli_dett_membro.ID_ATTIVITA_INEA IS NOT NULL THEN

                            IF rec_controlli_dett_membro.COEFFICIENTE IS NULL THEN
                           -- funzione che mi restituisce il valore dell'rls a fronte di un id attività inea --
                              v_valore_dx    := v_valore_dx + rls_attivita_inea(rec_controlli_dett_membro.ID_ATTIVITA_INEA, v_id_tmp_inea_azienda);
                           ELSE
                             v_valore_dx    := v_valore_dx + rls_attivita_inea(rec_controlli_dett_membro.ID_ATTIVITA_INEA, v_id_tmp_inea_azienda) * rec_controlli_dett_membro.COEFFICIENTE;
                           END IF;
                        ELSIF rec_controlli_dett_membro.COEFFICIENTE IS NOT NULL THEN

                            v_valore_dx := v_valore_dx + rec_controlli_dett_membro.COEFFICIENTE*v_rls_totale;
                        END IF;

                    ELSIF rec_controlli_dett_membro.ID_INEA_TIPO_PARAMETRO = c_parametro_operatore THEN

                        v_valore_operatore := rec_controlli_dett_membro.OPERATORE;

                    END IF;

                END LOOP;

                IF NOT confronta_valori(v_valore_sx, v_valore_dx,v_valore_operatore) THEN

                    v_controllo_ok := FALSE;
                    EXIT;
                ELSE
                  v_id_attivita_ote := rec_controlli.ID_ATTIVITA_OTE;
                END IF;

            END LOOP;

        ELSE

            EXIT;

        END IF;
      END IF;
    END LOOP;

    UPDATE DB_TMP_INEA_AZIENDA
    SET       ID_ATTIVITA_OTE = v_id_attivita_ote,
           ID_UDE = v_id_ude,
           RLS_TOTALE = v_rls_totale     --pp 01/06/09
    WHERE  ID_TMP_INEA_AZIENDA = v_id_tmp_inea_azienda;

    cancella_tabelle_temp(v_id_tmp_inea_azienda);

  rls := ROUND(v_rls_totale,2);

  IF nContPs != 0 THEN
    ps           := ROUND(v_rls_totale,2);
    v_rls_totale := 0;

    FOR rec_attivita_inea_azienda_ute IN cur_attivita_inea_azienda_ute  LOOP
      IF rec_attivita_inea_azienda_ute.CODICE_ATTIVITA_INEA = c_codice_attivita_suinetti THEN
        v_esiste_codice_suinetti := TRUE;
        v_id_attivita_inea_suinetti := rec_attivita_inea_azienda_ute.ATTIVITA_INEA;
      END IF;

      IF rec_attivita_inea_azienda_ute.CODICE_ATTIVITA_INEA = c_codice_attivita_suini THEN
        v_esiste_codice_suini := TRUE;
      END IF;

      IF v_esiste_codice_suinetti AND v_esiste_codice_suini THEN
        NULL;
      ELSE
        v_rls_totale := v_rls_totale + (rec_attivita_inea_azienda_ute.RLS  * rec_attivita_inea_azienda_ute.QUANTITA);
      END IF;
    END LOOP;

    rls := ROUND(v_rls_totale,2);
  END IF;


    ude := v_id_ude;
    ote := v_id_attivita_ote;
    v_DescErr     := NULL;
    v_return_val := 0;

EXCEPTION
WHEN OTHERS THEN
        v_DescErr := 'ERRORE GENERICO: (azienda '||p_id_azienda||') '||SUBSTR(SQLERRM,1,100)||' riga = '||dbms_utility.FORMAT_ERROR_BACKTRACE;
        v_return_val := 1;
END calcolo_inea;


/* Formatted on 29/05/2009 16.08.56 (QP5 v5.114.809.3010) */
PROCEDURE esegui_calcolo_inea(p_id_azienda                        DB_AZIENDA.ID_AZIENDA%TYPE,
                              p_id_ute                            DB_UTE.ID_UTE%TYPE,
                              p_id_dichiarazione_consistenza      DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                              rls                             OUT NUMBER,
                              ude                             OUT DB_TIPO_UDE.ID_UDE%TYPE,
                              ote                             OUT DB_TIPO_ATTIVITA_OTE.CODICE%TYPE,
                              ps                              OUT NUMBER,
                              v_return_val                    OUT NUMBER,
                              v_DescErr                       OUT VARCHAR2) IS

BEGIN
   calcolo_inea (p_id_azienda,
                 p_id_ute,
                 p_id_dichiarazione_consistenza,
                 rls,
                 ude,
                 ote,
                 ps,
                 v_return_val,
                 v_DescErr);

EXCEPTION
WHEN OTHERS THEN
        v_DescErr := 'ERRORE GENERICO: (azienda '||p_id_azienda||') '||SUBSTR(SQLERRM,1,100);
        v_return_val := 1;
END esegui_calcolo_inea;

END Pack_Inea;

/
--------------------------------------------------------
--  DDL for Package Body PACK_MANAGE_SEQUENCE
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PACK_MANAGE_SEQUENCE" AS

    msgErr VARCHAR2(1000);
    
    PROCEDURE resetThisSequence(PseqName IN VARCHAR2,
                                PPKcolumn IN VARCHAR2,
                                PtableName IN VARCHAR2) IS

      Ntmp   NUMBER;
      NPKval NUMBER;

    BEGIN
        --  recupero l'ultimo valore della PK della tabella
    --    EXECUTE IMMEDIATE 'SELECT NVL(MAX(' || PPKcolumn || '),0) FROM ' || PtableName INTO NPKval;
        -- 
        -- 1) calcolo l'indice di decremento: differenza tra max i
        EXECUTE IMMEDIATE 'SELECT ((SELECT NVL(MAX(' || PPKcolumn || '),0) FROM ' || PtableName || ') ' ||
        '- (' || PseqName || '.NEXTVAL)) FROM DUAL' INTO Ntmp;
          
        -- solo se ho sfasati sequence e max..
        IF Ntmp != 0 THEN                     
                   
            -- 2) alter sequence con indice di decremento
            EXECUTE IMMEDIATE 'ALTER SEQUENCE ' || PseqName || ' MINVALUE -1 INCREMENT BY ' || TO_CHAR(Ntmp);           
            
            -- 3) decremento sequence
            EXECUTE IMMEDIATE 'SELECT ' || PseqName || '.NEXTVAL FROM ' || 'DUAL' INTO Ntmp;
               
        --     se non ho record o comunque la mia PK ha valore 0.. reset a MINVALUE = 0 e riparto con il NEXTVAL = 1 ...
        --     IF NPKval <= 0 THEN  
        --        EXECUTE IMMEDIATE 'ALTER SEQUENCE ' || PseqName || ' MINVALUE 0';
        --     END IF;   
            
            -- 4) alter per riportare la sequence a indice incremento normale
            EXECUTE IMMEDIATE 'ALTER SEQUENCE ' || PseqName || ' MINVALUE 0 INCREMENT BY 1';
        END IF;        

    --EXCEPTION
    --    WHEN OTHERS THEN
    --        msgErr := SQLERRM; --> da gestire...
            
    END resetThisSequence;                                                                  

END PACK_MANAGE_SEQUENCE;

/
--------------------------------------------------------
--  DDL for Package Body PACK_PRATICA_AZIENDA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PACK_PRATICA_AZIENDA" IS

    FUNCTION SelectTAziendaByCuaa (pCuaa IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE) RETURN DB_ANAGRAFICA_AZIENDA%ROWTYPE IS
        recTAnagrAzienda DB_ANAGRAFICA_AZIENDA%ROWTYPE;
    BEGIN
        SELECT *
          INTO recTAnagrAzienda
          FROM DB_ANAGRAFICA_AZIENDA
         WHERE CUAA = pCuaa
           AND DATA_FINE_VALIDITA IS NULL
           AND DATA_CESSAZIONE IS NULL;

        RETURN recTAnagrAzienda;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             recTAnagrAzienda.ID_ANAGRAFICA_AZIENDA :=0;
             recTAnagrAzienda.CUAA := pCuaa;
             RETURN recTAnagrAzienda;
        WHEN TOO_MANY_ROWS THEN
             recTAnagrAzienda.ID_ANAGRAFICA_AZIENDA :=-1;
             recTAnagrAzienda.CUAA := pCuaa;
             RETURN recTAnagrAzienda;
    END SelectTAziendaByCuaa;

PROCEDURE AGGIORNA_PRATICA_AZIENDA( P_ID_AZIENDA IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                    P_MSGERR        IN OUT VARCHAR2,
                                    P_CODERR     IN OUT VARCHAR2) IS

/*
  CURSOR ABIO IS SELECT CA.DESCRIZIONE AS CATEGORIA, CP.DESCRIZIONE AS CLASSE,
  SA.DESCRIZIONE AS STATO, OB.DATA_AGGIORNAMENTO
  FROM DB_OPERATORE_BIOLOGICO OB, DB_TIPO_CATEGORIA_ATTIVITA CA, DB_TIPO_CLASSE_PRODUTTORE CP, DB_STATO_ATTIVITA SA
  WHERE OB.ID_AZIENDA= P_ID_AZIENDA AND OB.DATA_FINE IS NULL AND OB.ID_STATO_ATTIVITA=SA.ID_STATO_ATTIVITA
  AND OB.ID_CATEGORIA_ATTIVITA=CA.ID_CATEGORIA_ATTIVITA AND OB.ID_CLASSE_PRODUTTORE=CP.ID_CLASSE_PRODUTTORE;
*/

BEGIN

     DELETE FROM DB_PROCEDIMENTO_AZIENDA WHERE ID_AZIENDA = P_ID_AZIENDA;

     BEGIN
         SMRUMA.INSERISCI_PRATICHE_SU_SMRGAA(P_ID_AZIENDA);
     EXCEPTION
         WHEN OTHERS THEN
             P_MSGERR := 'ERRORE IN UMA.INSERISCI_PRATICHE_AZIENDA (ID_AZIENDA:'||TO_CHAR(p_id_azienda)||') '||SQLERRM;
             P_CODERR:= SQLCODE;
     END;

     BEGIN
         GNPS.INSERISCI_PRATICHE_SU_SMRGAA(P_ID_AZIENDA);
     EXCEPTION
         WHEN OTHERS THEN
             P_MSGERR := 'ERRORE IN GNPS.INSERISCI_PRATICHE_AZIENDA (ID_AZIENDA:'||TO_CHAR(p_id_azienda)||') '||SQLERRM;
             P_CODERR:= SQLCODE;
     END;

     /*BEGIN
         PSR.INSERISCI_PRATICHE_SU_SMRGAA(P_ID_AZIENDA);
     EXCEPTION
         WHEN OTHERS THEN
             P_MSGERR := 'ERRORE IN PSR.INSERISCI_PRATICHE_AZIENDA (ID_AZIENDA:'||TO_CHAR(p_id_azienda)||') '||SQLERRM;
             P_CODERR:= SQLCODE;
     END;*/

     BEGIN
         RPU.INSERISCI_PRATICHE_SU_SMRGAA(P_ID_AZIENDA);
     EXCEPTION
         WHEN OTHERS THEN
             P_MSGERR := 'ERRORE IN RPU.INSERISCI_PRATICHE_AZIENDA (ID_AZIENDA:'||TO_CHAR(p_id_azienda)||') '||SQLERRM;
             P_CODERR:= SQLCODE;
     END;

     BEGIN
         AVIV.INSERISCI_PRATICHE_SU_SMRGAA(P_ID_AZIENDA);
     EXCEPTION
         WHEN OTHERS THEN
             P_MSGERR := 'ERRORE IN AVIV.INSERISCI_PRATICHE_AZIENDA (ID_AZIENDA:'||TO_CHAR(p_id_azienda)||') '||SQLERRM;
             P_CODERR:= SQLCODE;
     END;

     BEGIN
         ABIO.INSERISCI_PRATICHE_SU_SMRGAA(P_ID_AZIENDA);
     EXCEPTION
         WHEN OTHERS THEN
             P_MSGERR := 'ERRORE IN ABIO.INSERISCI_PRATICHE_AZIENDA (ID_AZIENDA:'||TO_CHAR(p_id_azienda)||') '||SQLERRM;
             P_CODERR:= SQLCODE;
     END;

     BEGIN
         ATRV.INSERISCI_PRATICHE_SU_SMRGAA(P_ID_AZIENDA);
     EXCEPTION
         WHEN OTHERS THEN
             P_MSGERR := 'ERRORE IN ATRV.INSERISCI_PRATICHE_AZIENDA (ID_AZIENDA:'||TO_CHAR(p_id_azienda)||') '||SQLERRM;
             P_CODERR:= SQLCODE;
     END;

     BEGIN
         VIT.INSERISCI_PRATICHE_SU_SMRGAA(P_ID_AZIENDA);
     EXCEPTION
         WHEN OTHERS THEN
             P_MSGERR := 'ERRORE IN VIT.INSERISCI_PRATICHE_AZIENDA (ID_AZIENDA:'||TO_CHAR(p_id_azienda)||') '||SQLERRM;
             P_CODERR:= SQLCODE;
     END;

     -- comunicazioni 10R
     INSERT INTO DB_PROCEDIMENTO_AZIENDA
        (
        ID_PROCEDIMENTO_AZIENDA,
        ID_AZIENDA,
        ID_PROCEDIMENTO,
        NUMERO_PRATICA,
        DESCRIZIONE,
        STATO,
        DESCRIZIONE_STATO,
        NOTE,
        DATA_VALIDITA_STATO,
        ID_DICHIARAZIONE_CONSISTENZA,
        FLAG_CESSAZIONE_AZ_AMMESSA,
        ANNO_CAMPAGNA,
        EXT_ID_AMM_COMPETENZA
        )
    SELECT SEQ_PROCEDIMENTO_AZIENDA.nextval,
           DC.ID_AZIENDA,
           knIdProcComu10R,
           DC.NUMERO_PROTOCOLLO,
           'Comunicazione 10/R',
           'C',
           'Trasmessa a PA',
           NULL,
           DC.DATA_PROTOCOLLO,
           DC.ID_DICHIARAZIONE_CONSISTENZA,
           'S',
           TO_CHAR(DC.DATA,'YYYY'),
           NULL
      FROM DB_DICHIARAZIONE_CONSISTENZA DC,
           DB_TIPO_MOTIVO_DICHIARAZIONE TM
     WHERE TM.TIPO_DICHIARAZIONE = 'R'
       AND TM.ID_MOTIVO_DICHIARAZIONE = DC.ID_MOTIVO_DICHIARAZIONE
       AND DC.NUMERO_PROTOCOLLO IS NOT NULL
       AND DC.ID_AZIENDA = P_ID_AZIENDA;

     -- istanza di riesame di fotointerpretazione
     INSERT INTO DB_PROCEDIMENTO_AZIENDA
        (
        ID_PROCEDIMENTO_AZIENDA,
        ID_AZIENDA,
        ID_PROCEDIMENTO,
        NUMERO_PRATICA,
        DESCRIZIONE,
        STATO,
        DESCRIZIONE_STATO,
        NOTE,
        DATA_VALIDITA_STATO,
        ID_DICHIARAZIONE_CONSISTENZA,
        FLAG_CESSAZIONE_AZ_AMMESSA,
        ANNO_CAMPAGNA,
        EXT_ID_AMM_COMPETENZA
        )
    WITH ISTANZA AS (
    SELECT IR.PROTOCOLLO_ISTANZA,
           IR.ID_AZIENDA,
           IR.ANNO,
           IR.ID_FASE_ISTANZA_RIESAME,
           FIR.DESCRIZIONE,
           MAX(IR.DATA_AGGIORNAMENTO) AS DATA_AGGIORNAMENTO
      FROM DB_ISTANZA_RIESAME IR,
           DB_FASE_ISTANZA_RIESAME FIR
     WHERE IR.ID_AZIENDA = P_ID_AZIENDA
       AND IR.ID_FASE_ISTANZA_RIESAME = FIR.ID_FASE_ISTANZA_RIESAME
       AND IR.ID_FASE_ISTANZA_RIESAME = knIdFaseIstanzaRieFoto
  GROUP BY IR.PROTOCOLLO_ISTANZA,
           IR.ID_AZIENDA,
           IR.ANNO,
           IR.ID_FASE_ISTANZA_RIESAME,
           FIR.DESCRIZIONE) ,
    ISTANZA_BIS AS
       (
       SELECT I.ID_AZIENDA,
              I.PROTOCOLLO_ISTANZA,
              I.DESCRIZIONE,
              I.ANNO,
              (SELECT COUNT(ID_ISTANZA_RIESAME) || ',' || COUNT(DECODE(DATA_EVASIONE,NULL,NULL,1)) || ',' || COUNT(DECODE(DATA_ANNULLAMENTO,NULL,NULL,1))
                 FROM DB_ISTANZA_RIESAME
               WHERE ID_FASE_ISTANZA_RIESAME = I.ID_FASE_ISTANZA_RIESAME
                  AND ANNO = I.ANNO
                  AND PROTOCOLLO_ISTANZA = I.PROTOCOLLO_ISTANZA) AS NUMERI,
               I.DATA_AGGIORNAMENTO
         FROM ISTANZA I ),
    ISTANZA_TRIS AS   (
    SELECT ib.*,
           SUBSTR(NUMERI,1,INSTR(NUMERI,',') -1) AS ISTANZE,
           SUBSTR(NUMERI, INSTR(NUMERI,',') + 1, INSTR(NUMERI,',',INSTR(NUMERI,',') + 1)- (INSTR(NUMERI,',') + 1)) AS ISTANZE_EVASE,
           SUBSTR(NUMERI, INSTR(NUMERI,',',INSTR(NUMERI,',') +1) +1, LENGTH(NUMERI) - INSTR(NUMERI,',',INSTR(NUMERI,',') +1)) AS ISTANZE_ANNULLATE
      FROM ISTANZA_BIS IB),
      ISTANZA_FINALE AS (
    SELECT CASE WHEN ISTANZE = ISTANZE_ANNULLATE THEN
           'A'
           WHEN ISTANZE = ISTANZE_EVASE + ISTANZE_ANNULLATE THEN
           'C'
           ELSE
           'I'
           END AS STATO,
           IT.*
      FROM ISTANZA_TRIS IT)
      SELECT SEQ_PROCEDIMENTO_AZIENDA.nextval,
             ID_AZIENDA,
             knIdProcIstanzaRiesame,
             PROTOCOLLO_ISTANZA,
             'Istanza Riesame - ' || DESCRIZIONE,
             STATO,
             DECODE(STATO,'I','In Corso','C', 'Evasa', 'A', 'Annullata'),
             NULL,
             DATA_AGGIORNAMENTO,
             NULL,
             'S',
             ANNO,
             NULL
        FROM ISTANZA_FINALE;

     -- ISTANZA di riesame contradditorio , sopraluogo totalmente annullata
     INSERT INTO DB_PROCEDIMENTO_AZIENDA
        (
        ID_PROCEDIMENTO_AZIENDA,
        ID_AZIENDA,
        ID_PROCEDIMENTO,
        NUMERO_PRATICA,
        DESCRIZIONE,
        STATO,
        DESCRIZIONE_STATO,
        NOTE,
        DATA_VALIDITA_STATO,
        ID_DICHIARAZIONE_CONSISTENZA,
        FLAG_CESSAZIONE_AZ_AMMESSA,
        ANNO_CAMPAGNA,
        EXT_ID_AMM_COMPETENZA
        )
        WITH ISTANZA_ANNULLATA AS (
        SELECT IR.PROTOCOLLO_ISTANZA,
               IR.ID_AZIENDA,
               IR.ANNO,
               IR.ID_FASE_ISTANZA_RIESAME,
               FIR.DESCRIZIONE,
               MAX(IR.DATA_AGGIORNAMENTO) AS DATA_AGGIORNAMENTO
          FROM DB_ISTANZA_RIESAME IR,
               DB_FASE_ISTANZA_RIESAME FIR
         WHERE IR.ID_AZIENDA = P_ID_AZIENDA
           AND IR.ID_FASE_ISTANZA_RIESAME = FIR.ID_FASE_ISTANZA_RIESAME
           AND IR.ID_FASE_ISTANZA_RIESAME IN (knIdFaseIstanzaRieControllo,knIdFaseIstanzaRieSopralluogo)
           AND NOT EXISTS (SELECT ID_ISTANZA_RIESAME
                             FROM DB_ISTANZA_RIESAME
                            WHERE ID_FASE_ISTANZA_RIESAME = IR.ID_FASE_ISTANZA_RIESAME
                              AND PROTOCOLLO_ISTANZA = IR.PROTOCOLLO_ISTANZA
                              AND DATA_ANNULLAMENTO IS NULL)
      GROUP BY IR.PROTOCOLLO_ISTANZA,
               IR.ID_AZIENDA,
               IR.ANNO,
               IR.ID_FASE_ISTANZA_RIESAME,
               FIR.DESCRIZIONE)
        SELECT SEQ_PROCEDIMENTO_AZIENDA.nextval,
               ID_AZIENDA,
               knIdProcIstanzaRiesame,
               PROTOCOLLO_ISTANZA,
               'Istanza Riesame - ' || DESCRIZIONE,
               'A',
               'Annullata',
               NULL,
               DATA_AGGIORNAMENTO,
               NULL,
               'S',
               ANNO,
               NULL
          FROM ISTANZA_ANNULLATA;

    -- ISTANZA di riesame contradditorio , sopraluogo non totalmente annullata
     INSERT INTO DB_PROCEDIMENTO_AZIENDA
        (
        ID_PROCEDIMENTO_AZIENDA,
        ID_AZIENDA,
        ID_PROCEDIMENTO,
        NUMERO_PRATICA,
        DESCRIZIONE,
        STATO,
        DESCRIZIONE_STATO,
        NOTE,
        DATA_VALIDITA_STATO,
        ID_DICHIARAZIONE_CONSISTENZA,
        FLAG_CESSAZIONE_AZ_AMMESSA,
        ANNO_CAMPAGNA,
        EXT_ID_AMM_COMPETENZA
        )
    WITH ISTANZA AS (
        SELECT IR.PROTOCOLLO_ISTANZA,
               IR.ID_AZIENDA,
               IR.ANNO,
               IR.ID_FASE_ISTANZA_RIESAME,
               FIR.DESCRIZIONE,
               IR.ID_STATO_SITICONVOCA,
               MAX(IR.DATA_AGGIORNAMENTO) AS DATA_AGGIORNAMENTO
          FROM DB_ISTANZA_RIESAME IR,
               DB_FASE_ISTANZA_RIESAME FIR
         WHERE IR.ID_AZIENDA = P_ID_AZIENDA
           AND IR.ID_FASE_ISTANZA_RIESAME = FIR.ID_FASE_ISTANZA_RIESAME
           AND IR.ID_FASE_ISTANZA_RIESAME IN (knIdFaseIstanzaRieControllo,knIdFaseIstanzaRieSopralluogo)
           AND IR.DATA_ANNULLAMENTO IS NULL
      GROUP BY IR.PROTOCOLLO_ISTANZA,
               IR.ID_AZIENDA,
               IR.ANNO,
               IR.ID_FASE_ISTANZA_RIESAME,
               IR.ID_STATO_SITICONVOCA,
               FIR.DESCRIZIONE)
        SELECT SEQ_PROCEDIMENTO_AZIENDA.nextval,
               ID_AZIENDA,
               knIdProcIstanzaRiesame,
               PROTOCOLLO_ISTANZA,
               'Istanza Riesame - ' || IB.DESCRIZIONE,
               SS.CODICE_STATO_PRATICA_ANAGRAFE,
               DECODE(SS.CODICE_STATO_PRATICA_ANAGRAFE,'C', 'Evasa','I','In corso','A','Annullata'),
               NULL,
               DATA_AGGIORNAMENTO,
               NULL,
               'S',
               ANNO,
               NULL
          FROM ISTANZA IB,
               DB_STATO_SITICONVOCA SS
         WHERE IB.ID_STATO_SITICONVOCA = SS.ID_STATO_SITICONVOCA;

/*
     -- biologico
     BEGIN
     FOR REC_BIO IN ABIO LOOP
         INSERT INTO DB_PROCEDIMENTO_AZIENDA ( ID_PROCEDIMENTO_AZIENDA, ID_AZIENDA, ID_PROCEDIMENTO,
         NUMERO_PRATICA, DESCRIZIONE, STATO, DESCRIZIONE_STATO, NOTE, DATA_VALIDITA_STATO,
         ID_DICHIARAZIONE_CONSISTENZA, FLAG_CESSAZIONE_AZ_AMMESSA )
         VALUES ( seq_procedimento_azienda.NEXTVAL, p_id_azienda, 6, NULL,
         'Operatore biologico: '||REC_BIO.CATEGORIA ||' '|| REC_BIO.CLASSE, 'I', REC_BIO.STATO, NULL,  REC_BIO.DATA_AGGIORNAMENTO, NULL, 'S');
        END LOOP;
     EXCEPTION
         WHEN OTHERS THEN
             P_MSGERR := 'ERRORE IN BIOLOGICO '||SQLERRM;
             P_CODERR:= SQLCODE;
     END;
*/

-- BM001
        UPDATE DB_AZIENDA
        SET DATA_AGGIORNAMENTO_PRATICA = SYSDATE
        WHERE ID_AZIENDA = P_ID_AZIENDA;

END AGGIORNA_PRATICA_AZIENDA;


/**Controllare P_ESITO:
Se P_ESITO='S' à l'azienda può essere cessata
Se P_ESITO='W'à visualizzare a video p_msg e chiedere all'utente se vuole proseguire
Se p_ESITO='B' à non è possibile proseguire non la cessazione dell'azienda. Visualizzare il seguente messaggio: "Non è possibile cessare l'azienda: "+p_msg
*/
PROCEDURE CESSAZIONE_AMMESSA( P_ID_AZIENDA     IN        DB_AZIENDA.ID_AZIENDA%TYPE,
                                 P_ESITO        OUT        VARCHAR2,
                                 P_MSG          OUT     VARCHAR2,
                                 P_CODERR       OUT    VARCHAR2) IS
N_NUM_PRATICHE NUMBER :=0;
CURSOR C_PRATICHE_bloccanti IS
    SELECT *
    FROM DB_PROCEDIMENTO_AZIENDA
         WHERE ID_AZIENDA= P_ID_AZIENDA
         --AND STATO ='I'
         AND FLAG_CESSAZIONE_az_AMMESSA='N';


CURSOR C_PRATICHE_non_bloccanti IS
    SELECT *
    FROM DB_PROCEDIMENTO_AZIENDA
         WHERE ID_AZIENDA= P_ID_AZIENDA
          AND (STATO ='I'OR STATO='B')
          AND  (FLAG_CESSAZIONE_az_AMMESSA IS NULL OR FLAG_CESSAZIONE_az_AMMESSA<>'N');

BEGIN
     p_esito:='S';
     AGGIORNA_PRATICA_AZIENDA( P_ID_AZIENDA ,
                                    P_MSG,
                                    P_CODERR);
     IF P_MSG IS NOT NULL THEN
         RETURN;
     END IF;

     N_NUM_PRATICHE := 0 ;
     FOR rec_bloccanti IN C_PRATICHE_bloccanti
     LOOP
        P_ESITO :='B';

        IF N_NUM_PRATICHE = 0 THEN

            P_MSG   :='Sono presenti pratiche attive: ';
        END IF;

        P_MSG   :=P_MSG || '<br />'
                ||rec_bloccanti.descrizione || ' - '||rec_bloccanti.numero_pratica || ' - '|| rec_bloccanti.descrizione_stato ;
        N_NUM_PRATICHE := N_NUM_PRATICHE +1;
     END LOOP;

     IF N_NUM_PRATICHE = 0 THEN
         FOR rec_non_bloccanti IN C_PRATICHE_non_bloccanti
         LOOP
             P_ESITO    :='W';
            IF N_NUM_PRATICHE = 0 THEN
                P_MSG   :='Sono presenti pratiche attive: ';
            END IF;

            P_MSG   :=P_MSG || '<br />'
                    ||rec_non_bloccanti.descrizione || ' - '|| rec_non_bloccanti.numero_pratica|| ' - '|| rec_non_bloccanti.descrizione_stato;

          N_NUM_PRATICHE := N_NUM_PRATICHE +1;
         END LOOP;
     END IF;

     P_MSG   :=P_MSG || '   ';

EXCEPTION
         WHEN OTHERS THEN
             P_MSG := 'ERRORE IN CESSAZIONE_AMMESSA: '||SQLERRM;
             P_CODERR:= SQLCODE;
END CESSAZIONE_AMMESSA;

    /*********************************************************************
    Invia su DBMS_OUTPUT il messaggio di testo dato in input con in testa l'ora
    Tipo:   procedure
    input: LogMessage
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE LogMessage(pMessage VARCHAR2 ) IS
        buffer_overflow EXCEPTION;
        PRAGMA EXCEPTION_INIT(buffer_overflow, -20000);
    BEGIN

        DBMS_OUTPUT.PUT_LINE( TO_CHAR(SYSDATE,'HH24:MI:SS') || ' - ' || SUBSTR(pMessage,1,200) );

    EXCEPTION
        WHEN buffer_overflow THEN
             DBMS_OUTPUT.DISABLE;
             DBMS_OUTPUT.ENABLE(1000000); -- resetto il buffer
             DBMS_OUTPUT.PUT_LINE( TO_CHAR(SYSDATE,'HH24:MI:SS') || ' - ' || SUBSTR(pMessage,1,200) );
    END LogMessage;

    /*********************************************************************
    Dato un ID_AZIENDA, un esito ed un messaggio di errore effettua
    l'update per l'azienda su SMRGAA_W_AZIENDA_SCARICO_XML
    Tipo:   procedure
    input: pIdAzienda, pOkKo, pMsg
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE EvadiAziendaScarico (pIdAzienda   IN SMRGAA_W_AZIENDA_SCARICO_XML.ID_AZIENDA%TYPE,
                                   pOkKo        IN INTEGER,
                                   pMsg         IN VARCHAR2) IS
    BEGIN
        UPDATE SMRGAA_W_AZIENDA_SCARICO_XML
           SET ESITO = pOkKo,
               MESSAGGIO_ERRORE = pMsg
         WHERE ID_AZIENDA = pIdAzienda;

    END EvadiAziendaScarico;

    /*********************************************************************
    Effettua il popolamento della tabella SMRGAA_W_AZIENDA_SCARICO_XML
    ed il richiamo della procedure AGGIORNA_PRATICA_AZIENDA per ogni
    azienda presente sulla tabella
    Tipo:   procedure
    input: pIdParScFile, pTreChrCf, pAggPrat, pDataDa, pDataA
    output: pCodErr, pMsgErr
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE PopolaAziendePerScaricoXml (pIdParScFile  IN DB_PARAMETRO_SCARICO_FILE.ID_PARAMETRO_SCARICO_FILE%TYPE,
                                          pTreChrCf     IN VARCHAR2,
                                          pAggPrat      IN VARCHAR2,
                                          pDataDa       IN VARCHAR2,
                                          pDataA        IN VARCHAR2,
                                          pCodErr      OUT VARCHAR2,
                                          pMsgErr      OUT VARCHAR2
                                          ) IS

        CURSOR curAziendaDaElab IS
        SELECT DISTINCT ID_AZIENDA
          FROM SMRGAA_W_AZIENDA_SCARICO_XML
         WHERE ESITO IS NULL OR ESITO <> 0;

        dDataDa DATE;
        dDataA  DATE;

        NODATADA            EXCEPTION;
        WRONGDATADA         EXCEPTION;
        NODATAA             EXCEPTION;
        WRONGDATAA          EXCEPTION;
        nIdAziendaKo        SMRGAA_W_AZIENDA_SCARICO_XML.ID_AZIENDA%TYPE;
        nRichCosman         INTEGER:=0;

    BEGIN
        LogMessage ('PopolaAziendePerScaricoXml - Inizio Elaborazione');
        -- controllo se la data dalla quale considerare le dichiarazioni
        -- di consistenza è stata specificata
        IF pDataDa IS NULL THEN
           -- se non lo è do apposita anomalia
           RAISE NODATADA;
        ELSE
            -- se è stata specificata controllo che sia in formato corretto
            BEGIN
                dDataDa := TO_DATE(pDataDa, 'YYYY/MM/DD');
            EXCEPTION
                WHEN OTHERS THEN
                     -- se no do apposita anomalia
                     RAISE WRONGDATADA;
            END;
        END IF;

        -- controllo se la data fino alla quale considerare le dichiarazioni
        -- di consistenza è stata specificata
        IF pDataA IS NULL THEN
           -- se non lo è do apposita anomalia
           RAISE NODATAA;
        ELSE
            -- se è stata specificata controllo che sia in formato corretto
            BEGIN
                dDataA := TO_DATE(pDataA, 'YYYY/MM/DD');
            EXCEPTION
                WHEN OTHERS THEN
                     -- se no do apposita anomalia
                     RAISE WRONGDATAA;
            END;
        END IF;
        -- cancello i record elaborati precedentemente ed andati bene
        DELETE
          FROM SMRGAA_W_AZIENDA_SCARICO_XML
         WHERE ESITO = 0;

        -- effettuo il popolamento sulla tabella di appoggio
        -- delle aziende per le quali effettuare lo scarico XML
        -- e di conseguenza effettuare il richiamo alla procedure AGGIORNA_PRATICA_AZIENDA
        IF pTreChrCf IS NOT NULL THEN
            INSERT INTO SMRGAA_W_AZIENDA_SCARICO_XML
                (ID_DICHIARAZIONE_CONSISTENZA,ID_AZIENDA,ESITO)
            SELECT DC.ID_DICHIARAZIONE_CONSISTENZA, DC.ID_AZIENDA, DECODE(pAggPrat,'S',NULL,0)
              FROM DB_INTERMEDIARIO DI,
                   DB_DELEGA DDE,
                   DB_DICHIARAZIONE_CONSISTENZA DC
             WHERE SUBSTR(DI.CODICE_FISCALE,1,3) = pTreChrCf
               AND DI.ID_INTERMEDIARIO = DDE.ID_INTERMEDIARIO
               AND DDE.DATA_FINE IS NULL
               AND DDE.ID_PROCEDIMENTO = knIdProcSmrgaa
               AND DC.ID_AZIENDA = DDE.ID_AZIENDA
               AND DC.DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DC2.DATA_INSERIMENTO_DICHIARAZIONE)
                                                          FROM DB_DICHIARAZIONE_CONSISTENZA DC2,
                                                               DB_TIPO_MOTIVO_DICHIARAZIONE TMD
                                                         WHERE DC2.ID_AZIENDA = DC.ID_AZIENDA
                                                           AND DC2.ID_MOTIVO_DICHIARAZIONE = TMD.ID_MOTIVO_DICHIARAZIONE
                                                           AND TRUNC(DC2.DATA_INSERIMENTO_DICHIARAZIONE) >= TRUNC(dDataDa)
                                                           AND TRUNC(DC2.DATA_INSERIMENTO_DICHIARAZIONE) < TRUNC(dDataA)
                                                           AND DC2.NUMERO_PROTOCOLLO IS NOT NULL
                                                           AND TMD.TIPO_DICHIARAZIONE <> kvTipoDichCorrettiva
                                                           AND DC2.ID_MOTIVO_DICHIARAZIONE NOT IN
                                                               (SELECT MEP.ID_MOTIVO_DICHIARAZIONE
                                                                  FROM DB_MOTIVO_ESCLUSO_PROCEDIMENTO MEP
                                                                 WHERE MEP.ID_PROCEDIMENTO = knIdProcSmrgaa)) 
               AND ((TRUNC(DC.DATA_INSERIMENTO_DICHIARAZIONE) >= TRUNC(dDataDa) AND
                     TRUNC(DC.DATA_INSERIMENTO_DICHIARAZIONE) < TRUNC(dDataA)) OR
                    (TRUNC(DC.DATA_PROTOCOLLO) >= TRUNC(dDataDa) AND
                     TRUNC(DC.DATA_PROTOCOLLO) < TRUNC(dDataA))) 
               AND DC.NUMERO_PROTOCOLLO IS NOT NULL
               AND NOT EXISTS (SELECT ASX.ID_AZIENDA
                                 FROM SMRGAA_W_AZIENDA_SCARICO_XML ASX
                                WHERE ASX.ID_DICHIARAZIONE_CONSISTENZA = DC.ID_DICHIARAZIONE_CONSISTENZA);

               LogMessage ('Intermediario : ' || pTreChrCf || ' Accodate su SMRGAA_W_AZIENDA_SCARICO_XML : ' || TO_CHAR(SQL%ROWCOUNT) || ' records');

        END IF;

        -- se l'ID_PARAMETRO_SCARICO_FILE è passato in input
        -- vuol dire che devo lavorare anche su SOGGETTI specificati
        -- nella richiesta e presenti su DB_SOGGETTO_SCARICO_FILE
        IF pIdParScFile IS NOT NULL THEN
            -- controllo se la richiesta di scarico
            -- e' per cosman
            SELECT COUNT(ID_PARAMETRO_SCARICO_FILE)
              INTO nRichCosman
              FROM DB_PARAMETRO_SCARICO_FILE
             WHERE ID_PARAMETRO_SCARICO_FILE = pIdParScFile
               AND PATHNAME LIKE '%cosman%';


            INSERT INTO SMRGAA_W_AZIENDA_SCARICO_XML
                    (ID_DICHIARAZIONE_CONSISTENZA,ID_AZIENDA, ESITO)
            SELECT DC.ID_DICHIARAZIONE_CONSISTENZA, DC.ID_AZIENDA, DECODE(pAggPrat,'S',NULL,0)
              FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                   DB_SOGGETTO_SCARICO_FILE SCF,
                   DB_ANAGRAFICA_AZIENDA AZ
             WHERE SCF.ID_PARAMETRO_SCARICO_FILE = pIdParScFile
               AND AZ.CUAA = SCF.CUAA
               AND AZ.DATA_FINE_VALIDITA IS NULL
               AND AZ.DATA_CESSAZIONE IS NULL
               AND DC.ID_AZIENDA = AZ.ID_AZIENDA
               AND DC.DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DC2.DATA_INSERIMENTO_DICHIARAZIONE)
                                                          FROM DB_DICHIARAZIONE_CONSISTENZA DC2,
                                                               DB_TIPO_MOTIVO_DICHIARAZIONE TMD
                                                         WHERE DC2.ID_AZIENDA = DC.ID_AZIENDA
                                                           AND DC2.ID_MOTIVO_DICHIARAZIONE = TMD.ID_MOTIVO_DICHIARAZIONE
                                                           AND TRUNC(DC2.DATA_INSERIMENTO_DICHIARAZIONE) >= TRUNC(dDataDa)
                                                           AND TRUNC(DC2.DATA_INSERIMENTO_DICHIARAZIONE) < TRUNC(dDataA)
                                                           AND DC2.NUMERO_PROTOCOLLO IS NOT NULL
                                                           AND TMD.TIPO_DICHIARAZIONE <> kvTipoDichCorrettiva
                                                           AND DC2.ID_MOTIVO_DICHIARAZIONE NOT IN
                                                               (SELECT MEP.ID_MOTIVO_DICHIARAZIONE
                                                                  FROM DB_MOTIVO_ESCLUSO_PROCEDIMENTO MEP
                                                                 WHERE MEP.ID_PROCEDIMENTO = knIdProcSmrgaa)) 
               AND ((TRUNC(DC.DATA_INSERIMENTO_DICHIARAZIONE) >= TRUNC(dDataDa) AND
                     TRUNC(DC.DATA_INSERIMENTO_DICHIARAZIONE) < TRUNC(dDataA)) OR
                    (TRUNC(DC.DATA_PROTOCOLLO) >= TRUNC(dDataDa) AND
                     TRUNC(DC.DATA_PROTOCOLLO) < TRUNC(dDataA))) 
                AND DC.NUMERO_PROTOCOLLO IS NOT NULL
                AND NOT EXISTS (SELECT ASX.ID_AZIENDA
                                  FROM SMRGAA_W_AZIENDA_SCARICO_XML ASX
                                 WHERE ASX.ID_DICHIARAZIONE_CONSISTENZA = DC.ID_DICHIARAZIONE_CONSISTENZA);

            LogMessage ('Caricati su SMRGAA_W_AZIENDA_SCARICO_XML : ' || TO_CHAR(SQL%ROWCOUNT) || ' records di CUAA presenti su DB_SOGGETTO_SCARICO_FILE');

            -- se la richiesta e' per cosman la select
            -- cambia leggermente
            IF nRichCosman > 0 THEN
                -- notare l'eleganza della NVL
                -- se c'è una dichiarazione di tipo cosman vince lei
                -- altrimenti vince l'ultima non correttiva e non
                -- da escludersi per il procedimento SMRGAA
                INSERT INTO SMRGAA_W_AZIENDA_SCARICO_XML
                        (ID_DICHIARAZIONE_CONSISTENZA,ID_AZIENDA,ESITO)
                SELECT DC.ID_DICHIARAZIONE_CONSISTENZA, DC.ID_AZIENDA, DECODE(pAggPrat,'S',NULL,0)
                  FROM DB_AZIENDA_COLLEGATA AC,
                       DB_SOGGETTO_SCARICO_FILE SCF,
                       DB_ANAGRAFICA_AZIENDA AZ,
                       DB_DICHIARAZIONE_CONSISTENZA DC
                 WHERE SCF.ID_PARAMETRO_SCARICO_FILE = pIdParScFile
                   AND AZ.CUAA = SCF.CUAA
                   AND AZ.DATA_FINE_VALIDITA IS NULL
                   AND AZ.DATA_CESSAZIONE IS NULL
                   AND AC.ID_AZIENDA = AZ.ID_AZIENDA
                   AND AC.ID_AZIENDA_ASSOCIATA IS NOT NULL
                   AND DC.ID_AZIENDA = AC.ID_AZIENDA_ASSOCIATA
                   AND DC.DATA_INSERIMENTO_DICHIARAZIONE = NVL((SELECT MAX(DC2.DATA_INSERIMENTO_DICHIARAZIONE) 
                                                                  FROM DB_DICHIARAZIONE_CONSISTENZA DC2
                                                                 WHERE DC2.ID_AZIENDA = DC.ID_AZIENDA
                                                                   AND DC2.NUMERO_PROTOCOLLO IS NOT NULL
                                                                   AND DC2.ID_MOTIVO_DICHIARAZIONE = knIdTipoMotDichCosman),
                                                               (SELECT MAX(DC2.DATA_INSERIMENTO_DICHIARAZIONE)
                                                                  FROM DB_DICHIARAZIONE_CONSISTENZA DC2,
                                                                       DB_TIPO_MOTIVO_DICHIARAZIONE TMD
                                                                 WHERE DC2.ID_AZIENDA = DC.ID_AZIENDA
                                                                   AND DC2.ID_MOTIVO_DICHIARAZIONE = TMD.ID_MOTIVO_DICHIARAZIONE
                                                                   AND DC2.NUMERO_PROTOCOLLO IS NOT NULL
                                                                   AND TMD.TIPO_DICHIARAZIONE <> kvTipoDichCorrettiva
                                                                   AND DC2.ID_MOTIVO_DICHIARAZIONE NOT IN
                                                                       (SELECT MEP.ID_MOTIVO_DICHIARAZIONE
                                                                          FROM DB_MOTIVO_ESCLUSO_PROCEDIMENTO MEP
                                                                         WHERE MEP.ID_PROCEDIMENTO = knIdProcSmrgaa))) 
                   AND DC.NUMERO_PROTOCOLLO IS NOT NULL
                   AND ((TRUNC(DC.DATA_INSERIMENTO_DICHIARAZIONE) >= TRUNC(dDataDa) AND 
                         TRUNC(DC.DATA_INSERIMENTO_DICHIARAZIONE) < TRUNC(dDataA)) OR   -- o dichiarazione azienda collegata inserita nel periodo
                        (TRUNC(DC.DATA_PROTOCOLLO) >= TRUNC(dDataDa) AND                -- o dichiarazione azienda collegata protocollata nel periodo
                         TRUNC(DC.DATA_PROTOCOLLO) < TRUNC(dDataA)) OR                  -- o associazione azienda / azienda socia nel periodo
                        (TRUNC(AC.DATA_INIZIO_VALIDITA) BETWEEN TRUNC(dDataDA) AND TRUNC(dDataA) AND
                     NVL(TRUNC(AC.DATA_FINE_VALIDITA),TRUNC(dDataA)) BETWEEN TRUNC(dDataDA) AND TRUNC(dDataA)))
                   AND NOT EXISTS (SELECT ASX.ID_AZIENDA
                                     FROM SMRGAA_W_AZIENDA_SCARICO_XML ASX
                                    WHERE ASX.ID_DICHIARAZIONE_CONSISTENZA = DC.ID_DICHIARAZIONE_CONSISTENZA)
              GROUP BY DC.ID_DICHIARAZIONE_CONSISTENZA, DC.ID_AZIENDA;            ELSE

                -- inoltre se questi soggetti presenti su DB_SOGGETTO_SCARICO_FILE
                -- sono delle aziende di tipo forma associata devo prendere anche gli
                -- eventuali soci attivi alla data dello scarico
                -- protocollata o fatta nel periodo
                INSERT INTO SMRGAA_W_AZIENDA_SCARICO_XML
                        (ID_DICHIARAZIONE_CONSISTENZA,ID_AZIENDA,ESITO)
                SELECT DC.ID_DICHIARAZIONE_CONSISTENZA, DC.ID_AZIENDA, DECODE(pAggPrat,'S',NULL,0)
                  FROM DB_AZIENDA_COLLEGATA AC,
                       DB_SOGGETTO_SCARICO_FILE SCF,
                       DB_ANAGRAFICA_AZIENDA AZ,
                       DB_DICHIARAZIONE_CONSISTENZA DC
                 WHERE SCF.ID_PARAMETRO_SCARICO_FILE = pIdParScFile
                   AND AZ.CUAA = SCF.CUAA
                   AND AZ.DATA_FINE_VALIDITA IS NULL
                   AND AZ.DATA_CESSAZIONE IS NULL
                   AND AC.ID_AZIENDA = AZ.ID_AZIENDA
                   AND AC.ID_AZIENDA_ASSOCIATA IS NOT NULL
                   AND DC.ID_AZIENDA = AC.ID_AZIENDA_ASSOCIATA
                   AND DC.DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DC2.DATA_INSERIMENTO_DICHIARAZIONE)
                                                              FROM DB_DICHIARAZIONE_CONSISTENZA DC2,
                                                                   DB_TIPO_MOTIVO_DICHIARAZIONE TMD
                                                             WHERE DC2.ID_AZIENDA = DC.ID_AZIENDA
                                                               AND DC2.ID_MOTIVO_DICHIARAZIONE = TMD.ID_MOTIVO_DICHIARAZIONE
                                                               AND DC2.NUMERO_PROTOCOLLO IS NOT NULL
                                                               AND TMD.TIPO_DICHIARAZIONE <> kvTipoDichCorrettiva
                                                               AND DC2.ID_MOTIVO_DICHIARAZIONE NOT IN
                                                                   (SELECT MEP.ID_MOTIVO_DICHIARAZIONE
                                                                      FROM DB_MOTIVO_ESCLUSO_PROCEDIMENTO MEP
                                                                     WHERE MEP.ID_PROCEDIMENTO = knIdProcSmrgaa)) 
                   AND DC.NUMERO_PROTOCOLLO IS NOT NULL
                   AND ((TRUNC(DC.DATA_INSERIMENTO_DICHIARAZIONE) >= TRUNC(dDataDa) AND
                         TRUNC(DC.DATA_INSERIMENTO_DICHIARAZIONE) < TRUNC(dDataA)) OR   -- o dichiarazione azienda collegata inserita nel periodo
                        (TRUNC(DC.DATA_PROTOCOLLO) >= TRUNC(dDataDa) AND                -- o dichiarazione azienda collegata protocollata nel periodo
                         TRUNC(DC.DATA_PROTOCOLLO) < TRUNC(dDataA)) OR                  -- o associazione azienda / azienda socia nel periodo
                        (TRUNC(AC.DATA_INIZIO_VALIDITA) BETWEEN TRUNC(dDataDA) AND TRUNC(dDataA) AND
                     NVL(TRUNC(AC.DATA_FINE_VALIDITA),TRUNC(dDataA)) BETWEEN TRUNC(dDataDA) AND TRUNC(dDataA)))
                   AND NOT EXISTS (SELECT ASX.ID_AZIENDA
                                     FROM SMRGAA_W_AZIENDA_SCARICO_XML ASX
                                    WHERE ASX.ID_DICHIARAZIONE_CONSISTENZA = DC.ID_DICHIARAZIONE_CONSISTENZA)
              GROUP BY DC.ID_DICHIARAZIONE_CONSISTENZA, DC.ID_AZIENDA;

                LogMessage ('Caricati su SMRGAA_W_AZIENDA_SCARICO_XML : ' || TO_CHAR(SQL%ROWCOUNT) || ' records di aziende associate con CUAA presenti su DB_SOGGETTO_SCARICO_FILE');
            END IF;
        END IF;

        COMMIT;

        IF pAggPrat = 'S' THEN
           -- scorro la tabella di appoggio
           FOR recAziendaDaElab IN curAziendaDaElab LOOP
               -- e per ogni azienda effettuo il richiamo alla procedure
               AGGIORNA_PRATICA_AZIENDA (recAziendaDaElab.ID_AZIENDA,
                                         pMsgErr,
                                         pCodErr);
               -- se il codice errore è not null
               IF pCodErr IS NOT NULL THEN
                  -- vuol dire che la procedure è andata in errore
                  -- aggiorno l'esito sulla tabella a Ko con l'apposito messaggio
                  EvadiAziendaScarico (recAziendaDaElab.ID_AZIENDA,
                                       1, -- Ko
                                       SUBSTR(pCodErr,1,2000));
                  -- e termino l'elaborazione
                  nIdAziendaKo := recAziendaDaElab.ID_AZIENDA;
                  EXIT;
               ELSE
                  -- altrimenti vuol dire che la procedure è andata bene
                  EvadiAziendaScarico (recAziendaDaElab.ID_AZIENDA,
                                       0, -- Ok
                                       NULL);
               END IF;

               COMMIT;

           END LOOP;
        END IF;

        COMMIT;
        -- se si è piantato su un azienda do apposito errore
        IF nIdAziendaKo IS NOT NULL THEN
            pCodErr := '006';
            pMsgErr := 'Azienda : ' || nIdAziendaKo || ' - ' || pMsgErr;
            LogMessage ('PopolaAziendePerScaricoXml - Fine Elaborazione - Ko : Azienda ' || nIdAziendaKo || ' - ' || SUBSTR(pMsgErr,1,200));
        ELSE
            -- altrimenti è tutto ok
            pCodErr := NULL;
            pMsgErr := NULL;
            LogMessage ('PopolaAziendePerScaricoXml - Fine Elaborazione - Ok');
        END IF;

    EXCEPTION
        WHEN NODATADA THEN
            pCodErr := '002';
            pMsgErr := 'Parametro data dalla quale considerare le dichiarazioni di consistenza non specificato !!';
            LogMessage ('PopolaAziendePerScaricoXml - Fine Elaborazione - Ko - ' || pMsgErr);
        WHEN WRONGDATADA THEN
            pCodErr := '003';
            pMsgErr := 'Parametro data dalla quale considerare le dichiarazioni di consistenza in formato errato (<> YYYY/MM/DD) !!';
            LogMessage ('PopolaAziendePerScaricoXml - Fine Elaborazione - Ko - ' || pMsgErr);
        WHEN NODATAA THEN
            pCodErr := '004';
            pMsgErr := 'Parametro data fino alla quale considerare le dichiarazioni di consistenza non specificato !!';
            LogMessage ('PopolaAziendePerScaricoXml - Fine Elaborazione - Ko - ' || pMsgErr);
        WHEN WRONGDATAA THEN
            pCodErr := '005';
            pMsgErr := 'Parametro data fino alla quale considerare le dichiarazioni di consistenza in formato errato (<> YYYY/MM/DD) !!';
            LogMessage ('PopolaAziendePerScaricoXml - Fine Elaborazione - Ko - ' || pMsgErr);
        WHEN OTHERS THEN
            pCodErr := SQLCODE;
            pMsgErr := 'PopolaAziendePerScaricoXml - ' || SUBSTR(SQLERRM,1,250);
            ROLLBACK;
            LogMessage ('PopolaAziendePerScaricoXml - Fine Elaborazione - Ko - ' || pMsgErr);
    END PopolaAziendePerScaricoXml;

END Pack_Pratica_Azienda;

/
--------------------------------------------------------
--  DDL for Package Body PACK_RIBALTAMENTO_CONSISTENZA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PACK_RIBALTAMENTO_CONSISTENZA" IS
EsciRountine       EXCEPTION;
--ERR_GEN              TMP_LOG.COD_ERRORE%TYPE               := '999999';
ERR_GEN              VARCHAR2(10)               := '999999';
N_ID_UTENTE_AGGIORNAMENTO DB_ANAGRAFICA_AZIENDA.ID_UTENTE_AGGIORNAMENTO%TYPE;
S_MSGERR    VARCHAR2(1000);
P_CODERR    VARCHAR2(1000);
N_ID_UTE_PROV              DB_UTE.ID_UTE%TYPE;
N_ID_COND_PARTICELLA_PROV DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
N_ID_AZIENDA_PROV         DB_AZIENDA.ID_AZIENDA%TYPE;
N_ID_FABBRICATO_PROV       DB_FABBRICATO.ID_FABBRICATO%TYPE;
N_ID_ALLEVAMENTO_PROV      DB_ALLEVAMENTO.ID_ALLEVAMENTO%TYPE;
N_ID_MANODOPERA_PROV      DB_MANODOPERA.ID_MANODOPERA%TYPE;
D_DATA_CESSAZIONE          DB_ANAGRAFICA_AZIENDA.DATA_CESSAZIONE%TYPE;
S_CUAA_PROV                  DB_ANAGRAFICA_AZIENDA.CUAA%TYPE;
S_DENOMINAZIONE_PROV      DB_ANAGRAFICA_AZIENDA.DENOMINAZIONE%TYPE;
N_ID_UTILIZZO_PARTICELLA_PROV  DB_UTILIZZO_PARTICELLA.ID_UTILIZZO_PARTICELLA%TYPE;
N_ID_UTILIZZO_PARTICELLA_NEW  DB_UTILIZZO_PARTICELLA.ID_UTILIZZO_PARTICELLA%TYPE;
N_ID_PARTICELLA                  DB_STORICO_PARTICELLA.ID_PARTICELLA%TYPE;

-- per le aziende ancora attive
N_ID_CONSISTENZA          DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE;
D_DATA_INSERIMENTO        DB_DICHIARAZIONE_CONSISTENZA.DATA_INSERIMENTO_DICHIARAZIONE%TYPE;
N_ID_COND_DICH_PROV          DB_CONDUZIONE_DICHIARATA.ID_CONDUZIONE_DICHIARATA%TYPE;
N_ID_UTIL_DICH_PROV          DB_UTILIZZO_DICHIARATO.ID_UTILIZZO_DICHIARATO%TYPE;

CURSOR C_UTE IS
       SELECT ID_UTE, ID_AZIENDA, DENOMINAZIONE, INDIRIZZO, COMUNE, CAP, ID_ZONA_ALTIMETRICA,
                 ID_ATTIVITA_ATECO, TELEFONO, FAX, NOTE, DATA_INIZIO_ATTIVITA, DATA_FINE_ATTIVITA,
              CAUSALE_CESSAZIONE, MOTIVO_MODIFICA, ID_ATTIVITA_OTE
       FROM DB_UTE
       WHERE ID_AZIENDA = N_ID_AZIENDA_PROV
--         AND DATA_FINE_ATTIVITA IS NULL;
       AND DATA_INIZIO_ATTIVITA <= D_DATA_INSERIMENTO
       AND NVL(DATA_FINE_ATTIVITA, D_DATA_CUTOFF) > D_DATA_INSERIMENTO;


CURSOR C_CONDUZIONE IS
       SELECT ID_CONDUZIONE_PARTICELLA, ID_PARTICELLA, ID_TITOLO_POSSESSO,
                 SUPERFICIE_CONDOTTA, FLAG_UTILIZZO_PARTE, DATA_INIZIO_CONDUZIONE,
              PERCENTUALE_POSSESSO 
       FROM DB_CONDUZIONE_PARTICELLA
       WHERE ID_UTE = N_ID_UTE_PROV
       AND TRUNC(DATA_FINE_CONDUZIONE) = TRUNC(D_DATA_CESSAZIONE);

/* per le az. attive */
CURSOR C_CONDUZIONE_AZ_ATTIVA IS
       SELECT B.ID_CONDUZIONE_DICHIARATA, B.ID_PARTICELLA, B.ID_TITOLO_POSSESSO,
                 B.SUPERFICIE_CONDOTTA, B.DATA_INIZIO_CONDUZIONE,
              B.PERCENTUALE_POSSESSO 
       FROM DB_DICHIARAZIONE_CONSISTENZA A, DB_CONDUZIONE_DICHIARATA B
       WHERE B.ID_UTE = N_ID_UTE_PROV
       AND A.CODICE_FOTOGRAFIA_TERRENI=B.CODICE_FOTOGRAFIA_TERRENI
       AND A.ID_DICHIARAZIONE_CONSISTENZA=N_ID_CONSISTENZA;

CURSOR C_UTILIZZO IS
       SELECT *
       FROM DB_UTILIZZO_PARTICELLA
       WHERE ID_CONDUZIONE_PARTICELLA = N_ID_COND_PARTICELLA_PROV;

/* per le az. attive */
CURSOR C_UTILIZZO_DICHIARATO IS
       SELECT *
       FROM DB_UTILIZZO_DICHIARATO
       WHERE ID_CONDUZIONE_DICHIARATA = N_ID_COND_DICH_PROV;

CURSOR C_UTILIZZO_CONSOCIATO IS
       SELECT /*ID_UTILIZZO_CONSOCIATO, ID_UTILIZZO_PARTICELLA,*/ ID_PIANTE_CONSOCIATE, NUMERO_PIANTE
       FROM DB_UTILIZZO_CONSOCIATO
       WHERE ID_UTILIZZO_PARTICELLA = N_ID_UTILIZZO_PARTICELLA_PROV;

/* per le az. attive */
CURSOR C_UTILIZZO_CONSOCIATO_DICH IS
       SELECT ID_PIANTE_CONSOCIATE, NUMERO_PIANTE
       FROM DB_UTILIZZO_CONSOCIATO_DICH
       WHERE ID_UTILIZZO_DICHIARATO = N_ID_UTIL_DICH_PROV;

CURSOR C_ALLEVAMENTO IS
       SELECT ID_ALLEVAMENTO, ID_UTE, ID_ASL, ISTAT_COMUNE, ID_SPECIE_ANIMALE,
                 CODICE_AZIENDA_ZOOTECNICA, DATA_INIZIO, DATA_FINE, NOTE, INDIRIZZO, CAP, TELEFONO
         FROM DB_ALLEVAMENTO
        WHERE ID_UTE = N_ID_UTE_PROV
--          AND DATA_FINE IS NULL;
        AND DATA_INIZIO <= D_DATA_INSERIMENTO
        AND NVL(DATA_FINE, D_DATA_CUTOFF) > D_DATA_INSERIMENTO;

CURSOR C_CATEGORIE_ALLEVAMENTO IS
       SELECT ID_CATEGORIE_ALLEVAMENTO, ID_CATEGORIA_ANIMALE, QUANTITA, QUANTITA_PROPRIETA 
         FROM DB_CATEGORIE_ALLEVAMENTO
        WHERE ID_ALLEVAMENTO = N_ID_ALLEVAMENTO_PROV;

CURSOR C_FABBRICATO IS
       SELECT ID_FABBRICATO, ID_TIPOLOGIA_FABBRICATO, ID_FORMA_FABBRICATO, DENOMINAZIONE,
                 SUPERFICIE, ANNO_COSTRUZIONE, DIMENSIONE, LUNGHEZZA, LARGHEZZA, ALTEZZA, UTM_X,
              UTM_Y, NOTE, ID_UTE, DATA_INIZIO_VALIDITA, DATA_FINE_VALIDITA, ID_COLTURA_SERRA, MESI_RISCALDAMENTO_SERRA,
              ORE_RISCALDAMENTO_SERRA
         FROM DB_FABBRICATO
        WHERE ID_UTE = N_ID_UTE_PROV
--          AND DATA_FINE_VALIDITA IS NULL;
        AND DATA_INIZIO_VALIDITA <= D_DATA_INSERIMENTO
        AND NVL(DATA_FINE_VALIDITA, D_DATA_CUTOFF) > D_DATA_INSERIMENTO;


CURSOR C_FABBRICATO_PARTICELLA IS
       SELECT ID_FABBRICATO_PARTICELLA, ID_FABBRICATO, ID_PARTICELLA, DATA_INIZIO_VALIDITA
         FROM DB_FABBRICATO_PARTICELLA
        WHERE ID_FABBRICATO = N_ID_FABBRICATO_PROV
--          AND DATA_FINE_VALIDITA IS NULL;
        AND DATA_INIZIO_VALIDITA <= D_DATA_INSERIMENTO
        AND NVL(DATA_FINE_VALIDITA, D_DATA_CUTOFF) > D_DATA_INSERIMENTO;

CURSOR C_MANODOPERA IS
       SELECT ID_MANODOPERA, ID_AZIENDA, CODICE_INPS, DATA_INIZIO_VALIDITA, ID_FORMA_CONDUZIONE
         FROM DB_MANODOPERA
        WHERE ID_AZIENDA = N_ID_AZIENDA_PROV
--          AND DATA_FINE_VALIDITA IS NULL;
        AND DATA_INIZIO_VALIDITA <= D_DATA_INSERIMENTO
        AND NVL(DATA_FINE_VALIDITA, D_DATA_CUTOFF) > D_DATA_INSERIMENTO;

CURSOR C_DETTAGLIO_ATTIVITA IS
       SELECT ID_ATTIVITA_COMPLEMENTARI, DESCRIZIONE
         FROM DB_DETTAGLIO_ATTIVITA
        WHERE ID_MANODOPERA = N_ID_MANODOPERA_PROV;

CURSOR C_DETTAGLIO_MANODOPERA IS
       SELECT ID_CLASSE_MANODOPERA, UOMINI, DONNE, GIORNATE_ANNUE
         FROM DB_DETTAGLIO_MANODOPERA
        WHERE ID_MANODOPERA = N_ID_MANODOPERA_PROV;

FUNCTION REPERISCI_DATI_INIZIALI(P_ID_AZIENDA_NEW  IN  DB_AZIENDA.ID_AZIENDA%TYPE,
                                  P_ID_AZIENDA_OLD  IN  DB_AZIENDA.ID_AZIENDA%TYPE,
                                   P_MSGERR             IN OUT  VARCHAR2,
                                  P_CODERR      IN OUT  VARCHAR2) RETURN BOOLEAN IS

BEGIN
     BEGIN
      SELECT ID_UTENTE_AGGIORNAMENTO
        INTO N_ID_UTENTE_AGGIORNAMENTO
        FROM DB_ANAGRAFICA_AZIENDA
       WHERE ID_AZIENDA = P_ID_AZIENDA_NEW
         AND DATA_FINE_VALIDITA IS NULL;
     EXCEPTION
      WHEN  NO_DATA_FOUND THEN
          p_MsgErr   := 'ERRORE GRAVE! UTENTE DI AGGIORNAMENTO NON TROVATO PER LA NUOVA AZIENDA';
        p_CodErr   := ERR_GEN;
        RETURN (FALSE);
      WHEN  OTHERS        THEN
        p_MsgErr   := 'Errore REPERISCI_PERSONA_FISICA: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
     END;

     BEGIN
      SELECT DATA_CESSAZIONE, CUAA, DENOMINAZIONE
        INTO D_DATA_CESSAZIONE, S_CUAA_PROV, S_DENOMINAZIONE_PROV
        FROM DB_ANAGRAFICA_AZIENDA
       WHERE ID_AZIENDA = P_ID_AZIENDA_OLD
         AND DATA_FINE_VALIDITA IS NULL;
     EXCEPTION
      WHEN  NO_DATA_FOUND THEN
          p_MsgErr   := 'ERRORE GRAVE! UTENTE DI AGGIORNAMENTO NON TROVATO PER LA NUOVA AZIENDA';
        p_CodErr   := ERR_GEN;
        RETURN (FALSE);
      WHEN  OTHERS        THEN
        p_MsgErr   := 'Errore REPERISCI_PERSONA_FISICA: ' || SQLERRM;
        p_CodErr   := SQLCODE;
        RETURN (FALSE);
     END;



     RETURN (TRUE);

EXCEPTION
WHEN  OTHERS        THEN
    p_MsgErr   := 'Errore REPERISCI_DATI_INIZIALI: ' || SQLERRM;
    p_CodErr   := SQLCODE;
    RETURN (FALSE);
END REPERISCI_DATI_INIZIALI;

FUNCTION CONTA_UTE (P_ID_AZIENDA_NEW  IN     DB_AZIENDA.ID_AZIENDA%TYPE,
                    P_ID_UTE          OUT DB_UTE.ID_UTE%TYPE,
                     P_MSGERR       IN OUT VARCHAR2,
                    P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS


BEGIN
     BEGIN
         SELECT ID_UTE
         INTO    P_ID_UTE
         FROM DB_UTE
        WHERE ID_AZIENDA = P_ID_AZIENDA_NEW
--          AND COMUNE = P_COMUNE
          AND DATA_FINE_ATTIVITA IS NULL;
     EXCEPTION
     WHEN NO_DATA_FOUND THEN
               P_ID_UTE := NULL;
     WHEN TOO_MANY_ROWS THEN
          SELECT ID_UTE
          INTO    P_ID_UTE
          FROM (
            SELECT *
          FROM DB_UTE
          WHERE ID_AZIENDA = P_ID_AZIENDA_NEW
          AND DATA_FINE_ATTIVITA IS NULL
          ORDER BY DATA_INIZIO_ATTIVITA)
          WHERE ROWNUM=1;
     WHEN OTHERS THEN
        P_MSGERR      := 'ERRORE CONTA_UTE: '|| SQLERRM;
        P_CODERR      := SQLCODE;
        RETURN (FALSE);
     END;

     RETURN (TRUE);

EXCEPTION
WHEN OTHERS THEN
    P_MSGERR      := 'ERRORE CONTA_UTE: '|| SQLERRM;
    P_CODERR      := SQLCODE;
    RETURN (FALSE);
END CONTA_UTE;


FUNCTION REPERISCI_UTE (P_ID_AZIENDA_NEW  IN     DB_AZIENDA.ID_AZIENDA%TYPE,
                         P_ID_UTE_PROV      IN     DB_UTE.ID_UTE%TYPE,
                          P_COMUNE          IN DB_UTE.COMUNE%TYPE,
                        P_ID_UTE          OUT DB_UTE.ID_UTE%TYPE,
                         P_MSGERR       IN OUT VARCHAR2,
                        P_CODERR       IN OUT VARCHAR2) RETURN BOOLEAN IS

S_DENOMINAZIONE         DB_UTE.DENOMINAZIONE%TYPE;
N_ID_ATTIVITA_ATECO     DB_UTE.ID_ATTIVITA_ATECO%TYPE;
N_ID_ATTIVITA_OTE        DB_UTE.ID_ATTIVITA_OTE%TYPE;
N_ID_ZONA_ALT            DB_UTE.ID_ZONA_ALTIMETRICA%TYPE;
D_DATA_INIZIO_ATTIVITA    DB_UTE.DATA_INIZIO_ATTIVITA%TYPE;
N_COUNT                    NUMBER(5);
S_INDIRIZZO             DB_UTE.INDIRIZZO%TYPE;
S_CAP                    DB_UTE.CAP%TYPE;
S_TELEFONO                 DB_UTE.TELEFONO%TYPE;
S_FAX                     DB_UTE.FAX%TYPE;
S_NOTE                     DB_UTE.NOTE%TYPE;

BEGIN

       SELECT SEQ_UTE.NEXTVAL
         INTO P_ID_UTE
         FROM DUAL;

         SELECT DENOMINAZIONE, INDIRIZZO,  CAP, ID_ZONA_ALTIMETRICA,
                 ID_ATTIVITA_ATECO, TELEFONO, FAX, NOTE, DATA_INIZIO_ATTIVITA,
                ID_ATTIVITA_OTE
          INTO    S_DENOMINAZIONE, S_INDIRIZZO, S_CAP, N_ID_ZONA_ALT,
                 N_ID_ATTIVITA_ATECO, S_TELEFONO, S_FAX, S_NOTE, D_DATA_INIZIO_ATTIVITA,
                N_ID_ATTIVITA_OTE
           FROM DB_UTE
          WHERE ID_UTE = P_ID_UTE_PROV;

         INSERT INTO DB_UTE (ID_UTE, ID_AZIENDA, DENOMINAZIONE, INDIRIZZO, COMUNE,
                 ID_ZONA_ALTIMETRICA, CAP, ID_ATTIVITA_ATECO, NOTE, TELEFONO, FAX,
                ID_UTENTE_AGGIORNAMENTO, DATA_INIZIO_ATTIVITA, DATA_FINE_ATTIVITA,
                CAUSALE_CESSAZIONE, DATA_AGGIORNAMENTO, MOTIVO_MODIFICA, ID_ATTIVITA_OTE)
         VALUES (P_ID_UTE, P_ID_AZIENDA_NEW, S_DENOMINAZIONE, S_INDIRIZZO, P_COMUNE,
                  N_ID_ZONA_ALT, S_CAP, N_ID_ATTIVITA_ATECO, S_NOTE, S_TELEFONO, S_FAX,
                 N_ID_UTENTE_AGGIORNAMENTO, D_DATA_INIZIO_ATTIVITA, NULL, NULL, SYSDATE, NULL, N_ID_ATTIVITA_OTE);


     RETURN (TRUE);

EXCEPTION
WHEN OTHERS THEN
    P_MSGERR      := 'ERRORE REPERISCI_UTE: '|| SQLERRM;
    P_CODERR      := SQLCODE;
    RETURN (FALSE);
END REPERISCI_UTE;

PROCEDURE RIBALTAMENTO_CONSISTENZA(P_ID_AZIENDA_NEW  IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                      P_ID_AZIENDA_PROV IN      DB_AZIENDA.ID_AZIENDA%TYPE,
                                   P_MSGERR               IN OUT VARCHAR2,
                                   P_CODERR          IN OUT VARCHAR2)IS

N_ID_UTE                   DB_UTE.ID_UTE%TYPE;
N_ID_CONDUZIONE_PARTICELLA DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
N_ID_FABBRICATO            DB_FABBRICATO.ID_FABBRICATO%TYPE;
N_ID_ALLEVAMENTO             DB_ALLEVAMENTO.ID_ALLEVAMENTO%TYPE;
N_ID_MANODOPERA               DB_MANODOPERA.ID_MANODOPERA%TYPE;

FLAG_ESCI                   BOOLEAN;
N_ID_UTE_AZ_NEW               DB_UTE.ID_UTE%TYPE;

BEGIN
     IF NOT REPERISCI_DATI_INIZIALI(P_ID_AZIENDA_NEW, P_ID_AZIENDA_PROV,
             P_MSGERR, P_CODERR) THEN
        RAISE EsciRountine;
     END IF;
     N_ID_AZIENDA_PROV := P_ID_AZIENDA_PROV;

     FLAG_ESCI:=FALSE;
     IF D_DATA_CESSAZIONE IS NULL THEN
         /* azienda attiva */
        /* cerco l'ultima dichiarazione di consistenza dell'azienda */
        BEGIN
            SELECT ID_DICHIARAZIONE_CONSISTENZA, DATA_INSERIMENTO_DICHIARAZIONE
            INTO N_ID_CONSISTENZA, D_DATA_INSERIMENTO
            FROM DB_DICHIARAZIONE_CONSISTENZA
            WHERE ID_AZIENDA = P_ID_AZIENDA_PROV
            AND DATA_INSERIMENTO_DICHIARAZIONE =
              (SELECT MAX(DATA_INSERIMENTO_DICHIARAZIONE)
                 FROM DB_DICHIARAZIONE_CONSISTENZA
                   WHERE ID_AZIENDA = P_ID_AZIENDA_PROV);
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                  /* Non ho trovato dich. di cons.: devo uscire */
                 FLAG_ESCI:=TRUE;
        END;
     ELSE
         /* azienda cessata */
        /* uso un artifizio valorizzando la variabile d_data_inserimento con la sysdate, così mi tira su la situazione
           attuale per allev, fabbr, manod */
        D_DATA_INSERIMENTO:=SYSDATE;
        /* per pulizia */
        N_ID_CONSISTENZA:=NULL;
     END IF;

     IF NOT FLAG_ESCI THEN
          /* conto le ute dell'az.nuova. Recupero la prima se ce ne sono */
          IF NOT CONTA_UTE (P_ID_AZIENDA_NEW, N_ID_UTE_AZ_NEW, P_MSGERR, P_CODERR) THEN
            RAISE EsciRountine;
         END IF;

         FOR REC_UTE IN C_UTE LOOP

              IF N_ID_UTE_AZ_NEW IS NULL THEN
                  /* la creo */
                  IF NOT REPERISCI_UTE (P_ID_AZIENDA_NEW, REC_UTE.ID_UTE, REC_UTE.COMUNE,
                        N_ID_UTE, P_MSGERR, P_CODERR) THEN
                    RAISE EsciRountine;
                 END IF;
             ELSE
                  N_ID_UTE:=N_ID_UTE_AZ_NEW;
             END IF;

             N_ID_UTE_PROV := REC_UTE.ID_UTE;

              IF D_DATA_CESSAZIONE IS NULL THEN
                 /* az. attiva: devo ciclare sull'ultima dich. di cons. */
                 FOR REC_CONDUZIONE_AZ_ATTIVA IN C_CONDUZIONE_AZ_ATTIVA LOOP
                      SELECT SEQ_CONDUZIONE_PARTICELLA.NEXTVAL
                       INTO N_ID_CONDUZIONE_PARTICELLA
                       FROM DUAL;

                     INSERT INTO DB_CONDUZIONE_PARTICELLA (ID_CONDUZIONE_PARTICELLA,
                                                           ID_PARTICELLA,
                                                           ID_TITOLO_POSSESSO,
                                                           ID_UTE,
                                                           SUPERFICIE_CONDOTTA,
                                                           FLAG_UTILIZZO_PARTE,
                                                           DATA_INIZIO_CONDUZIONE,
                                                           DATA_FINE_CONDUZIONE,
                                                           NOTE,
                                                           DATA_AGGIORNAMENTO,
                                                           ID_UTENTE_AGGIORNAMENTO,
                                                           ESITO_CONTROLLO,
                                                           DATA_ESECUZIONE,
                                                           RECORD_MODIFICATO,
                                                           PERCENTUALE_POSSESSO)
                     VALUES (N_ID_CONDUZIONE_PARTICELLA,
                             REC_CONDUZIONE_AZ_ATTIVA.ID_PARTICELLA,
                             REC_CONDUZIONE_AZ_ATTIVA.ID_TITOLO_POSSESSO,
                             N_ID_UTE,
                             REC_CONDUZIONE_AZ_ATTIVA.SUPERFICIE_CONDOTTA,
                             NULL,
                             TRUNC (SYSDATE),
                             NULL,
                             SUBSTR ('IMPORTAZIONE DEL ' || TO_CHAR (SYSDATE, 'DD/MM/YYYY') || ' DA AZIENDA DI PROVENIENZA: ' || S_CUAA_PROV || ' - ' || S_DENOMINAZIONE_PROV,1,300),
                             SYSDATE,
                             N_ID_UTENTE_AGGIORNAMENTO,
                             NULL,
                             NULL,
                             NULL,
                             REC_CONDUZIONE_AZ_ATTIVA.PERCENTUALE_POSSESSO);

                     N_ID_COND_DICH_PROV := REC_CONDUZIONE_AZ_ATTIVA.ID_CONDUZIONE_DICHIARATA;
                     FOR REC_UTILIZZO_DICHIARATO IN C_UTILIZZO_DICHIARATO LOOP
                          N_ID_UTIL_DICH_PROV := REC_UTILIZZO_DICHIARATO.ID_UTILIZZO_DICHIARATO;

                         SELECT SEQ_UTILIZZO_PARTICELLA.NEXTVAL INTO N_ID_UTILIZZO_PARTICELLA_NEW FROM DUAL;

                          INSERT INTO DB_UTILIZZO_PARTICELLA (ID_UTILIZZO_PARTICELLA, ID_UTILIZZO,
                                 ID_CONDUZIONE_PARTICELLA, SUPERFICIE_UTILIZZATA, DATA_AGGIORNAMENTO,
                                ID_UTENTE_AGGIORNAMENTO, ANNO, NOTE, ID_UTILIZZO_SECONDARIO, SUP_UTILIZZATA_SECONDARIA, ID_VARIETA,
                                ID_VARIETA_SECONDARIA, ANNO_IMPIANTO, ID_IMPIANTO, SESTO_SU_FILE, SESTO_TRA_FILE, NUMERO_PIANTE_CEPPI,
                                ID_TIPO_DETTAGLIO_USO, ID_TIPO_DETT_USO_SECONDARIO, ID_TIPO_EFA, VALORE_ORIGINALE, 
                                VALORE_DOPO_CONVERSIONE, VALORE_DOPO_PONDERAZIONE, ID_TIPO_PERIODO_SEMINA, ID_TIPO_PERIODO_SEMINA_SECOND,
                                ID_SEMINA, ID_SEMINA_SECONDARIA, ID_CATALOGO_MATRICE,
                                DATA_INIZIO_DESTINAZIONE, DATA_FINE_DESTINAZIONE, ID_FASE_ALLEVAMENTO,
                                ID_PRATICA_MANTENIMENTO, ID_CATALOGO_MATRICE_SECONDARIO,
                                DATA_INIZIO_DESTINAZIONE_SEC, DATA_FINE_DESTINAZIONE_SEC, ID_ISOLA_GRAFICA,
                                ID_APPEZZAMENTO, ID_SHAPE, SHAPE
                                )
                         VALUES (N_ID_UTILIZZO_PARTICELLA_NEW, REC_UTILIZZO_DICHIARATO.ID_UTILIZZO,
                                 N_ID_CONDUZIONE_PARTICELLA, REC_UTILIZZO_DICHIARATO.SUPERFICIE_UTILIZZATA,
                                SYSDATE, N_ID_UTENTE_AGGIORNAMENTO, REC_UTILIZZO_DICHIARATO.ANNO, SUBSTR('IMPORTAZIONE DEL '|| TO_CHAR(SYSDATE,'DD/MM/YYYY') || ' DA AZIENDA DI PROVENIENZA: ' || S_CUAA_PROV || ' - ' || S_DENOMINAZIONE_PROV,1,100),
                                REC_UTILIZZO_DICHIARATO.ID_UTILIZZO_SECONDARIO, REC_UTILIZZO_DICHIARATO.SUP_UTILIZZATA_SECONDARIA, REC_UTILIZZO_DICHIARATO.ID_VARIETA,
                                REC_UTILIZZO_DICHIARATO.ID_VARIETA_SECONDARIA, REC_UTILIZZO_DICHIARATO.ANNO_IMPIANTO, REC_UTILIZZO_DICHIARATO.ID_IMPIANTO,
                                REC_UTILIZZO_DICHIARATO.SESTO_SU_FILE, REC_UTILIZZO_DICHIARATO.SESTO_TRA_FILE, REC_UTILIZZO_DICHIARATO.NUMERO_PIANTE_CEPPI,
                                REC_UTILIZZO_DICHIARATO.ID_TIPO_DETTAGLIO_USO, REC_UTILIZZO_DICHIARATO.ID_TIPO_DETT_USO_SECONDARIO, REC_UTILIZZO_DICHIARATO.ID_TIPO_EFA, REC_UTILIZZO_DICHIARATO.VALORE_ORIGINALE, 
                                REC_UTILIZZO_DICHIARATO.VALORE_DOPO_CONVERSIONE, REC_UTILIZZO_DICHIARATO.VALORE_DOPO_PONDERAZIONE, REC_UTILIZZO_DICHIARATO.ID_TIPO_PERIODO_SEMINA, REC_UTILIZZO_DICHIARATO.ID_TIPO_PERIODO_SEMINA_SECOND,
                                REC_UTILIZZO_DICHIARATO.ID_SEMINA, REC_UTILIZZO_DICHIARATO.ID_SEMINA_SECONDARIA, REC_UTILIZZO_DICHIARATO.ID_CATALOGO_MATRICE,
                                REC_UTILIZZO_DICHIARATO.DATA_INIZIO_DESTINAZIONE, REC_UTILIZZO_DICHIARATO.DATA_FINE_DESTINAZIONE, REC_UTILIZZO_DICHIARATO.ID_FASE_ALLEVAMENTO,
                                REC_UTILIZZO_DICHIARATO.ID_PRATICA_MANTENIMENTO, REC_UTILIZZO_DICHIARATO.ID_CATALOGO_MATRICE_SECONDARIO,
                                REC_UTILIZZO_DICHIARATO.DATA_INIZIO_DESTINAZIONE_SEC, REC_UTILIZZO_DICHIARATO.DATA_FINE_DESTINAZIONE_SEC, REC_UTILIZZO_DICHIARATO.ID_ISOLA_GRAFICA,
                                REC_UTILIZZO_DICHIARATO.ID_APPEZ, REC_UTILIZZO_DICHIARATO.ID_SHAPE, REC_UTILIZZO_DICHIARATO.SHAPE
                                );

                        FOR REC_UTILIZZO_CONSOCIATO_DICH IN C_UTILIZZO_CONSOCIATO_DICH LOOP
                            INSERT INTO DB_UTILIZZO_CONSOCIATO (ID_UTILIZZO_CONSOCIATO, ID_UTILIZZO_PARTICELLA, ID_PIANTE_CONSOCIATE, NUMERO_PIANTE)
                            VALUES (SEQ_UTILIZZO_CONSOCIATO.NEXTVAL, N_ID_UTILIZZO_PARTICELLA_NEW, REC_UTILIZZO_CONSOCIATO_DICH.ID_PIANTE_CONSOCIATE, REC_UTILIZZO_CONSOCIATO_DICH.NUMERO_PIANTE);
                        END LOOP;

                     END LOOP;
                 END LOOP;
             ELSE
                 /* az. cessata */
                 FOR REC_CONDUZIONE IN C_CONDUZIONE LOOP
                      SELECT SEQ_CONDUZIONE_PARTICELLA.NEXTVAL
                       INTO N_ID_CONDUZIONE_PARTICELLA
                       FROM DUAL;
                     INSERT INTO DB_CONDUZIONE_PARTICELLA (ID_CONDUZIONE_PARTICELLA,
                                                           ID_PARTICELLA,
                                                           ID_TITOLO_POSSESSO,
                                                           ID_UTE,
                                                           SUPERFICIE_CONDOTTA,
                                                           FLAG_UTILIZZO_PARTE,
                                                           DATA_INIZIO_CONDUZIONE,
                                                           DATA_FINE_CONDUZIONE,
                                                           NOTE,
                                                           DATA_AGGIORNAMENTO,
                                                           ID_UTENTE_AGGIORNAMENTO,
                                                           ESITO_CONTROLLO,
                                                           DATA_ESECUZIONE,
                                                           RECORD_MODIFICATO,
                                                           PERCENTUALE_POSSESSO)
                         VALUES (N_ID_CONDUZIONE_PARTICELLA,
                                 REC_CONDUZIONE.ID_PARTICELLA,
                                 REC_CONDUZIONE.ID_TITOLO_POSSESSO,
                                 N_ID_UTE,
                                 REC_CONDUZIONE.SUPERFICIE_CONDOTTA,
                                 REC_CONDUZIONE.FLAG_UTILIZZO_PARTE,
                                 TRUNC (SYSDATE),
                                 NULL,
                                 SUBSTR ('IMPORTAZIONE DEL ' || TO_CHAR (SYSDATE, 'DD/MM/YYYY') || ' DA AZIENDA DI PROVENIENZA: '|| S_CUAA_PROV|| ' - '|| S_DENOMINAZIONE_PROV,1,300),
                                 SYSDATE,
                                 N_ID_UTENTE_AGGIORNAMENTO,
                                 NULL,
                                 NULL,
                                 NULL,
                                 REC_CONDUZIONE.PERCENTUALE_POSSESSO);

                     N_ID_COND_PARTICELLA_PROV := REC_CONDUZIONE.ID_CONDUZIONE_PARTICELLA;
                     FOR REC_UTILIZZO IN C_UTILIZZO LOOP
                          N_ID_UTILIZZO_PARTICELLA_PROV := REC_UTILIZZO.ID_UTILIZZO_PARTICELLA;

                        SELECT SEQ_UTILIZZO_PARTICELLA.NEXTVAL INTO N_ID_UTILIZZO_PARTICELLA_NEW FROM DUAL;

                          INSERT INTO DB_UTILIZZO_PARTICELLA (ID_UTILIZZO_PARTICELLA, ID_UTILIZZO,
                                 ID_CONDUZIONE_PARTICELLA, SUPERFICIE_UTILIZZATA, DATA_AGGIORNAMENTO,
                                ID_UTENTE_AGGIORNAMENTO, ANNO, NOTE, ID_UTILIZZO_SECONDARIO, SUP_UTILIZZATA_SECONDARIA, ID_VARIETA,
                                ID_VARIETA_SECONDARIA, ANNO_IMPIANTO, ID_IMPIANTO, SESTO_SU_FILE, SESTO_TRA_FILE, NUMERO_PIANTE_CEPPI,
                                ID_TIPO_DETTAGLIO_USO, ID_TIPO_DETT_USO_SECONDARIO, ID_TIPO_EFA, VALORE_ORIGINALE, 
                                VALORE_DOPO_CONVERSIONE, VALORE_DOPO_PONDERAZIONE, ID_TIPO_PERIODO_SEMINA, ID_TIPO_PERIODO_SEMINA_SECOND,
                                ID_SEMINA, ID_SEMINA_SECONDARIA, ID_CATALOGO_MATRICE,
                                DATA_INIZIO_DESTINAZIONE, DATA_FINE_DESTINAZIONE, ID_FASE_ALLEVAMENTO,
                                ID_PRATICA_MANTENIMENTO, ID_CATALOGO_MATRICE_SECONDARIO,
                                DATA_INIZIO_DESTINAZIONE_SEC, DATA_FINE_DESTINAZIONE_SEC, ID_ISOLA_GRAFICA,
                                ID_APPEZZAMENTO, ID_SHAPE, SHAPE
                                )
                         VALUES (N_ID_UTILIZZO_PARTICELLA_NEW, REC_UTILIZZO.ID_UTILIZZO,
                                 N_ID_CONDUZIONE_PARTICELLA, REC_UTILIZZO.SUPERFICIE_UTILIZZATA,
                                SYSDATE, N_ID_UTENTE_AGGIORNAMENTO, REC_UTILIZZO.ANNO, SUBSTR('IMPORTAZIONE DEL '|| TO_CHAR(SYSDATE,'DD/MM/YYYY') || ' DA AZIENDA DI PROVENIENZA: ' || S_CUAA_PROV || ' - ' || S_DENOMINAZIONE_PROV,1,100),
                                REC_UTILIZZO.ID_UTILIZZO_SECONDARIO, REC_UTILIZZO.SUP_UTILIZZATA_SECONDARIA, REC_UTILIZZO.ID_VARIETA,
                                REC_UTILIZZO.ID_VARIETA_SECONDARIA, REC_UTILIZZO.ANNO_IMPIANTO, REC_UTILIZZO.ID_IMPIANTO,
                                REC_UTILIZZO.SESTO_SU_FILE, REC_UTILIZZO.SESTO_TRA_FILE, REC_UTILIZZO.NUMERO_PIANTE_CEPPI,
                                REC_UTILIZZO.ID_TIPO_DETTAGLIO_USO, REC_UTILIZZO.ID_TIPO_DETT_USO_SECONDARIO, REC_UTILIZZO.ID_TIPO_EFA, REC_UTILIZZO.VALORE_ORIGINALE, 
                                REC_UTILIZZO.VALORE_DOPO_CONVERSIONE, REC_UTILIZZO.VALORE_DOPO_PONDERAZIONE, REC_UTILIZZO.ID_TIPO_PERIODO_SEMINA, REC_UTILIZZO.ID_TIPO_PERIODO_SEMINA_SECOND,
                                REC_UTILIZZO.ID_SEMINA, REC_UTILIZZO.ID_SEMINA_SECONDARIA, REC_UTILIZZO.ID_CATALOGO_MATRICE,
                                REC_UTILIZZO.DATA_INIZIO_DESTINAZIONE, REC_UTILIZZO.DATA_FINE_DESTINAZIONE, REC_UTILIZZO.ID_FASE_ALLEVAMENTO,
                                REC_UTILIZZO.ID_PRATICA_MANTENIMENTO, REC_UTILIZZO.ID_CATALOGO_MATRICE_SECONDARIO,
                                REC_UTILIZZO.DATA_INIZIO_DESTINAZIONE_SEC, REC_UTILIZZO.DATA_FINE_DESTINAZIONE_SEC, REC_UTILIZZO.ID_ISOLA_GRAFICA,
                                REC_UTILIZZO.ID_APPEZZAMENTO, REC_UTILIZZO.ID_SHAPE, REC_UTILIZZO.SHAPE
                                );

                        FOR REC_UTILIZZO_CONSOCIATO IN C_UTILIZZO_CONSOCIATO LOOP
                            INSERT INTO DB_UTILIZZO_CONSOCIATO (ID_UTILIZZO_CONSOCIATO, ID_UTILIZZO_PARTICELLA, ID_PIANTE_CONSOCIATE, NUMERO_PIANTE)
                            VALUES (SEQ_UTILIZZO_CONSOCIATO.NEXTVAL, N_ID_UTILIZZO_PARTICELLA_NEW, REC_UTILIZZO_CONSOCIATO.ID_PIANTE_CONSOCIATE, REC_UTILIZZO_CONSOCIATO.NUMERO_PIANTE);
                        END LOOP;

                     END LOOP;
                     N_ID_PARTICELLA := REC_CONDUZIONE.ID_PARTICELLA;

                     -- l'azienda di provenienza e' sicuramente
                     -- cessata quindi non posso avere le unita' vitata
                     -- valide associate ad essa
                     -- devo andare a vedere il record cessato più recente
                     -- alla data di cessazione dell'azienda e lo assegno direttamente
                     -- alla nuova azienda
                     UPDATE DB_STORICO_UNITA_ARBOREA
                        SET ID_AZIENDA = P_ID_AZIENDA_NEW
                      WHERE ID_UNITA_ARBOREA IN (SELECT UA.ID_UNITA_ARBOREA
                                                   FROM DB_STORICO_UNITA_ARBOREA UA
                                                  WHERE UA.ID_PARTICELLA = N_ID_PARTICELLA
                                                    AND UA.ID_AZIENDA = N_ID_AZIENDA_PROV
                                                    AND UA.DATA_FINE_VALIDITA = (SELECT MAX(UA2.DATA_FINE_VALIDITA)
                                                                                   FROM DB_STORICO_UNITA_ARBOREA UA2
                                                                                  WHERE UA2.ID_UNITA_ARBOREA = UA.ID_UNITA_ARBOREA
                                                                                    AND UA2.ID_AZIENDA = N_ID_AZIENDA_PROV
                                                                                    AND TRUNC(UA2.DATA_FINE_VALIDITA) = TRUNC(D_DATA_CESSAZIONE)))
                        AND ID_AZIENDA IS NULL
                        AND DATA_FINE_VALIDITA IS NULL
                        AND DATA_CESSAZIONE IS NULL;



                 END LOOP;
             END IF;

             FOR REC_ALLEVAMENTO IN C_ALLEVAMENTO LOOP
                  SELECT SEQ_ALLEVAMENTO.NEXTVAL
                   INTO N_ID_ALLEVAMENTO
                   FROM DUAL;

                  INSERT INTO DB_ALLEVAMENTO (ID_ALLEVAMENTO, ID_UTE, ID_ASL, ISTAT_COMUNE,
                         ID_SPECIE_ANIMALE, CODICE_AZIENDA_ZOOTECNICA, DATA_INIZIO, DATA_FINE, NOTE,
                        DATA_AGGIORNAMENTO, ID_UTENTE_AGGIORNAMENTO, INDIRIZZO, CAP, TELEFONO)
                 VALUES (N_ID_ALLEVAMENTO, N_ID_UTE, REC_ALLEVAMENTO.ID_ASL,
                         REC_ALLEVAMENTO.ISTAT_COMUNE, REC_ALLEVAMENTO.ID_SPECIE_ANIMALE,
                        REC_ALLEVAMENTO.CODICE_AZIENDA_ZOOTECNICA, REC_ALLEVAMENTO.DATA_INIZIO,
                        NULL, 'IMPORTAZIONE DEL '|| TO_CHAR(SYSDATE,'DD/MM/YYYY') || ' DA AZIENDA DI PROVENIENZA: ' || S_CUAA_PROV || ' - ' || S_DENOMINAZIONE_PROV,
                        SYSDATE, N_ID_UTENTE_AGGIORNAMENTO, REC_ALLEVAMENTO.INDIRIZZO, REC_ALLEVAMENTO.CAP, REC_ALLEVAMENTO.TELEFONO);

                 N_ID_ALLEVAMENTO_PROV := REC_ALLEVAMENTO.ID_ALLEVAMENTO;


                 FOR REC_CATEGORIE_ALLEVAMENTO IN C_CATEGORIE_ALLEVAMENTO LOOP
                      INSERT INTO DB_CATEGORIE_ALLEVAMENTO (ID_CATEGORIE_ALLEVAMENTO,
                             ID_CATEGORIA_ANIMALE, ID_ALLEVAMENTO, QUANTITA, QUANTITA_PROPRIETA) 
                     VALUES (SEQ_CATEGORIE_ALLEVAMENTO.NEXTVAL, REC_CATEGORIE_ALLEVAMENTO.ID_CATEGORIA_ANIMALE,
                             N_ID_ALLEVAMENTO, REC_CATEGORIE_ALLEVAMENTO.QUANTITA, REC_CATEGORIE_ALLEVAMENTO.QUANTITA_PROPRIETA);

                     -- ribalto anche le sottocategoria
                     -- non facciamo lavorare troppo sti caa ....
                     INSERT INTO DB_SOTTOCATEGORIA_ALLEVAMENTO
                        (
                        ID_SOTTOCATEGORIA_ALLEVAMENTO,
                        ID_CATEGORIE_ALLEVAMENTO,
                        ID_SOTTOCATEGORIA_ANIMALE,
                        ORE_PASCOLO_INVERNO,
                        QUANTITA,
                        PESO_VIVO,
                        GIORNI_VUOTO_SANITARIO,
                        GIORNI_PASCOLO_ESTATE,
                        ORE_PASCOLO_ESTATE,
                        GIORNI_PASCOLO_INVERNO,
                        CICLI,
                        FLAG_BIOLOGICO,
                        NUMERO_CICLI_ANNUALI,
                        QUANTITA_PROPRIETA
                        )
                     SELECT SEQ_SOTTOCATEGORIA_ALLEVAMENTO.nextval,
                            SEQ_CATEGORIE_ALLEVAMENTO.currval,
                            ID_SOTTOCATEGORIA_ANIMALE,
                            ORE_PASCOLO_INVERNO,
                            QUANTITA,
                            PESO_VIVO,
                            GIORNI_VUOTO_SANITARIO,
                            GIORNI_PASCOLO_ESTATE,
                            ORE_PASCOLO_ESTATE,
                            GIORNI_PASCOLO_INVERNO,
                            CICLI,
                            FLAG_BIOLOGICO,
                            NUMERO_CICLI_ANNUALI,
                            QUANTITA_PROPRIETA
                       FROM DB_SOTTOCATEGORIA_ALLEVAMENTO
                      WHERE ID_CATEGORIE_ALLEVAMENTO = REC_CATEGORIE_ALLEVAMENTO.ID_CATEGORIE_ALLEVAMENTO;

                 END LOOP;
             END LOOP;

             FOR REC_FABBRICATO IN C_FABBRICATO LOOP
                  SELECT SEQ_FABBRICATO.NEXTVAL
                   INTO N_ID_FABBRICATO
                   FROM DUAL;

                  INSERT INTO DB_FABBRICATO (ID_FABBRICATO, ID_TIPOLOGIA_FABBRICATO,
                         ID_FORMA_FABBRICATO, DENOMINAZIONE, SUPERFICIE, ANNO_COSTRUZIONE,
                        DIMENSIONE, LUNGHEZZA, LARGHEZZA, DATA_AGGIORNAMENTO, ALTEZZA, UTM_X,
                        UTM_Y, NOTE, ID_UTENTE_AGGIORNAMENTO, ID_UTE, DATA_INIZIO_VALIDITA,
                        DATA_FINE_VALIDITA, ID_COLTURA_SERRA, MESI_RISCALDAMENTO_SERRA, ORE_RISCALDAMENTO_SERRA)
                 VALUES (N_ID_FABBRICATO, REC_FABBRICATO.ID_TIPOLOGIA_FABBRICATO,
                         REC_FABBRICATO.ID_FORMA_FABBRICATO, REC_FABBRICATO.DENOMINAZIONE,
                        REC_FABBRICATO.SUPERFICIE, REC_FABBRICATO.ANNO_COSTRUZIONE,
                        REC_FABBRICATO.DIMENSIONE, REC_FABBRICATO.LUNGHEZZA, REC_FABBRICATO.LARGHEZZA,
                        SYSDATE, REC_FABBRICATO.ALTEZZA, REC_FABBRICATO.UTM_X,
                        REC_FABBRICATO.UTM_Y, 'IMPORTAZIONE DEL '|| TO_CHAR(SYSDATE,'DD/MM/YYYY') || ' DA AZIENDA DI PROVENIENZA: ' || S_CUAA_PROV || ' - ' || S_DENOMINAZIONE_PROV,
                        N_ID_UTENTE_AGGIORNAMENTO, N_ID_UTE, REC_FABBRICATO.DATA_INIZIO_VALIDITA,  NULL,
                        REC_FABBRICATO.ID_COLTURA_SERRA, REC_FABBRICATO.MESI_RISCALDAMENTO_SERRA, REC_FABBRICATO.ORE_RISCALDAMENTO_SERRA);

                 N_ID_FABBRICATO_PROV := REC_FABBRICATO.ID_FABBRICATO;
                 FOR REC_FABBRICATO_PARTICELLA IN C_FABBRICATO_PARTICELLA LOOP
                      INSERT INTO DB_FABBRICATO_PARTICELLA (ID_FABBRICATO_PARTICELLA, ID_FABBRICATO,
                             ID_PARTICELLA, DATA_INIZIO_VALIDITA, DATA_FINE_VALIDITA)
                     VALUES(SEQ_PARTICELLA_FABBRICATO.NEXTVAL, N_ID_FABBRICATO,
                             REC_FABBRICATO_PARTICELLA.ID_PARTICELLA,
                            REC_FABBRICATO_PARTICELLA.DATA_INIZIO_VALIDITA, NULL);

                 END LOOP;

             END LOOP;
         END LOOP;

         FOR REC_MANODOPERA IN C_MANODOPERA LOOP
              SELECT SEQ_MANODOPERA.NEXTVAL
               INTO N_ID_MANODOPERA
              FROM  DUAL;

             INSERT INTO DB_MANODOPERA (ID_MANODOPERA, ID_AZIENDA, CODICE_INPS, DATA_INIZIO_VALIDITA,
                     DATA_FINE_VALIDITA, DATA_AGGIORNAMENTO, ID_UTENTE_AGGIORNAMENTO, ID_FORMA_CONDUZIONE)
             VALUES (N_ID_MANODOPERA, P_ID_AZIENDA_NEW, REC_MANODOPERA.CODICE_INPS,
                     REC_MANODOPERA.DATA_INIZIO_VALIDITA, NULL, SYSDATE, N_ID_UTENTE_AGGIORNAMENTO,
                    REC_MANODOPERA.ID_FORMA_CONDUZIONE);

             N_ID_MANODOPERA_PROV := REC_MANODOPERA.ID_MANODOPERA;
             FOR REC_DETTAGLIO_ATTIVITA IN C_DETTAGLIO_ATTIVITA LOOP
                INSERT INTO DB_DETTAGLIO_ATTIVITA (ID_DETTAGLIO_ATTIVITA, ID_MANODOPERA,
                       ID_ATTIVITA_COMPLEMENTARI, DESCRIZIONE)
                VALUES (SEQ_DETTAGLIO_ATTIVITA.NEXTVAL, N_ID_MANODOPERA,
                       REC_DETTAGLIO_ATTIVITA.ID_ATTIVITA_COMPLEMENTARI, REC_DETTAGLIO_ATTIVITA.DESCRIZIONE);
            END LOOP;

            FOR REC_DETTAGLIO_MANODOPERA IN C_DETTAGLIO_MANODOPERA LOOP
                INSERT INTO DB_DETTAGLIO_MANODOPERA (ID_DETTAGLIO_MANODOPERA, ID_MANODOPERA,
                       ID_CLASSE_MANODOPERA, UOMINI, DONNE, GIORNATE_ANNUE)
                VALUES (SEQ_DETTAGLIO_MANODOPERA.NEXTVAL, N_ID_MANODOPERA,
                       REC_DETTAGLIO_MANODOPERA.ID_CLASSE_MANODOPERA, REC_DETTAGLIO_MANODOPERA.UOMINI,
                       REC_DETTAGLIO_MANODOPERA.DONNE, REC_DETTAGLIO_MANODOPERA.GIORNATE_ANNUE);
            END LOOP;

         END LOOP;
     END IF; -- if not flag esci

     --COMMIT;
EXCEPTION
WHEN EsciRountine THEN
     NULL;
WHEN OTHERS THEN
     P_MSGERR := 'ERRORE GRAVE NEL RIBALTAMENTO DELLA CONSISTENZA. CONTATTARE L''ASSISTENZA: ' || SQLERRM;
     P_CODERR := SQLCODE;
END RIBALTAMENTO_CONSISTENZA;

END Pack_Ribaltamento_Consistenza;          -- Package

/
--------------------------------------------------------
--  DDL for Package Body PACK_RIBALTA_UV_SU_PCOLTURALE
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PACK_RIBALTA_UV_SU_PCOLTURALE" IS
EsciRountine       EXCEPTION;
--ERR_GEN              TMP_LOG.COD_ERRORE%TYPE               := '999999';
ERR_GEN              VARCHAR2(10)               := '999999';


    /*********************************************************************
    Dato un codice altro dato seleziona il corrispettivo record attivo (data fine validita a null)
    sulla tabella DB_ALTRI_DATI
    Tipo: function
    input: pCodAltroDato
    output: nessuno
    ritorno: DB_ALTRI_DATI%ROWTYPE
    *********************************************************************/
    FUNCTION SelDAltroDatoByCodice (pCodAltroDato IN DB_ALTRI_DATI.CODICE%TYPE)
    RETURN DB_ALTRI_DATI%ROWTYPE IS
        recDAltriDati DB_ALTRI_DATI%ROWTYPE;
    BEGIN

        SELECT *
          INTO recDAltriDati
          FROM DB_ALTRI_DATI
         WHERE CODICE = pCodAltroDato
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recDAltriDati;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelDAltroDatoByCodice;

    /*FUNCTION SelTDettaglioUsoByIdVarietaCod (pIdVarieta         IN DB_R_CATALOGO_MATRICE.ID_VARIETA%TYPE,
                                             pCodDettaglioUso   IN DB_TIPO_DETTAGLIO_USO.CODICE_DETTAGLIO_USO%TYPE,
                                             pIdPeriodoSemina  OUT DB_TIPO_VARIETA.ID_TIPO_PERIODO_SEMINA%TYPE
                                             ) RETURN DB_TIPO_DETTAGLIO_USO%ROWTYPE IS

        recDTipoDettUso     DB_TIPO_DETTAGLIO_USO%ROWTYPE;
        nIdTipoPeriodoSem   DB_TIPO_VARIETA.ID_TIPO_PERIODO_SEMINA%TYPE;
    BEGIN


        SELECT TV.ID_TIPO_PERIODO_SEMINA
          INTO nIdTipoPeriodoSem
          FROM DB_TIPO_VARIETA TV
         WHERE TV.ID_VARIETA = pIdVarieta;

        pIdPeriodoSemina := nIdTipoPeriodoSem;

        SELECT *
          INTO recDTipoDettUso
          FROM DB_TIPO_DETTAGLIO_USO DE
         WHERE ID_VARIETA = pIdVarieta
           AND CODICE_DETTAGLIO_USO = pCodDettaglioUso
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recDTipoDettUso;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTDettaglioUsoByIdVarietaCod;*/

    /*********************************************************************
    Dato un record di tipo DB_UTILIZZO_PARTICELLA lo inserisce
    sull'omonima tabella
    Tipo:   procedure
    input:  pRecTUtilizzoParticella
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InsertTUtilizzoParticella (pRecTUtilizzoParticella IN DB_UTILIZZO_PARTICELLA%ROWTYPE) IS
    BEGIN
        INSERT INTO DB_UTILIZZO_PARTICELLA
            (
            ID_UTILIZZO_PARTICELLA,
            ID_UTILIZZO,
            ID_CONDUZIONE_PARTICELLA,
            SUPERFICIE_UTILIZZATA,
            DATA_AGGIORNAMENTO,
            ID_UTENTE_AGGIORNAMENTO,
            ANNO,
            NOTE,
            ID_UTILIZZO_SECONDARIO,
            SUP_UTILIZZATA_SECONDARIA,
            ID_VARIETA,
            ID_VARIETA_SECONDARIA,
            ANNO_IMPIANTO,
            ID_IMPIANTO,
            SESTO_SU_FILE,
            SESTO_TRA_FILE,
            NUMERO_PIANTE_CEPPI,
            ID_TIPO_DETTAGLIO_USO,
            ID_TIPO_DETT_USO_SECONDARIO,
            ID_TIPO_EFA,
            VALORE_ORIGINALE,
            VALORE_DOPO_CONVERSIONE,
            VALORE_DOPO_PONDERAZIONE,
            ID_TIPO_PERIODO_SEMINA,
            ID_TIPO_PERIODO_SEMINA_SECOND,
            ID_SEMINA, ID_SEMINA_SECONDARIA, ID_CATALOGO_MATRICE, DATA_INIZIO_DESTINAZIONE,
            DATA_FINE_DESTINAZIONE, ID_FASE_ALLEVAMENTO, ID_PRATICA_MANTENIMENTO,
            ID_CATALOGO_MATRICE_SECONDARIO, DATA_INIZIO_DESTINAZIONE_SEC, DATA_FINE_DESTINAZIONE_SEC,
            ID_ISOLA_GRAFICA, ID_APPEZZAMENTO, ID_SHAPE, SHAPE
            )
        VALUES
            (
            pRecTUtilizzoParticella.ID_UTILIZZO_PARTICELLA,
            pRecTUtilizzoParticella.ID_UTILIZZO,
            pRecTUtilizzoParticella.ID_CONDUZIONE_PARTICELLA,
            pRecTUtilizzoParticella.SUPERFICIE_UTILIZZATA,
            pRecTUtilizzoParticella.DATA_AGGIORNAMENTO,
            pRecTUtilizzoParticella.ID_UTENTE_AGGIORNAMENTO,
            pRecTUtilizzoParticella.ANNO,
            pRecTUtilizzoParticella.NOTE,
            pRecTUtilizzoParticella.ID_UTILIZZO_SECONDARIO,
            pRecTUtilizzoParticella.SUP_UTILIZZATA_SECONDARIA,
            pRecTUtilizzoParticella.ID_VARIETA,
            pRecTUtilizzoParticella.ID_VARIETA_SECONDARIA,
            pRecTUtilizzoParticella.ANNO_IMPIANTO,
            pRecTUtilizzoParticella.ID_IMPIANTO,
            pRecTUtilizzoParticella.SESTO_SU_FILE,
            pRecTUtilizzoParticella.SESTO_TRA_FILE,
            pRecTUtilizzoParticella.NUMERO_PIANTE_CEPPI,
            pRecTUtilizzoParticella.ID_TIPO_DETTAGLIO_USO,
            pRecTUtilizzoParticella.ID_TIPO_DETT_USO_SECONDARIO,
            pRecTUtilizzoParticella.ID_TIPO_EFA,
            pRecTUtilizzoParticella.VALORE_ORIGINALE,
            pRecTUtilizzoParticella.VALORE_DOPO_CONVERSIONE,
            pRecTUtilizzoParticella.VALORE_DOPO_PONDERAZIONE,
            pRecTUtilizzoParticella.ID_TIPO_PERIODO_SEMINA,
            pRecTUtilizzoParticella.ID_TIPO_PERIODO_SEMINA_SECOND,
            pRecTUtilizzoParticella.ID_SEMINA, pRecTUtilizzoParticella.ID_SEMINA_SECONDARIA, pRecTUtilizzoParticella.ID_CATALOGO_MATRICE, pRecTUtilizzoParticella.DATA_INIZIO_DESTINAZIONE,
            pRecTUtilizzoParticella.DATA_FINE_DESTINAZIONE, pRecTUtilizzoParticella.ID_FASE_ALLEVAMENTO, pRecTUtilizzoParticella.ID_PRATICA_MANTENIMENTO,
            pRecTUtilizzoParticella.ID_CATALOGO_MATRICE_SECONDARIO, pRecTUtilizzoParticella.DATA_INIZIO_DESTINAZIONE_SEC, pRecTUtilizzoParticella.DATA_FINE_DESTINAZIONE_SEC,
            pRecTUtilizzoParticella.ID_ISOLA_GRAFICA, pRecTUtilizzoParticella.ID_APPEZZAMENTO, pRecTUtilizzoParticella.ID_SHAPE, pRecTUtilizzoParticella.SHAPE
            );
    END InsertTUtilizzoParticella;

    /*********************************************************************
    Dato un ID_PARTICELLA ricerca il relativo ID_PARTICELLA_CERTIFICATA attivo su
    DB_PARTICELLA_CERTIFICATA se ne trova più di uno ritorna -1
    Tipo: function
    input: pIdParticella
    output: nessuno
    ritorno: DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA
    *********************************************************************/
    FUNCTION SelectIdPartCertif (pIdParticella IN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA%TYPE)
    RETURN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE IS
        nIdPartCertificata DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE;
    BEGIN

        SELECT ID_PARTICELLA_CERTIFICATA
          INTO nIdPartCertificata
          FROM DB_PARTICELLA_CERTIFICATA
         WHERE ID_PARTICELLA = pIdParticella
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN nIdPartCertificata;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelectIdPartCertif;

    /*********************************************************************
    Dato un id_utilizzo_particella cancella se presenti i figli sulla
    tabella DB_UTILIZZO_CONSOCIATO
    Tipo: procedure
    input: pIdUtilizzoParticella
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE DelTUtilConsociatoByIdUtilPart (pIdUtilizzoParticella IN DB_UTILIZZO_CONSOCIATO.ID_UTILIZZO_PARTICELLA%TYPE) IS
    BEGIN
        DELETE
           FROM DB_UTILIZZO_CONSOCIATO
          WHERE ID_UTILIZZO_PARTICELLA = pIdUtilizzoParticella;
    END DelTUtilConsociatoByIdUtilPart;

    /*********************************************************************
    Dato un id_utilizzo_particella cancella il corrispettivo record dalla
    tabella DB_UTILIZZO_PARTICELLA
    Tipo: procedure
    input: pIdUtilizzoParticella
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE DelTUtilizzoParticellaById(pIdUtilizzoParticella IN DB_UTILIZZO_PARTICELLA.ID_UTILIZZO_PARTICELLA%TYPE) IS
    BEGIN
        DelTUtilConsociatoByIdUtilPart (pIdUtilizzoParticella);
        DELETE
          FROM DB_UTILIZZO_PARTICELLA
         WHERE ID_UTILIZZO_PARTICELLA = pIdUtilizzoParticella;
    END DelTUtilizzoParticellaById;

    /*********************************************************************
    Dato un ID_UTILIZZO_PARTICELLA ed una superficie aggiorna per il corrispettivo
    record di DB_UTILIZZO_PARTICELLA la superficie utilizzata
    Tipo: procedure
    input: pIdUtilizzoParticella , pSupUtilizzata
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE AggSupUtilTUtilizzoPartById (pIdUtilizzoParticella IN DB_UTILIZZO_PARTICELLA.ID_UTILIZZO_PARTICELLA%TYPE,
                                           pSupUtilizzata        IN DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE
                                           ) IS
    BEGIN
        UPDATE DB_UTILIZZO_PARTICELLA
           SET SUPERFICIE_UTILIZZATA = pSupUtilizzata
         WHERE ID_UTILIZZO_PARTICELLA = pIdUtilizzoParticella;
    END AggSupUtilTUtilizzoPartById;

    /*********************************************************************
    Per l'azienda , la particella e la conduzione date in input riproporziona
    la superficie utilizzata per gli utilizzi con il flag ALLINEA_UV ad 'S'
    se questa è maggiore dell'eleggibile
    Tipo: procedure
    input: pIdAzienda , pIdParticella, pIdConduzione
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE RiprUtilizziConduzione (pIdAzienda    IN DB_UTE.ID_AZIENDA%TYPE,
                                      pIdParticella IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE,
                                      pIdConduzione IN DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE
                                      ) IS
        CURSOR curUtilizzoParticella (pIdConduzioneParticella IN DB_UTILIZZO_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE) IS
        SELECT UP.*
          FROM DB_UTILIZZO_PARTICELLA UP,
               DB_TIPO_UTILIZZO TU,DB_R_CATALOGO_MATRICE CM 
         WHERE UP.ID_CONDUZIONE_PARTICELLA = pIdConduzioneParticella
           AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND CM.ID_UTILIZZO = TU.ID_UTILIZZO 
           AND TU.ALLINEA_UV = 'S';

        nIdParticellaCertificata DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE;
        nTotSupEleg              DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        nTotSupUtil              DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        vStrCatMatr              VARCHAR2(4000);
    BEGIN
        -- ricerco la particella certificata per ID_PARTICELLA
        nIdParticellaCertificata := SelectIdPartCertif(pIdParticella);
        -- se la trovo
        IF nIdParticellaCertificata IS NOT NULL THEN
           -- scorro gli utilizzi con ALLINEA_UV ad 'S'
           FOR recUtilizzoParticella IN curUtilizzoParticella (pIdConduzione) LOOP
               -- cerco la superficie eleggibile per la varietà
               nTotSupEleg := PCK_SMRGAA_LIBRERIA.SelTotSupElegByPartEVetVarNTar (nIdParticellaCertificata,
                                                                                  recUtilizzoParticella.ID_CATALOGO_MATRICE);
               -- nTotSupEleg := PCK_SMRGAA_LIBRERIA.SelTotSupElegByPartEVetVar (nIdParticellaCertificata,
               --                                                               recUtilizzoParticella.ID_VARIETA);

               -- cerco la superficie utilizzata per la particella e le varietà compatibili
               nTotSupUtil := PCK_SMRGAA_LIBRERIA.SelTotSupUtilVarCompatibili(pIdAzienda,
                                                                              pIdParticella,
                                                                              nIdParticellaCertificata,
                                                                              recUtilizzoParticella.ID_CATALOGO_MATRICE,
                                                                              vStrCatMatr);
               -- mi calcolo la superficie eleggibile rimanenente
               nTotSupEleg := nTotSupEleg - nTotSupUtil;
               -- se è maggiore di zero
               IF nTotSupEleg > 0 THEN
                  -- se l'utilizzata è maggiore della stessa
                  IF recUtilizzoParticella.SUPERFICIE_UTILIZZATA > nTotSupEleg THEN
                     -- setto l'utilizzata uguale all'eleggibile
                     AggSupUtilTUtilizzoPartById (recUtilizzoParticella.ID_UTILIZZO_PARTICELLA,
                                                  nTotSupEleg);
                  END IF;
               ELSE
                  -- se l'eleggibile è minore od uguale a zero
                  -- cancello l'utilizzo della particella
                  DelTUtilizzoParticellaById(recUtilizzoParticella.ID_UTILIZZO_PARTICELLA);
               END IF;

           END LOOP;
        END IF;

    END RiprUtilizziConduzione;


PROCEDURE RIBALTA_UV_OLD (P_ID_AZIENDA                IN DB_AZIENDA.ID_AZIENDA%TYPE,
                          P_ELENCO_UV               IN NUM_VARRAY,
                          P_ID_UTENTE_AGGIORNAMENTO IN DB_DICHIARAZIONE_CONSISTENZA.ID_UTENTE%TYPE,
                          P_MSGERR                      IN OUT VARCHAR2,
                          P_CODERR                       IN OUT VARCHAR2)IS

    CURSOR C_UNITA_ARBOREA IS
    SELECT CP.ID_CONDUZIONE_PARTICELLA, CP.ID_PARTICELLA, CM.ID_UTILIZZO, CM.ID_VARIETA, SUM(SUA.AREA) * CP.PERCENTUALE_POSSESSO / 100 AS AREA,
           CM.ID_CATALOGO_MATRICE,CM.ID_TIPO_DETTAGLIO_USO,CMS.ID_TIPO_PERIODO_SEMINA,
           CASE WHEN TRUNC(SYSDATE) < (SELECT TO_DATE(VALORE_STRINGA||'/'||TO_CHAR(SYSDATE,'YYYY'),'DD/MM/YYYY')
                                       FROM   DB_ALTRI_DATI
                                       WHERE  CODICE             = 'DATA_SWAP_SEMINA'
                                       AND    DATA_FINE_VALIDITA IS NULL) THEN TO_CHAR(TRUNC(SYSDATE),'YYYY') + CMS.ANNO_DECODIFICA_PRE_DATA
                ELSE TO_CHAR(TRUNC(SYSDATE),'YYYY') + CMS.ANNO_DECODIFICA_POST_DATA END ANNO,
           CMS.INIZIO_DESTINAZIONE_DEFAULT,CMS.FINE_DESTINAZIONE_DEFAULT
      FROM DB_STORICO_UNITA_ARBOREA SUA, DB_CONDUZIONE_PARTICELLA CP, DB_UTE U,
           DB_R_CATALOGO_MATRICE CM,DB_R_CATALOGO_MATRICE_SEMINA CMS
     WHERE SUA.ID_AZIENDA = P_ID_AZIENDA
       AND SUA.ID_AZIENDA = U.ID_AZIENDA 
       AND SUA.DATA_FINE_VALIDITA IS NULL
       AND SUA.ID_PARTICELLA = CP.ID_PARTICELLA
       AND (P_ELENCO_UV IS NOT NULL AND 
            SUA.ID_PARTICELLA IN (SELECT SA.ID_PARTICELLA -- valorizzato allora ribalto solamente
                                    FROM DB_STORICO_UNITA_ARBOREA SA -- le particelle delle uv del vettore
                                   WHERE SA.ID_STORICO_UNITA_ARBOREA IN (SELECT * FROM TABLE(P_ELENCO_UV))) OR
            P_ELENCO_UV IS NULL) -- altrimenti ribalto tutto
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND CP.ID_UTE = U.ID_UTE
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND CMS.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
       AND CMS.FLAG_DEFAULT = 'S' 
       AND SUA.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
       --AND NVL(ID_UTILIZZO,0) <> 0
       --AND NVL(ID_VARIETA,0) <> 0
  GROUP BY CP.ID_CONDUZIONE_PARTICELLA, CP.ID_PARTICELLA, CP.PERCENTUALE_POSSESSO,CM.ID_UTILIZZO, CM.ID_VARIETA,
           CM.ID_CATALOGO_MATRICE,CM.ID_TIPO_DETTAGLIO_USO,CMS.ID_TIPO_PERIODO_SEMINA,CMS.ANNO_DECODIFICA_PRE_DATA,CMS.ANNO_DECODIFICA_POST_DATA,
           CMS.INIZIO_DESTINAZIONE_DEFAULT,CMS.FINE_DESTINAZIONE_DEFAULT
  ORDER BY CP.ID_CONDUZIONE_PARTICELLA, CP.ID_PARTICELLA, CP.PERCENTUALE_POSSESSO,CM.ID_UTILIZZO, CM.ID_VARIETA;

    N_ID_CONDUZIONE_PARTICELLA  DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
    N_ID_PARTICELLA             DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE;

  VetRecPratMant  TypVetRecPratMant;
BEGIN

     FOR REC_UNITA_ARBOREA IN C_UNITA_ARBOREA LOOP
          IF NVL(N_ID_CONDUZIONE_PARTICELLA,0) <> REC_UNITA_ARBOREA.ID_CONDUZIONE_PARTICELLA THEN
             -- aggiornare la superficie condotta
             IF N_ID_CONDUZIONE_PARTICELLA IS NOT NULL THEN
                RiprUtilizziConduzione (P_ID_AZIENDA,N_ID_PARTICELLA,N_ID_CONDUZIONE_PARTICELLA);

 
                UPDATE DB_CONDUZIONE_PARTICELLA
                   SET SUPERFICIE_CONDOTTA = (SELECT SUM(SUPERFICIE_UTILIZZATA)
                                                FROM DB_UTILIZZO_PARTICELLA
                                               WHERE ID_CONDUZIONE_PARTICELLA = N_ID_CONDUZIONE_PARTICELLA)
                 WHERE ID_CONDUZIONE_PARTICELLA = N_ID_CONDUZIONE_PARTICELLA;

             END IF;

              N_ID_CONDUZIONE_PARTICELLA := REC_UNITA_ARBOREA.ID_CONDUZIONE_PARTICELLA;
             N_ID_PARTICELLA := REC_UNITA_ARBOREA.ID_PARTICELLA;

             DELETE FROM DB_UTILIZZO_CONSOCIATO
             WHERE ID_UTILIZZO_PARTICELLA IN (SELECT ID_UTILIZZO_PARTICELLA FROM DB_UTILIZZO_PARTICELLA
                                              WHERE ID_CONDUZIONE_PARTICELLA = REC_UNITA_ARBOREA.ID_CONDUZIONE_PARTICELLA
                                              AND ID_UTILIZZO IN (SELECT ID_UTILIZZO FROM DB_TIPO_UTILIZZO WHERE TIPO = 'V'));

              DELETE FROM DB_UTILIZZO_PARTICELLA
             WHERE ID_CONDUZIONE_PARTICELLA = REC_UNITA_ARBOREA.ID_CONDUZIONE_PARTICELLA
               AND ID_UTILIZZO IN (SELECT ID_UTILIZZO FROM DB_TIPO_UTILIZZO WHERE TIPO = 'V');
         END IF;

         VetRecPratMant := Pck_Smrgaa_Libreria.getListIdPraticaMantenimento(REC_UNITA_ARBOREA.ID_CATALOGO_MATRICE,'S');

         INSERT INTO DB_UTILIZZO_PARTICELLA (ID_UTILIZZO_PARTICELLA, ID_UTILIZZO, ID_CONDUZIONE_PARTICELLA,
                 SUPERFICIE_UTILIZZATA, DATA_AGGIORNAMENTO, ID_UTENTE_AGGIORNAMENTO, ANNO, NOTE, ID_UTILIZZO_SECONDARIO,
                SUP_UTILIZZATA_SECONDARIA, ID_VARIETA, ID_VARIETA_SECONDARIA, ANNO_IMPIANTO, ID_IMPIANTO, SESTO_SU_FILE,
                SESTO_TRA_FILE, NUMERO_PIANTE_CEPPI,
                ID_CATALOGO_MATRICE,
                DATA_INIZIO_DESTINAZIONE,
                DATA_FINE_DESTINAZIONE,
                ID_TIPO_DETTAGLIO_USO,
                ID_TIPO_PERIODO_SEMINA,
                ID_PRATICA_MANTENIMENTO)
         VALUES (SEQ_UTILIZZO_PARTICELLA.NEXTVAL, REC_UNITA_ARBOREA.ID_UTILIZZO, REC_UNITA_ARBOREA.ID_CONDUZIONE_PARTICELLA,
                 REC_UNITA_ARBOREA.AREA, SYSDATE, P_ID_UTENTE_AGGIORNAMENTO, TO_NUMBER(TO_CHAR(SYSDATE,'YYYY')), 'ALLINEAMENTO DA UV',
                NULL, NULL, REC_UNITA_ARBOREA.ID_VARIETA, NULL, NULL, NULL, NULL, NULL, NULL,
                REC_UNITA_ARBOREA.ID_CATALOGO_MATRICE,
                TO_DATE(REC_UNITA_ARBOREA.INIZIO_DESTINAZIONE_DEFAULT||'/'||REC_UNITA_ARBOREA.ANNO,'DD/MM/YYYY'),
                TO_DATE(REC_UNITA_ARBOREA.FINE_DESTINAZIONE_DEFAULT||'/'||REC_UNITA_ARBOREA.ANNO,'DD/MM/YYYY'),
                REC_UNITA_ARBOREA.ID_TIPO_DETTAGLIO_USO,
                REC_UNITA_ARBOREA.ID_TIPO_PERIODO_SEMINA,
                VetRecPratMant(1).nIdPraticaMantenimento);

     END LOOP;

     -- e per l'ultima conduzione devo effettuare l'aggiornamento fuori ciclo
     IF N_ID_CONDUZIONE_PARTICELLA IS NOT NULL THEN

        RiprUtilizziConduzione (P_ID_AZIENDA,N_ID_PARTICELLA,N_ID_CONDUZIONE_PARTICELLA);

 
        UPDATE DB_CONDUZIONE_PARTICELLA
           SET SUPERFICIE_CONDOTTA = (SELECT SUM(SUPERFICIE_UTILIZZATA)
                                        FROM DB_UTILIZZO_PARTICELLA
                                       WHERE ID_CONDUZIONE_PARTICELLA = N_ID_CONDUZIONE_PARTICELLA)
         WHERE ID_CONDUZIONE_PARTICELLA = N_ID_CONDUZIONE_PARTICELLA;

     END IF;

EXCEPTION
WHEN EsciRountine THEN
     NULL;
WHEN OTHERS THEN
     P_MSGERR := 'ERRORE GRAVE NELL''ALLINEAMENTO DEL PIANO COLTURALE DALLE UV. CONTATTARE L''ASSISTENZA:' || SQLERRM;
     P_CODERR := SQLCODE;
END RIBALTA_UV_OLD;

PROCEDURE RIBALTA_UV (P_ID_AZIENDA              IN DB_AZIENDA.ID_AZIENDA%TYPE,
                      P_ELENCO_UV               IN NUM_VARRAY,
                      P_ID_UTENTE_AGGIORNAMENTO IN DB_DICHIARAZIONE_CONSISTENZA.ID_UTENTE%TYPE,
                      P_MSGERR                  IN OUT VARCHAR2,
                      P_CODERR                  IN OUT VARCHAR2)IS


    -- superficie vitata per particella ed utilizzo vitato
    CURSOR curSupVitataParticellaUV IS
    SELECT SUA.ID_PARTICELLA, CM.ID_UTILIZZO, CM.ID_VARIETA, SUM(SUA.AREA) AS TOT_AREA,
           CM.ID_CATALOGO_MATRICE,CM.ID_TIPO_DETTAGLIO_USO,CMS.ID_TIPO_PERIODO_SEMINA,
           CASE WHEN TRUNC(SYSDATE) < (SELECT TO_DATE(VALORE_STRINGA||'/'||TO_CHAR(SYSDATE,'YYYY'),'DD/MM/YYYY')
                                       FROM   DB_ALTRI_DATI
                                       WHERE  CODICE             = 'DATA_SWAP_SEMINA'
                                       AND    DATA_FINE_VALIDITA IS NULL) THEN TO_CHAR(TRUNC(SYSDATE),'YYYY') + CMS.ANNO_DECODIFICA_PRE_DATA
                ELSE TO_CHAR(TRUNC(SYSDATE),'YYYY') + CMS.ANNO_DECODIFICA_POST_DATA END ANNO,
           CMS.INIZIO_DESTINAZIONE_DEFAULT,CMS.FINE_DESTINAZIONE_DEFAULT
      FROM DB_STORICO_UNITA_ARBOREA SUA,DB_R_CATALOGO_MATRICE CM,DB_R_CATALOGO_MATRICE_SEMINA CMS
     WHERE SUA.ID_AZIENDA = P_ID_AZIENDA
       AND SUA.DATA_FINE_VALIDITA IS NULL
       AND (P_ELENCO_UV IS NOT NULL AND 
            SUA.ID_PARTICELLA IN (SELECT SA.ID_PARTICELLA -- valorizzato allora ribalto solamente
                                    FROM DB_STORICO_UNITA_ARBOREA SA -- le particelle delle uv del vettore
                                   WHERE SA.ID_STORICO_UNITA_ARBOREA IN (SELECT * FROM TABLE(P_ELENCO_UV))) OR
            P_ELENCO_UV IS NULL) -- altrimenti ribalto tutto
       --AND SUA.ID_UTILIZZO IS NOT NULL
       --AND SUA.ID_VARIETA IS NOT NULL
       AND CMS.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE
       AND CMS.FLAG_DEFAULT = 'S'
       AND SUA.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
       AND EXISTS (SELECT CP.ID_CONDUZIONE_PARTICELLA
                     FROM DB_CONDUZIONE_PARTICELLA CP,
                          DB_UTE UT
                    WHERE UT.ID_AZIENDA = P_ID_AZIENDA
                      AND UT.DATA_FINE_ATTIVITA IS NULL
                      AND UT.ID_UTE = CP.ID_UTE
                      AND CP.DATA_FINE_CONDUZIONE IS NULL
                      AND CP.ID_PARTICELLA = SUA.ID_PARTICELLA) 
  GROUP BY SUA.ID_PARTICELLA, CM.ID_UTILIZZO, CM.ID_VARIETA,CM.ID_CATALOGO_MATRICE,CM.ID_TIPO_DETTAGLIO_USO,CMS.ID_TIPO_PERIODO_SEMINA,
           CMS.INIZIO_DESTINAZIONE_DEFAULT,CMS.FINE_DESTINAZIONE_DEFAULT,CMS.ANNO_DECODIFICA_PRE_DATA,CMS.ANNO_DECODIFICA_POST_DATA
  ORDER BY SUA.ID_PARTICELLA, CM.ID_UTILIZZO, CM.ID_VARIETA;

    -- conduzioni della particella con utilizzi a vite
    CURSOR curConduzioneParticella  (pIdParticella IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT CP.*
      FROM DB_CONDUZIONE_PARTICELLA CP,
           DB_UTE U
     WHERE U.ID_AZIENDA = P_ID_AZIENDA
       AND U.ID_UTE = CP.ID_UTE
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND CP.ID_PARTICELLA = pIdParticella
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND EXISTS (SELECT UP.ID_UTILIZZO_PARTICELLA
                     FROM DB_UTILIZZO_PARTICELLA UP,
                          DB_TIPO_UTILIZZO TU
                    WHERE UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
                      AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
                      AND TU.TIPO = 'V');

    nNumCdConUtVite     INTEGER:=0;
    nIdParticella       DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE:=0;
    recTUtilizzoPart    DB_UTILIZZO_PARTICELLA%ROWTYPE;
    recDTipoDettUso     DB_TIPO_DETTAGLIO_USO%ROWTYPE;
    nIdTipoPerSemina    DB_TIPO_VARIETA.ID_TIPO_PERIODO_SEMINA%TYPE;
    recDAltriDati       DB_ALTRI_DATI%ROWTYPE;

    -- cursore delle conduzione particella con utilizzi a vite più somma percentuale possesso
    -- per vettore VetConduzione
    CURSOR curTypCondWithPercCondTotale (pIdParticella IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE) IS
    SELECT CP.*,
           SUM(CP.PERCENTUALE_POSSESSO) OVER (PARTITION BY CP.ID_PARTICELLA) AS PERC_COND_TOTALE
      FROM DB_CONDUZIONE_PARTICELLA CP,
           DB_UTE U
     WHERE U.ID_AZIENDA = P_ID_AZIENDA
       AND U.ID_UTE = CP.ID_UTE
       AND U.DATA_FINE_ATTIVITA IS NULL
       AND CP.ID_PARTICELLA = pIdParticella
       AND CP.DATA_FINE_CONDUZIONE IS NULL
       AND EXISTS (SELECT UP.ID_UTILIZZO_PARTICELLA
                     FROM DB_UTILIZZO_PARTICELLA UP,
                          DB_TIPO_UTILIZZO TU
                    WHERE UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
                      AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
                      AND TU.TIPO = 'V');


    TYPE TypVetConduzione IS TABLE OF curTypCondWithPercCondTotale%ROWTYPE INDEX BY PLS_INTEGER;
    VetConduzione TypVetConduzione;

    VetRecPratMant  TypVetRecPratMant;

  dDataSwap  DATE;
  vAnno      VARCHAR2(10);

BEGIN

    -- cerco il codice dell'uso agricolo da definire
    recDAltriDati := SelDAltroDatoByCodice (kvCodAltroDatoUsoAgrDaDefinire);

    IF recDAltriDati.VALORE_STRINGA IS NULL THEN
       recDAltriDati.VALORE_STRINGA := '400';
    END IF;


    -- scorro le particelle delle unità vitate raggruppate particella, id_varieta ed id_utilizzo
    FOR recSupVitataParticellaUV IN curSupVitataParticellaUV LOOP
        -- se la particella in elaborazione è diversa da quella precedente
        IF nIdParticella <> recSupVitataParticellaUV.ID_PARTICELLA THEN
           -- se la particella precedente è diversa da zero
           IF nIdParticella <> 0 THEN
              -- vuol dire che ho terminato di trattare la particella precedente
              FOR recConduzioneParticella IN curConduzioneParticella (nIdParticella) LOOP
                -- posso aggiustare la superficie utilizzata che ho inserito per i vari utilizzi all'eleggibile
                RiprUtilizziConduzione (P_ID_AZIENDA,nIdParticella,recConduzioneParticella.ID_CONDUZIONE_PARTICELLA);
                -- inoltre posso calcolare la condotta come somma delle utilizzate
                UPDATE DB_CONDUZIONE_PARTICELLA
                   SET SUPERFICIE_CONDOTTA = (SELECT SUM(SUPERFICIE_UTILIZZATA)
                                                FROM DB_UTILIZZO_PARTICELLA
                                               WHERE ID_CONDUZIONE_PARTICELLA = recConduzioneParticella.ID_CONDUZIONE_PARTICELLA)
                 WHERE ID_CONDUZIONE_PARTICELLA = recConduzioneParticella.ID_CONDUZIONE_PARTICELLA;

              END LOOP;
           END IF;

           -- sparo le conduzioni della particella con utilizzo a vite in un vettore
           -- e mi calcolo già l'eventuale somma della percentuale di possesso in caso di più
           -- conduzione per particella
           SELECT CP.*,
                  SUM(CP.PERCENTUALE_POSSESSO) OVER (PARTITION BY CP.ID_PARTICELLA)
             BULK COLLECT INTO VetConduzione
             FROM DB_CONDUZIONE_PARTICELLA CP,
                  DB_UTE U
            WHERE U.ID_AZIENDA = P_ID_AZIENDA
              AND U.ID_UTE = CP.ID_UTE
              AND U.DATA_FINE_ATTIVITA IS NULL
              AND CP.ID_PARTICELLA = recSupVitataParticellaUV.ID_PARTICELLA
              AND CP.DATA_FINE_CONDUZIONE IS NULL
              AND EXISTS (SELECT UP.ID_UTILIZZO_PARTICELLA
                            FROM DB_UTILIZZO_PARTICELLA UP,
                                 DB_TIPO_UTILIZZO TU
                           WHERE UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
                             AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
                             AND TU.TIPO = 'V');

            -- scorro le conduzione della particella che hanno come figli utilizzi a vite
            -- e cancello DB_UTILIZZO_CONSOCIATO e DB_UTILIZZO_PARTICELLA
            FOR recConduzioneParticella IN curConduzioneParticella (recSupVitataParticellaUV.ID_PARTICELLA) LOOP
                DELETE
                  FROM DB_UTILIZZO_CONSOCIATO
                 WHERE ID_UTILIZZO_PARTICELLA IN (SELECT ID_UTILIZZO_PARTICELLA
                                                    FROM DB_UTILIZZO_PARTICELLA
                                                   WHERE ID_CONDUZIONE_PARTICELLA = recConduzioneParticella.ID_CONDUZIONE_PARTICELLA
                                                     AND ID_UTILIZZO IN (SELECT ID_UTILIZZO
                                                                           FROM DB_TIPO_UTILIZZO
                                                                          WHERE TIPO = 'V'));

                DELETE
                  FROM DB_UTILIZZO_PARTICELLA
                 WHERE ID_CONDUZIONE_PARTICELLA = recConduzioneParticella.ID_CONDUZIONE_PARTICELLA
                   AND ID_UTILIZZO IN (SELECT ID_UTILIZZO
                                         FROM DB_TIPO_UTILIZZO
                                        WHERE TIPO = 'V');
            END LOOP;

        END IF;
        -- se ho trovato almeno uno conduzione della particella con utilizzi a vite
        IF VetConduzione.COUNT > 0 THEN
            -- scorro le conduzioni della particella corrente e vi inserisco gli utilizzi presi
            -- da DB_STORICO_UNITA_ARBOREA
            FOR i IN 1..VetConduzione.COUNT LOOP

                SELECT SEQ_UTILIZZO_PARTICELLA.NEXTVAL
                  INTO recTUtilizzoPart.ID_UTILIZZO_PARTICELLA
                  FROM DUAL;

                recTUtilizzoPart.ID_UTILIZZO := recSupVitataParticellaUV.ID_UTILIZZO;
                recTUtilizzoPart.ID_CONDUZIONE_PARTICELLA := VetConduzione(i).ID_CONDUZIONE_PARTICELLA;
                -- se avevo più di una conduzione (con figli con utilizzi a vite)
                IF VetConduzione.COUNT > 1 THEN
                   -- applico la riduzione per percentuale di possesso al totale dell'area
                   recTUtilizzoPart.SUPERFICIE_UTILIZZATA := recSupVitataParticellaUV.TOT_AREA * ((100 * VetConduzione(i).PERCENTUALE_POSSESSO) / VetConduzione(i).PERC_COND_TOTALE) / 100;
                ELSE
                   -- altrimenti metto il totale dell'area pulito
                   recTUtilizzoPart.SUPERFICIE_UTILIZZATA := recSupVitataParticellaUV.TOT_AREA;
                END IF;

                -- e li setto
                recTUtilizzoPart.ID_TIPO_DETTAGLIO_USO := recSupVitataParticellaUV.ID_TIPO_DETTAGLIO_USO;
                recTUtilizzoPart.ID_TIPO_PERIODO_SEMINA := recSupVitataParticellaUV.ID_TIPO_PERIODO_SEMINA;
                recTUtilizzoPart.DATA_AGGIORNAMENTO := SYSDATE;
                recTUtilizzoPart.ID_UTENTE_AGGIORNAMENTO := P_ID_UTENTE_AGGIORNAMENTO;
                recTUtilizzoPart.ANNO := TO_NUMBER(TO_CHAR(SYSDATE,'YYYY'));
                recTUtilizzoPart.NOTE := 'ALLINEAMENTO DA UV';
                recTUtilizzoPart.ID_VARIETA := recSupVitataParticellaUV.ID_VARIETA;

                recTUtilizzoPart.ID_CATALOGO_MATRICE := recSupVitataParticellaUV.ID_CATALOGO_MATRICE;
                recTUtilizzoPart.DATA_INIZIO_DESTINAZIONE := TO_DATE(recSupVitataParticellaUV.INIZIO_DESTINAZIONE_DEFAULT||'/'||recSupVitataParticellaUV.ANNO,'DD/MM/YYYY');

                IF recSupVitataParticellaUV.INIZIO_DESTINAZIONE_DEFAULT > recSupVitataParticellaUV.FINE_DESTINAZIONE_DEFAULT THEN
                  recTUtilizzoPart.DATA_FINE_DESTINAZIONE := TO_DATE(recSupVitataParticellaUV.FINE_DESTINAZIONE_DEFAULT||'/'||(recSupVitataParticellaUV.ANNO + 1),'DD/MM/YYYY');
                ELSE
                  recTUtilizzoPart.DATA_FINE_DESTINAZIONE := TO_DATE(recSupVitataParticellaUV.FINE_DESTINAZIONE_DEFAULT||'/'||recSupVitataParticellaUV.ANNO,'DD/MM/YYYY');
                END IF;

                VetRecPratMant := Pck_Smrgaa_Libreria.getListIdPraticaMantenimento(recSupVitataParticellaUV.ID_CATALOGO_MATRICE,'S');
                recTUtilizzoPart.ID_PRATICA_MANTENIMENTO := VetRecPratMant(1).nIdPraticaMantenimento;

                InsertTUtilizzoParticella (recTUtilizzoPart);

            END LOOP;

        ELSE
           -- se non avevo conduzione attive con figli utilizzi a vite
           SELECT SEQ_UTILIZZO_PARTICELLA.NEXTVAL
             INTO recTUtilizzoPart.ID_UTILIZZO_PARTICELLA
             FROM DUAL;

           recTUtilizzoPart.ID_UTILIZZO := recSupVitataParticellaUV.ID_UTILIZZO;
           -- prendo la prima (MIN) conduzione della particella per l'azienda
           SELECT MIN(CP.ID_CONDUZIONE_PARTICELLA)
             INTO recTUtilizzoPart.ID_CONDUZIONE_PARTICELLA
             FROM DB_CONDUZIONE_PARTICELLA CP,
                  DB_UTE U
            WHERE U.ID_AZIENDA = P_ID_AZIENDA
              AND U.ID_UTE = CP.ID_UTE
              AND U.DATA_FINE_ATTIVITA IS NULL
              AND CP.ID_PARTICELLA = recSupVitataParticellaUV.ID_PARTICELLA
              AND CP.DATA_FINE_CONDUZIONE IS NULL;

           recTUtilizzoPart.SUPERFICIE_UTILIZZATA := recSupVitataParticellaUV.TOT_AREA;
           recTUtilizzoPart.DATA_AGGIORNAMENTO := SYSDATE;
           recTUtilizzoPart.ID_UTENTE_AGGIORNAMENTO := P_ID_UTENTE_AGGIORNAMENTO;
           recTUtilizzoPart.ANNO := TO_NUMBER(TO_CHAR(SYSDATE,'YYYY'));
           recTUtilizzoPart.NOTE := 'ALLINEAMENTO DA UV';
           recTUtilizzoPart.ID_VARIETA := recSupVitataParticellaUV.ID_VARIETA;


           recTUtilizzoPart.ID_TIPO_DETTAGLIO_USO := recSupVitataParticellaUV.ID_TIPO_DETTAGLIO_USO;
           recTUtilizzoPart.ID_TIPO_PERIODO_SEMINA := recSupVitataParticellaUV.ID_TIPO_PERIODO_SEMINA;

            recTUtilizzoPart.ID_CATALOGO_MATRICE := recSupVitataParticellaUV.ID_CATALOGO_MATRICE;
            recTUtilizzoPart.DATA_INIZIO_DESTINAZIONE := TO_DATE(recSupVitataParticellaUV.INIZIO_DESTINAZIONE_DEFAULT||'/'||recSupVitataParticellaUV.ANNO,'DD/MM/YYYY');

            IF recSupVitataParticellaUV.INIZIO_DESTINAZIONE_DEFAULT > recSupVitataParticellaUV.FINE_DESTINAZIONE_DEFAULT THEN
              recTUtilizzoPart.DATA_FINE_DESTINAZIONE := TO_DATE(recSupVitataParticellaUV.FINE_DESTINAZIONE_DEFAULT||'/'||(recSupVitataParticellaUV.ANNO + 1),'DD/MM/YYYY');
            ELSE
              recTUtilizzoPart.DATA_FINE_DESTINAZIONE := TO_DATE(recSupVitataParticellaUV.FINE_DESTINAZIONE_DEFAULT||'/'||recSupVitataParticellaUV.ANNO,'DD/MM/YYYY');
            END IF;

            VetRecPratMant := Pck_Smrgaa_Libreria.getListIdPraticaMantenimento(recSupVitataParticellaUV.ID_CATALOGO_MATRICE,'S');
            recTUtilizzoPart.ID_PRATICA_MANTENIMENTO := VetRecPratMant(1).nIdPraticaMantenimento;

           InsertTUtilizzoParticella (recTUtilizzoPart);

        END IF;

        nIdParticella := recSupVitataParticellaUV.ID_PARTICELLA;

    END LOOP;

    -- fuori ciclo eventualmente
    IF nIdParticella <> 0 THEN
       FOR recConduzioneParticella IN curConduzioneParticella (nIdParticella) LOOP
           -- posso aggiustare la superficie utilizzata che ho inserito per i vari utilizzi della particella all'eleggibile
           RiprUtilizziConduzione (P_ID_AZIENDA,nIdParticella,recConduzioneParticella.ID_CONDUZIONE_PARTICELLA);

           -- e ricalcolarmi la condotta come somma dell'utilizzata
           UPDATE DB_CONDUZIONE_PARTICELLA
              SET SUPERFICIE_CONDOTTA = (SELECT SUM(SUPERFICIE_UTILIZZATA)
                                           FROM DB_UTILIZZO_PARTICELLA
                                          WHERE ID_CONDUZIONE_PARTICELLA = recConduzioneParticella.ID_CONDUZIONE_PARTICELLA)
            WHERE ID_CONDUZIONE_PARTICELLA = recConduzioneParticella.ID_CONDUZIONE_PARTICELLA;

        END LOOP;
    END IF;

  SELECT TO_DATE(VALORE_STRINGA||'/'||TO_CHAR(SYSDATE,'YYYY'),'DD/MM/YYYY')
  INTO   dDataSwap
  FROM   DB_ALTRI_DATI
  WHERE  CODICE             = 'DATA_SWAP_SEMINA'
  AND    DATA_FINE_VALIDITA IS NULL;

  IF TRUNC(SYSDATE) < dDataSwap THEN
    vAnno := TO_CHAR(SYSDATE,'YYYY');
  ELSE
    vAnno := TO_CHAR(SYSDATE,'YYYY') + 1;
  END IF;

    -- devo andare per gli utilizzi a vino
    -- su particelle che non presentano piu' unita' vitate attive
    -- ad impostare l'utilizzo ad uso agricolo non definito
    UPDATE DB_UTILIZZO_PARTICELLA UP
       SET (ID_UTILIZZO, ID_VARIETA, ID_TIPO_DETTAGLIO_USO, ID_TIPO_PERIODO_SEMINA,ID_CATALOGO_MATRICE,ID_FASE_ALLEVAMENTO,
            ID_PRATICA_MANTENIMENTO,DATA_FINE_DESTINAZIONE, DATA_INIZIO_DESTINAZIONE)
                                     = (
                                        SELECT TV.ID_UTILIZZO, TV.ID_VARIETA, TDU.ID_TIPO_DETTAGLIO_USO,
                                               CMS.ID_TIPO_PERIODO_SEMINA,CM.ID_CATALOGO_MATRICE,NULL,
                                               8, -- pratica mantenimento: nessuna pratica
                                               TO_DATE('31/12/'||vAnno,'DD/MM/YYYY'),
                                               TO_DATE('01/01/'||vAnno,'DD/MM/YYYY')
                                          FROM DB_TIPO_UTILIZZO TU,
                                               DB_TIPO_VARIETA TV,
                                               DB_TIPO_DETTAGLIO_USO TDU ,
                                               DB_R_CATALOGO_MATRICE CM,DB_TIPO_DESTINAZIONE TD,
                                               DB_TIPO_QUALITA_USO TQU,DB_R_CATALOGO_MATRICE_SEMINA CMS
                                         WHERE TU.CODICE = recDAltriDati.Valore_Stringa -- Uso agricolo da definire
                                           AND TU.ANNO_FINE_VALIDITA IS NULL
                                           AND TU.ID_UTILIZZO = TV.ID_UTILIZZO
                                           AND TV.CODICE_VARIETA = kvCodVarietaGenerica
                                           AND TV.ANNO_FINE_VALIDITA IS NULL
                                           AND TDU.CODICE_DETTAGLIO_USO = kvCodDettaglioUsoGenerico
                                           AND TDU.DATA_FINE_VALIDITA IS NULL
                                           AND CM.ID_VARIETA = TV.ID_VARIETA
                                           AND CM.ID_UTILIZZO = TU.ID_UTILIZZO
                                           AND CM.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO
                                           AND CM.ID_TIPO_DESTINAZIONE = TD.ID_TIPO_DESTINAZIONE
                                           AND CM.ID_TIPO_QUALITA_USO = TQU.ID_TIPO_QUALITA_USO
                                           AND TD.CODICE_DESTINAZIONE = kvCodVarietaGenerica
                                           AND TQU.CODICE_QUALITA_USO = kvCodVarietaGenerica
                                           AND CMS.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE
                                           AND CMS.FLAG_DEFAULT = 'S'
                                           ),
           DATA_AGGIORNAMENTO = SYSDATE,
           ID_UTENTE_AGGIORNAMENTO = P_ID_UTENTE_AGGIORNAMENTO,
           NOTE = 'ALLINEAMENTO DA UV'
     WHERE ID_CONDUZIONE_PARTICELLA IN
        (SELECT CP.ID_CONDUZIONE_PARTICELLA
           FROM DB_CONDUZIONE_PARTICELLA CP,
                DB_UTE U,
                DB_STORICO_PARTICELLA SP,
                COMUNE C,
                PROVINCIA P
          WHERE U.ID_AZIENDA = P_ID_AZIENDA
            AND U.ID_UTE = CP.ID_UTE
            AND U.DATA_FINE_ATTIVITA IS NULL
            AND CP.DATA_FINE_CONDUZIONE IS NULL
            AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
            AND SP.DATA_FINE_VALIDITA IS NULL
            AND SP.COMUNE = C.ISTAT_COMUNE
            AND C.ISTAT_PROVINCIA = P.ISTAT_PROVINCIA
            AND P.ID_REGIONE = kvIdRegionePiemonte
            AND NOT EXISTS( SELECT SUA.ID_STORICO_UNITA_ARBOREA
                              FROM DB_STORICO_UNITA_ARBOREA SUA
                             WHERE SUA.ID_AZIENDA = P_ID_AZIENDA
                               AND SUA.DATA_FINE_VALIDITA IS NULL
                               AND SUA.ID_PARTICELLA = CP.ID_PARTICELLA
                               AND SUA.ID_CATALOGO_MATRICE IS NOT NULL)) 
       AND UP.ID_CATALOGO_MATRICE IN
        (SELECT CM.ID_CATALOGO_MATRICE  
           FROM DB_TIPO_UTILIZZO TU,DB_R_CATALOGO_MATRICE CM
          WHERE TU.TIPO = 'V'
          AND   CM.ID_UTILIZZO = TU.ID_UTILIZZO);


EXCEPTION
    WHEN EsciRountine THEN
         NULL;
    WHEN OTHERS THEN
         P_MSGERR := 'ERRORE GRAVE NELL''ALLINEAMENTO DEL PIANO COLTURALE DALLE UV. CONTATTARE L''ASSISTENZA:' || SQLERRM||' - RIGA = '||dbms_utility.FORMAT_ERROR_BACKTRACE;
         P_CODERR := SQLCODE;
END RIBALTA_UV;

END Pack_Ribalta_Uv_Su_Pcolturale;          -- Package

/
--------------------------------------------------------
--  DDL for Package Body PACK_RIPRISTINA_DICHIARAZIONE
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PACK_RIPRISTINA_DICHIARAZIONE" IS


EsciRountine       EXCEPTION;
--ERR_GEN              TMP_LOG.COD_ERRORE%TYPE               := '999999';
ERR_GEN              VARCHAR2(10)               := '999999';
S_MSGERR    VARCHAR2(1000);
P_CODERR    VARCHAR2(1000);
N_ID_UTILIZZO_PARTICELLA            DB_UTILIZZO_PARTICELLA.ID_UTILIZZO_PARTICELLA%TYPE;
N_CODICE_FOTOGRAFIA_TERRENI         DB_DICHIARAZIONE_CONSISTENZA.CODICE_FOTOGRAFIA_TERRENI%TYPE;
N_ID_CONDUZIONE_DICHIARATA          DB_CONDUZIONE_DICHIARATA.ID_CONDUZIONE_DICHIARATA%TYPE;
N_ID_UTILIZZO_DICHIARATO            DB_UTILIZZO_DICHIARATO.ID_UTILIZZO_DICHIARATO%TYPE;
D_DATA_DICHIARAZIONE                    DB_DICHIARAZIONE_CONSISTENZA.DATA%TYPE;
N_ID_AZIENDA                            DB_AZIENDA.ID_AZIENDA%TYPE;
N_ID_CONDUZIONE_PARTICELLA         DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
N_ID_CONDUZIONE_PARTICELLA_DOC     DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
N_ID_FABBRICATO                        DB_FABBRICATO.ID_FABBRICATO%TYPE;
N_ID_FABBRICATO_NEW                    DB_FABBRICATO.ID_FABBRICATO%TYPE;
N_ID_ALLEVAMENTO                             DB_ALLEVAMENTO.ID_ALLEVAMENTO%TYPE;
N_ID_ALLEVAMENTO_NEW                   DB_ALLEVAMENTO.ID_ALLEVAMENTO%TYPE;
N_ID_CATEGORIE_ALLEVAMENTO            DB_CATEGORIE_ALLEVAMENTO.ID_CATEGORIE_ALLEVAMENTO%TYPE;
N_ID_CATEGORIE_ALLEVAMENTO_NEW    DB_CATEGORIE_ALLEVAMENTO.ID_CATEGORIE_ALLEVAMENTO%TYPE;
N_ID_SOTTOCAT_ALLEVAMENTO            DB_SOTTOCATEGORIA_ALLEVAMENTO.ID_SOTTOCATEGORIA_ALLEVAMENTO%TYPE;
N_ID_SOTTOCAT_ALLEVAMENTO_NEW     DB_SOTTOCATEGORIA_ALLEVAMENTO.ID_SOTTOCATEGORIA_ALLEVAMENTO%TYPE;
N_ID_STABULAZIONE_TRATT_NEW         DB_STABULAZIONE_TRATTAMENTO.ID_STABULAZIONE_TRATTAMENTO%TYPE;
N_ID_STABULAZIONE_TRATT                 DB_STABULAZIONE_TRATTAMENTO.ID_STABULAZIONE_TRATTAMENTO%TYPE;

N_ID_MANODOPERA                       DB_MANODOPERA.ID_MANODOPERA%TYPE;
N_MAX_ID_ALLEVAMENTO                   DB_ALLEVAMENTO.ID_ALLEVAMENTO%TYPE;
N_MAX_ID_FABBRICATO                  DB_FABBRICATO.ID_FABBRICATO%TYPE;
N_ID_ATTESTAZIONE_AZIENDA_NEW        DB_ATTESTAZIONE_AZIENDA.ID_ATTESTAZIONE_AZIENDA%TYPE;

VarPart                                    NUM_VARRAY;
VarPartNull                                NUM_VARRAY    := NULL;
nLoop                                        NUMBER;

recCatalogoMatrice     DB_R_CATALOGO_MATRICE%ROWTYPE;
recCatalogoMatriceSec  DB_R_CATALOGO_MATRICE%ROWTYPE;

-- aggiunta PERCENTUALE_POSSESSO
CURSOR C_CONDUZIONE_DICHIARATA IS
       SELECT *
       FROM DB_CONDUZIONE_DICHIARATA
       WHERE CODICE_FOTOGRAFIA_TERRENI = N_CODICE_FOTOGRAFIA_TERRENI
       ORDER BY ID_CONDUZIONE_PARTICELLA;

CURSOR C_UTILIZZO_DICHIARATO IS
       SELECT /*ID_UTILIZZO_DICHIARATO, CODICE_FOTOGRAFIA_TERRENI, ID_CONDUZIONE_DICHIARATA, ANNO, ID_UTILIZZO_SECONDARIO,
                 SUPERFICIE_UTILIZZATA, NOTE, DATA_AGGIORNAMENTO, SUP_UTILIZZATA_SECONDARIA,
              ID_UTENTE_AGGIORNAMENTO,SHAPE,ID_SHAPE,
              ANNO_IMPIANTO, ID_IMPIANTO, SESTO_SU_FILE,SESTO_TRA_FILE, NUMERO_PIANTE_CEPPI,*/
              DECODE(CM.ID_TIPO_DESTINAZIONE,NULL,(SELECT MIN(CMNEW.ID_CATALOGO_MATRICE)
                                                   FROM   DB_R_CATALOGO_MATRICE CMNEW
                                                   WHERE  CMNEW.ID_CATALOGO_MATRICE_PADRE = CM.ID_CATALOGO_MATRICE
                                                   AND    CMNEW.DATA_FINE_VALIDITA        IS NULL), CM.ID_CATALOGO_MATRICE) CATALOGO_MATRICE,
              DECODE(CM_SEC.ID_TIPO_DESTINAZIONE,NULL,(SELECT MIN(CMNEW.ID_CATALOGO_MATRICE)
                                                       FROM   DB_R_CATALOGO_MATRICE CMNEW
                                                       WHERE  CMNEW.ID_CATALOGO_MATRICE_PADRE = CM_SEC.ID_CATALOGO_MATRICE
                                                       AND    CMNEW.DATA_FINE_VALIDITA        IS NULL), CM_SEC.ID_CATALOGO_MATRICE) CATALOGO_MATRICE_SEC,
              UD.*
 
       FROM DB_UTILIZZO_DICHIARATO UD,DB_R_CATALOGO_MATRICE CM,DB_R_CATALOGO_MATRICE CM_SEC
       WHERE UD.ID_CONDUZIONE_DICHIARATA = N_ID_CONDUZIONE_DICHIARATA
       AND CM.ID_CATALOGO_MATRICE = UD.ID_CATALOGO_MATRICE  
       AND UD.ID_CATALOGO_MATRICE_SECONDARIO = CM_SEC.ID_CATALOGO_MATRICE(+); 


CURSOR C_UTILIZZO_CONSOCIATO_DICH IS
       SELECT ID_UTILIZZO_CONSOCIATO_DICH, ID_UTILIZZO_DICHIARATO, ID_PIANTE_CONSOCIATE, NUMERO_PIANTE
       FROM DB_UTILIZZO_CONSOCIATO_DICH
       WHERE ID_UTILIZZO_DICHIARATO = N_ID_UTILIZZO_DICHIARATO;

CURSOR C_DOCUMENTO_CONDUZIONE IS
       SELECT ID_DOCUMENTO_CONDUZIONE, ID_CONDUZIONE_PARTICELLA, A.ID_DOCUMENTO, A.DATA_INSERIMENTO, A.DATA_INIZIO_VALIDITA,
                 A.DATA_FINE_VALIDITA
         FROM DB_DOCUMENTO_CONDUZIONE A, DB_DOCUMENTO B
        WHERE A.ID_DOCUMENTO = B.ID_DOCUMENTO
--          AND A.DATA_FINE_VALIDITA IS NULL            -- BM001
          AND TRUNC(NVL(A.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','DD/MM/YYYY')))  >= TRUNC(D_DATA_DICHIARAZIONE)    -- BM001
          AND    TRUNC(A.DATA_INIZIO_VALIDITA)  < TRUNC(D_DATA_DICHIARAZIONE)            -- BM001
          AND A.ID_CONDUZIONE_PARTICELLA = N_ID_CONDUZIONE_PARTICELLA_DOC
          AND (B.ID_STATO_DOCUMENTO IS NULL OR B.ID_STATO_DOCUMENTO = 2) 
          AND B.EXT_ID_DOCUMENTO NOT IN (SELECT ID_DOCUMENTO    
                                           FROM DB_TIPO_CATEGORIA_DOCUMENTO TCD,
                                                DB_DOCUMENTO_CATEGORIA DC
                                          WHERE TCD.TIPO_IDENTIFICATIVO = 'TC'
                                            AND TCD.ID_CATEGORIA_DOCUMENTO = DC.ID_CATEGORIA_DOCUMENTO);

CURSOR C_ALLEVAMENTO_ATTIVO IS
       SELECT ID_ALLEVAMENTO
         FROM DB_ALLEVAMENTO AL, DB_UTE U
        WHERE AL.ID_UTE = U.ID_UTE
          AND U.ID_AZIENDA = N_ID_AZIENDA
          AND AL.DATA_FINE IS NULL
          AND ID_ALLEVAMENTO > N_MAX_ID_ALLEVAMENTO;

CURSOR C_ALLEVAMENTO IS
       SELECT AL.*
         FROM DB_ALLEVAMENTO AL, DB_UTE U
        WHERE AL.ID_UTE = U.ID_UTE
          AND U.ID_AZIENDA = N_ID_AZIENDA
          AND AL.DATA_INIZIO < D_DATA_DICHIARAZIONE
          AND NVL(AL.DATA_FINE,TO_DATE('31/12/9999','DD/MM/YYYY')) > D_DATA_DICHIARAZIONE;

CURSOR C_CATEGORIE_ALLEVAMENTO IS
       SELECT ID_CATEGORIE_ALLEVAMENTO, ID_CATEGORIA_ANIMALE, QUANTITA,PESO_VIVO_UNITARIO
         FROM DB_CATEGORIE_ALLEVAMENTO
        WHERE ID_ALLEVAMENTO = N_ID_ALLEVAMENTO;

CURSOR C_SOTTOCATEGORIA_ALLEVAMENTO IS
        SELECT * FROM DB_SOTTOCATEGORIA_ALLEVAMENTO
        WHERE ID_CATEGORIE_ALLEVAMENTO = N_ID_CATEGORIE_ALLEVAMENTO;


CURSOR C_STABULAZIONE_TRATTAMENTO IS
        SELECT * FROM DB_STABULAZIONE_TRATTAMENTO
        WHERE ID_SOTTOCATEGORIA_ALLEVAMENTO = N_ID_SOTTOCAT_ALLEVAMENTO;

CURSOR C_FABBRICATO_ATTIVO IS
       SELECT ID_FABBRICATO
         FROM DB_FABBRICATO FB, DB_UTE U
        WHERE FB.ID_UTE = U.ID_UTE
          AND U.ID_AZIENDA = N_ID_AZIENDA
          AND FB.DATA_FINE_VALIDITA IS NULL
          AND ID_FABBRICATO > N_MAX_ID_FABBRICATO;

CURSOR C_FABBRICATO IS
       SELECT ID_FABBRICATO, ID_TIPOLOGIA_FABBRICATO, ID_FORMA_FABBRICATO, FB.DENOMINAZIONE,
                 SUPERFICIE, ANNO_COSTRUZIONE, DIMENSIONE, LUNGHEZZA, LARGHEZZA, ALTEZZA, UTM_X,
              UTM_Y, FB.NOTE, FB.ID_UTE, DATA_INIZIO_VALIDITA, DATA_FINE_VALIDITA, ID_COLTURA_SERRA, MESI_RISCALDAMENTO_SERRA,
              ORE_RISCALDAMENTO_SERRA,VOLUME_UTILE_PRESUNTO, SUPERFICIE_COPERTA, SUPERFICIE_SCOPERTA,SUPERFICIE_SCOPERTA_EXTRA
         FROM DB_FABBRICATO FB, DB_UTE U
        WHERE FB.ID_UTE = U.ID_UTE
          AND U.ID_AZIENDA = N_ID_AZIENDA
          AND FB.DATA_INIZIO_VALIDITA < D_DATA_DICHIARAZIONE
          AND NVL(FB.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','DD/MM/YYYY')) > D_DATA_DICHIARAZIONE;

CURSOR C_FABBRICATO_PARTICELLA IS
       SELECT ID_FABBRICATO_PARTICELLA, ID_FABBRICATO, ID_PARTICELLA, DATA_INIZIO_VALIDITA
         FROM DB_FABBRICATO_PARTICELLA
        WHERE ID_FABBRICATO = N_ID_FABBRICATO
          AND DATA_FINE_VALIDITA IS NULL;

CURSOR C_ATTESTAZIONE_DICHIARATA IS
    SELECT ID_ATTESTAZIONE,ID_ATTESTAZIONE_DICHIARATA
     FROM DB_ATTESTAZIONE_DICHIARATA
    WHERE CODICE_FOTOGRAFIA_TERRENI = N_CODICE_FOTOGRAFIA_TERRENI;

PROCEDURE RIPRISTINA_DICHIARAZIONE(P_ID_DICHIARAZIONE             IN     DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                      P_ID_UTENTE_AGGIORNAMENTO IN     DB_DICHIARAZIONE_CONSISTENZA.ID_UTENTE%TYPE,
                                   P_MSGERR                       IN OUT VARCHAR2,
                                   P_CODERR                    IN OUT VARCHAR2)IS

BEGIN

     BEGIN
         SELECT CODICE_FOTOGRAFIA_TERRENI, ID_AZIENDA, DATA_INSERIMENTO_DICHIARAZIONE
           INTO N_CODICE_FOTOGRAFIA_TERRENI, N_ID_AZIENDA, D_DATA_DICHIARAZIONE
           FROM DB_DICHIARAZIONE_CONSISTENZA
          WHERE ID_DICHIARAZIONE_CONSISTENZA = P_ID_DICHIARAZIONE;
     EXCEPTION
     WHEN NO_DATA_FOUND THEN
         P_MSGERR := 'ERRORE NEL REPERIMENTO DELLA CONSISTENZA. CONTATTARE L''ASSISTENZA COMUNICANDO ID_DICHIARAZIONE: ' || TO_CHAR(P_ID_DICHIARAZIONE);
         P_CODERR := ERR_GEN;
     WHEN OTHERS THEN
         P_MSGERR := 'ERRORE NEL REPERIMENTO DELLA CONSISTENZA. CONTATTARE L''ASSISTENZA COMUNICANDO IL SEGUENTE ERRORE: ' || SQLERRM;
         P_CODERR := SQLCODE;
     END;

     UPDATE DB_CONDUZIONE_PARTICELLA SET DATA_FINE_CONDUZIONE = SYSDATE, ESITO_CONTROLLO = NULL, DATA_ESECUZIONE = NULL
     WHERE DATA_FINE_CONDUZIONE IS NULL AND ID_UTE IN (SELECT ID_UTE
                                                               FROM DB_UTE U
                                                        WHERE ID_AZIENDA = N_ID_AZIENDA
                                                          AND U.DATA_FINE_ATTIVITA IS NULL);

     FOR REC_CONDUZIONE_DICHIARATA IN C_CONDUZIONE_DICHIARATA LOOP
          N_ID_CONDUZIONE_DICHIARATA := REC_CONDUZIONE_DICHIARATA.ID_CONDUZIONE_DICHIARATA;
         N_ID_CONDUZIONE_PARTICELLA_DOC := REC_CONDUZIONE_DICHIARATA.ID_CONDUZIONE_PARTICELLA;

          SELECT SEQ_CONDUZIONE_PARTICELLA.NEXTVAL INTO N_ID_CONDUZIONE_PARTICELLA FROM DUAL;

          INSERT INTO DB_CONDUZIONE_PARTICELLA (ID_CONDUZIONE_PARTICELLA, ID_PARTICELLA, ID_TITOLO_POSSESSO, ID_UTE,
                 SUPERFICIE_CONDOTTA, FLAG_UTILIZZO_PARTE, DATA_INIZIO_CONDUZIONE, DATA_FINE_CONDUZIONE, NOTE,
                DATA_AGGIORNAMENTO, ID_UTENTE_AGGIORNAMENTO, ESITO_CONTROLLO, DATA_ESECUZIONE, RECORD_MODIFICATO,
                DICHIARAZIONE_RIPRISTINATA, ID_DICHIARAZIONE_CONSISTENZA, PERCENTUALE_POSSESSO) 
         VALUES (N_ID_CONDUZIONE_PARTICELLA, REC_CONDUZIONE_DICHIARATA.ID_PARTICELLA, REC_CONDUZIONE_DICHIARATA.ID_TITOLO_POSSESSO,
                 REC_CONDUZIONE_DICHIARATA.ID_UTE, REC_CONDUZIONE_DICHIARATA.SUPERFICIE_CONDOTTA, NULL,
                SYSDATE, NULL, 'RIPRISTINO DICHIARAZIONE', SYSDATE, P_ID_UTENTE_AGGIORNAMENTO, NULL, NULL, NULL, 'S', P_ID_DICHIARAZIONE, REC_CONDUZIONE_DICHIARATA.PERCENTUALE_POSSESSO);

         FOR REC_UTILIZZO_DICHIARATO IN C_UTILIZZO_DICHIARATO LOOP
           IF REC_UTILIZZO_DICHIARATO.CATALOGO_MATRICE IS NOT NULL THEN
             SELECT *
             INTO   recCatalogoMatrice
             FROM   DB_R_CATALOGO_MATRICE
             WHERE  ID_CATALOGO_MATRICE = REC_UTILIZZO_DICHIARATO.CATALOGO_MATRICE;


             BEGIN
               SELECT *
               INTO   recCatalogoMatriceSec
               FROM   DB_R_CATALOGO_MATRICE
               WHERE  ID_CATALOGO_MATRICE = REC_UTILIZZO_DICHIARATO.CATALOGO_MATRICE_SEC;
             EXCEPTION
               WHEN NO_DATA_FOUND THEN
                 recCatalogoMatriceSec := NULL;
             END;

             SELECT SEQ_UTILIZZO_PARTICELLA.NEXTVAL INTO N_ID_UTILIZZO_PARTICELLA FROM DUAL;

             INSERT INTO DB_UTILIZZO_PARTICELLA (ID_UTILIZZO_PARTICELLA, ID_UTILIZZO,
                         ID_CONDUZIONE_PARTICELLA, SUPERFICIE_UTILIZZATA, DATA_AGGIORNAMENTO,
                        ID_UTENTE_AGGIORNAMENTO, ANNO, NOTE, ID_UTILIZZO_SECONDARIO, SUP_UTILIZZATA_SECONDARIA, ID_VARIETA,
                        ID_VARIETA_SECONDARIA, ANNO_IMPIANTO, ID_IMPIANTO, SESTO_SU_FILE, SESTO_TRA_FILE, NUMERO_PIANTE_CEPPI,
                        ID_TIPO_DETTAGLIO_USO, ID_TIPO_DETT_USO_SECONDARIO, ID_TIPO_EFA, VALORE_ORIGINALE,
                        VALORE_DOPO_CONVERSIONE, VALORE_DOPO_PONDERAZIONE, ID_TIPO_PERIODO_SEMINA, ID_TIPO_PERIODO_SEMINA_SECOND,
                        ID_SEMINA, ID_SEMINA_SECONDARIA, ID_CATALOGO_MATRICE, DATA_INIZIO_DESTINAZIONE,
                        DATA_FINE_DESTINAZIONE, ID_FASE_ALLEVAMENTO, ID_PRATICA_MANTENIMENTO,
                        ID_CATALOGO_MATRICE_SECONDARIO, DATA_INIZIO_DESTINAZIONE_SEC,
                        DATA_FINE_DESTINAZIONE_SEC, ID_ISOLA_GRAFICA, ID_APPEZZAMENTO, ID_SHAPE, SHAPE
                        )
             VALUES (N_ID_UTILIZZO_PARTICELLA, recCatalogoMatrice.ID_UTILIZZO,
                     N_ID_CONDUZIONE_PARTICELLA, REC_UTILIZZO_DICHIARATO.SUPERFICIE_UTILIZZATA,
                     SYSDATE, P_ID_UTENTE_AGGIORNAMENTO, TO_NUMBER(TO_CHAR(SYSDATE,'yyyy')), 'RIPRISTINO DICHIARAZIONE ',
                     recCatalogoMatriceSec.ID_UTILIZZO,
                     REC_UTILIZZO_DICHIARATO.SUP_UTILIZZATA_SECONDARIA,
                     recCatalogoMatrice.ID_VARIETA,
                     recCatalogoMatriceSec.ID_VARIETA ,
                     REC_UTILIZZO_DICHIARATO.ANNO_IMPIANTO, REC_UTILIZZO_DICHIARATO.ID_IMPIANTO,
                     REC_UTILIZZO_DICHIARATO.SESTO_SU_FILE, REC_UTILIZZO_DICHIARATO.SESTO_TRA_FILE,
                     REC_UTILIZZO_DICHIARATO.NUMERO_PIANTE_CEPPI,
                     recCatalogoMatrice.ID_TIPO_DETTAGLIO_USO, 
                     recCatalogoMatriceSec.ID_TIPO_DETTAGLIO_USO, 
                     REC_UTILIZZO_DICHIARATO.ID_TIPO_EFA, 
                     REC_UTILIZZO_DICHIARATO.VALORE_ORIGINALE, 
                     REC_UTILIZZO_DICHIARATO.VALORE_DOPO_CONVERSIONE, 
                     REC_UTILIZZO_DICHIARATO.VALORE_DOPO_PONDERAZIONE, 
                     NVL(REC_UTILIZZO_DICHIARATO.ID_TIPO_PERIODO_SEMINA, (SELECT ID_TIPO_PERIODO_SEMINA
                                                FROM DB_R_CATALOGO_MATRICE_SEMINA
                                               WHERE ID_CATALOGO_MATRICE = recCatalogoMatrice.ID_CATALOGO_MATRICE
                                               AND   FLAG_DEFAULT = 'S')),
                     NVL(REC_UTILIZZO_DICHIARATO.ID_TIPO_PERIODO_SEMINA_SECOND, (SELECT ID_TIPO_PERIODO_SEMINA
                                                FROM DB_R_CATALOGO_MATRICE_SEMINA
                                               WHERE ID_CATALOGO_MATRICE = recCatalogoMatriceSec.ID_CATALOGO_MATRICE
                                               AND   FLAG_DEFAULT = 'S')),
                     REC_UTILIZZO_DICHIARATO.ID_SEMINA, REC_UTILIZZO_DICHIARATO.ID_SEMINA_SECONDARIA, recCatalogoMatrice.ID_CATALOGO_MATRICE, REC_UTILIZZO_DICHIARATO.DATA_INIZIO_DESTINAZIONE,
                     REC_UTILIZZO_DICHIARATO.DATA_FINE_DESTINAZIONE, REC_UTILIZZO_DICHIARATO.ID_FASE_ALLEVAMENTO, REC_UTILIZZO_DICHIARATO.ID_PRATICA_MANTENIMENTO,
                     recCatalogoMatriceSec.ID_CATALOGO_MATRICE, REC_UTILIZZO_DICHIARATO.DATA_INIZIO_DESTINAZIONE_SEC,
                     REC_UTILIZZO_DICHIARATO.DATA_FINE_DESTINAZIONE_SEC, REC_UTILIZZO_DICHIARATO.ID_ISOLA_GRAFICA, REC_UTILIZZO_DICHIARATO.ID_APPEZ, REC_UTILIZZO_DICHIARATO.ID_SHAPE, REC_UTILIZZO_DICHIARATO.SHAPE);


              FOR REC_UTILIZZO_CONSOCIATO_DICH IN C_UTILIZZO_CONSOCIATO_DICH LOOP
                  INSERT INTO DB_UTILIZZO_CONSOCIATO (ID_UTILIZZO_CONSOCIATO, ID_UTILIZZO_PARTICELLA, ID_PIANTE_CONSOCIATE, NUMERO_PIANTE)
                  VALUES (SEQ_UTILIZZO_CONSOCIATO.NEXTVAL, N_ID_UTILIZZO_PARTICELLA, REC_UTILIZZO_CONSOCIATO_DICH.ID_PIANTE_CONSOCIATE, REC_UTILIZZO_CONSOCIATO_DICH.NUMERO_PIANTE);
              END LOOP;
           END IF;
         END LOOP;

         FOR REC_DOCUMENTO_CONDUZIONE IN C_DOCUMENTO_CONDUZIONE LOOP
              INSERT INTO DB_DOCUMENTO_CONDUZIONE (ID_DOCUMENTO_CONDUZIONE, ID_CONDUZIONE_PARTICELLA, ID_DOCUMENTO,
                     DATA_INSERIMENTO, DATA_INIZIO_VALIDITA, DATA_FINE_VALIDITA)
             VALUES (SEQ_DOCUMENTO_CONDUZIONE.NEXTVAL, N_ID_CONDUZIONE_PARTICELLA,REC_DOCUMENTO_CONDUZIONE.ID_DOCUMENTO,
                     SYSDATE, SYSDATE, NULL);
             UPDATE DB_DOCUMENTO_CONDUZIONE SET DATA_FINE_VALIDITA = SYSDATE WHERE ID_DOCUMENTO_CONDUZIONE = REC_DOCUMENTO_CONDUZIONE.ID_DOCUMENTO_CONDUZIONE;
         END LOOP;

     END LOOP;

    -- UNITA ARBOREE
    UPDATE DB_STORICO_UNITA_ARBOREA
    SET data_fine_validita    =    SYSDATE
    WHERE id_storico_unita_arborea IN (    SELECT DISTINCT c.id_storico_unita_arborea
                                                    FROM   DB_UTE a,
                                                           DB_CONDUZIONE_PARTICELLA b,
                                                           DB_STORICO_UNITA_ARBOREA c
                                                    WHERE a.id_Azienda                =    N_ID_AZIENDA
                                                    AND     a.id_ute                        =    b.id_ute
                                                    AND     b.data_fine_conduzione     IS NULL
                                                    AND     b.id_particella            =    c.id_particella
                                                    AND     c.id_azienda                =    a.id_azienda
                                                    AND     c.data_fine_validita     IS NULL
                                                 );
    
    INSERT INTO DB_STORICO_UNITA_ARBOREA (ID_STORICO_UNITA_ARBOREA,
                                          ID_UNITA_ARBOREA,
                                          ID_PARTICELLA,
                                          PROGR_UNAR,
                                          DATA_INIZIO_VALIDITA,
                                          DATA_FINE_VALIDITA,
                                          DATA_LAVORAZIONE,
                                          ID_TIPOLOGIA_UNAR,
                                          AREA,
                                          SESTO_SU_FILA,
                                          SESTO_TRA_FILE,
                                          NUM_CEPPI,
                                          ANNO_IMPIANTO,
                                          ANNO_REINNESTO,
                                          ID_FORMA_ALLEVAMENTO,
                                          ID_IRRIGAZIONE_UNAR,
                                          ID_COLTIVAZIONE_UNAR,
                                          CODICE_TIPO_VARIETA,
                                          PRESENZA_ALTRI_VITIGNI,
                                          NUMERO_PIANTE_PRODUTTIVO,
                                          NUMERO_ALTRE_PIANTE,
                                          CAMPAGNA,
                                          ID_TIPOLOGIA_VIGNETO,
                                          TIPO_IMPIANTO,
                                          NUMERO_CASTAGNI,
                                          GRUPPO,
                                          RICADUTA,
                                          ID_GIACITURA_UNAR,
                                          ID_ROCCIA_UNAR,
                                          ID_SCHELETRO_UNAR,
                                          ID_STATO_VEGETATIVO_UNAR,
                                          ID_POTATURA_UNAR,
                                          ID_GIUDIZIO_UNAR,
                                          SUPPLEMENTARI,
                                          MECCANIZZABILE,
                                          DIMENSIONE_CHIOMA,
                                          ID_ETA_IMPIANTO_UNAR,
                                          PROVINCIA_CCIAA,
                                          MATRICOLA_CCIAA,
                                          CONFERMA_PREC_ISCRIZIONE_ALBO,
                                          RICHIESTA_NUOVA_ISCR_ALBO,
                                          CONFERMA_RICH_NUOVA_ISCR_ALBO,
                                          SUPERFICIE_DA_ISCRIVERE_ALBO,
                                          ANNO_ISCRIZIONE_ALBO,
                                          ID_FONTE,
                                          ID_VARIAZIONE_UNAR,
                                          NOTE,
                                          DATA_AGGIORNAMENTO,
                                          ID_UTENTE_AGGIORNAMENTO,
                                          ID_VARIETA,
                                          ID_UTILIZZO,
                                          PERCENTUALE_VARIETA,
                                          ID_VINO,
                                          RECORD_MODIFICATO,
                                          DATA_ESECUZIONE,
                                          ESITO_CONTROLLO,
                                          ID_AZIENDA,
                                          ID_TIPOLOGIA_VINO,
                                          ID_CAUSALE_MODIFICA,
                                          DATA_CESSAZIONE,
                                          ID_CESSAZIONE_UNAR,
                                          STATO_UNITA_ARBOREA,
                                          ANNO_RIFERIMENTO,
                                          COLTURA_SPECIALIZZATA,
                                          DATA_ISCRIZIONE_ALBO,
                                          ANNO_PRIMA_PRODUZIONE,
                                          VIGNA,
                                          ID_GENERE_ISCRIZIONE,
                                          DATA_IMPIANTO,
                                          DATA_PRIMA_PRODUZIONE,
                                          ID_VIGNA,
                                          ETICHETTA,
                                          ID_MENZIONE_GEOGRAFICA,
                                          FLAG_IMPRODUTTIVA,
                                          PERCENTUALE_FALLANZA,
                                          ID_CATALOGO_MATRICE) 
   SELECT SEQ_STORICO_UNITA_ARBOREA.NEXTVAL,
          c.ID_UNITA_ARBOREA,
          c.ID_PARTICELLA,
          b.PROGR_UNAR,
          SYSDATE,
          NULL,
          b.DATA_LAVORAZIONE,
          b.ID_TIPOLOGIA_UNAR,
          b.AREA,
          b.SESTO_SU_FILA,
          b.SESTO_TRA_FILE,
          b.NUM_CEPPI,
          b.ANNO_IMPIANTO,
          b.ANNO_REINNESTO,
          b.ID_FORMA_ALLEVAMENTO,
          b.ID_IRRIGAZIONE_UNAR,
          b.ID_COLTIVAZIONE_UNAR,
          b.CODICE_TIPO_VARIETA,
          b.PRESENZA_ALTRI_VITIGNI,
          b.NUMERO_PIANTE_PRODUTTIVO,
          b.NUMERO_ALTRE_PIANTE,
          b.CAMPAGNA,
          b.ID_TIPOLOGIA_VIGNETO,
          b.TIPO_IMPIANTO,
          b.NUMERO_CASTAGNI,
          b.GRUPPO,
          b.RICADUTA,
          b.ID_GIACITURA_UNAR,
          b.ID_ROCCIA_UNAR,
          b.ID_SCHELETRO_UNAR,
          b.ID_STATO_VEGETATIVO_UNAR,
          b.ID_POTATURA_UNAR,
          b.ID_GIUDIZIO_UNAR,
          b.SUPPLEMENTARI,
          b.MECCANIZZABILE,
          b.DIMENSIONE_CHIOMA,
          b.ID_ETA_IMPIANTO_UNAR,
          b.PROVINCIA_CCIAA,
          b.MATRICOLA_CCIAA,
          b.CONFERMA_PREC_ISCRIZIONE_ALBO,
          b.RICHIESTA_NUOVA_ISCR_ALBO,
          b.CONFERMA_RICH_NUOVA_ISCR_ALBO,
          b.SUPERFICIE_DA_ISCRIVERE_ALBO,
          b.ANNO_ISCRIZIONE_ALBO,
          b.ID_FONTE,
          b.ID_VARIAZIONE_UNAR,
          'RIPRISTINO DICHIARAZIONE',
          SYSDATE,
          P_ID_UTENTE_AGGIORNAMENTO,
          DECODE(CM.ID_TIPO_DESTINAZIONE,NULL,(SELECT MIN(CMNEW.ID_VARIETA)
                                               FROM   DB_R_CATALOGO_MATRICE CMNEW
                                               WHERE  CMNEW.ID_CATALOGO_MATRICE_PADRE = CM.ID_CATALOGO_MATRICE
                                               AND    CMNEW.DATA_FINE_VALIDITA        IS NULL), CM.ID_VARIETA),
          DECODE(CM.ID_TIPO_DESTINAZIONE,NULL,(SELECT MIN(CMNEW.ID_UTILIZZO)
                                               FROM   DB_R_CATALOGO_MATRICE CMNEW
                                               WHERE  CMNEW.ID_CATALOGO_MATRICE_PADRE = CM.ID_CATALOGO_MATRICE
                                               AND    CMNEW.DATA_FINE_VALIDITA        IS NULL), CM.ID_UTILIZZO),
          b.PERCENTUALE_VARIETA,
          b.ID_VINO,
          'S',
          NULL,
          NULL,
          b.ID_AZIENDA,
          b.ID_TIPOLOGIA_VINO,
          NVL (c.ID_CAUSALE_MODIFICA, 3),
          b.DATA_CESSAZIONE,
          b.ID_CESSAZIONE_UNAR,
          b.STATO_UNITA_ARBOREA,
          b.ANNO_RIFERIMENTO,
          b.COLTURA_SPECIALIZZATA,
          b.DATA_ISCRIZIONE_ALBO,
          b.ANNO_PRIMA_PRODUZIONE,
          b.VIGNA,
          b.ID_GENERE_ISCRIZIONE,
          b.DATA_IMPIANTO,
          b.DATA_PRIMA_PRODUZIONE,
          b.ID_VIGNA,
          b.ETICHETTA,
          b.ID_MENZIONE_GEOGRAFICA,
          b.FLAG_IMPRODUTTIVA,
          b.PERCENTUALE_FALLANZA,
          DECODE(CM.ID_TIPO_DESTINAZIONE,NULL,(SELECT MIN(CMNEW.ID_CATALOGO_MATRICE)
                                               FROM   DB_R_CATALOGO_MATRICE CMNEW
                                               WHERE  CMNEW.ID_CATALOGO_MATRICE_PADRE = CM.ID_CATALOGO_MATRICE
                                               AND    CMNEW.DATA_FINE_VALIDITA        IS NULL), CM.ID_CATALOGO_MATRICE)
     FROM DB_DICHIARAZIONE_CONSISTENZA a,
          DB_UNITA_ARBOREA_DICHIARATA b,
          DB_STORICO_UNITA_ARBOREA c,
          DB_R_CATALOGO_MATRICE CM
    WHERE a.id_dichiarazione_consistenza = P_ID_DICHIARAZIONE
      AND a.codice_fotografia_terreni = b.codice_fotografia_terreni
      AND b.ID_STORICO_UNITA_ARBOREA = c.ID_STORICO_UNITA_ARBOREA
      AND B.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE;

    VarPart := NUM_VARRAY();
    nLoop := 0;
    FOR REC_PART IN     (    SELECT DISTINCT c.id_particella
                                FROM      DB_UTE a,
                                       DB_CONDUZIONE_PARTICELLA b,
                                       DB_STORICO_UNITA_ARBOREA c
                                WHERE a.id_Azienda                =    N_ID_AZIENDA
                                AND     a.id_ute                        =    b.id_ute
                                AND     b.data_fine_conduzione     IS NULL
                                AND     b.id_particella            =    c.id_particella
                                AND     c.id_azienda                =    a.id_azienda
                                AND     c.data_fine_validita     IS NULL ) LOOP

            nLoop :=    nLoop + 1;


            VarPart.EXTEND;

            VarPart(nLoop) := REC_PART.ID_PARTICELLA;

            IF nLoop > 99 THEN

                Pack_Aggiorna_Uv.AGGIORNA_STATO_UV( VarPart, P_CODERR, P_MSGERR );
                 IF P_CODERR IS NOT NULL THEN
                    RAISE EsciRountine;
                END IF;
                VarPart := NUM_VARRAY();
                nLoop := 0;

            END IF;

    END LOOP;
    IF nLoop > 0 THEN
        Pack_Aggiorna_Uv.AGGIORNA_STATO_UV( VarPart, P_CODERR, P_MSGERR );
        IF P_CODERR IS NOT NULL THEN
            RAISE EsciRountine;
        END IF;
    END IF;


     --estraggo l'id_massimo dell'allevamento
        SELECT NVL(MAX(ID_ALLEVAMENTO),0)
         INTO N_MAX_ID_ALLEVAMENTO
         FROM DB_ALLEVAMENTO AL, DB_UTE U
        WHERE AL.ID_UTE = U.ID_UTE
          AND U.ID_AZIENDA = N_ID_AZIENDA
          AND AL.DATA_INIZIO < D_DATA_DICHIARAZIONE
          AND NVL(AL.DATA_FINE,TO_DATE('31/12/9999','DD/MM/YYYY')) > D_DATA_DICHIARAZIONE;

     FOR REC_ALLEVAMENTO_ATTIVO IN C_ALLEVAMENTO_ATTIVO LOOP
          UPDATE DB_ALLEVAMENTO SET DATA_FINE = SYSDATE WHERE ID_ALLEVAMENTO = REC_ALLEVAMENTO_ATTIVO.ID_ALLEVAMENTO;
     END LOOP;

     FOR REC_ALLEVAMENTO IN C_ALLEVAMENTO LOOP
       IF REC_ALLEVAMENTO.DATA_FINE IS NOT NULL THEN
          SELECT SEQ_ALLEVAMENTO.NEXTVAL INTO N_ID_ALLEVAMENTO_NEW FROM DUAL;
           INSERT INTO DB_ALLEVAMENTO (ID_ALLEVAMENTO, ID_UTE, ID_ASL, ISTAT_COMUNE,
             ID_SPECIE_ANIMALE, CODICE_AZIENDA_ZOOTECNICA, DATA_INIZIO, DATA_FINE, NOTE,
            DATA_AGGIORNAMENTO, ID_UTENTE_AGGIORNAMENTO, INDIRIZZO, CAP, TELEFONO, DICHIARAZIONE_RIPRISTINATA,
            ID_DICHIARAZIONE_CONSISTENZA,CODICE_FISCALE_PROPRIETARIO, DENOMINAZIONE_PROPRIETARIO, CODICE_FISCALE_DETENTORE, DENOMINAZIONE_DETENTORE, DATA_INIZIO_DETENZIONE, DATA_FINE_DETENZIONE, FLAG_SOCCIDA, ID_TIPO_PRODUZIONE, ID_ORIENTAMENTO_PRODUTTIVO, DESCRIZIONE_ALTRI_TRATTAM, FLAG_DEIEZIONE_AVICOLI, MEDIA_CAPI_LATTAZIONE, QUANTITA_ACQUA_LAVAGGIO, FLAG_ACQUE_EFFLUENTI, ID_MUNGITURA, SUPERFICIE_LETTIERA_PERMANENTE,ALTEZZA_LETTIERA_PERMANENTE)
          VALUES (N_ID_ALLEVAMENTO_NEW, REC_ALLEVAMENTO.ID_UTE, REC_ALLEVAMENTO.ID_ASL,
             REC_ALLEVAMENTO.ISTAT_COMUNE, REC_ALLEVAMENTO.ID_SPECIE_ANIMALE,
            REC_ALLEVAMENTO.CODICE_AZIENDA_ZOOTECNICA, SYSDATE,
            NULL, 'RIPRISTINO DICHIARAZIONE', SYSDATE, P_ID_UTENTE_AGGIORNAMENTO, REC_ALLEVAMENTO.INDIRIZZO,
            REC_ALLEVAMENTO.CAP, REC_ALLEVAMENTO.TELEFONO,'S', P_ID_DICHIARAZIONE,REC_ALLEVAMENTO.CODICE_FISCALE_PROPRIETARIO, REC_ALLEVAMENTO.DENOMINAZIONE_PROPRIETARIO, REC_ALLEVAMENTO.CODICE_FISCALE_DETENTORE, REC_ALLEVAMENTO.DENOMINAZIONE_DETENTORE, REC_ALLEVAMENTO.DATA_INIZIO_DETENZIONE, REC_ALLEVAMENTO.DATA_FINE_DETENZIONE, REC_ALLEVAMENTO.FLAG_SOCCIDA, REC_ALLEVAMENTO.ID_TIPO_PRODUZIONE, REC_ALLEVAMENTO.ID_ORIENTAMENTO_PRODUTTIVO, REC_ALLEVAMENTO.DESCRIZIONE_ALTRI_TRATTAM, REC_ALLEVAMENTO.FLAG_DEIEZIONE_AVICOLI, REC_ALLEVAMENTO.MEDIA_CAPI_LATTAZIONE, REC_ALLEVAMENTO.QUANTITA_ACQUA_LAVAGGIO, REC_ALLEVAMENTO.FLAG_ACQUE_EFFLUENTI, REC_ALLEVAMENTO.ID_MUNGITURA, REC_ALLEVAMENTO.SUPERFICIE_LETTIERA_PERMANENTE, REC_ALLEVAMENTO.ALTEZZA_LETTIERA_PERMANENTE);

         N_ID_ALLEVAMENTO := REC_ALLEVAMENTO.ID_ALLEVAMENTO;

         FOR REC_CATEGORIE_ALLEVAMENTO IN C_CATEGORIE_ALLEVAMENTO LOOP

            SELECT SEQ_CATEGORIE_ALLEVAMENTO.NEXTVAL INTO  N_ID_CATEGORIE_ALLEVAMENTO_NEW FROM DUAL;

            INSERT INTO DB_CATEGORIE_ALLEVAMENTO (ID_CATEGORIE_ALLEVAMENTO,ID_CATEGORIA_ANIMALE, ID_ALLEVAMENTO, QUANTITA,PESO_VIVO_UNITARIO)
            VALUES (N_ID_CATEGORIE_ALLEVAMENTO_NEW, REC_CATEGORIE_ALLEVAMENTO.ID_CATEGORIA_ANIMALE,N_ID_ALLEVAMENTO_NEW, REC_CATEGORIE_ALLEVAMENTO.QUANTITA,REC_CATEGORIE_ALLEVAMENTO.PESO_VIVO_UNITARIO);

            N_ID_CATEGORIE_ALLEVAMENTO := REC_CATEGORIE_ALLEVAMENTO.ID_CATEGORIE_ALLEVAMENTO;

            FOR REC_SOTTOCATEGORIA_ALLEVAMENTO IN C_SOTTOCATEGORIA_ALLEVAMENTO LOOP

                SELECT SEQ_SOTTOCATEGORIA_ALLEVAMENTO.NEXTVAL INTO N_ID_SOTTOCAT_ALLEVAMENTO_NEW FROM DUAL;

                INSERT INTO DB_SOTTOCATEGORIA_ALLEVAMENTO (ID_SOTTOCATEGORIA_ALLEVAMENTO, ID_SOTTOCATEGORIA_ANIMALE, ID_CATEGORIE_ALLEVAMENTO, ORE_PASCOLO_INVERNO, QUANTITA, PESO_VIVO, GIORNI_VUOTO_SANITARIO, GIORNI_PASCOLO_ESTATE, ORE_PASCOLO_ESTATE, GIORNI_PASCOLO_INVERNO, CICLI)
                VALUES(N_ID_SOTTOCAT_ALLEVAMENTO_NEW, REC_SOTTOCATEGORIA_ALLEVAMENTO.ID_SOTTOCATEGORIA_ANIMALE, N_ID_CATEGORIE_ALLEVAMENTO_NEW, REC_SOTTOCATEGORIA_ALLEVAMENTO.ORE_PASCOLO_INVERNO, REC_SOTTOCATEGORIA_ALLEVAMENTO.QUANTITA, REC_SOTTOCATEGORIA_ALLEVAMENTO.PESO_VIVO, REC_SOTTOCATEGORIA_ALLEVAMENTO.GIORNI_VUOTO_SANITARIO, REC_SOTTOCATEGORIA_ALLEVAMENTO.GIORNI_PASCOLO_ESTATE, REC_SOTTOCATEGORIA_ALLEVAMENTO.ORE_PASCOLO_ESTATE, REC_SOTTOCATEGORIA_ALLEVAMENTO.GIORNI_PASCOLO_INVERNO, REC_SOTTOCATEGORIA_ALLEVAMENTO.CICLI);

                N_ID_SOTTOCAT_ALLEVAMENTO := REC_SOTTOCATEGORIA_ALLEVAMENTO.ID_SOTTOCATEGORIA_ALLEVAMENTO;

                FOR REC_STABULAZIONE_TRATTAMENTO IN C_STABULAZIONE_TRATTAMENTO LOOP
                    SELECT SEQ_STABULAZIONE_TRATTAMENTO.NEXTVAL INTO N_ID_STABULAZIONE_TRATT_NEW FROM DUAL;

                    INSERT INTO DB_STABULAZIONE_TRATTAMENTO (ID_STABULAZIONE_TRATTAMENTO, ID_SOTTOCATEGORIA_ALLEVAMENTO, ID_STABULAZIONE, QUANTITA_STABULATI, ID_TRATTAMENTO)
                    VALUES (N_ID_STABULAZIONE_TRATT_NEW, N_ID_SOTTOCAT_ALLEVAMENTO_NEW, REC_STABULAZIONE_TRATTAMENTO.ID_STABULAZIONE, REC_STABULAZIONE_TRATTAMENTO.QUANTITA_STABULATI, REC_STABULAZIONE_TRATTAMENTO.ID_TRATTAMENTO);

                    N_ID_STABULAZIONE_TRATT := REC_STABULAZIONE_TRATTAMENTO.ID_STABULAZIONE_TRATTAMENTO;

                    INSERT INTO DB_EFFLUENTE_PRODOTTO
                    SELECT SEQ_EFFLUENTE_PRODOTTO.NEXTVAL,N_ID_STABULAZIONE_TRATT_NEW,ID_EFFLUENTE, FLAG_TRATTAMENTO, VOLUME_PRODOTTO, AZOTO_PRODOTTO, VOLUME_PRODOTTO_AZIENDALE, AZOTO_PRODOTTO_AZIENDALE
                    FROM  DB_EFFLUENTE_PRODOTTO
                    WHERE ID_STABULAZIONE_TRATTAMENTO = N_ID_STABULAZIONE_TRATT;

                END LOOP;

            END LOOP;

         END LOOP;
     END IF;
    END LOOP;

         --estraggo l'id_massimo dell'allevamento
        SELECT NVL(MAX(ID_FABBRICATO),0)
         INTO N_MAX_ID_FABBRICATO
         FROM DB_FABBRICATO FB, DB_UTE U
        WHERE FB.ID_UTE = U.ID_UTE
          AND U.ID_AZIENDA = N_ID_AZIENDA
          AND FB.DATA_INIZIO_VALIDITA < D_DATA_DICHIARAZIONE
          AND NVL(FB.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','DD/MM/YYYY')) > D_DATA_DICHIARAZIONE;

     FOR REC_FABBRICATO_ATTIVO IN C_FABBRICATO_ATTIVO LOOP
          UPDATE DB_FABBRICATO SET DATA_FINE_VALIDITA = SYSDATE WHERE ID_FABBRICATO = REC_FABBRICATO_ATTIVO.ID_FABBRICATO;
     END LOOP;


    FOR REC_FABBRICATO IN C_FABBRICATO LOOP
        IF REC_FABBRICATO.DATA_FINE_VALIDITA IS NOT NULL THEN
           SELECT SEQ_FABBRICATO.NEXTVAL INTO N_ID_FABBRICATO_NEW FROM DUAL;

            INSERT INTO DB_FABBRICATO (ID_FABBRICATO, ID_TIPOLOGIA_FABBRICATO,
                     ID_FORMA_FABBRICATO, DENOMINAZIONE, SUPERFICIE, ANNO_COSTRUZIONE,
                    DIMENSIONE, LUNGHEZZA, LARGHEZZA, DATA_AGGIORNAMENTO, ALTEZZA, UTM_X,
                    UTM_Y, NOTE, ID_UTENTE_AGGIORNAMENTO, ID_UTE, DATA_INIZIO_VALIDITA,
                    DATA_FINE_VALIDITA, ID_COLTURA_SERRA, MESI_RISCALDAMENTO_SERRA, ORE_RISCALDAMENTO_SERRA,
                    DICHIARAZIONE_RIPRISTINATA, ID_DICHIARAZIONE_CONSISTENZA,VOLUME_UTILE_PRESUNTO, SUPERFICIE_COPERTA, SUPERFICIE_SCOPERTA,SUPERFICIE_SCOPERTA_EXTRA)
             VALUES (N_ID_FABBRICATO_NEW, REC_FABBRICATO.ID_TIPOLOGIA_FABBRICATO,
                     REC_FABBRICATO.ID_FORMA_FABBRICATO, REC_FABBRICATO.DENOMINAZIONE,
                    REC_FABBRICATO.SUPERFICIE, REC_FABBRICATO.ANNO_COSTRUZIONE,
                    REC_FABBRICATO.DIMENSIONE, REC_FABBRICATO.LUNGHEZZA, REC_FABBRICATO.LARGHEZZA,
                    SYSDATE, REC_FABBRICATO.ALTEZZA, REC_FABBRICATO.UTM_X,
                    REC_FABBRICATO.UTM_Y, 'RIPRISTINO DICHIARAZIONE',
                    P_ID_UTENTE_AGGIORNAMENTO, REC_FABBRICATO.ID_UTE, SYSDATE,  NULL,
                    REC_FABBRICATO.ID_COLTURA_SERRA, REC_FABBRICATO.MESI_RISCALDAMENTO_SERRA,
                    REC_FABBRICATO.ORE_RISCALDAMENTO_SERRA, 'S', P_ID_DICHIARAZIONE,REC_FABBRICATO.VOLUME_UTILE_PRESUNTO, REC_FABBRICATO.SUPERFICIE_COPERTA, REC_FABBRICATO.SUPERFICIE_SCOPERTA, REC_FABBRICATO.SUPERFICIE_SCOPERTA_EXTRA);

             N_ID_FABBRICATO := REC_FABBRICATO.ID_FABBRICATO;
             FOR REC_FABBRICATO_PARTICELLA IN C_FABBRICATO_PARTICELLA LOOP
                  INSERT INTO DB_FABBRICATO_PARTICELLA (ID_FABBRICATO_PARTICELLA,                 ID_FABBRICATO,            ID_PARTICELLA,                                     DATA_INIZIO_VALIDITA,     DATA_FINE_VALIDITA)
                 VALUES(                                            SEQ_PARTICELLA_FABBRICATO.NEXTVAL,     N_ID_FABBRICATO_NEW,    REC_FABBRICATO_PARTICELLA.ID_PARTICELLA,    SYSDATE,                     NULL);

             END LOOP;
        END IF;
     END LOOP;


        DELETE DB_PARAMETRI_ATT_AZIENDA WHERE ID_ATTESTAZIONE_AZIENDA IN (SELECT ID_ATTESTAZIONE_AZIENDA FROM DB_ATTESTAZIONE_AZIENDA WHERE ID_AZIENDA = N_ID_AZIENDA);

        DELETE  DB_ATTESTAZIONE_AZIENDA WHERE ID_AZIENDA = N_ID_AZIENDA;


        FOR REC_ATTESTAZIONE_DICHIARATA IN C_ATTESTAZIONE_DICHIARATA LOOP

            SELECT SEQ_ATTESTAZIONE_AZIENDA.NEXTVAL INTO N_ID_ATTESTAZIONE_AZIENDA_NEW FROM DUAL;

            INSERT INTO DB_ATTESTAZIONE_AZIENDA (ID_ATTESTAZIONE_AZIENDA, ID_AZIENDA, ID_ATTESTAZIONE, DATA_ULTIMO_AGGIORNAMENTO, ID_UTENTE_AGGIORNAMENTO)
            VALUES (N_ID_ATTESTAZIONE_AZIENDA_NEW, N_ID_AZIENDA, REC_ATTESTAZIONE_DICHIARATA.ID_ATTESTAZIONE,
            SYSDATE, P_ID_UTENTE_AGGIORNAMENTO);

            INSERT INTO DB_PARAMETRI_ATT_AZIENDA (    ID_PARAMETRI_ATT_AZIENDA,                 ID_ATTESTAZIONE_AZIENDA,                 PARAMETRO_1, PARAMETRO_2, PARAMETRO_3, PARAMETRO_4, PARAMETRO_5)
            SELECT                                             SEQ_PARAMETRI_ATT_AZIENDA.NEXTVAL,     N_ID_ATTESTAZIONE_AZIENDA_NEW,         PARAMETRO_1, PARAMETRO_2, PARAMETRO_3, PARAMETRO_4, PARAMETRO_5 FROM DB_PARAMETRI_ATT_DICHIARATA WHERE ID_ATTESTAZIONE_DICHIARATA = REC_ATTESTAZIONE_DICHIARATA.ID_ATTESTAZIONE_DICHIARATA;


        END LOOP;

     COMMIT;
EXCEPTION
WHEN EsciRountine THEN
     NULL;
WHEN OTHERS THEN
     P_MSGERR := 'ERRORE GRAVE NEL RIBALTAMENTO DELLA CONSISTENZA. CONTATTARE L''ASSISTENZA:' || SQLERRM||' RIGA = '||dbms_utility.FORMAT_ERROR_BACKTRACE;
     P_CODERR := SQLCODE;
END RIPRISTINA_DICHIARAZIONE;

END Pack_Ripristina_Dichiarazione;          -- Package

/
--------------------------------------------------------
--  DDL for Package Body PCK_AGGIORNA_DATI_BIOLOGICO
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_AGGIORNA_DATI_BIOLOGICO" AS
/*****************************************************************************
Package che espone tutte le function / stored procedure propedeutiche all'aggiornamento
dei dati relaviti all'agricoltura biologica provenienti dalla fonte ABIO sull'anagrafe
aziende agricole
******************************************************************************/

    /*********************************************************************
    Inserisce un record di tipo DB_R_AZIENDA_INFO_AGGIUNTIVA sull'omonima tabella
    Tipo: procedure
    input: pRecRAzInfoAggiuntiva
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertRAziendaInfoAggiuntiva (pRecRAzInfoAggiuntiva IN DB_R_AZIENDA_INFO_AGGIUNTIVA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_R_AZIENDA_INFO_AGGIUNTIVA
            (
            ID_AZIENDA_INFO_AGGIUNTIVA,
            ID_AZIENDA,
            ID_INFO_AGGIUNTIVA,
            NOTE,
            ID_UTENTE_AGGIORNAMENTO,
            DATA_AGGIORNAMENTO,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA
            )
        VALUES
            (
            pRecRAzInfoAggiuntiva.ID_AZIENDA_INFO_AGGIUNTIVA,
            pRecRAzInfoAggiuntiva.ID_AZIENDA,
            pRecRAzInfoAggiuntiva.ID_INFO_AGGIUNTIVA,
            pRecRAzInfoAggiuntiva.NOTE,
            pRecRAzInfoAggiuntiva.ID_UTENTE_AGGIORNAMENTO,
            pRecRAzInfoAggiuntiva.DATA_AGGIORNAMENTO,
            pRecRAzInfoAggiuntiva.DATA_INIZIO_VALIDITA,
            pRecRAzInfoAggiuntiva.DATA_FINE_VALIDITA
            );
    END InsertRAziendaInfoAggiuntiva;

    /*********************************************************************
    Dati ID_AZIENDA e un tipologia di informazione aggiuntiva
    ricerca se e' gia' presente sulla tabella DB_R_AZIENDA_INFO_AGGIUNTIVA
    Tipo: function
    input: pIdAzienda, pIdTipoInfoAgg
    output: nessuno
    ritorno: DB_R_AZIENDA_INFO_AGGIUNTIVA%ROWTYPE
    *********************************************************************/
    FUNCTION SelRAziendaInfoAgByIdAzInfoAg (pIdAzienda      IN DB_R_AZIENDA_INFO_AGGIUNTIVA.ID_AZIENDA%TYPE,
                                            pIdTipoInfoAgg  IN DB_R_AZIENDA_INFO_AGGIUNTIVA.ID_INFO_AGGIUNTIVA%TYPE
                                            ) RETURN DB_R_AZIENDA_INFO_AGGIUNTIVA%ROWTYPE IS
        recRAzInfoAgg DB_R_AZIENDA_INFO_AGGIUNTIVA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recRAzInfoAgg
          FROM DB_R_AZIENDA_INFO_AGGIUNTIVA
         WHERE ID_AZIENDA = pIdAzienda
           AND ID_INFO_AGGIUNTIVA = pIdTipoInfoAgg
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recRAzInfoAgg;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelRAziendaInfoAgByIdAzInfoAg;

    /*********************************************************************
    Cessa impostando la data di fine validita = SYSDATE i record di
    DB_R_AZIENDA_INFO_AGGIUNTIVA attivi trovati per ID_AZIENDA ed
    ID_INFO_AGGIUNTIVA
    Tipo: procedure
    input: pIdAzienda, pIdTipoInfoAgg
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE CessaInfoAggiuntiva (pIdAzienda       IN DB_R_AZIENDA_INFO_AGGIUNTIVA.ID_AZIENDA%TYPE,
                                   pIdTipoInfoAgg   IN DB_R_AZIENDA_INFO_AGGIUNTIVA.ID_INFO_AGGIUNTIVA%TYPE
                                   )  IS
    BEGIN

        UPDATE DB_R_AZIENDA_INFO_AGGIUNTIVA
           SET DATA_FINE_VALIDITA = SYSDATE
         WHERE ID_AZIENDA = pIdAzienda
           AND ID_INFO_AGGIUNTIVA = pIdTipoInfoAgg
           AND DATA_FINE_VALIDITA IS NULL;

    END CessaInfoAggiuntiva;

    /*********************************************************************
    Inserisce un nuovo record su DB_R_AZIENDA_INFO_AGGIUNTIVA per l'azienda
    data in input e la tipologia di info aggiuntiva data in input
    se non ne risulta una gia' presente e attiva
    Tipo: procedure
    input: pIdAzienda, pIdTipoInfoAgg
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE AggiungiInfoAggiuntiva (pIdAzienda       IN DB_R_AZIENDA_INFO_AGGIUNTIVA.ID_AZIENDA%TYPE,
                                      pIdTipoInfoAgg   IN DB_R_AZIENDA_INFO_AGGIUNTIVA.ID_INFO_AGGIUNTIVA%TYPE
                                      )  IS

        recRAzInfoAgg   DB_R_AZIENDA_INFO_AGGIUNTIVA%ROWTYPE;

    BEGIN

        recRAzInfoAgg := SelRAziendaInfoAgByIdAzInfoAg (pIdAzienda,
                                                        pIdTipoInfoAgg);

        IF recRAzInfoAgg.ID_AZIENDA_INFO_AGGIUNTIVA IS NULL THEN

           SELECT SEQ_DB_R_AZIENDA_INFO_AGGIUNT.nextval
             INTO recRAzInfoAgg.ID_AZIENDA_INFO_AGGIUNTIVA
             FROM DUAL;

           recRAzInfoAgg.ID_AZIENDA := pIdAzienda;
           recRAzInfoAgg.ID_INFO_AGGIUNTIVA := pIdTipoInfoAgg;
           recRAzInfoAgg.NOTE := NULL;
           recRAzInfoAgg.ID_UTENTE_AGGIORNAMENTO := knIdUtenteAggBatch;
           recRAzInfoAgg.DATA_AGGIORNAMENTO := SYSDATE;
           recRAzInfoAgg.DATA_INIZIO_VALIDITA := SYSDATE;
           recRAzInfoAgg.DATA_FINE_VALIDITA := NULL;
           InsertRAziendaInfoAggiuntiva (recRAzInfoAgg);

        END IF;

    END AggiungiInfoAggiuntiva;

    /*********************************************************************
    Inserisce un record di tipo DB_FABBRICATO_BIO sull'omonima tabella
    Tipo: procedure
    input: pRecTFabbricatoBIO
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTFabbricatoBio (pRecTFabbricatoBIO IN DB_FABBRICATO_BIO%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_FABBRICATO_BIO
            (
            ID_FABBRICATO_BIO,
            ID_AZIENDA,
            EXT_ID_NOTIFICA,
            ID_FABBRICATO,
            DIMENSIONE,
            DIMENSIONE_CONVENZIONALE,
            DIMENSIONE_BIOLOGICO,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA
            )
        VALUES
            (
            pRecTFabbricatoBIO.ID_FABBRICATO_BIO,
            pRecTFabbricatoBIO.ID_AZIENDA,
            pRecTFabbricatoBIO.EXT_ID_NOTIFICA,
            pRecTFabbricatoBIO.ID_FABBRICATO,
            pRecTFabbricatoBIO.DIMENSIONE,
            pRecTFabbricatoBIO.DIMENSIONE_CONVENZIONALE,
            pRecTFabbricatoBIO.DIMENSIONE_BIOLOGICO,
            pRecTFabbricatoBIO.DATA_INIZIO_VALIDITA,
            pRecTFabbricatoBIO.DATA_FINE_VALIDITA
            );

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertTFabbricatoBio - ID_FABBRICATO_BIO = ' || pRecTFabbricatoBIO.ID_FABBRICATO_BIO);
             RAISE;
    END InsertTFabbricatoBio;

    /*********************************************************************
    Inserisce un record di tipo DB_ALLEVAMENTO_BIO sull'omonima tabella
    Tipo: procedure
    input: pRecTAllevamentoBIO
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTAllevamentoBio (pRecTAllevamentoBIO IN DB_ALLEVAMENTO_BIO%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_ALLEVAMENTO_BIO
            (
            ID_ALLEVAMENTO_BIO,
            ID_AZIENDA,
            EXT_ID_NOTIFICA,
            ID_UTE,
            CODICE_AZIENDA_ZOOTECNICA,
            ID_CATEGORIA_ANIMALE,
            ID_SPECIE_ANIMALE,
            QUANTITA,
            QUANTITA_CONVENZIONALE,
            QUANTITA_BIOLOGICO,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA
            )
        VALUES
            (
            pRecTAllevamentoBIO.ID_ALLEVAMENTO_BIO,
            pRecTAllevamentoBIO.ID_AZIENDA,
            pRecTAllevamentoBIO.EXT_ID_NOTIFICA,
            pRecTAllevamentoBIO.ID_UTE,
            pRecTAllevamentoBIO.CODICE_AZIENDA_ZOOTECNICA,
            pRecTAllevamentoBIO.ID_CATEGORIA_ANIMALE,
            pRecTAllevamentoBIO.ID_SPECIE_ANIMALE,
            pRecTAllevamentoBIO.QUANTITA,
            pRecTAllevamentoBIO.QUANTITA_CONVENZIONALE,
            pRecTAllevamentoBIO.QUANTITA_BIOLOGICO,
            pRecTAllevamentoBIO.DATA_INIZIO_VALIDITA,
            pRecTAllevamentoBIO.DATA_FINE_VALIDITA
            );

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertTAllevamentoBio - ID_ALLEVAMENTO_BIO = ' || pRecTAllevamentoBIO.ID_ALLEVAMENTO_BIO);
             RAISE;
    END InsertTAllevamentoBio;

    /*********************************************************************
    Inserisce un record di tipo DB_PARTICELLA_BIO sull'omonima tabella
    Tipo: procedure
    input: pRecTParticellaBIO
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTParticellaBio (pRecTParticellaBIO IN DB_PARTICELLA_BIO%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_PARTICELLA_BIO
            (
            ID_PARTICELLA_BIO,
            ID_AZIENDA,
            EXT_ID_NOTIFICA,
            ID_PARTICELLA,
            SUP_BIOLOGICO,
            SUP_CONVENZIONALE,
            SUP_IN_CONVERSIONE,
            DATA_INIZIO_CONVERSIONE,
            DATA_FINE_CONVERSIONE,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA
            )
        VALUES
            (
            pRecTParticellaBIO.ID_PARTICELLA_BIO,
            pRecTParticellaBIO.ID_AZIENDA,
            pRecTParticellaBIO.EXT_ID_NOTIFICA,
            pRecTParticellaBIO.ID_PARTICELLA,
            pRecTParticellaBIO.SUP_BIOLOGICO,
            pRecTParticellaBIO.SUP_CONVENZIONALE,
            pRecTParticellaBIO.SUP_IN_CONVERSIONE,
            pRecTParticellaBIO.DATA_INIZIO_CONVERSIONE,
            pRecTParticellaBIO.DATA_FINE_CONVERSIONE,
            pRecTParticellaBIO.DATA_INIZIO_VALIDITA,
            pRecTParticellaBIO.DATA_FINE_VALIDITA
            );

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertTParticellaBio - ID_PARTICELLA_BIO = ' || pRecTParticellaBIO.ID_PARTICELLA_BIO);
             RAISE;
    END InsertTParticellaBio;

    /*********************************************************************
    Dato un ID_STORICO_PARTICELLA selezione il corrispettivo ID_PARTICELLA
    su DB_STORICO_PARTICELLA
    Tipo: function
    input: pIdStoricoParticella
    output: nessuno
    ritorno: nIdParticella
    *********************************************************************/
    FUNCTION SelIdParticellaByIdStorico (pIdStoricoParticella IN DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE)
    RETURN DB_STORICO_PARTICELLA.ID_PARTICELLA%TYPE IS
        nIdParticella DB_STORICO_PARTICELLA.ID_PARTICELLA%TYPE;
    BEGIN

        SELECT ID_PARTICELLA
          INTO nIdParticella
          FROM DB_STORICO_PARTICELLA
         WHERE ID_STORICO_PARTICELLA = pIdStoricoParticella;

        RETURN nIdParticella;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('SelIdParticellaByIdStorico - pIdStoricoParticella = ' || pIdStoricoParticella);
             RAISE;
    END SelIdParticellaByIdStorico;

    /*********************************************************************
    Conclude l'attività biologica cioè va a storicizzare tutte le informazioni
    biologiche attive per l'azienda
    Tipo: procedure
    input: pRecPraticaBio
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ConcludiAttivitaBiologica (pRecPraticaBio IN PCK_AGGIORNA_FASCICOLO.curElencoPratiche%ROWTYPE) IS
    BEGIN

        UPDATE DB_PARTICELLA_BIO
           SET DATA_FINE_VALIDITA = pRecPraticaBio.DATA_OPERAZIONE
         WHERE ID_AZIENDA = pRecPraticaBio.EXT_ID_AZIENDA
           AND DATA_FINE_VALIDITA IS NULL;


        UPDATE DB_ALLEVAMENTO_BIO
           SET DATA_FINE_VALIDITA = pRecPraticaBio.DATA_OPERAZIONE
         WHERE ID_AZIENDA = pRecPraticaBio.EXT_ID_AZIENDA
           AND DATA_FINE_VALIDITA IS NULL;

        UPDATE DB_FABBRICATO_BIO
           SET DATA_FINE_VALIDITA = pRecPraticaBio.DATA_OPERAZIONE
         WHERE ID_AZIENDA = pRecPraticaBio.EXT_ID_AZIENDA
           AND DATA_FINE_VALIDITA IS NULL;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('ConcludiAttivitaBiologica - ID_AZIENDA = ' || pRecPraticaBio.EXT_ID_AZIENDA);
             RAISE;
    END ConcludiAttivitaBiologica;

    /*********************************************************************
    Imposta la data di fine validità sulla particella data in input
    per l'azienda data in input
    Tipo: procedure
    input: pIdAzienda, pIdParticella,pDtFine
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ConcludiParticellaBio (pIdAzienda     IN  DB_PARTICELLA_BIO.ID_AZIENDA%TYPE,
                                     pIdParticella  IN  DB_PARTICELLA_BIO.ID_PARTICELLA%TYPE,
                                     pDtFine        IN  DB_PARTICELLA_BIO.DATA_FINE_VALIDITA%TYPE
                                     ) IS
    BEGIN

        UPDATE DB_PARTICELLA_BIO
           SET DATA_FINE_VALIDITA = pDtFine
         WHERE ID_AZIENDA = pIdAzienda
           AND ID_PARTICELLA = pIdParticella
           AND DATA_FINE_VALIDITA IS NULL;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('ConcludiParticellaBio - pIdAzienda/pIdParticella = ' || pIdAzienda/pIdParticella);
             RAISE;
    END ConcludiParticellaBio;

    /*********************************************************************
    Data una notifica abio seleziona i corrispettivi appezzamenti di terreno
    biologici e li inserisci su DB_PARTICELLA_BIO
    Tipo: function
    input: pRecPraticaBio
    output: nessuno
    ritorno: nNumParticelle
    *********************************************************************/
    FUNCTION GestioneParticellaBio (pRecPraticaBio IN PCK_AGGIORNA_FASCICOLO.curElencoPratiche%ROWTYPE)
    RETURN INTEGER IS
        nNumParticelle      INTEGER:=0;
        recTPartBIO         DB_PARTICELLA_BIO%ROWTYPE;
    BEGIN

        FOR recParticellaBIO IN PCK_AGGIORNA_FASCICOLO.curConsistenzaTerritoriale (pRecPraticaBio.ID_NOTIFICA) LOOP

            recTPartBIO.ID_PARTICELLA := SelIdParticellaByIdStorico (recParticellaBIO.EXT_ID_STORICO_PARTICELLA);


            nNumParticelle := nNumParticelle + 1;

            SELECT SEQ_DB_PARTICELLA_BIO.nextval
              INTO recTPartBIO.ID_PARTICELLA_BIO
              FROM DUAL;

            recTPartBIO.ID_AZIENDA := pRecPraticaBio.EXT_ID_AZIENDA;
            recTPartBIO.EXT_ID_NOTIFICA := pRecPraticaBio.ID_NOTIFICA;
            recTPartBIO.SUP_BIOLOGICO := recParticellaBIO.SUP_BIOLOGICO;
            recTPartBIO.SUP_CONVENZIONALE := recParticellaBIO.SUP_CONVENZIONALE;
            recTPartBIO.SUP_IN_CONVERSIONE := recParticellaBIO.SUP_IN_CONVERSIONE;
            recTPartBIO.DATA_INIZIO_CONVERSIONE := recParticellaBIO.DATA_INIZIO_CONVERSIONE;
            recTPartBIO.DATA_FINE_CONVERSIONE := recParticellaBIO.DATA_FINE_CONVERSIONE;
            recTPartBIO.DATA_INIZIO_VALIDITA := pRecPraticaBio.DATA_OPERAZIONE;

            InsertTParticellaBio (recTPartBIO);

        END LOOP;

        RETURN nNumParticelle;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('GestioneParticellaBio - ID_NOTIFICA = ' || pRecPraticaBio.ID_NOTIFICA);
             RAISE;
    END GestioneParticellaBio;

    /*********************************************************************
    Imposta la data di fine validità sulla
    Tipo: procedure
    input: pIdAzienda, pIdParticella,pDtFine
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ConcludiAllevamentoBio (pRecPraticaBIO        IN PCK_AGGIORNA_FASCICOLO.curElencoPratiche%ROWTYPE,
                                      pRecAllevamentoBIO    IN PCK_AGGIORNA_FASCICOLO.curConsistenzaZootecnica%ROWTYPE
                                      ) IS
    BEGIN

        UPDATE DB_ALLEVAMENTO_BIO
           SET DATA_FINE_VALIDITA = pRecPraticaBIO.DATA_OPERAZIONE
         WHERE ID_AZIENDA = pRecPraticaBIO.EXT_ID_AZIENDA
           AND ID_UTE = pRecAllevamentoBIO.EXT_ID_UTE
           AND ID_CATEGORIA_ANIMALE = pRecAllevamentoBIO.EXT_ID_CATEGORIA_ANIMALE
           AND ID_SPECIE_ANIMALE = pRecAllevamentoBIO.EXT_ID_SPECIE_ANIMALE
           AND NVL(CODICE_AZIENDA_ZOOTECNICA,'N.P.') = NVL(pRecAllevamentoBIO.CODICE_AZIENDA_ZOOTECNICA,'N.P.')
           AND EXT_ID_NOTIFICA <> pRecPraticaBIO.ID_NOTIFICA
           AND DATA_FINE_VALIDITA IS NULL;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('ConcludiAllevamentoBio - ID_AZIENDA = ' || pRecPraticaBIO.EXT_ID_AZIENDA);
             RAISE;
    END ConcludiAllevamentoBio;

    /*********************************************************************
    Data una notifica abio seleziona i corrispettivi allevamenti
    biologici e li inserisci su DB_ALLEVAMENTO_BIO
    Tipo: function
    input: pRecPraticaBio
    output: nessuno
    ritorno: nNumAllevamenti
    *********************************************************************/
    FUNCTION GestioneAllevamentoBio (pRecPraticaBio IN PCK_AGGIORNA_FASCICOLO.curElencoPratiche%ROWTYPE)
    RETURN INTEGER IS
        nNumAllevamenti INTEGER:=0;
        recTAllevBio    DB_ALLEVAMENTO_BIO%ROWTYPE;
    BEGIN

        FOR recAllevamentoBIO IN PCK_AGGIORNA_FASCICOLO.curConsistenzaZootecnica (pRecPraticaBio.ID_NOTIFICA) LOOP

 

            nNumAllevamenti := nNumAllevamenti + 1;

            SELECT SEQ_DB_ALLEVAMENTO_BIO.nextval
              INTO recTAllevBio.ID_ALLEVAMENTO_BIO
              FROM DUAL;

            recTAllevBio.ID_AZIENDA := pRecPraticaBio.EXT_ID_AZIENDA;
            recTAllevBio.EXT_ID_NOTIFICA := pRecPraticaBio.ID_NOTIFICA;
            recTAllevBio.ID_UTE := recAllevamentoBIO.EXT_ID_UTE;
            recTAllevBio.CODICE_AZIENDA_ZOOTECNICA := recAllevamentoBIO.CODICE_AZIENDA_ZOOTECNICA;
            recTAllevBio.ID_CATEGORIA_ANIMALE := recAllevamentoBIO.EXT_ID_CATEGORIA_ANIMALE;
            recTAllevBio.ID_SPECIE_ANIMALE := recAllevamentoBIO.EXT_ID_SPECIE_ANIMALE;
            recTAllevBio.QUANTITA := recAllevamentoBIO.NUM_CAPI;
            recTAllevBio.QUANTITA_CONVENZIONALE := recAllevamentoBIO.NUM_CAPI_CONVENZIONALE;
            recTAllevBio.QUANTITA_BIOLOGICO := recAllevamentoBIO.NUM_CAPI_BIOLOGICO;
            recTAllevBio.DATA_INIZIO_VALIDITA := pRecPraticaBio.DATA_OPERAZIONE;

            InsertTAllevamentoBio (recTAllevBio);

        END LOOP;

        RETURN nNumAllevamenti;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('GestioneAllevamentoBio - ID_NOTIFICA = ' || pRecPraticaBio.ID_NOTIFICA);
             RAISE;
    END GestioneAllevamentoBio;

    /*********************************************************************
    Imposta la data di fine validità sulla particella data in input
    per l'azienda data in input
    Tipo: procedure
    input: pIdAzienda, pIdParticella,pDtFine
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ConcludiFabbricatoBio (pIdAzienda     IN  DB_FABBRICATO_BIO.ID_AZIENDA%TYPE,
                                     pIdFabbricato  IN  DB_FABBRICATO_BIO.ID_FABBRICATO%TYPE,
                                     pDtFine        IN  DB_FABBRICATO_BIO.DATA_FINE_VALIDITA%TYPE
                                     ) IS
    BEGIN

        UPDATE DB_FABBRICATO_BIO
           SET DATA_FINE_VALIDITA = pDtFine
         WHERE ID_AZIENDA = pIdAzienda
           AND ID_FABBRICATO = pIdFabbricato
           AND DATA_FINE_VALIDITA IS NULL;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('ConcludiFabbricatoBio - pIdAzienda/pIdFabbricato = ' || pIdAzienda/pIdFabbricato);
             RAISE;
    END ConcludiFabbricatoBio;

    /*********************************************************************
    Data una notifica abio seleziona i corrispettivi fabbricati
    biologici e li inserisci su DB_FABBRICATO_BIO
    Tipo: function
    input: pRecPraticaBio
    output: nessuno
    ritorno: nNumFabbricati
    *********************************************************************/
    FUNCTION GestioneFabbricatiBio (pRecPraticaBio IN PCK_AGGIORNA_FASCICOLO.curElencoPratiche%ROWTYPE)
    RETURN INTEGER IS
        nNumFabbricati INTEGER:=0;
        recTFabbrBio   DB_FABBRICATO_BIO%ROWTYPE;
    BEGIN

        FOR recFabbricatoBIO IN PCK_AGGIORNA_FASCICOLO.curConsistenzaStrutturale (pRecPraticaBio.ID_NOTIFICA) LOOP




            nNumFabbricati := nNumFabbricati + 1;

            SELECT SEQ_DB_FABBRICATO_BIO.nextval
              INTO recTFabbrBio.ID_FABBRICATO_BIO
              FROM DUAL;

            recTFabbrBio.ID_AZIENDA := pRecPraticaBio.EXT_ID_AZIENDA;
            recTFabbrBio.EXT_ID_NOTIFICA := pRecPraticaBio.ID_NOTIFICA;
            recTFabbrBio.ID_FABBRICATO := recFabbricatoBIO.EXT_ID_FABBRICATO;
            recTFabbrBio.DIMENSIONE := recFabbricatoBIO.DIMENSIONE;
            recTFabbrBio.DIMENSIONE_CONVENZIONALE := recFabbricatoBIO.DIMENSIONE_CONVENZIONALE;
            recTFabbrBio.DIMENSIONE_BIOLOGICO := recFabbricatoBIO.DIMENSIONE_BIOLOGICO;
            recTFabbrBio.DATA_INIZIO_VALIDITA := pRecPraticaBio.DATA_OPERAZIONE;

            InsertTFabbricatoBio(recTFabbrBio);

        END LOOP;

        RETURN nNumFabbricati;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('GestioneFabbricatiBio - ID_NOTIFICA = ' || pRecPraticaBio.ID_NOTIFICA);
             RAISE;
    END GestioneFabbricatiBio;

    /*********************************************************************
    Effettua l'aggiornamento dei dati relativi all'agricoltura biologica passati
    da ABIO su SMRGAA
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION AggiornaDatiBiologico RETURN NUMBER IS
        -- record di appoggio per il reperimento dei dati dell'applicazione corrente
        recDApplicazione        SMRGAA_D_APPLICAZIONI_BATCH%ROWTYPE;
        -- conterrà l'id esecuzione
        nIdEsecuzione           SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE;
        -- conterrà il codice di ritorno
        nRetCode                NUMBER(1):=0;
        -- record che contiene i dati dell'ultima esecuzione del batch andata a buon fine
        recTLastEsecOk          SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE;
        -- contatore notifiche abio trattate
        nRecNotificaAbio        INTEGER:=0;
        -- contatore particelle trattate per notifica
        nRecParticelleBio       INTEGER:=0;
        -- contatore allevamenti trattati per notifica
        nRecAllevamentiBio      INTEGER:=0;
        -- contatore fabbricati trattati per notifica
        nRecFabbricatiBio       INTEGER:=0;
        -- contatore particelle trattate totali
        nRecTotParticelleBio    INTEGER:=0;
        -- contatore allevamenti trattati totali
        nRecTotAllevamentiBio   INTEGER:=0;
        -- contatore fabbricati trattati totali
        nRecTotFabbricatiBio    INTEGER:=0;

    BEGIN

        nRetCode := Pck_SMRGAA_Log.VerificaAttivazioneBatch( knIdApplBatchAggBiologico ,recDApplicazione);

        IF nRetCode > 0 THEN
             -- Errore, Batch non attivo
            RETURN nRetCode;
        END IF;

         -- Inserimento in tabella dell'identificativo di esecuzione
         -- nIdEsecuzione restituito in output
        Pck_SMRGAA_Log.InsertTEsecuzione ( knIdApplBatchAggBiologico, nIdEsecuzione );
        COMMIT;

         -- Scrittura nel file nomefile_esecuzione del nIdEsecuzione
        Pck_SMRGAA_Log.ScriviFileEsecuzione (  recDApplicazione.nomefile_esecuzione,
                                               recDApplicazione.path_file_esecuzione,
                                               nIdEsecuzione );

        Pck_SMRGAA_Log.LeggiFileEsecuzione ( recDApplicazione.nomefile_esecuzione, recDApplicazione.path_file_esecuzione );

        Pck_SMRGAA_Log.SetLogLevel ( recDApplicazione.log_level );

        Pck_SMRGAA_Log.Init( knIdApplBatchAggBiologico, 'AggiornaDatiBiologico' );

        Pck_SMRGAA_Log.LogInfo ('Inizio Elaborazione');

        recTLastEsecOk := Pck_SMRGAA_Log.SelectTLastEsecuzioneOK (knIdApplBatchAggBiologico);

        IF recTLastEsecOk.DT_INIZIO_ESECUZIONE IS NULL THEN
           recTLastEsecOk.DT_INIZIO_ESECUZIONE := TO_DATE('01/01/1900','DD/MM/YYYY');
        END IF;

        -- scorro le notifiche abio
        FOR recPraticaBio IN PCK_AGGIORNA_FASCICOLO.curElencoPratiche (recTLastEsecOk.DT_INIZIO_ESECUZIONE) LOOP
            nRecNotificaAbio := nRecNotificaAbio + 1;
            Pck_SMRGAA_Log.LogDebug ('Elaborazione notifica abio : ' || recPraticaBio.ID_NOTIFICA);
            IF recPraticaBio.CESSAZIONE_ATTIVITA_BIO = 'S' THEN
               Pck_SMRGAA_Log.LogDebug ('Cessazione attività biologica notifica : ' || recPraticaBio.ID_NOTIFICA);
               ConcludiAttivitaBiologica (recPraticaBio);
               CessaInfoAggiuntiva (recPraticaBio.EXT_ID_AZIENDA, knIdTipoInfoAggiuntivaBio);
            ELSE
                -- chiamo questa procedure che cessa allevamenti, appezzamenti e fabbricati
                -- e poi al massimo li reinserisco con le procedure di cui sotto
                ConcludiAttivitaBiologica (recPraticaBio);

                -- ed inserisco le particelle biologiche sull'apposita tabella SMRGAA
                nRecParticelleBio := GestioneParticellaBio(recPraticaBio);
                Pck_SMRGAA_Log.LogDebug ('Acquisite : ' || nRecParticelleBio || ' particelle ');
                -- idem per gli allevamenti
                nRecAllevamentiBio := GestioneAllevamentoBio(recPraticaBio);
                Pck_SMRGAA_Log.LogDebug ('Acquisiti : ' || nRecAllevamentiBio || ' allevamenti ');
                -- ed idem per i fabbricati
                nRecFabbricatiBio := GestioneFabbricatiBio(recPraticaBio);
                Pck_SMRGAA_Log.LogDebug ('Acquisiti : ' || nRecFabbricatiBio || ' fabbricati ');
                Pck_SMRGAA_Log.LogDebug ('Elaborazione notifica abio : ' || recPraticaBio.ID_NOTIFICA || ' - terminata');

                IF nRecParticelleBio > 0 OR
                   nRecAllevamentiBio > 0 OR
                   nRecFabbricatiBIo > 0 THEN
                   AggiungiInfoAggiuntiva (recPraticaBio.EXT_ID_AZIENDA, knIdTipoInfoAggiuntivaBio);
                ELSE
                   CessaInfoAggiuntiva (recPraticaBio.EXT_ID_AZIENDA, knIdTipoInfoAggiuntivaBio);
                END IF;

                nRecTotParticelleBio := nRecTotParticelleBio +  nRecParticelleBio;
                nRecTotAllevamentiBio := nRecTotAllevamentiBio + nRecAllevamentiBio;
                nRecTotFabbricatiBio := nRecTotFabbricatiBio  + nRecFabbricatiBio;



            END IF;

            COMMIT;

        END LOOP;

        Pck_SMRGAA_Log.LogInfo ('Fine Elaborazione - Trattate : ' || nRecNotificaAbio || ' notifiche ABIO');
        Pck_SMRGAA_Log.LogInfo ('Acquisite : ' || nRecTotParticelleBio || ' particelle biologiche');
        Pck_SMRGAA_Log.LogInfo ('Acquisiti : ' || nRecTotAllevamentiBio || ' allevamenti biologici');
        Pck_SMRGAA_Log.LogInfo ('Acquisiti : ' || nRecTotFabbricatiBio || ' fabbricati biologici');

        PCK_SMRGAA_LOG.ValorizzaEsitoBatch;

        COMMIT;

        RETURN nRetCode;

    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            PCK_SMRGAA_LOG.LogSqlError ('AggiornaDatiBiologico');
            RETURN 1;
    END AggiornaDatiBiologico;

END Pck_Aggiorna_Dati_Biologico;

/
--------------------------------------------------------
--  DDL for Package Body PCK_AGGIORNA_DATI_ELEGGIBILITA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_AGGIORNA_DATI_ELEGGIBILITA" AS

    /*********************************************************************
    Dato un codice altro dato seleziona il corrispettivo record attivo (data fine validita a null)
    sulla tabella DB_ALTRI_DATI
    Tipo: function
    input: pCodAltroDato
    output: nessuno
    ritorno: DB_ALTRI_DATI%ROWTYPE
    *********************************************************************/
    FUNCTION SelDAltroDatoByCodice (pCodAltroDato IN DB_ALTRI_DATI.CODICE%TYPE)
    RETURN DB_ALTRI_DATI%ROWTYPE IS
        recDAltriDati DB_ALTRI_DATI%ROWTYPE;
    BEGIN

        SELECT *
          INTO recDAltriDati
          FROM DB_ALTRI_DATI
         WHERE CODICE = pCodAltroDato
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recDAltriDati;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelDAltroDatoByCodice;

    /*********************************************************************
    Controlla se per le particelle associate al documento istanza di riesame passato
    in input è mai stata evasa un'istanza di riesame per l'anno passato in input e la
    fase istanza di riesame passata in input
    Tipo: function
    input: pIdAzienda, pAnno , pIdDoc, pIdFaseIs
    output: nessuno
    ritorno: DB_TIPO_CATEGORIA_NOTIFICA%ROWTYPE
    *********************************************************************/
    FUNCTION ExistsParticellaDocRieEvasa (pIdAzienda IN DB_ISTANZA_RIESAME.ID_AZIENDA%TYPE,
                                          pAnno      IN DB_ISTANZA_RIESAME.ANNO%TYPE,
                                          pIdDoc     IN DB_DOCUMENTO_CONDUZIONE.ID_DOCUMENTO%TYPE,
                                          pIdFaseIs  IN DB_ISTANZA_RIESAME.ID_FASE_ISTANZA_RIESAME%TYPE
                                          ) RETURN BOOLEAN IS
        nEvase INTEGER;
        bRet   BOOLEAN:=FALSE;
    BEGIN

        SELECT COUNT(DC.ID_DOCUMENTO_CONDUZIONE)
          INTO nEvase
          FROM DB_DOCUMENTO_CONDUZIONE DC,
               DB_CONDUZIONE_PARTICELLA CP
         WHERE DC.ID_DOCUMENTO = pIdDoc
           AND DC.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
           AND EXISTS (SELECT IR.ID_ISTANZA_RIESAME
                         FROM DB_ISTANZA_RIESAME IR
                        WHERE IR.ID_AZIENDA = pIdAzienda
                          AND IR.ANNO = pAnno
                          AND IR.ID_FASE_ISTANZA_RIESAME = pIdFaseIs
                          AND IR.ID_PARTICELLA = CP.ID_PARTICELLA
                          AND IR.DATA_EVASIONE IS NOT NULL);
        IF nEvase > 0 THEN
           bRet := TRUE;
        END IF;

        RETURN bRet;

    END ExistsParticellaDocRieEvasa;

    /*********************************************************************
    Dato un ID_CATEGORIA_NOTIFICA ritorna il corrispettivo record trovato
    su DB_TIPO_CATEGORIA_NOTIFICA andando per primary key
    Tipo: function
    input: pIdCatNot
    output: nessuno
    ritorno: DB_TIPO_CATEGORIA_NOTIFICA%ROWTYPE
    *********************************************************************/
    FUNCTION SelDCategoriaNotificaById (pIdCatNot IN DB_TIPO_CATEGORIA_NOTIFICA.ID_CATEGORIA_NOTIFICA%TYPE)
    RETURN DB_TIPO_CATEGORIA_NOTIFICA%ROWTYPE IS
        recDCategNotifica DB_TIPO_CATEGORIA_NOTIFICA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recDCategNotifica
          FROM DB_TIPO_CATEGORIA_NOTIFICA
         WHERE ID_CATEGORIA_NOTIFICA = pIdCatNot;

        RETURN recDCategNotifica;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('SelDCategoriaNotificaById - ID_CATEGORIA_NOTIFICA = ' || pIdCatNot);
             RAISE;
    END SelDCategoriaNotificaById;

    /*********************************************************************
    Inserisce un record di tipo DB_NOTIFICA sull'omonima tabella
    Tipo: procedure
    input: pRecTNotifica
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTNotifica (pRecTNotifica IN DB_NOTIFICA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_NOTIFICA
            (
            ID_NOTIFICA,
            ID_AZIENDA,
            ID_UTENTE_INSERIMENTO,
            ID_TIPOLOGIA_NOTIFICA,
            ID_PROCEDIMENTO_MITTENTE,
            ID_PROCEDIMENTO_DESTINATARIO,
            DATA_INSERIMENTO,
            DESCRIZIONE,
            DATA_CHIUSURA,
            NOTE_CHIUSURA,
            ID_UTENTE_CHIUSURA,
            ID_CATEGORIA_NOTIFICA,
            ID_UTENTE_AGGIORNAMENTO,
            DATA_AGGIORNAMENTO
            )
        VALUES
            (
            pRecTNotifica.ID_NOTIFICA,
            pRecTNotifica.ID_AZIENDA,
            pRecTNotifica.ID_UTENTE_INSERIMENTO,
            pRecTNotifica.ID_TIPOLOGIA_NOTIFICA,
            pRecTNotifica.ID_PROCEDIMENTO_MITTENTE,
            pRecTNotifica.ID_PROCEDIMENTO_DESTINATARIO,
            pRecTNotifica.DATA_INSERIMENTO,
            pRecTNotifica.DESCRIZIONE,
            pRecTNotifica.DATA_CHIUSURA,
            pRecTNotifica.NOTE_CHIUSURA,
            pRecTNotifica.ID_UTENTE_CHIUSURA,
            pRecTNotifica.ID_CATEGORIA_NOTIFICA,
            pRecTNotifica.ID_UTENTE_AGGIORNAMENTO,
            pRecTNotifica.DATA_AGGIORNAMENTO
            );
    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertTNotifica - ID_NOTIFICA = ' || pRecTNotifica.ID_NOTIFICA);
             RAISE;
    END InsertTNotifica;

    /*********************************************************************
    Imposta la data di fine validità a sysdate su un record di DB_STORICO_PARTICELLA
    Tipo: procedure
    input: pIdStoricoParticella
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ConcludiStoricoParticella (pIdStoricoParticella IN DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE) IS
    BEGIN
        UPDATE DB_STORICO_PARTICELLA
           SET DATA_FINE_VALIDITA = SYSDATE
         WHERE ID_STORICO_PARTICELLA = pIdStoricoParticella;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('ConcludiStoricoParticella - ID_STORICO_PARTICELLA = ' || pIdStoricoParticella);
             RAISE;
    END ConcludiStoricoParticella;

    /*********************************************************************
    Inserisce un record di tipo DB_ISTANZA_RIESAME nell'omonima tabella
    Tipo: procedure
    input: pRecTIstanzaRiesame
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTIstanzaRiesame (pRecTIstanzaRiesame IN DB_ISTANZA_RIESAME%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_ISTANZA_RIESAME
            (
            ID_ISTANZA_RIESAME,
            ID_FASE_ISTANZA_RIESAME,
            ANNO,
            ID_AZIENDA,
            ID_PARTICELLA,
            DATA_RICHIESTA,
            DATA_ANNULLAMENTO,
            DATA_EVASIONE,
            DATA_AGGIORNAMENTO
            )
        VALUES
            (
            pRecTIstanzaRiesame.ID_ISTANZA_RIESAME,
            pRecTIstanzaRiesame.ID_FASE_ISTANZA_RIESAME,
            pRecTIstanzaRiesame.ANNO,
            pRecTIstanzaRiesame.ID_AZIENDA,
            pRecTIstanzaRiesame.ID_PARTICELLA,
            pRecTIstanzaRiesame.DATA_RICHIESTA,
            pRecTIstanzaRiesame.DATA_ANNULLAMENTO,
            pRecTIstanzaRiesame.DATA_EVASIONE,
            pRecTIstanzaRiesame.DATA_AGGIORNAMENTO
            );

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertTIstanzaRiesame - ID_ISTANZA_RIESAME = ' || pRecTIstanzaRiesame.ID_ISTANZA_RIESAME);
             RAISE;
    END InsertTIstanzaRiesame;

    /*********************************************************************
    Inserisce un record di tipo DB_STORICO_PARTICELLA sulla tabella omonima
    Tipo: procedure
    input: pRecTStoricoParticella
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTStoricoParticella (pRecTStoricoParticella IN DB_STORICO_PARTICELLA%ROWTYPE) IS
    BEGIN
        INSERT INTO DB_STORICO_PARTICELLA
            (
            ID_STORICO_PARTICELLA,
            ID_PARTICELLA,
            SEZIONE,
            COMUNE,
            DATA_INIZIO_VALIDITA,
            FOGLIO,
            DATA_FINE_VALIDITA,
            PARTICELLA,
            SUP_CATASTALE,
            SUBALTERNO,
            ID_AREA_A,
            ID_ZONA_ALTIMETRICA,
            FLAG_IRRIGABILE,
            ID_AREA_B,
            ID_CASO_PARTICOLARE,
            ID_AREA_C,
            ID_AREA_D,
            DATA_AGGIORNAMENTO,
            ID_UTENTE_AGGIORNAMENTO,
            ID_CAUSALE_MOD_PARTICELLA,
            FLAG_CAPTAZIONE_POZZI,
            MOTIVO_MODIFICA,
            SUP_NON_ELEGGIBILE,
            SUP_NE_BOSCO_ACQUE_FABBRICATO,
            SUP_NE_FORAGGIERE,
            SUP_EL_FRUTTA_GUSCIO,
            SUP_EL_PRATO_PASCOLO,
            SUP_EL_COLTURE_MISTE,
            SUP_COLTIVAZ_ARBOREA_CONS,
            SUP_COLTIVAZ_ARBOREA_SPEC,
            DATA_FOTO,
            ID_FONTE,
            TIPO_FOTO,
            ID_DOCUMENTO,
            ID_IRRIGAZIONE,
            ID_DOCUMENTO_PROTOCOLLATO,
            ID_FASCIA_FLUVIALE,
            ID_AREA_G,
            ID_AREA_H,
            SUPERFICIE_GRAFICA,
            ID_POTENZIALITA_IRRIGUA,
            ID_TERRAZZAMENTO,
            ID_ROTAZIONE_COLTURALE,
            ID_AREA_I,
            ID_AREA_L,
            ID_AREA_M, 
            PERCENTUALE_PENDENZA_MEDIA, 
            GRADI_PENDENZA_MEDIA,       
            GRADI_ESPOSIZIONE_MEDIA,    
            METRI_ALTITUDINE_MEDIA,     
            ID_METODO_IRRIGUO
            )
        VALUES
            (
            pRecTStoricoParticella.ID_STORICO_PARTICELLA,
            pRecTStoricoParticella.ID_PARTICELLA,
            pRecTStoricoParticella.SEZIONE,
            pRecTStoricoParticella.COMUNE,
            pRecTStoricoParticella.DATA_INIZIO_VALIDITA,
            pRecTStoricoParticella.FOGLIO,
            pRecTStoricoParticella.DATA_FINE_VALIDITA,
            pRecTStoricoParticella.PARTICELLA,
            pRecTStoricoParticella.SUP_CATASTALE,
            pRecTStoricoParticella.SUBALTERNO,
            pRecTStoricoParticella.ID_AREA_A,
            pRecTStoricoParticella.ID_ZONA_ALTIMETRICA,
            pRecTStoricoParticella.FLAG_IRRIGABILE,
            pRecTStoricoParticella.ID_AREA_B,
            pRecTStoricoParticella.ID_CASO_PARTICOLARE,
            pRecTStoricoParticella.ID_AREA_C,
            pRecTStoricoParticella.ID_AREA_D,
            pRecTStoricoParticella.DATA_AGGIORNAMENTO,
            pRecTStoricoParticella.ID_UTENTE_AGGIORNAMENTO,
            pRecTStoricoParticella.ID_CAUSALE_MOD_PARTICELLA,
            pRecTStoricoParticella.FLAG_CAPTAZIONE_POZZI,
            pRecTStoricoParticella.MOTIVO_MODIFICA,
            pRecTStoricoParticella.SUP_NON_ELEGGIBILE,
            pRecTStoricoParticella.SUP_NE_BOSCO_ACQUE_FABBRICATO,
            pRecTStoricoParticella.SUP_NE_FORAGGIERE,
            pRecTStoricoParticella.SUP_EL_FRUTTA_GUSCIO,
            pRecTStoricoParticella.SUP_EL_PRATO_PASCOLO,
            pRecTStoricoParticella.SUP_EL_COLTURE_MISTE,
            pRecTStoricoParticella.SUP_COLTIVAZ_ARBOREA_CONS,
            pRecTStoricoParticella.SUP_COLTIVAZ_ARBOREA_SPEC,
            pRecTStoricoParticella.DATA_FOTO,
            pRecTStoricoParticella.ID_FONTE,
            pRecTStoricoParticella.TIPO_FOTO,
            pRecTStoricoParticella.ID_DOCUMENTO,
            pRecTStoricoParticella.ID_IRRIGAZIONE,
            pRecTStoricoParticella.ID_DOCUMENTO_PROTOCOLLATO,
            pRecTStoricoParticella.ID_FASCIA_FLUVIALE,
            pRecTStoricoParticella.ID_AREA_G,
            pRecTStoricoParticella.ID_AREA_H,
            pRecTStoricoParticella.SUPERFICIE_GRAFICA,
            pRecTStoricoParticella.ID_POTENZIALITA_IRRIGUA,
            pRecTStoricoParticella.ID_TERRAZZAMENTO,
            pRecTStoricoParticella.ID_ROTAZIONE_COLTURALE,
            pRecTStoricoParticella.ID_AREA_I,
            pRecTStoricoParticella.ID_AREA_L,
            pRecTStoricoParticella.ID_AREA_M,
            pRecTStoricoParticella.PERCENTUALE_PENDENZA_MEDIA, --M.C. 06/08/2015
            pRecTStoricoParticella.GRADI_PENDENZA_MEDIA,       --M.C. 06/08/2015
            pRecTStoricoParticella.GRADI_ESPOSIZIONE_MEDIA,    --M.C. 06/08/2015
            pRecTStoricoParticella.METRI_ALTITUDINE_MEDIA,      --M.C. 06/08/2015
            pRecTStoricoParticella.ID_METODO_IRRIGUO
            );

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertTStoricoParticella - ID_STORICO_PARTICELLA = ' || pRecTStoricoParticella.ID_STORICO_PARTICELLA);
             RAISE;
    END InsertTStoricoParticella;

    /*********************************************************************
    Dato un record di DB_STORICO_PARTICELLA chiude l'iter corrente e ne
    inserisce uno nuovo andando ad impostare la data di inizio validità
    a sysdate ed il motivo delle modifica a 'Variazione superficie grafica'
    Tipo: procedure
    input: pRecTStoricoParticella
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE AggiornaStoricoParticella (pRecTStoricoParticella IN OUT DB_STORICO_PARTICELLA%ROWTYPE) IS
    BEGIN
        ConcludiStoricoParticella (pRecTStoricoParticella.ID_STORICO_PARTICELLA);

        SELECT SEQ_STORICO_PARTICELLA.nextval
          INTO pRecTStoricoParticella.ID_STORICO_PARTICELLA
          FROM DUAL;
        pRecTStoricoParticella.ID_UTENTE_AGGIORNAMENTO := 9999999999;
        pRecTStoricoParticella.DATA_INIZIO_VALIDITA := SYSDATE;

        InsertTStoricoParticella (pRecTStoricoParticella);

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('AggiornaStoricoParticella - ID_STORICO_PARTICELLA = ' || pRecTStoricoParticella.ID_STORICO_PARTICELLA);
             RAISE;
    END AggiornaStoricoParticella;

    /*********************************************************************
    Effettua l'aggiornamento di alcune colonne di DB_PARTICELLA_CERTIFICAtA
    accedendo per chiave primaria
    Tipo: procedure
    input: pRecTParticellaCertificata
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE UpdateTParticellaCertificata (pRecTParticellaCertificata IN DB_PARTICELLA_CERTIFICATA%ROWTYPE) IS
    BEGIN

        UPDATE DB_PARTICELLA_CERTIFICATA
           SET PARTICELLA_A_GIS = pRecTParticellaCertificata.PARTICELLA_A_GIS,
               ESITO = pRecTParticellaCertificata.ESITO,
               DATA_VALIDAZIONE_FONTE_ELEGG = pRecTParticellaCertificata.DATA_VALIDAZIONE_FONTE_ELEGG,
               ID_FONTE_ELEGG = pRecTParticellaCertificata.ID_FONTE_ELEGG,
               DATA_ULTIMO_AGGIORNAMENTO = pRecTParticellaCertificata.DATA_ULTIMO_AGGIORNAMENTO,
               SUP_GRAFICA = pRecTParticellaCertificata.SUP_GRAFICA,
               SUP_USO_GRAFICA = pRecTParticellaCertificata.SUP_USO_GRAFICA,
               SUP_SEMINABILE = pRecTParticellaCertificata.SUP_SEMINABILE,
               SUP_AREA_COPERTA = pRecTParticellaCertificata.SUP_AREA_COPERTA,
               SUP_AREA_SCOPERTA = pRecTParticellaCertificata.SUP_AREA_SCOPERTA,
               SUP_INCOLTI = pRecTParticellaCertificata.SUP_INCOLTI,
               SUP_COLT_ARBOREA_SPECIALIZZATA = pRecTParticellaCertificata.SUP_COLT_ARBOREA_SPECIALIZZATA,
               SUP_STRADE = pRecTParticellaCertificata.SUP_STRADE,
               SUP_COLTIVAZIONE_ARBOREA_CONSO = pRecTParticellaCertificata.SUP_COLTIVAZIONE_ARBOREA_CONSO,
               SUP_ACQUE = pRecTParticellaCertificata.SUP_USO_NON_AGRICOLO,
               SUP_USO_NON_AGRICOLO = pRecTParticellaCertificata.SUP_USO_NON_AGRICOLO,
               DATA_ULTIMA_LAVORAZIONE = pRecTParticellaCertificata.DATA_ULTIMA_LAVORAZIONE,
               STATO_ULTIMA_LAVORAZIONE = pRecTParticellaCertificata.STATO_ULTIMA_LAVORAZIONE,
               STATO_GIS = pRecTParticellaCertificata.STATO_GIS,
               STATO_CXF = pRecTParticellaCertificata.STATO_CXF ,
               DATA_SOSPENSIONE = pRecTParticellaCertificata.DATA_SOSPENSIONE
         WHERE ID_PARTICELLA_CERTIFICATA = pRecTParticellaCertificata.ID_PARTICELLA_CERTIFICATA;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('UpdateTParticellaCertificata - ID_PARTICELLA_CERTIFICATA = ' || pRecTParticellaCertificata.ID_PARTICELLA_CERTIFICATA);
             RAISE;
    END UpdateTParticellaCertificata;

    /*********************************************************************
    Seleziona il record attivo (DATA_FINE_VALIDITA a null) di DB_PARTICELLA_CERTIFICATA
    accedendo per chiave catastale
    Tipo: function
    input: pIstatComune, pSezione, pFoglio, pParticella, pSubalterno
    output: nessuno
    ritorno: DB_PARTICELLA_CERTIFICATA%ROWTYPE
    *********************************************************************/
    FUNCTION SelTPartCertByChiaveCatastale (pIstatComune IN DB_PARTICELLA_CERTIFICATA.COMUNE%TYPE,
                                            pSezione     IN DB_PARTICELLA_CERTIFICATA.SEZIONE%TYPE,
                                            pFoglio      IN DB_PARTICELLA_CERTIFICATA.FOGLIO%TYPE,
                                            pParticella  IN DB_PARTICELLA_CERTIFICATA.PARTICELLA%TYPE,
                                            pSubalterno  IN DB_PARTICELLA_CERTIFICATA.SUBALTERNO%TYPE
                                            ) RETURN DB_PARTICELLA_CERTIFICATA%ROWTYPE IS
        recTPartCertificata DB_PARTICELLA_CERTIFICATA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTPartCertificata
          FROM DB_PARTICELLA_CERTIFICATA
         WHERE COMUNE = pIstatComune
           AND NVL(SEZIONE,'#') = NVL(pSezione,'#')
           AND FOGLIO = pFoglio
           AND PARTICELLA = pParticella
           AND NVL(SUBALTERNO,'#') = NVL(pSubalterno,'#')
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recTPartCertificata;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('SelTPartCertByChiaveCatastale ' || pIstatComune || '/' || pSezione || '/' || pFoglio || '/' || pParticella || '/' || pSubalterno);
             RAISE;
    END SelTPartCertByChiaveCatastale;

    /*********************************************************************
    Seleziona il record attivo (DATA_FINE_VALIDITA a null) di DB_STORICO_PARTICELLA accedendo
    per chiave catastale
    Tipo: function
    input: pIstatComune, pSezione, pFoglio, pParticella, pSubalterno
    output: nessuno
    ritorno: DB_STORICO_PARTICELLA%ROWTYPE
    *********************************************************************/
    FUNCTION SelTStorPartByChiaveCatastale (pIstatComune IN DB_STORICO_PARTICELLA.COMUNE%TYPE,
                                            pSezione     IN DB_STORICO_PARTICELLA.SEZIONE%TYPE,
                                            pFoglio      IN DB_STORICO_PARTICELLA.FOGLIO%TYPE,
                                            pParticella  IN DB_STORICO_PARTICELLA.PARTICELLA%TYPE,
                                            pSubalterno  IN DB_STORICO_PARTICELLA.SUBALTERNO%TYPE
                                            ) RETURN DB_STORICO_PARTICELLA%ROWTYPE IS
        recTStoricoParticella DB_STORICO_PARTICELLA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTStoricoParticella
          FROM DB_STORICO_PARTICELLA
         WHERE COMUNE = pIstatComune
           AND NVL(SEZIONE,'#') = NVL(pSezione,'#')
           AND FOGLIO = pFoglio
           AND PARTICELLA = pParticella
           AND NVL(SUBALTERNO,'#') = NVL(pSubalterno,'#')
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recTStoricoParticella;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('SelTStorPartByChiaveCatastale = ' || pIstatComune || '/' || pSezione || '/' || pFoglio || '/' || pParticella || '/' || pSubalterno);
             RAISE;
    END SelTStorPartByChiaveCatastale;

    /*********************************************************************
    Inserisce un record di tipo DB_PARTICELLA_CERTIFICATA sull'omonima tabella
    Tipo: procedure
    input: pRecTPartCertificata
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTParticellaCertificata (pRecTPartCertificata IN DB_PARTICELLA_CERTIFICATA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_PARTICELLA_CERTIFICATA
            (
            ID_PARTICELLA_CERTIFICATA,
            COMUNE,
            SEZIONE,
            FOGLIO,
            PARTICELLA,
            ID_ZONA_ALTIMETRICA,
            ID_PARTICELLA,
            SUP_CATASTALE,
            SUP_NON_ELEGGIBILE,
            SUP_NE_BOSCO_ACQUE_FABBRICATO,
            SUP_NE_FORAGGIERE,
            SUP_EL_FRUTTA_GUSCIO,
            SUP_EL_PRATO_PASCOLO,
            SUP_EL_COLTURE_MISTE,
            SUP_COLTIVAZ_ARBOREA_CONS,
            SUP_COLTIVAZ_ARBOREA_SPEC,
            DATA_FOTO,
            TIPO_FOTO,
            DATA_CARICAMENTO,
            STATO,
            SUBALTERNO,
            ID_FONTE,
            QUALITA,
            CLASSE,
            PARTITA,
            DATA_ULTIMO_AGGIORNAMENTO,
            DENOMINATORE,
            DATA_VALIDAZIONE_FONTE_CATASTO,
            DATA_VALIDAZIONE_FONTE_ELEGG,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA,
            FLAG_PROVENIENZA,
            DATA_SOPPRESSIONE,
            SUP_SEMINABILE,
            ID_QUALITA,
            PARTICELLA_A_GIS,
            SUP_ACQUE,
            SUP_INCOLTI,
            SUP_COLT_ARBOREA_SPECIALIZZATA,
            SUP_USO_NON_AGRICOLO,
            SUP_STRADE,
            SUP_COLTIVAZIONE_ARBOREA_CONSO,
            SUP_AREA_SCOPERTA,
            SUP_AREA_COPERTA,
            ESITO,
            ID_FONTE_ELEGG,
            INIZIO_VALIDITA_AGEA,
            FINE_VALIDITA_AGEA,
            FLAG_SCARTO,
            DATA_ATTO,
            DATA_REGISTRAZIONE,
            DATA_ULTIMA_LAVORAZIONE,
            STATO_ULTIMA_LAVORAZIONE,
            FLAG_CXF_DU2007,
            SUP_GRAFICA,
            SUP_USO_GRAFICA,
            STATO_GIS,
            STATO_CXF,
            DATA_SOSPENSIONE
            )
        VALUES
            (
            pRecTPartCertificata.ID_PARTICELLA_CERTIFICATA,
            pRecTPartCertificata.COMUNE,
            pRecTPartCertificata.SEZIONE,
            pRecTPartCertificata.FOGLIO,
            pRecTPartCertificata.PARTICELLA,
            pRecTPartCertificata.ID_ZONA_ALTIMETRICA,
            pRecTPartCertificata.ID_PARTICELLA,
            pRecTPartCertificata.SUP_CATASTALE,
            pRecTPartCertificata.SUP_NON_ELEGGIBILE,
            pRecTPartCertificata.SUP_NE_BOSCO_ACQUE_FABBRICATO,
            pRecTPartCertificata.SUP_NE_FORAGGIERE,
            pRecTPartCertificata.SUP_EL_FRUTTA_GUSCIO,
            pRecTPartCertificata.SUP_EL_PRATO_PASCOLO,
            pRecTPartCertificata.SUP_EL_COLTURE_MISTE,
            pRecTPartCertificata.SUP_COLTIVAZ_ARBOREA_CONS,
            pRecTPartCertificata.SUP_COLTIVAZ_ARBOREA_SPEC,
            pRecTPartCertificata.DATA_FOTO,
            pRecTPartCertificata.TIPO_FOTO,
            pRecTPartCertificata.DATA_CARICAMENTO,
            pRecTPartCertificata.STATO,
            pRecTPartCertificata.SUBALTERNO,
            pRecTPartCertificata.ID_FONTE,
            pRecTPartCertificata.QUALITA,
            pRecTPartCertificata.CLASSE,
            pRecTPartCertificata.PARTITA,
            pRecTPartCertificata.DATA_ULTIMO_AGGIORNAMENTO,
            pRecTPartCertificata.DENOMINATORE,
            pRecTPartCertificata.DATA_VALIDAZIONE_FONTE_CATASTO,
            pRecTPartCertificata.DATA_VALIDAZIONE_FONTE_ELEGG,
            pRecTPartCertificata.DATA_INIZIO_VALIDITA,
            pRecTPartCertificata.DATA_FINE_VALIDITA,
            pRecTPartCertificata.FLAG_PROVENIENZA,
            pRecTPartCertificata.DATA_SOPPRESSIONE,
            pRecTPartCertificata.SUP_SEMINABILE,
            pRecTPartCertificata.ID_QUALITA,
            pRecTPartCertificata.PARTICELLA_A_GIS,
            pRecTPartCertificata.SUP_ACQUE,
            pRecTPartCertificata.SUP_INCOLTI,
            pRecTPartCertificata.SUP_COLT_ARBOREA_SPECIALIZZATA,
            pRecTPartCertificata.SUP_USO_NON_AGRICOLO,
            pRecTPartCertificata.SUP_STRADE,
            pRecTPartCertificata.SUP_COLTIVAZIONE_ARBOREA_CONSO,
            pRecTPartCertificata.SUP_AREA_SCOPERTA,
            pRecTPartCertificata.SUP_AREA_COPERTA,
            pRecTPartCertificata.ESITO,
            pRecTPartCertificata.ID_FONTE_ELEGG,
            pRecTPartCertificata.INIZIO_VALIDITA_AGEA,
            pRecTPartCertificata.FINE_VALIDITA_AGEA,
            pRecTPartCertificata.FLAG_SCARTO,
            pRecTPartCertificata.DATA_ATTO,
            pRecTPartCertificata.DATA_REGISTRAZIONE,
            pRecTPartCertificata.DATA_ULTIMA_LAVORAZIONE,
            pRecTPartCertificata.STATO_ULTIMA_LAVORAZIONE,
            pRecTPartCertificata.FLAG_CXF_DU2007,
            pRecTPartCertificata.SUP_GRAFICA,
            pRecTPartCertificata.SUP_USO_GRAFICA,
            pRecTPartCertificata.STATO_GIS,
            pRecTPartCertificata.STATO_CXF,
            pRecTPartCertificata.DATA_SOSPENSIONE
            );

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertTParticellaCertificata - ID_PARTICELLA_CERTIFICATA = ' || pRecTPartCertificata.ID_PARTICELLA_CERTIFICATA);
             RAISE;
    END InsertTParticellaCertificata;

FUNCTION SelDZonaAltimetricaForFoglio(pIstatComune  COMUNE.ISTAT_COMUNE%TYPE,
                                      pSezione      DB_FOGLIO.SEZIONE%TYPE,
                                      pFoglio       DB_FOGLIO.FOGLIO%TYPE) RETURN DB_FOGLIO.ID_ZONA_ALTIMETRICA%TYPE IS

  nZonaAlt DB_FOGLIO.ID_ZONA_ALTIMETRICA%TYPE;
BEGIN
  SELECT ID_ZONA_ALTIMETRICA
  INTO   nZonaAlt
  FROM   DB_FOGLIO
  WHERE  COMUNE           = pIstatComune
  AND    NVL(SEZIONE,'-') = NVL(pSezione, '-')
  AND    FOGLIO           = pFoglio;

  RETURN nZonaAlt;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN NULL;
  WHEN OTHERS THEN
    PCK_SMRGAA_LOG.LogSqlError ('SelDZonaAltimetricaForFoglio - pIstatComune,pSezione,pFoglio = ' || pIstatComune||' - '||
                                pSezione||' - '||pFoglio);
    RAISE;
END SelDZonaAltimetricaForFoglio;

    /*********************************************************************
    Dato un id_particella seleziona la stessa su DB_PARTICELLA e ne ritorna
    il ROWTYPE
    Tipo: procedure
    input: pIdParticella
    output: nessuno
    ritorno: DB_PARTICELLA%ROWTYPE
    *********************************************************************/
    FUNCTION SelectTParticellaById (pIdParticella IN DB_PARTICELLA.ID_PARTICELLA%TYPE)
    RETURN DB_PARTICELLA%ROWTYPE IS
        recTParticella DB_PARTICELLA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTParticella
          FROM DB_PARTICELLA
         WHERE ID_PARTICELLA = pIdParticella;

        RETURN recTParticella;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('SelectTParticellaById - pIdParticella = ' || pIdParticella);
             RAISE;
    END SelectTParticellaById;

    /*********************************************************************
    Dato un id_particella_certificata controllo se è presente almeno un record
    attivo (DATA_FINE_VALIDITA a NULL) sulla tabella DB_ESITO_PASCOLO_MAGRO
    Tipo: function
    input: pIdParticellaCertificata
    output: nessuno
    ritorno: TRUE / FALSE
    *********************************************************************/
    FUNCTION ExixtsEsitoPascoloMagro (pIdParticellaCertificata IN DB_ESITO_PASCOLO_MAGRO.ID_PARTICELLA_CERTIFICATA%TYPE)
    RETURN BOOLEAN IS
        nRec INTEGER:=0;
        bRet BOOLEAN:=FALSE;
    BEGIN
        SELECT COUNT(ID_ESITO_PASCOLO_MAGRO)
          INTO nRec
          FROM DB_ESITO_PASCOLO_MAGRO
         WHERE ID_PARTICELLA_CERTIFICATA = pIdParticellaCertificata
           AND DATA_FINE_VALIDITA IS NULL;

        IF nRec > 0 THEN
           bRet := TRUE;
        END IF;

        RETURN bRet;

    END ExixtsEsitoPascoloMagro;

    /*********************************************************************
    Dati la particella e la sua data ultima lavorazione se quest'ultima è
    maggiore della massima data richiesta riesame presente su DB_ISTANZA_RIESAME
    per le azienda (si solito una) che conducono la particella slego
    tutti i documenti di riesame attivi sulla particella e metto
    ad evaso la fase 1 (lavorazione) dell'istanza di riesame sulla particella
    Tipo: procedure
    input: pIdParticella, pAnnoCampagnaEleggibilita, pDataUltimaLavorazione, pRecDTipoCategNot,
           pIdListaCampione, pDescListaCampione, pDataSospensione
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE SlegaConduzAssociateDocRiesame (pIdParticella             IN DB_PARTICELLA.ID_PARTICELLA%TYPE,
                                              pAnnoCampagnaEleggibilita IN INTEGER,
                                              pDataUltimaLavorazione    IN DATE,
                                              pRecDTipoCategNot         IN DB_TIPO_CATEGORIA_NOTIFICA%ROWTYPE,
                                              pIdListaCampione          IN DB_ISTANZA_RIESAME.ID_LISTA_CAMPIONE%TYPE,
                                              pDescListaCampione        IN DB_ISTANZA_RIESAME.DESC_LISTA_CAMPIONE%TYPE,
                                              pDataSospensione          IN DATE
                                              ) IS
        recTParticella DB_PARTICELLA%ROWTYPE;
        nIdDocumento   DB_DOCUMENTO_CONDUZIONE.ID_DOCUMENTO%TYPE;
        TYPE TypVetDoc IS TABLE OF DB_DOCUMENTO_CONDUZIONE.ID_DOCUMENTO%TYPE INDEX BY PLS_INTEGER;
        VetDoc TypVetDoc;
        recTNotifica   DB_NOTIFICA%ROWTYPE;

        CURSOR curIstanzaRiesamePart IS
        SELECT ID_AZIENDA, MAX(DATA_RICHIESTA) AS DATA_RICHIESTA
          FROM DB_ISTANZA_RIESAME
         WHERE ID_PARTICELLA = pIdParticella
           AND ANNO = pAnnoCampagnaEleggibilita 
           AND DATA_EVASIONE IS NULL 
           AND DATA_ANNULLAMENTO IS NULL  
      GROUP BY ID_AZIENDA;

    BEGIN
        -- recTParticella := SelectTParticellaById (pIdParticella);
        -- scorro le aziende per le quali la particella è in istanza di riesame
        -- (di solito una)
        FOR recIstanzaRiesamePart IN curIstanzaRiesamePart LOOP
            -- se la data lavorazione / fotointerpretazione della particella
            -- è maggiore della data richiesta istanza di riesame

            -- IF (pDataUltimaLavorazione > recIstanzaRiesamePart.DATA_RICHIESTA) OR pIdListaCampione IS NOT NULL THEN

            -- cesso il legame documento istanza di riesame particella
            -- ma uso la tabella DB_R_FASE_RIESAME_TP_DOCUMENTO
            -- per la fase istanza riesame fotointerpretazione
            -- per prendere le possibili tipologie di documento
            UPDATE DB_DOCUMENTO_CONDUZIONE
               SET DATA_FINE_VALIDITA = SYSDATE
             WHERE ID_DOCUMENTO_CONDUZIONE IN (
                SELECT DC.ID_DOCUMENTO_CONDUZIONE
                  FROM DB_DOCUMENTO_CONDUZIONE DC,
                       DB_DOCUMENTO D,
                       DB_CONDUZIONE_PARTICELLA CP,
                       DB_R_FASE_RIESAME_TP_DOCUMENTO FRTD
                 WHERE D.EXT_ID_DOCUMENTO = FRTD.ID_DOCUMENTO
                   AND FRTD.ID_FASE_ISTANZA_RIESAME = knIdFaseIstRiesameInLav
                   AND FRTD.DATA_FINE_VALIDITA IS NULL
                   AND D.ID_DOCUMENTO = DC.ID_DOCUMENTO
                   AND D.ID_AZIENDA = recIstanzaRiesamePart.ID_AZIENDA
                   AND D.ID_STATO_DOCUMENTO IS NULL
                   AND (D.DATA_FINE_VALIDITA IS NULL OR D.DATA_FINE_VALIDITA > SYSDATE)
                   AND CP.ID_PARTICELLA = pIdParticella
                   --AND CP.DATA_FINE_CONDUZIONE IS NULL
                   AND CP.ID_CONDUZIONE_PARTICELLA = DC.ID_CONDUZIONE_PARTICELLA
                   AND (DC.DATA_FINE_VALIDITA IS NULL OR DC.DATA_FINE_VALIDITA > SYSDATE))
            RETURN ID_DOCUMENTO BULK COLLECT INTO VetDoc;

            PCK_SMRGAA_LOG.LogDebug ('Particella : ' || pIdParticella || ' slegati : ' || SQL%ROWCOUNT || ' documenti di istanza di riesame');

            -- per i documenti impattati dalla update di sopra (dovrebbe comunque essere 1 solo)
            -- controllo se ci sono ancora documenti_conduzioni attivi (data_fine = null) in caso non ce
            -- ne siano cesso anche il documento
            FOR I IN 1..VetDoc.COUNT LOOP

                UPDATE DB_DOCUMENTO D
                   SET D.DATA_FINE_VALIDITA = SYSDATE
                 WHERE D.ID_DOCUMENTO = VetDoc(I)
                   AND (D.DATA_FINE_VALIDITA IS NULL OR D.DATA_FINE_VALIDITA > SYSDATE)
                   AND NOT EXISTS (SELECT DC.ID_DOCUMENTO_CONDUZIONE
                                     FROM DB_DOCUMENTO_CONDUZIONE DC
                                    WHERE DC.ID_DOCUMENTO = D.ID_DOCUMENTO
                                      AND DC.DATA_FINE_VALIDITA IS NULL)
                RETURN ID_DOCUMENTO INTO nIdDocumento;

                IF nIdDocumento IS NOT NULL THEN
                   SELECT SEQ_NOTIFICA.nextval
                     INTO recTNotifica.ID_NOTIFICA
                     FROM DUAL;

                   recTNotifica.ID_AZIENDA := recIstanzaRiesamePart.ID_AZIENDA;
                   recTNotifica.ID_UTENTE_INSERIMENTO := 9999999999;
                   recTNotifica.ID_TIPOLOGIA_NOTIFICA := pRecDTipoCategNot.ID_TIPOLOGIA_NOTIFICA;
                   recTNotifica.ID_CATEGORIA_NOTIFICA := pRecDTipoCategNot.ID_CATEGORIA_NOTIFICA;
                   recTNotifica.ID_PROCEDIMENTO_MITTENTE := knIdProcedimentoSMRGAA;
                   recTNotifica.ID_PROCEDIMENTO_DESTINATARIO := knIdProcedimentoSMRGAA;
                   recTNotifica.DATA_INSERIMENTO := SYSDATE;
                   recTNotifica.ID_UTENTE_AGGIORNAMENTO := 9999999999; 
                   recTNotifica.DATA_AGGIORNAMENTO := SYSDATE; 
                   IF pDataSospensione IS NOT NULL THEN
                      recTNotifica.DESCRIZIONE := 'Chiusura automatica per scadenza dei termini della sospensione';
                   ELSE
                      recTNotifica.DESCRIZIONE := 'Chiusura automatica per evasione fotinterpretazione gis';
                   END IF;
                   InsertTNotifica (recTNotifica);

                END IF;

            END LOOP;

            -- metto a SYSDATE la DATA_EVASIONE della fase IN LAVORAZIONE
            -- dell'istanza di riesame per l'azienda e la particella interessate
            UPDATE DB_ISTANZA_RIESAME
               SET DATA_EVASIONE = pDataUltimaLavorazione,
                   ID_LISTA_CAMPIONE = pIdListaCampione,
                   DESC_LISTA_CAMPIONE = pDescListaCampione,
                   DATA_AGGIORNAMENTO = SYSDATE, 
                   DATA_SOSPENSIONE_SCADUTA = pDataSospensione 
             WHERE ID_AZIENDA = recIstanzaRiesamePart.ID_AZIENDA
               AND ID_PARTICELLA = pIdParticella
               AND ID_FASE_ISTANZA_RIESAME = knIdFaseIstRiesameInLav
               AND DATA_EVASIONE IS NULL
               AND DATA_ANNULLAMENTO IS NULL; 

            PCK_SMRGAA_LOG.LogDebug ('Particella : ' || pIdParticella || ' evasa/e : ' || SQL%ROWCOUNT || '  istanza/e di riesame');

            -- END IF;
        END LOOP;
    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('SlegaConduzAssociateDocRiesame - pIdParticella/pDataUltimaLavorazione = ' || pIdParticella || '/' || pDataUltimaLavorazione);
             RAISE;
    END SlegaConduzAssociateDocRiesame;

    /*********************************************************************
    Aggiorna il FLAG_ISTANZA_RIESAME ad 'S' per la dichiarazione consistenza
    data in input
    Tipo: procedure
    input: pIdDichConsistenza
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE UpdateFlagRichiestaRiesame (pIdDichConsistenza IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE) IS
    BEGIN

        UPDATE DB_DICHIARAZIONE_CONSISTENZA
           SET FLAG_ISTANZA_RIESAME = 'S'
         WHERE ID_DICHIARAZIONE_CONSISTENZA = pIdDichConsistenza;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('UpdateFlagRichiestaRiesame - pIdDichConsistenza = ' || pIdDichConsistenza);
             RAISE;
    END UpdateFlagRichiestaRiesame;

    /*********************************************************************
    Aggiorna il flag elaborato ad 'S' ok a 'K' (ko) in per l'id_eleggibilita_gis
    dato in input a seconda di come è andata l'elaborazione (bElabKo)
    Tipo: procedure
    input: pIdEleggibilitaGis, bElabKo
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE EvadiEleggibilitaGis (pIdEleggibilitaGis  IN SMRGAA_W_ELEGGIBILITA_GIS.ID_ELEGGIBILITA_GIS%TYPE,
                                    bElabKo             IN BOOLEAN
                                    ) IS
    BEGIN

        IF bElabKo THEN
            UPDATE SMRGAA_W_ELEGGIBILITA_GIS
               SET ELABORATO = 'K'
             WHERE ID_ELEGGIBILITA_GIS = pIdEleggibilitaGis;
        ELSE
            UPDATE SMRGAA_W_ELEGGIBILITA_GIS
               SET ELABORATO = 'S'
             WHERE ID_ELEGGIBILITA_GIS = pIdEleggibilitaGis;
        END IF;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('EvadiEleggibilitaGis - pIdEleggibilitaGis = ' || pIdEleggibilitaGis);
             RAISE;
    END EvadiEleggibilitaGis;

    /*********************************************************************
    Inserisce sulla tabella SMRGAA_W_ELEGGIBILITA_GIS un record col suo ROWTYPE
    Tipo: procedure
    input: pRecWEleggibilitaGis
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertWEleggibilitaGis (pRecWEleggibilitaGis IN SMRGAA_W_ELEGGIBILITA_GIS%ROWTYPE) IS
    BEGIN
        INSERT INTO SMRGAA_W_ELEGGIBILITA_GIS
            (
            ID_ELEGGIBILITA_GIS,
            ISTAT_COMUNE,
            SEZIONE,
            FOGLIO,
            PARTICELLA,
            SUBALTERNO,
            SUP_CATASTALE,
            PARTICELLA_A_GIS,
            SUP_GIS_PARTICELLA,
            SUP_GIS_SUOLO,
            ESITO,
            COD_ERRORE,
            DATA_AGGIORNAMENTO,
            STATO_GIS,
            STATO_CXF,
            DATA_LAVORAZIONE,
            STATO_LAVORAZIONE,
            DATA_SOSPENSIONE
            )
        VALUES
            (
            pRecWEleggibilitaGis.ID_ELEGGIBILITA_GIS,
            pRecWEleggibilitaGis.ISTAT_COMUNE,
            pRecWEleggibilitaGis.SEZIONE,
            pRecWEleggibilitaGis.FOGLIO,
            pRecWEleggibilitaGis.PARTICELLA,
            pRecWEleggibilitaGis.SUBALTERNO,
            pRecWEleggibilitaGis.SUP_CATASTALE,
            pRecWEleggibilitaGis.PARTICELLA_A_GIS,
            pRecWEleggibilitaGis.SUP_GIS_PARTICELLA,
            pRecWEleggibilitaGis.SUP_GIS_SUOLO,
            pRecWEleggibilitaGis.ESITO,
            pRecWEleggibilitaGis.COD_ERRORE,
            pRecWEleggibilitaGis.DATA_AGGIORNAMENTO,
            pRecWEleggibilitaGis.STATO_GIS,
            pRecWEleggibilitaGis.STATO_CXF,
            pRecWEleggibilitaGis.DATA_LAVORAZIONE,
            pRecWEleggibilitaGis.STATO_LAVORAZIONE,
            pRecWEleggibilitaGis.DATA_SOSPENSIONE
            );
    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertWEleggibilitaGis - ID_ELEGGIBILITA_GIS = ' || pRecWEleggibilitaGis.ID_ELEGGIBILITA_GIS);
             RAISE;
    END InsertWEleggibilitaGis;

    /*********************************************************************
    Inserisce sulla tabella SMRGAA_W_ELEGGIBILITA_GIS_DETT un record col suo ROWTYPE
    Tipo: procedure
    input: pRecWEleggiblitaGisDett
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertWEleggibilitaGisDett (pRecWEleggiblitaGisDett IN SMRGAA_W_ELEGGIBILITA_GIS_DETT%ROWTYPE) IS
    BEGIN
        INSERT INTO SMRGAA_W_ELEGGIBILITA_GIS_DETT
            (
            ID_ELEGGIBILITA_GIS_DETT,
            ID_ELEGGIBILITA_GIS,
            AREA_COLT,
            COD_VARIETA,
            TARA,
            PIANTE_PROD,
            PIANTE_TOT,
            CLASSE,
            ID_ELEGGIBILITA,
            ID_ELEGGIBILITA_FIT
            )
        VALUES
            (
            pRecWEleggiblitaGisDett.ID_ELEGGIBILITA_GIS_DETT,
            pRecWEleggiblitaGisDett.ID_ELEGGIBILITA_GIS,
            pRecWEleggiblitaGisDett.AREA_COLT,
            pRecWEleggiblitaGisDett.COD_VARIETA,
            pRecWEleggiblitaGisDett.TARA,
            pRecWEleggiblitaGisDett.PIANTE_PROD,
            pRecWEleggiblitaGisDett.PIANTE_TOT,
            pRecWEleggiblitaGisDett.CLASSE,
            pRecWEleggiblitaGisDett.ID_ELEGGIBILITA,
            pRecWEleggiblitaGisDett.ID_ELEGGIBILITA_FIT
            );
    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertWEleggibilitaGisDett - ID_ELEGGIBILITA_GIS_DETT = ' || pRecWEleggiblitaGisDett.ID_ELEGGIBILITA_GIS_DETT);
             RAISE;
    END InsertWEleggibilitaGisDett;

    /*********************************************************************
    Controlla se la chiave catastale del record preso dal file di testo e
    accodato nel variabile pRecWElegNew è diversa da quella precedente accoda
    nella variabile di appoggio pRecWElegOld
    Tipo: procedure
    input: pRecWElegNew, pRecWElegOld
    output: nessuno
    ritorno: TRUE / FALSE
    *********************************************************************/
    FUNCTION ChiaveCatastaleDiversa  (pRecWElegNew IN SMRGAA_W_ELEGGIBILITA_GIS%ROWTYPE,
                                      pRecWElegOld IN SMRGAA_W_ELEGGIBILITA_GIS%ROWTYPE
                                      ) RETURN BOOLEAN IS
        bRet BOOLEAN:=FALSE;
    BEGIN

        IF (pRecWElegNew.ISTAT_COMUNE <> pRecWElegOld.ISTAT_COMUNE OR
            NVL(pRecWElegNew.SEZIONE,'#') <> NVL(pRecWElegOld.SEZIONE,'#') OR
            pRecWElegNew.FOGLIO <> pRecWElegOld.FOGLIO OR
            pRecWElegNew.PARTICELLA <> pRecWElegOld.PARTICELLA OR
            NVL(pRecWElegNew.SUBALTERNO,'#') <> NVL(pRecWElegOld.SUBALTERNO,'#')) OR
           (pRecWElegOld.ISTAT_COMUNE IS NULL AND
            pRecWElegOld.SEZIONE IS NULL AND
            pRecWElegOld.FOGLIO IS NULL AND
            pRecWElegOld.PARTICELLA IS NULL AND
            pRecWElegOld.SUBALTERNO IS NULL) THEN

            bRet:=TRUE;
        END IF;

        RETURN bRet;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('ChiaveCatastaleDiversa - COMUNE/SEZIONE/FOGLIO/PARTICELLA/SUBALTERNO - ' || pRecWElegNew.ISTAT_COMUNE || '/' || pRecWElegNew.SEZIONE || '/' || pRecWElegNew.FOGLIO || '/' || pRecWElegNew.PARTICELLA || '/' || pRecWElegNew.SUBALTERNO);
             RAISE;
    END ChiaveCatastaleDiversa;

    /*********************************************************************
    Effettua il caricamento sulle tabelle di appoggio SMRGAA_W_ELEGGIBILITA_GIS
    e SMRGAA_W_ELEGGIBILITA_GIS_DETT dei dati relativi all'eleggibilita presenti
    nel file di testo col nome passato in input
    Tipo: procedure
    input: pPathName, pNomeFile
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE CaricaTabelleDiLavoro (pPathName  IN VARCHAR2,
                                     pNomeFile  IN VARCHAR2
                                     ) IS
        fFileEleggibilita   UTL_FILE.FILE_TYPE;
        vRigaApp            VARCHAR2(2000);
        nRecElab            INTEGER:=0;
        nPartElab           INTEGER:=0;
        n                   INTEGER:=0;
        recTEleggibilitaOld SMRGAA_W_ELEGGIBILITA_GIS%ROWTYPE;
        recTEleggibilita    SMRGAA_W_ELEGGIBILITA_GIS%ROWTYPE;
        recTDettEleggiblita SMRGAA_W_ELEGGIBILITA_GIS_DETT%ROWTYPE;
    BEGIN

        PCK_SMRGAA_LOG.LogInfo ('Inizio Caricamento tabelle di appoggio : SMRGAA_W_ELEGGIBLITA_GIS e SMRGAA_W_ELEGGIBILITA_GIS_DETT');
        EXECUTE IMMEDIATE 'TRUNCATE TABLE SMRGAA_W_ELEGGIBILITA_GIS';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE SMRGAA_W_ELEGGIBILITA_GIS_DETT';
        fFileEleggibilita := UTL_FILE.FOPEN( pPathName, pNomeFile, 'R',2000);

        LOOP
            BEGIN
                nRecElab := nRecElab + 1;
                UTL_FILE.GET_LINE( fFileEleggibilita, vRigaApp );
                -- dati relativi alla particella catastale
                -- comune
                n := NVL(INSTR(vRigaApp,';'),0);
                recTEleggibilita.ISTAT_COMUNE := TRIM(SUBSTR(vRigaApp,1,n-1));
                vRigaApp := SUBSTR(vRigaApp, n+1 );
                -- sezione
                n := NVL(INSTR(vRigaApp,';'),0);
                recTEleggibilita.SEZIONE := TRIM(SUBSTR(vRigaApp,1,n-1));
                vRigaApp := SUBSTR(vRigaApp, n+1 );
                -- foglio
                n := NVL(INSTR(vRigaApp,';'),0);
                recTEleggibilita.FOGLIO  := TRIM(SUBSTR(vRigaApp,1,n-1));
                vRigaApp := SUBSTR(vRigaApp, n+1 );
                -- particella
                n := NVL(INSTR(vRigaApp,';'),0);
                recTEleggibilita.PARTICELLA := TRIM(SUBSTR(vRigaApp,1,n-1));
                vRigaApp := SUBSTR(vRigaApp, n+1 );
                -- subalterno
                n := NVL(INSTR(vRigaApp,';'),0);
                recTEleggibilita.SUBALTERNO  := TRIM(SUBSTR(vRigaApp,1,n-1));
                vRigaApp := SUBSTR(vRigaApp, n+1 );

                IF ChiaveCatastaleDiversa (recTEleggibilita, recTEleggibilitaOld) THEN
                   SELECT SEQ_SMRGAA_W_ELEGGIBILITA_GIS.nextval
                     INTO recTEleggibilita.ID_ELEGGIBILITA_GIS
                     FROM DUAL;
                    -- superficie catastale
                    n := NVL(INSTR(vRigaApp,';'),0);
                    recTEleggibilita.SUP_CATASTALE := TRIM(SUBSTR(vRigaApp,1,n-1));
                    vRigaApp := SUBSTR(vRigaApp, n+1 );
                    -- flag particella a gis
                    n := NVL(INSTR(vRigaApp,';'),0);
                    recTEleggibilita.PARTICELLA_A_GIS := TRIM(SUBSTR(vRigaApp,1,n-1));
                    vRigaApp := SUBSTR(vRigaApp, n+1 );
                    -- superficie gis particella
                    n := NVL(INSTR(vRigaApp,';'),0);
                    recTEleggibilita.SUP_GIS_PARTICELLA := TRIM(SUBSTR(vRigaApp,1,n-1));
                    vRigaApp := SUBSTR(vRigaApp, n+1 );
                    -- superficie gis suolo
                    n := NVL(INSTR(vRigaApp,';'),0);
                    recTEleggibilita.SUP_GIS_SUOLO  := TRIM(SUBSTR(vRigaApp,1,n-1));
                    vRigaApp := SUBSTR(vRigaApp, n+1 );
                ELSE
                    -- salto i quattro campi successivi in quanto coincidenti con quelli
                    -- del record precedente
                    n := NVL(INSTR(vRigaApp,';'),0);
                    vRigaApp := SUBSTR(vRigaApp, n+1 );
                    n := NVL(INSTR(vRigaApp,';'),0);
                    vRigaApp := SUBSTR(vRigaApp, n+1 );
                    n := NVL(INSTR(vRigaApp,';'),0);
                    vRigaApp := SUBSTR(vRigaApp, n+1 );
                    n := NVL(INSTR(vRigaApp,';'),0);
                    vRigaApp := SUBSTR(vRigaApp, n+1 );
                    recTEleggibilita := recTEleggibilitaOld;
                END IF;

                -- dati relativi all'eleggibilità
                SELECT SEQ_SMRGAA_W_ELEG_GIS_DETT.nextval
                  INTO recTDettEleggiblita.ID_ELEGGIBILITA_GIS_DETT
                  FROM DUAL;
                -- ID_ELEGGIBILITA_GIS padre
                recTDettEleggiblita.ID_ELEGGIBILITA_GIS := recTEleggibilita.ID_ELEGGIBILITA_GIS;
                -- area coltivata
                n := NVL(INSTR(vRigaApp,';'),0);
                recTDettEleggiblita.AREA_COLT := TRIM(SUBSTR(vRigaApp,1,n-1));
                vRigaApp := SUBSTR(vRigaApp, n+1 );
                -- codice varieta
                n := NVL(INSTR(vRigaApp,';'),0);
                recTDettEleggiblita.COD_VARIETA := TRIM(SUBSTR(vRigaApp,1,n-1));
                vRigaApp := SUBSTR(vRigaApp, n+1 );
                -- tara
                n := NVL(INSTR(vRigaApp,';'),0);
                recTDettEleggiblita.TARA := TRIM(SUBSTR(vRigaApp,1,n-1));
                vRigaApp := SUBSTR(vRigaApp, n+1 );
                -- piante
                n := NVL(INSTR(vRigaApp,';'),0);
                recTDettEleggiblita.PIANTE_PROD := TRIM(SUBSTR(vRigaApp,1,n-1));
                vRigaApp := SUBSTR(vRigaApp, n+1 );
                -- piante totali
                n := NVL(INSTR(vRigaApp,';'),0);
                recTDettEleggiblita.PIANTE_TOT := TRIM(SUBSTR(vRigaApp,1,n-1));
                vRigaApp := SUBSTR(vRigaApp, n+1 );
                -- classe
                n := NVL(INSTR(vRigaApp,';'),0);
                recTDettEleggiblita.CLASSE := TRIM(SUBSTR(vRigaApp,1,n-1));
                vRigaApp := SUBSTR(vRigaApp, n+1 );
                -- dati relativi all'esito dell'operazione
                IF recTEleggibilita.ID_ELEGGIBILITA_GIS <>
                   NVL(recTEleggibilitaOld.ID_ELEGGIBILITA_GIS,0) THEN
                    nPartElab := nPartElab + 1;
                    -- esito
                    n := NVL(INSTR(vRigaApp,';'),0);
                    recTEleggibilita.ESITO := TRIM(SUBSTR(vRigaApp,1,n-1));
                    vRigaApp := SUBSTR(vRigaApp, n+1 );
                    -- codice errore
                    n := NVL(INSTR(vRigaApp,';'),0);
                    recTEleggibilita.COD_ERRORE := TRIM(SUBSTR(vRigaApp,1,n-1));
                    vRigaApp := SUBSTR(vRigaApp, n+1 );
                    -- stato gis
                    n := NVL(INSTR(vRigaApp,';'),0);
                    recTEleggibilita. STATO_GIS := TRIM(SUBSTR(vRigaApp,1,n-1));
                    vRigaApp := SUBSTR(vRigaApp, n+1 );
                    -- stato cxf
                    n := NVL(INSTR(vRigaApp,';'),0);
                    recTEleggibilita.STATO_CXF := TRIM(SUBSTR(vRigaApp,1,n-1));
                    vRigaApp := SUBSTR(vRigaApp, n+1 );
                    -- data lavorazione
                    n := NVL(INSTR(vRigaApp,';'),0);
                    recTEleggibilita.DATA_LAVORAZIONE := TO_DATE(TRIM(SUBSTR(vRigaApp,1,n-1)),'DD/MM/YYYY hh24:mi:ss');
                    vRigaApp := SUBSTR(vRigaApp, n+1 );
                    -- stato lavorazione
                    n := NVL(INSTR(vRigaApp,';'),0);
                    recTEleggibilita.STATO_LAVORAZIONE:= TRIM(SUBSTR(vRigaApp,1,n-1));
                    vRigaApp := SUBSTR(vRigaApp, n+1 );
                    -- data sospensione
                    n := NVL(INSTR(vRigaApp,';'),0);
                    recTEleggibilita.DATA_SOSPENSIONE := TO_DATE(TRIM(SUBSTR(vRigaApp,1,n-1)),'DD/MM/YYYY hh24:mi:ss');
                    vRigaApp := SUBSTR(vRigaApp, n+1 );
                    -- data aggiornamento a sysdate
                    recTEleggibilita.DATA_AGGIORNAMENTO := SYSDATE;
                    InsertWEleggibilitaGis (recTEleggibilita);
                    recTEleggibilitaOld := recTEleggibilita;
                END IF;

                InsertWEleggibilitaGisDett (recTDettEleggiblita);
                -- ogni mille records committo
                IF MOD(nPartElab,1000) = 0 THEN
                   COMMIT;
                END IF;

            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     EXIT;
            END;

        END LOOP;
        UTL_FILE.FCLOSE(fFileEleggibilita);

        PCK_SMRGAA_LOG.LogInfo ('Fine caricamento , inserite : ' || nPartElab || ' particelle catastali e ' || nRecElab || ' eleggiblità');

        COMMIT;

    EXCEPTION
        WHEN OTHERS THEN
            PCK_SMRGAA_LOG.LogSqlError ('CaricaTabelleDiLavoro');
            UTL_FILE.FCLOSE(fFileEleggibilita);
            RAISE;
    END CaricaTabelleDiLavoro;

    /*********************************************************************
    Dato un ID_ELEGGIBILITA_FITTIZIA ritorna il primo ID_ELEGGIBILITA
    a cui è associato ordinando per il livello della DB_TIPO_ELEGGIBILITA
    decrescente
    Tipo: Function
    input: pIdEleFit
    output: nessuno
    ritorno: nIdEle
    *********************************************************************/
    FUNCTION FIND_ELEGGIBILITA_DA_CLS_FIT(pIdEleFit IN NUMBER) RETURN NUMBER IS
        nIdEle  DB_TIPO_ELEGGIBILITA.ID_ELEGGIBILITA%TYPE;
    BEGIN
        SELECT ID_ELEGGIBILITA
          INTO nIdEle
          FROM (SELECT A.ID_ELEGGIBILITA, B.LIVELLO
                  FROM DB_VARIETA_ELEGGIBILITA a,
                       DB_TIPO_ELEGGIBILITA b
                 WHERE A.ID_ELEGGIBILITA = B.ID_ELEGGIBILITA
                   AND A.ID_ELEGGIBILITA_FIT = pIdEleFit
              GROUP BY A.ID_ELEGGIBILITA,B.LIVELLO
              ORDER BY  B.LIVELLO DESC)
          WHERE ROWNUM = 1;

        RETURN nIdEle;

    EXCEPTION
        WHEN OTHERS THEN
            nIdEle := NULL;
            RETURN(nIdEle);
    END FIND_ELEGGIBILITA_DA_CLS_FIT;

    /*********************************************************************
    Dato un ID_ELEGGIBILITA_GIS ed un ID_ELEGGIBILITA effettua
    la SUM della colonna AREA_COLT della tabella di appoggio
    SMRGAA_W_ELEGGIBILITA_GIS_DETT
    Tipo: Function
    input: pIdElegGis, pIdElegg
    output: nessuno
    ritorno: nTotSum
    *********************************************************************/
    FUNCTION FIND_SUPERFICI(pIdElegGis  IN SMRGAA_W_ELEGGIBILITA_GIS_DETT.ID_ELEGGIBILITA_GIS%TYPE,
                            pIdElegg    IN SMRGAA_W_ELEGGIBILITA_GIS_DETT.ID_ELEGGIBILITA%TYPE
                          )  RETURN NUMBER IS
        nTotSum NUMBER;
    BEGIN

        SELECT NVL(SUM(NVL(AREA_COLT,0)),0)
          INTO nTotSum
          FROM SMRGAA_W_ELEGGIBILITA_GIS_DETT
         WHERE ID_ELEGGIBILITA_GIS = pIdElegGis
           AND ID_ELEGGIBILITA = pIdElegg;

        RETURN(nTotSum);

    END FIND_SUPERFICI;

    /*********************************************************************
    Dato un ID_ELEGGIBILITA_GIS ritorna la somma dell'AREA_COLTURA
    per ogni eleggibilita per cui sono presenti records su SMRGAA_W_ELEGGIBILITA_GIS_DETT
    Tipo: procedure
    input: pIdElegGis
    output: pTot1,pTot2,pTot3,pTot4,pTot5,pTot6,pTot7,pTot8,pTot9
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE FIND_SUPERFICI_TOT( pIdElegGis    IN  SMRGAA_W_ELEGGIBILITA_GIS_DETT.ID_ELEGGIBILITA_GIS%TYPE,
                                  pTot1         OUT NUMBER,
                                  pTot2         OUT NUMBER,
                                  pTot3         OUT NUMBER,
                                  pTot4         OUT NUMBER,
                                  pTot5         OUT NUMBER,
                                  pTot6         OUT NUMBER,
                                  pTot7         OUT NUMBER,
                                  pTot8         OUT NUMBER,
                                  pTot9         OUT NUMBER) IS

        CURSOR curEleggibilitaDett IS
        SELECT NVL(SUM(NVL(AREA_COLT,0)),0) TOTSUP,
               ID_ELEGGIBILITA
          FROM SMRGAA_W_ELEGGIBILITA_GIS_DETT
         WHERE ID_ELEGGIBILITA_GIS = pIdElegGis
      GROUP BY ID_ELEGGIBILITA;

    BEGIN

        pTot1 := 0;
        pTot2 := 0;
        pTot3 := 0;
        pTot4 := 0;
        pTot5 := 0;
        pTot6 := 0;
        pTot7 := 0;
        pTot8 := 0;
        pTot9 := 0;

        FOR recEleggibilitaDett IN curEleggibilitaDett LOOP
            IF  recEleggibilitaDett.ID_ELEGGIBILITA = 1 THEN
                pTot1 := recEleggibilitaDett.TOTSUP;
            ELSIF  recEleggibilitaDett.ID_ELEGGIBILITA = 2 THEN
                pTot2 := recEleggibilitaDett.TOTSUP;
            ELSIF  recEleggibilitaDett.ID_ELEGGIBILITA = 3 THEN
                pTot3 := recEleggibilitaDett.TOTSUP;
            ELSIF  recEleggibilitaDett.ID_ELEGGIBILITA = 4 THEN
                pTot4 := recEleggibilitaDett.TOTSUP;
            ELSIF  recEleggibilitaDett.ID_ELEGGIBILITA = 5 THEN
                pTot5 := recEleggibilitaDett.TOTSUP;
            ELSIF  recEleggibilitaDett.ID_ELEGGIBILITA = 6 THEN
                pTot6 := recEleggibilitaDett.TOTSUP;
            ELSIF  recEleggibilitaDett.ID_ELEGGIBILITA = 7 THEN
                pTot7 := recEleggibilitaDett.TOTSUP;
            ELSIF  recEleggibilitaDett.ID_ELEGGIBILITA = 8 THEN
                pTot8 := recEleggibilitaDett.TOTSUP;
            ELSIF  recEleggibilitaDett.ID_ELEGGIBILITA = 9 THEN
                pTot9 := recEleggibilitaDett.TOTSUP;
            END IF;
        END LOOP;

    END FIND_SUPERFICI_TOT;

    /*********************************************************************
    Scorre i record da elaborare presenti su SMRGAA_W_ELEGGIBILITA_GIS ed
    effettua l'aggiornamento / inserimento dei dati su DB_PARTICELLA_CERTIFICATA,
    DB_PARTICELLA_CERT_ELEG e DB_STORICO_PARTICELLA
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION Acquisizione_Eleggibilita RETURN NUMBER IS

        CURSOR curEleggibilitaGis IS
        SELECT EG.*, MAX (CAMPAGNA) OVER (PARTITION BY ISTAT_COMUNE,SEZIONE,FOGLIO,PARTICELLA,SUBALTERNO) AS CAMPAGNA_MAX
          FROM SMRGAA_W_ELEGGIBILITA_GIS EG
         WHERE EG.ELABORATO IS NULL
      ORDER BY EG.ISTAT_COMUNE,EG.SEZIONE,EG.FOGLIO,EG.PARTICELLA,EG.SUBALTERNO ASC,EG.CAMPAGNA DESC;

        CURSOR curParticellaCampione IS
        SELECT *
          FROM SMRGAA_W_PARTICELLA_CAMPIONE
         WHERE ELABORATO IS NULL;

        nTot1               NUMBER;
        nTot2               NUMBER;
        nTot3               NUMBER;
        nTot4               NUMBER;
        nTot5               NUMBER;
        nTot6               NUMBER;
        nTot7               NUMBER;
        nTot8               NUMBER;
        nTot9               NUMBER;
        nRec                INTEGER:=0;
        nRecKo              INTEGER:=0;
        -- record di appoggio per il reperimento dei dati dell'applicazione corrente
        recDApplicazione    SMRGAA_D_APPLICAZIONI_BATCH%ROWTYPE;
        -- conterrà l'id esecuzione
        nIdEsecuzione       SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE;
        -- conterrà il codice di ritorno
        nRetCode            NUMBER(1):=0;
        bErr                BOOLEAN:=FALSE;

        recTParticellaCert  DB_PARTICELLA_CERTIFICATA%ROWTYPE;
        recTStoricoPart     DB_STORICO_PARTICELLA%ROWTYPE;
        -- vettore di parametri di input
        vetParametri        PCK_SMRGAA_LOG.TypVetParametriApplicazione;
        vTipoEsecuzione     VARCHAR2(1);
        bParamOk            BOOLEAN:=TRUE;
        nAnnoMax            INTEGER;
        bInserimento        BOOLEAN:=FALSE;
        bAggiornaStorico    BOOLEAN:=FALSE;
        recDTipoCategNot    DB_TIPO_CATEGORIA_NOTIFICA%ROWTYPE;

    BEGIN

        nRetCode := Pck_SMRGAA_Log.VerificaAttivazioneBatch( knIdApplBatchEleggibilita ,recDApplicazione);

        IF nRetCode > 0 THEN
             -- Errore, Batch non attivo
            RETURN nRetCode;
        END IF;

        Pck_SMRGAA_Log.LeggiFileEsecuzione ( recDApplicazione.nomefile_esecuzione, recDApplicazione.path_file_esecuzione );

        Pck_SMRGAA_Log.SetLogLevel ( recDApplicazione.log_level );

        Pck_SMRGAA_Log.Init( knIdApplBatchEleggibilita,'Acquisizione_Eleggibilita');

        Pck_SMRGAA_Log.LogInfo ('Inizio Elaborazione');

        -- carico il vettore di parametri per il batch
        vetParametri := PCK_SMRGAA_LOG.CaricaParametriApplicazione(knIdApplBatchEleggibilita);

        IF vetParametri.COUNT > 0 THEN
            BEGIN
                vTipoEsecuzione:= vetParametri (kvCodParametroTipoEsecuzione).val_varchar2;
                PCK_SMRGAA_LOG.LogInfo ('Parametro opzionale : ' || kvCodParametroTipoEsecuzione || ' presente ed uguale a : ' || vTipoEsecuzione);
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    vTipoEsecuzione := 'N';
                WHEN OTHERS THEN
                    PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroTipoEsecuzione || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                    bParamOk := FALSE;
            END;

            BEGIN
                recDTipoCategNot.ID_CATEGORIA_NOTIFICA := vetParametri (kvCodParametroCategNotIstRies).val_number;
                recDTipoCategNot := SelDCategoriaNotificaById (recDTipoCategNot.ID_CATEGORIA_NOTIFICA);
                PCK_SMRGAA_LOG.LogInfo ('Parametro obbligatorio : ' || kvCodParametroCategNotIstRies || ' presente ed uguale a : ' || recDTipoCategNot.ID_CATEGORIA_NOTIFICA);

            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    PCK_SMRGAA_LOG.LogAnomalia ('Parametro obbligatorio : ' || kvCodParametroCategNotIstRies || ' non valorizzato !! - Termino Elaborazione');
                    bParamOk := FALSE;
                WHEN OTHERS THEN
                    PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroCategNotIstRies || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                    bParamOk := FALSE;
            END;


        END IF;

        IF bParamOk THEN
            -- cancello i parametri di esecuzione opzionali
            PCK_SMRGAA_LOG.EliminaParametroApplicazione (knIdApplBatchEleggibilita,kvCodParametroDataDa);
            PCK_SMRGAA_LOG.EliminaParametroApplicazione (knIdApplBatchEleggibilita,kvCodParametroTipoEsecuzione);
            PCK_SMRGAA_LOG.EliminaParametroApplicazione (knIdApplBatchEleggibilita,kvCodParametroTipoEliminazione);

            -- Recupero i dati di eleggibilita e di
            -- eleggibilita fittizia dalla classe GIS

            UPDATE SMRGAA_W_ELEGGIBILITA_GIS_DETT EGD
               SET EGD.ID_ELEGGIBILITA_FIT = (SELECT ID_ELEGGIBILITA_FIT
                                                FROM DB_TIPO_ELEGGIBILITA_FIT
                                               WHERE CODICE = EGD.CLASSE
                                                 AND DATA_FINE_VALIDITA IS NULL),
                   EGD.ID_ELEGGIBILITA =( WITH ELEGGIBILITA AS
                                                (SELECT VE.ID_ELEGGIBILITA, VE.ID_ELEGGIBILITA_FIT, TEF.CODICE, TE.LIVELLO
                                                   FROM DB_VARIETA_ELEGGIBILITA VE,
                                                        DB_TIPO_ELEGGIBILITA TE,
                                                        DB_TIPO_ELEGGIBILITA_FIT TEF
                                                  WHERE VE.ID_ELEGGIBILITA_FIT = TEF.ID_ELEGGIBILITA_FIT
                                                    AND VE.ID_ELEGGIBILITA = TE.ID_ELEGGIBILITA
                                                    AND VE.DATA_FINE_VALIDITA IS NULL
                                                 GROUP BY VE.ID_ELEGGIBILITA, VE.ID_ELEGGIBILITA_FIT, TEF.CODICE, TE.LIVELLO
                                                 ORDER BY TEF.CODICE,TE.LIVELLO DESC
                                                 )
                                            SELECT ID_ELEGGIBILITA
                                              FROM ELEGGIBILITA
                                             WHERE CODICE = EGD.CLASSE
                                               AND ROWNUM = 1)
             WHERE EGD.CLASSE IS NOT NULL
               AND EGD.ID_ELEGGIBILITA_FIT IS NULL;

            nRec := SQL%ROWCOUNT;
            PCK_SMRGAA_LOG.LogInfo ('Aggiornate ID_ELEGGIBILITA ed ID_ELEGGIBILITA_FIT su SMRGAA_W_ELEGGIBILITA_GIS_DETT per : ' || nRec || ' records');

            COMMIT;

            nRec:= 0;

            --- Carico l'eleggiblità appena importata
            FOR recEleggibilitaGis IN curEleggibilitaGis LOOP
                BEGIN
                    bInserimento := FALSE;
                    bAggiornaStorico := FALSE;
                    bErr :=FALSE;
                    -- cerco la particella su DB_STORICO_PARTICELLA
                    recTStoricoPart := SelTStorPartByChiaveCatastale (recEleggibilitaGis.ISTAT_COMUNE,
                                                                      recEleggibilitaGis.SEZIONE,
                                                                      recEleggibilitaGis.FOGLIO,
                                                                      recEleggibilitaGis.PARTICELLA,
                                                                      recEleggibilitaGis.SUBALTERNO);
                    -- cerco la particella su DB_PARTICELLA_CERTIFICATA
                    recTParticellaCert := SelTPartCertByChiaveCatastale (recEleggibilitaGis.ISTAT_COMUNE,
                                                                         recEleggibilitaGis.SEZIONE,
                                                                         recEleggibilitaGis.FOGLIO,
                                                                         recEleggibilitaGis.PARTICELLA,
                                                                         recEleggibilitaGis.SUBALTERNO);

                    FIND_SUPERFICI_TOT(recEleggibilitaGis.ID_ELEGGIBILITA_GIS,nTot1,nTot2,nTot3,nTot4,nTot5,nTot6,nTot7,nTot8,nTot9);

                    -- se la particella non c'è su DB_PARTICELLA_CERTIFICATA
                    IF recTParticellaCert.ID_PARTICELLA_CERTIFICATA IS NULL THEN
                        -- la inserisco
                        bInserimento := TRUE;
                        SELECT SEQ_PARTICELLA_CERTIFICATA.nextval
                          INTO recTParticellaCert.ID_PARTICELLA_CERTIFICATA
                          FROM DUAL;

                        recTParticellaCert.COMUNE := recEleggibilitaGis.ISTAT_COMUNE;
                        recTParticellaCert.SEZIONE := recEleggibilitaGis.SEZIONE;
                        recTParticellaCert.FOGLIO := recEleggibilitaGis.FOGLIO;
                        recTParticellaCert.PARTICELLA := recEleggibilitaGis.PARTICELLA;
                        recTParticellaCert.SUBALTERNO := recEleggibilitaGis.SUBALTERNO;
                        recTParticellaCert.STATO := 'A';
                        recTParticellaCert.ID_ZONA_ALTIMETRICA := NVL(SelDZonaAltimetricaForFoglio(recEleggibilitaGis.ISTAT_COMUNE,
                                                                                                   recEleggibilitaGis.SEZIONE,
                                                                                                   recEleggibilitaGis.FOGLIO),6);
                        recTParticellaCert.ID_PARTICELLA := recTStoricoPart.ID_PARTICELLA;
                        recTParticellaCert.ID_FONTE := 2;
                        recTParticellaCert.DATA_INIZIO_VALIDITA := SYSDATE;
                        recTParticellaCert.DATA_FINE_VALIDITA := NULL;
                        recTParticellaCert.DATA_CARICAMENTO := SYSDATE;
                        recTParticellaCert.DATA_VALIDAZIONE_FONTE_CATASTO := SYSDATE;
                        recTParticellaCert.SUP_CATASTALE := 0;
                    ELSE
                        -- seleziono il massimo anno campagna per il quale
                        -- in base dati è presente un'eleggibilità per la particella certificata
                        SELECT MAX(ANNO_CAMPAGNA)
                          INTO nAnnoMax
                          FROM DB_PARTICELLA_CERT_ELEG
                         WHERE ID_PARTICELLA_CERTIFICATA = recTParticellaCert.ID_PARTICELLA_CERTIFICATA;
                    END IF;

                    -- in ogni caso devo aggiornare una marea di colonne
                    recTParticellaCert.DATA_ULTIMO_AGGIORNAMENTO := SYSDATE;
                    recTParticellaCert.PARTICELLA_A_GIS := recEleggibilitaGis.PARTICELLA_A_GIS;
                    recTParticellaCert.ESITO := recEleggibilitaGis.ESITO;
                    recTParticellaCert.DATA_VALIDAZIONE_FONTE_ELEGG := TRUNC(recEleggibilitaGis.DATA_AGGIORNAMENTO);
                    recTParticellaCert.ID_FONTE_ELEGG := 2;
                    -- recTParticellaCert.SUP_GRAFICA := recEleggibilitaGis.SUP_GIS_PARTICELLA / 10000;
                    recTParticellaCert.SUP_GRAFICA := recEleggibilitaGis.SUP_GIS_SUOLO / 10000;
                    recTParticellaCert.SUP_USO_GRAFICA := recEleggibilitaGis.SUP_GIS_SUOLO / 10000;
                    recTParticellaCert.SUP_SEMINABILE := nTot2 / 10000 ;
                    recTParticellaCert.SUP_AREA_COPERTA := nTot9 / 10000;
                    recTParticellaCert.SUP_AREA_SCOPERTA := nTot8 / 10000;
                    recTParticellaCert.SUP_INCOLTI := nTot3 / 10000;
                    recTParticellaCert.SUP_COLT_ARBOREA_SPECIALIZZATA := nTot4 / 10000;
                    recTParticellaCert.SUP_STRADE := nTot6 / 10000;
                    recTParticellaCert.SUP_COLTIVAZIONE_ARBOREA_CONSO := nTot7 / 10000;
                    recTParticellaCert.SUP_ACQUE := nTot1 / 10000;
                    recTParticellaCert.SUP_USO_NON_AGRICOLO := nTot5 / 10000;
                    recTParticellaCert.DATA_ULTIMA_LAVORAZIONE := recEleggibilitaGis.DATA_LAVORAZIONE;
                    recTParticellaCert.STATO_ULTIMA_LAVORAZIONE := recEleggibilitaGis.STATO_LAVORAZIONE;
                    recTParticellaCert.STATO_GIS := recEleggibilitaGis.STATO_GIS;
                    recTParticellaCert.STATO_CXF := recEleggibilitaGis.STATO_CXF;
                    recTParticellaCert.DATA_SOSPENSIONE := recEleggibilitaGis.DATA_SOSPENSIONE;
                    -- se si tratta di nuova particella certificata
                    IF bInserimento THEN
                       -- effettuo la insert
                       InsertTParticellaCertificata (recTParticellaCert);
                       bAggiornaStorico := TRUE; 
                    ELSE
                       -- altrimenti se si tratta di esecuzione massiva
                       IF vTipoEsecuzione = 'M' THEN
                          -- controllo se per la particella la campagna che sto trattando
                          -- e quella massima all'interno del flusso
                          IF recEleggibilitaGis.CAMPAGNA = recEleggibilitaGis.CAMPAGNA_MAX THEN
                             -- effettuo l'update
                             UpdateTParticellaCertificata (recTParticellaCert);
                             bAggiornaStorico := TRUE;
                          END IF;
                       ELSE
                           -- effettuo l'update di DB_PARTICELLA_CERTIFICATA solamente se l'anno campagna
                           -- in elaborazione è maggiore od uguale dell'ultimo anno campagna per il quale
                           -- ho delle eleggibilità per la particella certificata
                           IF recEleggibilitaGis.CAMPAGNA >= NVL(nAnnoMax,recEleggibilitaGis.CAMPAGNA) THEN
                              UpdateTParticellaCertificata (recTParticellaCert);
                              bAggiornaStorico := TRUE;
                           END IF;
                       END IF;
                       -- cancello le eleggibilità della particella
                       -- per l'anno campagna
                       DELETE
                         FROM DB_PARTICELLA_CERT_ELEG
                        WHERE ID_PARTICELLA_CERTIFICATA = recTParticellaCert.ID_PARTICELLA_CERTIFICATA
                          AND ANNO_CAMPAGNA = recEleggibilitaGis.CAMPAGNA;
                    END IF;

                EXCEPTION
                    WHEN OTHERS THEN
                         PCK_SMRGAA_LOG.LogAnomalia ('Chiave catastale : - COMUNE : ' || recEleggibilitaGis.ISTAT_COMUNE ||
                                                                       ' - SEZIONE : '|| recEleggibilitaGis.SEZIONE ||
                                                                       ' - FOGLIO : '|| recEleggibilitaGis.FOGLIO ||
                                                                       ' - PARTICELLA : ' || recEleggibilitaGis.PARTICELLA ||
                                                                       ' - SUBALTERNO : '|| recEleggibilitaGis.SUBALTERNO ||
                                                     ' errore oracle durante aggiornamento particella certificata : ' || SUBSTR(SQLERRM,1,100));
                         recTParticellaCert.ID_PARTICELLA_CERTIFICATA := NULL;
                         bErr := TRUE;
                         nRecKo := nRecKo + 1;
                END;

                -- se ho inserito / aggiornare correttamente la particella certificata
                IF recTParticellaCert.ID_PARTICELLA_CERTIFICATA IS NOT NULL THEN
                    -- posso provare ad inserire anche le eleggibilità ad essa legate
                    BEGIN
                        INSERT INTO DB_PARTICELLA_CERT_ELEG (ID_PARTICELLA_CERT_ELEG,
                                                             ID_PARTICELLA_CERTIFICATA,
                                                             ID_ELEGGIBILITA,
                                                             ID_ELEGGIBILITA_FIT,
                                                             SUPERFICIE,
                                                             SUPERFICIE_TARA,
                                                             PIANTE_PROD,
                                                             PIANTE_TOT,
                                                             DATA_FOTOINTERPRETAZIONE,
                                                             ANNO_CAMPAGNA
                                                             )
                        SELECT SEQ_PARTICELLA_CERT_ELEG.NEXTVAL,
                               recTParticellaCert.ID_PARTICELLA_CERTIFICATA,
                               ID_ELEGGIBILITA,
                               ID_ELEGGIBILITA_FIT,
                               AREA_COLT / 10000,
                               TARA / 10000,
                               PIANTE_PROD,
                               PIANTE_TOT,
                               recEleggibilitaGis.DATA_FOTOINTERPRETAZIONE,
                               recEleggibilitaGis.CAMPAGNA
                          FROM SMRGAA_W_ELEGGIBILITA_GIS_DETT
                         WHERE ID_ELEGGIBILITA_GIS = recEleggibilitaGis.ID_ELEGGIBILITA_GIS
                           AND ID_ELEGGIBILITA  IS NOT NULL;

                        -- somma la superficie eleggibile
                        -- appena inserita per la particella certificata e l'anno campagna
                        SELECT SUM(SUPERFICIE)
                          INTO recTParticellaCert.SUP_STRADE -- uso il campo sup_strade come campo di appoggio per tenere la nuova superficie grafica
                          FROM DB_PARTICELLA_CERT_ELEG
                         WHERE ID_PARTICELLA_CERTIFICATA = recTParticellaCert.ID_PARTICELLA_CERTIFICATA
                           AND ANNO_CAMPAGNA = recEleggibilitaGis.CAMPAGNA;

                        -- confronto se la somma della superficie eleggibile e' diversa
                        -- dalla grafica impostata precedentemente
                        IF recTParticellaCert.SUP_STRADE <> recTParticellaCert.SUP_GRAFICA THEN
                           -- se si aggiorno la SUP_GRAFICA con valore calcolato come somma dell'eleggibile
                           UPDATE DB_PARTICELLA_CERTIFICATA
                              SET SUP_GRAFICA = recTParticellaCert.SUP_STRADE,
                                  SUP_USO_GRAFICA = recTParticellaCert.SUP_STRADE
                            WHERE ID_PARTICELLA_CERTIFICATA = recTParticellaCert.ID_PARTICELLA_CERTIFICATA;
                           -- aassegno alla colonna SUP_GRAFIA d'appoggio il valore di SUP_STRADE
                           recTParticellaCert.SUP_GRAFICA := recTParticellaCert.SUP_STRADE;
                        END IF;

                        -- se devo aggiornare lo storico particella
                        IF bAggiornaStorico THEN
                            -- e se la particella esiste su DB_STORICO_PARTICELLA
                           IF recTStoricoPart.ID_STORICO_PARTICELLA IS NOT NULL THEN
                              -- effettuo l'aggiornamento della superficie grafica
                              IF recTStoricoPart.SUPERFICIE_GRAFICA <> recTParticellaCert.SUP_GRAFICA OR
                                 recTStoricoPart.PERCENTUALE_PENDENZA_MEDIA <> recEleggibilitaGis.PENDENZA_PCT OR
                                 recTStoricoPart.GRADI_PENDENZA_MEDIA <> recEleggibilitaGis.PENDENZA_GRAD OR
                                 recTStoricoPart.GRADI_ESPOSIZIONE_MEDIA <> recEleggibilitaGis.ESPOSIZIONE OR
                                 recTStoricoPart.METRI_ALTITUDINE_MEDIA <> recEleggibilitaGis.ALTITUDINE THEN

                                 recTStoricoPart.SUPERFICIE_GRAFICA := recTParticellaCert.SUP_GRAFICA;
                                 recTStoricoPart.MOTIVO_MODIFICA := 'Variazione superficie grafica x campagna o info 3D ' || recEleggibilitaGis.CAMPAGNA;
                                 recTStoricoPart.PERCENTUALE_PENDENZA_MEDIA := recEleggibilitaGis.PENDENZA_PCT;
                                 recTStoricoPart.GRADI_PENDENZA_MEDIA := recEleggibilitaGis.PENDENZA_GRAD;
                                 recTStoricoPart.GRADI_ESPOSIZIONE_MEDIA := recEleggibilitaGis.ESPOSIZIONE;
                                 recTStoricoPart.METRI_ALTITUDINE_MEDIA := recEleggibilitaGis.ALTITUDINE;
                                 AggiornaStoricoParticella(recTStoricoPart);
                              END IF;
                           END IF;
                        END IF;


                    EXCEPTION
                        WHEN OTHERS THEN
                             PCK_SMRGAA_LOG.LogAnomalia ('Errore durante l''aggiornamento di DB_PARTICELLA_CERT_ELEG per ID_PARTICELLA_CERTIFICATA = ' || recTParticellaCert.ID_PARTICELLA_CERTIFICATA || ' ' || SUBSTR(SQLERRM,1,100));
                             nRecKo := nRecKo + 1;
                             bErr := TRUE;
                    END;
                END IF;

                EvadiEleggibilitaGis (recEleggibilitaGis.ID_ELEGGIBILITA_GIS, bErr);

                COMMIT;

                nRec := nRec + 1;

            END LOOP;

            PCK_SMRGAA_LOG.LogInfo ('Aggiornata DB_PARTICELLA_CERTIFICATA trattati : ' || nRec || ' records,
                                                                            di cui : ' || TO_CHAR(nRec - nRecKo) || ' aggiornati correttamente ,
                                                                            di cui : ' || nRecKo || ' con anomalie che hanno impedito l''aggiornamento');
          -- gestione istanze lavorate
          FOR rec IN (SELECT *
                      FROM   SMRGAA_W_ISTANZE_LAVORATE) LOOP

            -- cerco la particella su DB_STORICO_PARTICELLA
            recTStoricoPart := SelTStorPartByChiaveCatastale(rec.ISTAT_COMUNE,
                                                             rec.SEZIONE,
                                                             rec.FOGLIO,
                                                             rec.PARTICELLA,
                                                             rec.SUBALTERNO);

            -- cerco la particella su DB_PARTICELLA_CERTIFICATA
            recTParticellaCert := SelTPartCertByChiaveCatastale(rec.ISTAT_COMUNE,
                                                                rec.SEZIONE,
                                                                rec.FOGLIO,
                                                                rec.PARTICELLA,
                                                                rec.SUBALTERNO);

            IF recTParticellaCert.ID_PARTICELLA IS NULL THEN
              recTParticellaCert.ID_PARTICELLA := recTStoricoPart.ID_PARTICELLA;
            END IF;

            IF recTParticellaCert.ID_PARTICELLA IS NOT NULL THEN
              SlegaConduzAssociateDocRiesame(recTParticellaCert.ID_PARTICELLA,
                                             rec.CAMPAGNA,
                                             rec.DATA_FOTOINTERPRETAZIONE,
                                             recDTipoCategNot,
                                             NULL,
                                             NULL,
                                             NULL);
            END IF;
          END LOOP;
        END IF;

        PCK_SMRGAA_LOG.LogInfo ('Inizio Gestione particelle in istanza di riesame presenti in lista lavorazione CAMPIONE');

        FOR recParticellaCampione IN curParticellaCampione LOOP

            -- cerco la particella su DB_STORICO_PARTICELLA
            recTStoricoPart := SelTStorPartByChiaveCatastale (recParticellaCampione.ISTAT_COMUNE,
                                                              recParticellaCampione.SEZIONE,
                                                              recParticellaCampione.FOGLIO,
                                                              recParticellaCampione.PARTICELLA,
                                                              recParticellaCampione.SUBALTERNO);

            IF recTStoricoPart.ID_PARTICELLA IS NOT NULL THEN

                SlegaConduzAssociateDocRiesame (recTStoricoPart.ID_PARTICELLA,
                                                recParticellaCampione.CAMPAGNA,
                                                recParticellaCampione.DATA_LAVORAZIONE,
                                                recDTipoCategNot,
                                                recParticellaCampione.ID_LISTA_LAVORAZIONE,
                                                recParticellaCampione.DESC_LISTA_LAVORAZIONE,
                                                NULL);

                UPDATE SMRGAA_W_PARTICELLA_CAMPIONE
                   SET ELABORATO = 'S'
                 WHERE ID_PARTICELLA_CAMPIONE = recParticellaCampione.ID_PARTICELLA_CAMPIONE;
            ELSE
                PCK_SMRGAA_LOG.LogAnomalia ('Particella Campione - COMUNE / SEZIONE / FOGLIO / PARTICELLA / SUBALTERNO  = ' ||
                                             recParticellaCampione.ISTAT_COMUNE || '/' || recParticellaCampione.SEZIONE || '/' || recParticellaCampione.FOGLIO || '/' || recParticellaCampione.PARTICELLA || '/' || recParticellaCampione.SUBALTERNO || ' - non trovata');

                UPDATE SMRGAA_W_PARTICELLA_CAMPIONE
                   SET ELABORATO = 'K'
                 WHERE ID_PARTICELLA_CAMPIONE = recParticellaCampione.ID_PARTICELLA_CAMPIONE;

            END IF;
        END LOOP;

        PCK_SMRGAA_LOG.LogInfo ('Fine Gestione particelle in istanza di riesame presenti in lista lavorazione CAMPIONE');

        PCK_SMRGAA_LOG.LogInfo ('Fine Elaborazione');

        COMMIT;

        RETURN nRetCode;

    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            PCK_SMRGAA_LOG.LogSqlError ('ACQUISIZIONE_ELEGGIBILITA');
            RETURN 1;
    END Acquisizione_Eleggibilita;

    /*********************************************************************
    Scorre i record di SMRGAA_W_PARTICELLA_SOSPESA ed aggiorna la DATA_SOSPENSIONE
    su DB_PARTICELLA_CERTIFICATA in caso la particella sia presente per la chiave
    catastale
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION Acquisizione_Sospensione RETURN NUMBER IS
        CURSOR curParticellaConLavSospesa IS
        SELECT *
          FROM SMRGAA_W_PARTICELLA_SOSPESA
         WHERE ELABORATO IS NULL
           AND FLAG_SOSPENSIONE_SCADUTA IS NULL;

        CURSOR curParticellaConLavSospesaIs IS
        SELECT *
          FROM SMRGAA_W_PARTICELLA_SOSPESA
         WHERE ELABORATO IS NULL
           AND FLAG_SOSPENSIONE_SCADUTA = 'S';

        -- record di appoggio per il reperimento dei dati dell'applicazione corrente
        recDApplicazione    SMRGAA_D_APPLICAZIONI_BATCH%ROWTYPE;
        -- conterrà l'id esecuzione
        nIdEsecuzione       SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE;
        -- conterrà il codice di ritorno
        nRetCode            NUMBER(1):=0;
        recTParticellaCert  DB_PARTICELLA_CERTIFICATA%ROWTYPE;
        -- contatore particelle con DATA_SOSPENSIONE non aggiornata
        nRecKo              INTEGER:=0;
        -- contatore particelle con DATA_SOSPENSIONE aggiornata
        nRec                INTEGER:=0;
        -- record di appoggio per reperiemento storico particella
        recTStoricoPart     DB_STORICO_PARTICELLA%ROWTYPE;
        --
        dMaxDataFoto        DATE;

        recDTipoCategNot    DB_TIPO_CATEGORIA_NOTIFICA%ROWTYPE;

        -- vettore di parametri di input
        vetParametri        PCK_SMRGAA_LOG.TypVetParametriApplicazione;
        bParamOk            BOOLEAN:=TRUE;

    BEGIN

        nRetCode := Pck_SMRGAA_Log.VerificaAttivazioneBatch( knIdApplBatchEleggibilita ,recDApplicazione);

        IF nRetCode > 0 THEN
             -- Errore, Batch non attivo
            RETURN nRetCode;
        END IF;

        Pck_SMRGAA_Log.LeggiFileEsecuzione ( recDApplicazione.nomefile_esecuzione, recDApplicazione.path_file_esecuzione );

        Pck_SMRGAA_Log.SetLogLevel ( recDApplicazione.log_level );

        Pck_SMRGAA_Log.Init( knIdApplBatchEleggibilita,'Acquisizione_Sospensione');

        Pck_SMRGAA_Log.LogInfo ('Inizio Elaborazione');

        vetParametri := PCK_SMRGAA_LOG.CaricaParametriApplicazione(knIdApplBatchEleggibilita);

        IF vetParametri.COUNT > 0 THEN

            BEGIN
                recDTipoCategNot.ID_CATEGORIA_NOTIFICA := vetParametri (kvCodParametroCategNotIstRies).val_number;
                recDTipoCategNot := SelDCategoriaNotificaById (recDTipoCategNot.ID_CATEGORIA_NOTIFICA);
                PCK_SMRGAA_LOG.LogInfo ('Parametro obbligatorio : ' || kvCodParametroCategNotIstRies || ' presente ed uguale a : ' || recDTipoCategNot.ID_CATEGORIA_NOTIFICA);

            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    PCK_SMRGAA_LOG.LogAnomalia ('Parametro obbligatorio : ' || kvCodParametroCategNotIstRies || ' non valorizzato !! - Termino Elaborazione');
                    bParamOk := FALSE;
                WHEN OTHERS THEN
                    PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroCategNotIstRies || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                    bParamOk := FALSE;
            END;

        END IF;

        IF bParamOk THEN

            nRecKo := 0;
            nRec := 0;
            FOR recParticellaConLavSospesa IN curParticellaConLavSospesa LOOP
                -- cerco la particella su DB_PARTICELLA_CERTIFICATA
                recTParticellaCert := SelTPartCertByChiaveCatastale (recParticellaConLavSospesa.ISTAT_COMUNE,
                                                                     recParticellaConLavSospesa.SEZIONE,
                                                                     recParticellaConLavSospesa.FOGLIO,
                                                                     recParticellaConLavSospesa.PARTICELLA,
                                                                     recParticellaConLavSospesa.SUBALTERNO);

                IF recTParticellaCert.ID_PARTICELLA_CERTIFICATA IS NOT NULL THEN

                   UPDATE DB_PARTICELLA_CERTIFICATA
                      SET DATA_SOSPENSIONE = recParticellaConLavSospesa.DATA_SOSPENSIONE,
                          MOTIVAZIONE_GIS = recParticellaConLavSospesa.MOTIVAZIONE_GIS, 
                          DATA_ULTIMO_AGGIORNAMENTO = SYSDATE
                    WHERE ID_PARTICELLA_CERTIFICATA = recTParticellaCert.ID_PARTICELLA_CERTIFICATA;

                   UPDATE SMRGAA_W_PARTICELLA_SOSPESA
                      SET ELABORATO = 'S'
                   WHERE ID_PARTICELLA_SOSPESA = recParticellaConLavSospesa.ID_PARTICELLA_SOSPESA;

                ELSE
                   PCK_SMRGAA_LOG.LogAnomalia ('Chiave catastale : - COMUNE : ' || recParticellaConLavSospesa.ISTAT_COMUNE ||
                                                                 ' - SEZIONE : '|| recParticellaConLavSospesa.SEZIONE ||
                                                                 ' - FOGLIO : '|| recParticellaConLavSospesa.FOGLIO ||
                                                                 ' - PARTICELLA : ' || recParticellaConLavSospesa.PARTICELLA ||
                                                                 ' - SUBALTERNO : '|| recParticellaConLavSospesa.SUBALTERNO ||
                                                                 ' non presente su DB_PARTICELLA_CERTIFICATA , data_sospensione lavorazione non aggiornata');

                   UPDATE SMRGAA_W_PARTICELLA_SOSPESA
                      SET ELABORATO = 'K'
                   WHERE ID_PARTICELLA_SOSPESA = recParticellaConLavSospesa.ID_PARTICELLA_SOSPESA;

                   nRecKo := nRecKo + 1;
                END IF;

                nRec := nRec + 1;

                COMMIT;

            END LOOP;

            PCK_SMRGAA_LOG.LogInfo ('Aggiornata DATA_SOSPENSIONE della lavorazione su DB_PARTICELLA_CERTIFICATA per : ' || TO_CHAR(nRec - nRecKo) || ' particelle');
            PCK_SMRGAA_LOG.LogInfo ('Escluse dall''aggiornamento : ' || nRecKo || ' particelle in quanto non presenti su DB_PARTICELLA_CERTIFICATA');

            nRec := 0;
            nRecKo := 0;
            FOR recParticellaConLavSospesaIs IN curParticellaConLavSospesaIs LOOP
                nRec := nRec + 1;

                -- cerco la particella su DB_PARTICELLA_CERTIFICATA
                recTParticellaCert := SelTPartCertByChiaveCatastale (recParticellaConLavSospesaIs.ISTAT_COMUNE,
                                                                     recParticellaConLavSospesaIs.SEZIONE,
                                                                     recParticellaConLavSospesaIs.FOGLIO,
                                                                     recParticellaConLavSospesaIs.PARTICELLA,
                                                                     recParticellaConLavSospesaIs.SUBALTERNO);


                IF recTParticellaCert.ID_PARTICELLA IS NOT NULL THEN

                    SELECT MAX(DATA_FOTOINTERPRETAZIONE)
                      INTO dMaxDataFoto
                      FROM DB_PARTICELLA_CERT_ELEG
                     WHERE ID_PARTICELLA_CERTIFICATA = recTParticellaCert.ID_PARTICELLA_CERTIFICATA
                       AND ANNO_CAMPAGNA <= recParticellaConLavSospesaIs.ANNO_ISTANZA; 

                    IF dMaxDataFoto IS NOT NULL THEN

                        SlegaConduzAssociateDocRiesame (recTParticellaCert.ID_PARTICELLA,
                                                        recParticellaConLavSospesaIs.ANNO_ISTANZA,
                                                        dMaxDataFoto,
                                                        recDTipoCategNot,
                                                        NULL,
                                                        NULL,
                                                        recParticellaConLavSospesaIs.DATA_SOSPENSIONE);

                        UPDATE SMRGAA_W_PARTICELLA_SOSPESA
                           SET ELABORATO = 'S'
                         WHERE ID_PARTICELLA_SOSPESA = recParticellaConLavSospesaIs.ID_PARTICELLA_SOSPESA;
                    ELSE
                        PCK_SMRGAA_LOG.LogAnomalia ('Particella Sospesa - COMUNE / SEZIONE / FOGLIO / PARTICELLA / SUBALTERNO  = ' ||
                                                     recParticellaConLavSospesaIs.ISTAT_COMUNE || '/' || recParticellaConLavSospesaIs.SEZIONE || '/' || recParticellaConLavSospesaIs.FOGLIO || '/' || recParticellaConLavSospesaIs.PARTICELLA || '/' || recParticellaConLavSospesaIs.SUBALTERNO || ' - non trovata su DB_PARTICELLA_CERT_ELEG per ANNO_ISTANZA = ' || recParticellaConLavSospesaIs.ANNO_ISTANZA);

                        nRecKo := nRecKo + 1;

                    END IF;
                ELSE
                    PCK_SMRGAA_LOG.LogAnomalia ('Particella Sospesa - COMUNE / SEZIONE / FOGLIO / PARTICELLA / SUBALTERNO  = ' ||
                                                 recParticellaConLavSospesaIs.ISTAT_COMUNE || '/' || recParticellaConLavSospesaIs.SEZIONE || '/' || recParticellaConLavSospesaIs.FOGLIO || '/' || recParticellaConLavSospesaIs.PARTICELLA || '/' || recParticellaConLavSospesaIs.SUBALTERNO || ' - non trovata su DB_PARTICELLA_CERTFIFICATA');

                    UPDATE SMRGAA_W_PARTICELLA_SOSPESA
                       SET ELABORATO = 'K'
                     WHERE ID_PARTICELLA_SOSPESA = recParticellaConLavSospesaIs.ID_PARTICELLA_SOSPESA;

                    nRecKo := nRecKo + 1;

                END IF;

            END LOOP;

            PCK_SMRGAA_LOG.LogInfo ('Trattate : ' || nRec || ' particelle in istanze di riesame scadute per decorrenza termini');
            PCK_SMRGAA_LOG.LogInfo ('Escluse dall''aggiornamento : ' || nRecKo || ' particelle in quanto non presenti su DB_PARTICELLA_CERTIFICATA / DB_PARTICELLA_CERT_ELEG');
            Pck_SMRGAA_Log.LogInfo ('Fine Elaborazione');

        END IF;

        PCK_SMRGAA_LOG.ValorizzaEsitoBatch;


        COMMIT;

        RETURN nRetCode;

    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            PCK_SMRGAA_LOG.LogSqlError ('ACQUISIZIONE_SOSPENSIONE');
            RETURN 1;
    END Acquisizione_Sospensione;

    /*********************************************************************
    Crea un file di testo contenente un data che sarà poi utilizzata da una
    procedura residente sul db SITIPIOPR di abaco per estrarre le particelle
    per le quali è stata calcolata l'eleggibilità dopo quella data inoltre
    genera un file di testo contenente le particelle oggetto di istanza di
    riesame che devono essere inserite nella lista di lavorazione del GIS
    prima di richiamare il calcolo dell'eleggibilità
    Tipo:    function
    input:  pNomeFileData, pNomeFileParticelle
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION InviaDataUltimoRicalcolo (pNomeFileData        IN VARCHAR2,
                                       pNomeFileParticelle  IN VARCHAR2)RETURN NUMBER IS

        -- record di appoggio per il reperimento dei dati dell'applicazione corrente
        recDApplicazione    SMRGAA_D_APPLICAZIONI_BATCH%ROWTYPE;
        -- conterrà l'id esecuzione
        nIdEsecuzione       SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE;
        -- conterrà il codice di ritorno
        nRetCode            NUMBER(1):=0;
        -- vettore di parametri di input
        vetParametri        PCK_SMRGAA_LOG.TypVetParametriApplicazione;
        -- data di appoggio
        dDataDa             DATE;
        -- data di appoggio per forzatura invio UV
        dDataMinInvioUv     DATE;
        -- booleana di appoggio che mi dice se i parametri sono OK
        bParamOk            BOOLEAN:=TRUE;
        -- puntatore al file in cui inseriro la data dalla quale reperire le particelle eleggibili
        fFileData           UTL_FILE.FILE_TYPE;
        -- puntatore al file in cui inseriro le particelle oggetto di istanze di riesame
        fFileParticelle     UTL_FILE.FILE_TYPE;
        -- riga di appoggio per scrittura su file
        vRiga               VARCHAR2(1000);
        -- numero di particelle con documento istanza di riesame
        nNumPartInviate     INTEGER:=0;
        -- numero di particelle da eliminare da istanza di riesame
        nNumPartDaEliminare INTEGER:=0;
        -- variabile che mi dice se effettuare l'invio delle particelle con istanza di riesame
        vInviaParticelle    VARCHAR2(1);
        -- variabile per effettuare la rottura di chiava al cambio della dichiarazione di consistenza
        nOldIdDich          DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE:=0;
        -- tipologia esecuzione batch RPAIEA000-1 (M = Massiva , N = Normale)
        vTipoEsecuzione     VARCHAR2(1);
        -- tipologia di eliminazione particelle in istanze di riesame non più presenti in documenti di riesame attivi
        vTipoEliminazione   VARCHAR2(1);
        -- record di appoggio per inserimento su DB_ISTANZA_RIESAME
        recTIstanzaRiesame  DB_ISTANZA_RIESAME%ROWTYPE;
        -- record che conterrà i dati dell'ultima esecuzione andata a buon fine del batch
        recTLastEsecOk      SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE;
        -- identificativo documento istanza riesame per foto-interpretazione
        nIdDocIstRiesFoto   DB_TIPO_DOCUMENTO.ID_DOCUMENTO%TYPE;
        -- record di appoggio per inserimento notifiche
        recTNotifica        DB_NOTIFICA%ROWTYPE;
        -- record di appoggio per reperimento tipologia notifica
        recDTipoCategNot    DB_TIPO_CATEGORIA_NOTIFICA%ROWTYPE;

        
        CURSOR curParticelleDaInviare (pIdDocIstRiesXFoto IN DB_TIPO_DOCUMENTO.ID_DOCUMENTO%TYPE,
                                       pDtLastExec        IN DATE,
                                       pGiornoMese        IN VARCHAR2) IS
        SELECT DC.ID_DICHIARAZIONE_CONSISTENZA,
               IR.ID_ISTANZA_RIESAME , 
               AZ.CUAA,
               AZ.ID_AZIENDA, 
               DECODE(PR.ID_REGIONE,kvIdRegionePiemonte,'IS', 'EXT') AS COD_SETTORE,
               DECODE(PR.ID_REGIONE,kvIdRegionePiemonte,'IS', 'EXT') || IR.ANNO AS PROV_RIF, --  MS 13/03/2012
               IR.ANNO AS ANNO_RIFERIMENTO, 
               SP.ID_PARTICELLA,
               SUBSTR(SP.COMUNE,1,3) AS COD_PROV,
               SUBSTR(SP.COMUNE,4,6) AS COD_COMU,
               SP.SEZIONE,
               SP.FOGLIO,
               SP.PARTICELLA,
               SP.SUBALTERNO,
               IR.NOTE,
               IR.LAVORAZIONE_PRIORITARIA,
               'F' AS TIPO -- nuova fotointerpretazione
          FROM DB_TIPO_MOTIVO_DICHIARAZIONE MOT,
               DB_ANAGRAFICA_AZIENDA AZ,
               DB_DICHIARAZIONE_CONSISTENZA DC,
               DB_CONDUZIONE_DICHIARATA CD,
               DB_STORICO_PARTICELLA SP,
               DB_PARTICELLA_CERTIFICATA PC,
               DB_ISTANZA_RIESAME IR,
               COMUNE C,
               PROVINCIA PR
         WHERE DC.ID_AZIENDA = IR.ID_AZIENDA
           AND NVL(DC.FLAG_ISTANZA_RIESAME,'N') = 'N'
           AND IR.DATA_INVIO_GIS IS NULL 
           AND (IR.DATA_AGGIORNAMENTO >= pDtLastExec OR DC.DATA_INSERIMENTO_DICHIARAZIONE > IR.DATA_AGGIORNAMENTO)
           AND IR.ANNO = DC.ANNO
           AND IR.ID_PARTICELLA = SP.ID_PARTICELLA
           AND IR.ID_FASE_ISTANZA_RIESAME = knIdFaseIstRiesameInLav
           AND IR.DATA_EVASIONE IS NULL
           AND IR.DATA_ANNULLAMENTO IS NULL
           AND MOT.TIPO_DICHIARAZIONE <> kvCodTipoMotivoDichCorrettiva
           AND DC.ID_MOTIVO_DICHIARAZIONE = MOT.ID_MOTIVO_DICHIARAZIONE
           AND DC.ID_MOTIVO_DICHIARAZIONE <> knIdTipoMotivoDichSiccita2006
           AND DC.DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DIC2.DATA_INSERIMENTO_DICHIARAZIONE)
                                                      FROM DB_DICHIARAZIONE_CONSISTENZA DIC2,
                                                           DB_TIPO_MOTIVO_DICHIARAZIONE MOT2
                                                     WHERE DIC2.ID_AZIENDA = DC.ID_AZIENDA
                                                       AND DIC2.ID_MOTIVO_DICHIARAZIONE <> knIdTipoMotivoDichSiccita2006
                                                       AND DIC2.ANNO = IR.ANNO 
                                                       AND MOT2.TIPO_DICHIARAZIONE <> kvCodTipoMotivoDichCorrettiva
                                                       AND DIC2.ID_MOTIVO_DICHIARAZIONE = MOT2.ID_MOTIVO_DICHIARAZIONE
                                                       AND DIC2.DATA_PROTOCOLLO IS NOT NULL)
           -- AND DC.DATA_INSERIMENTO_DICHIARAZIONE >= IR.DATA_RICHIESTA 
           AND DC.DATA_PROTOCOLLO IS NOT NULL
           AND AZ.DATA_FINE_VALIDITA IS NULL
           AND AZ.ID_AZIENDA = DC.ID_AZIENDA
           AND CD.CODICE_FOTOGRAFIA_TERRENI = DC.CODICE_FOTOGRAFIA_TERRENI
           AND CD.ID_STORICO_PARTICELLA = SP.ID_STORICO_PARTICELLA
           AND SP.ID_PARTICELLA = PC.ID_PARTICELLA
           AND SP.COMUNE = C.ISTAT_COMUNE
           AND C.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
           AND PC.DATA_FINE_VALIDITA IS NULL
           AND PC.PARTICELLA_A_GIS <> 0 -- non in P30
           AND PC.ESITO = 0 -- non in P25
           AND SP.PARTICELLA IS NOT NULL
           AND CD.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento
        UNION
        SELECT DC.ID_DICHIARAZIONE_CONSISTENZA,
               NULL AS ID_ISTANZA_RIESAME, 
               AZ.CUAA,
               AZ.ID_AZIENDA, 
               DECODE(PR.ID_REGIONE,kvIdRegionePiemonte,'PO', 'EXT') AS COD_SETTORE,
               DECODE(PR.ID_REGIONE,kvIdRegionePiemonte,'PO', 'EXT') || TO_NUMBER(TO_CHAR(DC.DATA_INSERIMENTO_DICHIARAZIONE,'YYYY'),'9999')  AS PROV_RIF,
               TO_NUMBER(TO_CHAR(DC.DATA_INSERIMENTO_DICHIARAZIONE,'YYYY'),'9999') AS ANNO_RIFERIMENTO,
               SP.ID_PARTICELLA,
               SUBSTR(SP.COMUNE,1,3) AS COD_PROV,
               SUBSTR(SP.COMUNE,4,6) AS COD_COMU,
               SP.SEZIONE,
               SP.FOGLIO,
               SP.PARTICELLA,
               SP.SUBALTERNO,
               NULL AS NOTE,
               'N' AS LAVORAZIONE_PRIORITARIA,
               'P' AS TIPO -- nuova poligonazione
          FROM DB_TIPO_MOTIVO_DICHIARAZIONE MOT,
               DB_ANAGRAFICA_AZIENDA AZ,
               DB_DICHIARAZIONE_CONSISTENZA DC,
               DB_CONDUZIONE_DICHIARATA CD,
               DB_STORICO_PARTICELLA SP,
               DB_PARTICELLA_CERTIFICATA PC,
               COMUNE C,
               PROVINCIA PR
         WHERE MOT.TIPO_DICHIARAZIONE <> kvCodTipoMotivoDichCorrettiva
           AND DC.ID_MOTIVO_DICHIARAZIONE = MOT.ID_MOTIVO_DICHIARAZIONE
           AND DC.ID_MOTIVO_DICHIARAZIONE  <> knIdTipoMotivoDichSiccita2006
           AND DC.DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DIC2.DATA_INSERIMENTO_DICHIARAZIONE)
                                                      FROM DB_DICHIARAZIONE_CONSISTENZA DIC2,
                                                           DB_TIPO_MOTIVO_DICHIARAZIONE MOT2
                                                     WHERE DIC2.ID_AZIENDA = DC.ID_AZIENDA
                                                       AND DIC2.ID_MOTIVO_DICHIARAZIONE <> knIdTipoMotivoDichSiccita2006
                                                       AND DIC2.ANNO = TO_CHAR(SYSDATE,'YYYY') 
                                                       AND MOT2.TIPO_DICHIARAZIONE <> kvCodTipoMotivoDichCorrettiva
                                                       AND DIC2.ID_MOTIVO_DICHIARAZIONE = MOT2.ID_MOTIVO_DICHIARAZIONE
                                                       AND DIC2.DATA_PROTOCOLLO IS NOT NULL)
           AND DC.DATA_PROTOCOLLO IS NOT NULL
           AND NVL(DC.FLAG_ISTANZA_RIESAME,'N') = 'N'
           AND AZ.DATA_FINE_VALIDITA IS NULL
           AND AZ.ID_AZIENDA = DC.ID_AZIENDA
           AND CD.CODICE_FOTOGRAFIA_TERRENI = DC.CODICE_FOTOGRAFIA_TERRENI
           AND CD.ID_STORICO_PARTICELLA = SP.ID_STORICO_PARTICELLA
           AND EXISTS (SELECT UD.ID_UTILIZZO_DICHIARATO 
                         FROM DB_UTILIZZO_DICHIARATO UD,
                              DB_TIPO_UTILIZZO TU
                        WHERE TU.ESCLUDI_CONTROLLO_ELEGGIBILITA = 'N'
                          AND TU.ID_UTILIZZO = UD.ID_UTILIZZO
                          AND UD.ID_CONDUZIONE_DICHIARATA = CD.ID_CONDUZIONE_DICHIARATA
                          AND ROWNUM < 2) -- metto pure la stop-key per velocizzare
           AND SP.ID_PARTICELLA = PC.ID_PARTICELLA
           AND SP.COMUNE = C.ISTAT_COMUNE
           AND C.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
           AND PC.DATA_FINE_VALIDITA IS NULL
           AND (PC.PARTICELLA_A_GIS = 0 OR PC.ESITO <> 0)  -- in P30 o P25
           AND SP.PARTICELLA IS NOT NULL
           AND CD.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento
        UNION
        SELECT DC.ID_DICHIARAZIONE_CONSISTENZA,
               NULL AS ID_ISTANZA_RIESAME, 
               AZ.CUAA,
               AZ.ID_AZIENDA, 
               DECODE(PR.ID_REGIONE,kvIdRegionePiemonte,'PO', 'EXT') AS COD_SETTORE,
               DECODE(PR.ID_REGIONE,kvIdRegionePiemonte,'PO', 'EXT') || TO_NUMBER(TO_CHAR(DC.DATA_INSERIMENTO_DICHIARAZIONE,'YYYY'),'9999')  AS PROV_RIF,
               TO_NUMBER(TO_CHAR(DC.DATA_INSERIMENTO_DICHIARAZIONE,'YYYY'),'9999') AS ANNO_RIFERIMENTO,
               SP.ID_PARTICELLA,
               SUBSTR(SP.COMUNE,1,3) AS COD_PROV,
               SUBSTR(SP.COMUNE,4,6) AS COD_COMU,
               SP.SEZIONE,
               SP.FOGLIO,
               SP.PARTICELLA,
               SP.SUBALTERNO,
               NULL AS NOTE,
               'N' AS LAVORAZIONE_PRIORITARIA,
               'P' AS TIPO -- nuova poligonazione
          FROM DB_TIPO_MOTIVO_DICHIARAZIONE MOT,
               DB_ANAGRAFICA_AZIENDA AZ,
               DB_DICHIARAZIONE_CONSISTENZA DC,
               DB_CONDUZIONE_DICHIARATA CD,
               DB_STORICO_PARTICELLA SP,
               COMUNE C,
               PROVINCIA PR
         WHERE MOT.TIPO_DICHIARAZIONE <> kvCodTipoMotivoDichCorrettiva
           AND DC.ID_MOTIVO_DICHIARAZIONE = MOT.ID_MOTIVO_DICHIARAZIONE
           AND DC.ID_MOTIVO_DICHIARAZIONE  <> knIdTipoMotivoDichSiccita2006
           AND DC.DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DIC2.DATA_INSERIMENTO_DICHIARAZIONE)
                                                      FROM DB_DICHIARAZIONE_CONSISTENZA DIC2,
                                                           DB_TIPO_MOTIVO_DICHIARAZIONE MOT2
                                                     WHERE DIC2.ID_AZIENDA = DC.ID_AZIENDA
                                                       AND DIC2.ID_MOTIVO_DICHIARAZIONE <> knIdTipoMotivoDichSiccita2006
                                                       AND DIC2.ANNO = TO_CHAR(SYSDATE,'YYYY') 
                                                       AND MOT2.TIPO_DICHIARAZIONE <> kvCodTipoMotivoDichCorrettiva
                                                       AND DIC2.ID_MOTIVO_DICHIARAZIONE = MOT2.ID_MOTIVO_DICHIARAZIONE
                                                       AND DIC2.DATA_PROTOCOLLO IS NOT NULL)
           AND DC.DATA_PROTOCOLLO IS NOT NULL
           AND NVL(DC.FLAG_ISTANZA_RIESAME,'N') = 'N'
           AND AZ.DATA_FINE_VALIDITA IS NULL
           AND AZ.ID_AZIENDA = DC.ID_AZIENDA
           AND CD.CODICE_FOTOGRAFIA_TERRENI = DC.CODICE_FOTOGRAFIA_TERRENI
           AND CD.ID_STORICO_PARTICELLA = SP.ID_STORICO_PARTICELLA
           AND EXISTS (SELECT UD.ID_UTILIZZO_DICHIARATO 
                         FROM DB_UTILIZZO_DICHIARATO UD,
                              DB_TIPO_UTILIZZO TU
                        WHERE TU.ESCLUDI_CONTROLLO_ELEGGIBILITA = 'N'
                          AND TU.ID_UTILIZZO = UD.ID_UTILIZZO
                          AND UD.ID_CONDUZIONE_DICHIARATA = CD.ID_CONDUZIONE_DICHIARATA
                          AND ROWNUM < 2) -- metto pure la stop-key per velocizzare
           AND SP.COMUNE = C.ISTAT_COMUNE
           AND C.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
           AND SP.PARTICELLA IS NOT NULL
           AND CD.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento
           AND NOT EXISTS(SELECT ID_PARTICELLA_CERTIFICATA
                            FROM DB_PARTICELLA_CERTIFICATA
                           WHERE ID_PARTICELLA = SP.ID_PARTICELLA
                             AND DATA_FINE_VALIDITA IS NULL) -- non presenti su DB_PARTICELLA_CERTIFICATA
         UNION
        SELECT NULL AS ID_DICHIARAZIONE_CONSISTENZA,
               NULL AS ID_ISTANZA_RIESAME, 
               AZ.CUAA,
               AZ.ID_AZIENDA, 
               TCM.CODICE_CAUSALE AS COD_SETTORE, 
               CASE
               WHEN SUA.DATA_INTERVENTO IS NULL THEN
                    TCM.CODICE_CAUSALE || TO_NUMBER(TO_CHAR(SUA.DATA_AGGIORNAMENTO,'YYYY'),'9999') || '_' || PR.SIGLA_PROVINCIA
               WHEN SUA.DATA_INTERVENTO > TO_DATE(pGiornoMese || '/' || TO_CHAR(SUA.DATA_INTERVENTO,'YYYY'),'DD/MM/YYYY') THEN
                    TCM.CODICE_CAUSALE || TO_CHAR(TO_NUMBER(TO_CHAR(SUA.DATA_INTERVENTO,'YYYY'),'9999') + 1) || '_' || PR.SIGLA_PROVINCIA
               WHEN SUA.DATA_INTERVENTO <= TO_DATE(pGiornoMese || '/' || TO_CHAR(SUA.DATA_INTERVENTO,'YYYY'),'DD/MM/YYYY') THEN
                    TCM.CODICE_CAUSALE || TO_NUMBER(TO_CHAR(SUA.DATA_INTERVENTO,'YYYY'),'9999') || '_' || PR.SIGLA_PROVINCIA
               END AS PROV_RIF,
               CASE
               WHEN SUA.DATA_INTERVENTO IS NULL THEN
                    TO_NUMBER(TO_CHAR(SUA.DATA_AGGIORNAMENTO,'YYYY'),'9999')
               WHEN SUA.DATA_INTERVENTO > TO_DATE(pGiornoMese || '/' || TO_CHAR(SUA.DATA_INTERVENTO,'YYYY'),'DD/MM/YYYY') THEN
                    TO_NUMBER(TO_CHAR(SUA.DATA_INTERVENTO,'YYYY'),'9999') + 1
               WHEN SUA.DATA_INTERVENTO <= TO_DATE(pGiornoMese || '/' || TO_CHAR(SUA.DATA_INTERVENTO,'YYYY'),'DD/MM/YYYY') THEN
                    TO_NUMBER(TO_CHAR(SUA.DATA_INTERVENTO,'YYYY'),'9999')
               END AS ANNO_RIFERIMENTO,
               SP.ID_PARTICELLA,
               SUBSTR(SP.COMUNE,1,3) AS COD_PROV,
               SUBSTR(SP.COMUNE,4,6) AS COD_COMU,
               SP.SEZIONE,
               SP.FOGLIO,
               SP.PARTICELLA,
               SP.SUBALTERNO,
               SUA.NOTE, 
               'N' AS LAVORAZIONE_PRIORITARIA,
               DECODE(TCM.IMPIANTO,'S','I','E') AS TIPO
          FROM DB_ANAGRAFICA_AZIENDA AZ,
               DB_STORICO_PARTICELLA SP,
               DB_STORICO_UNITA_ARBOREA SUA,
               DB_TIPO_CAUSALE_MODIFICA TCM,
               COMUNE C,
               PROVINCIA PR
         WHERE AZ.DATA_FINE_VALIDITA IS NULL
           AND AZ.DATA_CESSAZIONE IS NULL
           AND AZ.ID_AZIENDA = SUA.ID_AZIENDA
           AND ((SUA.DATA_FINE_VALIDITA IS NULL AND TCM.ESTIRPO = 'N') OR TCM.ESTIRPO = 'S') 
           -- AND SUA.DATA_CESSAZIONE IS NULL
           AND SUA.ID_TIPOLOGIA_UNAR = knIdTipologiaUnarVino
           AND SUA.ID_CAUSALE_MODIFICA = TCM.ID_CAUSALE_MODIFICA
           AND TCM.ESCLUDI_P26 = 'S'
           AND SP.ID_PARTICELLA = SUA.ID_PARTICELLA
           AND SP.COMUNE = C.ISTAT_COMUNE
           AND C.ISTAT_PROVINCIA = PR.ISTAT_PROVINCIA
           AND SP.DATA_FINE_VALIDITA IS NULL
           AND SUA.DATA_AGGIORNAMENTO >= NVL(dDataMinInvioUv,pDtLastExec);

        -- cursore che estrae le particelle
        -- da eliminare dall'istanza di riesame
        CURSOR curParticelleDaEliminare (pDtLastExec IN DATE) IS
        SELECT IR.ANNO,
               IR.ID_AZIENDA,
               SP.*,
               DECODE(P.ID_REGIONE,kvIdRegionePiemonte,'IS','EXT') AS  COD_SETTORE
          FROM DB_ISTANZA_RIESAME IR,
               DB_STORICO_PARTICELLA SP,
               COMUNE C,
               PROVINCIA P
         WHERE IR.DATA_ANNULLAMENTO > pDtLastExec
           AND IR.ID_FASE_ISTANZA_RIESAME = knIdFaseIstRiesameInLav
           AND IR.ID_PARTICELLA = SP.ID_PARTICELLA
           AND SP.DATA_FINE_VALIDITA IS NULL
           AND SP.COMUNE = C.ISTAT_COMUNE
           AND C.ISTAT_PROVINCIA = P.ISTAT_PROVINCIA;

        CURSOR curDocumentoDaChiudere (pIdAzienda IN DB_DOCUMENTO.ID_AZIENDA%TYPE,
                                       pAnnoDoc   IN INTEGER) IS
        SELECT D.ID_DOCUMENTO
          FROM DB_DOCUMENTO D,
               DB_R_FASE_RIESAME_TP_DOCUMENTO RTD
         WHERE D.ID_AZIENDA = pIdAzienda
           AND TO_CHAR(D.DATA_INSERIMENTO,'YYYY') = pAnnoDoc
           AND D.ID_STATO_DOCUMENTO IS NULL
           AND D.DATA_FINE_VALIDITA IS NULL
           AND D.EXT_ID_DOCUMENTO = RTD.ID_DOCUMENTO
           AND RTD.DATA_FINE_VALIDITA IS NULL
           AND RTD.ID_FASE_ISTANZA_RIESAME = knIdFaseIstRiesameInLav
           AND NOT EXISTS (SELECT ID_DOCUMENTO_CONDUZIONE
                             FROM DB_DOCUMENTO_CONDUZIONE DC
                            WHERE DC.ID_DOCUMENTO = D.ID_DOCUMENTO
                              AND DC.DATA_FINE_VALIDITA IS NULL);


        recDAltriDati       DB_ALTRI_DATI%ROWTYPE;
        nGGMaxSospLavIs     SMRGAA_R_PARAM_APPLICAZIONE.VALORE_NUMBER%TYPE;
        vData               VARCHAR2(10);
    BEGIN


        nRetCode := Pck_SMRGAA_Log.VerificaAttivazioneBatch( knIdApplBatchEleggibilita ,recDApplicazione);

        IF nRetCode > 0 THEN
             -- Errore, Batch non attivo
            RETURN nRetCode;
        END IF;

         -- Inserimento in tabella dell'identificativo di esecuzione
         -- nIdEsecuzione restituito in output
        Pck_SMRGAA_Log.InsertTEsecuzione ( knIdApplBatchEleggibilita, nIdEsecuzione );
        COMMIT;

         -- Scrittura nel file nomefile_esecuzione del nIdEsecuzione
        Pck_SMRGAA_Log.ScriviFileEsecuzione ( recDApplicazione.nomefile_esecuzione,
                                              recDApplicazione.path_file_esecuzione,
                                              nIdEsecuzione );

        Pck_SMRGAA_Log.LeggiFileEsecuzione ( recDApplicazione.nomefile_esecuzione, recDApplicazione.path_file_esecuzione );

        Pck_SMRGAA_Log.SetLogLevel ( recDApplicazione.log_level );

        Pck_SMRGAA_Log.Init( knIdApplBatchEleggibilita, 'InviaDataUltimoRicalcolo' );

        -- cerco l'ultima esecuzione del batch precedente a quella attuale andata a buon fine
        recTLastEsecOk := Pck_SMRGAA_Log.SelectTLastEsecuzioneOK (knIdApplBatchEleggibilita);
        -- se non la trovo
        IF recTLastEsecOk.ID_ESECUZIONE IS NULL THEN
           -- utilizzerò la SYSDATE (troncata)
           recTLastEsecOk.DT_INIZIO_ESECUZIONE := TRUNC(SYSDATE);
           recTLastEsecOk.DT_FINE_ESECUZIONE := TRUNC(SYSDATE);

        END IF;

        -- carico il vettore di parametri per il batch
        vetParametri := PCK_SMRGAA_LOG.CaricaParametriApplicazione(knIdApplBatchEleggibilita);
        -- in questo caso il batch dovrebbe avere solamente il parametro "ABEL" contenente la data
        -- dalla quale recuperare le particelle elaborate per l'eleggibilità che tra l'altro è opzionale
        IF vetParametri.COUNT = 0 THEN
            -- quindi se non c'è non mi blocco
            PCK_SMRGAA_LOG.LogInfo ('Parametro : ' || kvCodParametroDataDa || ' non presente');
            PCK_SMRGAA_LOG.LogInfo ('Parametro : ' || kvCodParametroDataMinInvioUv || ' non presente');
            PCK_SMRGAA_LOG.LogInfo ('Parametro : ' || kvCodParametroInvioParticelle || ' non presente');
            PCK_SMRGAA_LOG.LogInfo ('Parametro : ' || kvCodParametroTipoEsecuzione || 'non presente');
            PCK_SMRGAA_LOG.LogInfo ('Parametro : ' || kvCodParametroIdDocIstRieXFoto || 'non presente');
        ELSE

            BEGIN
                -- se c'è però deve essere ok
                dDataMinInvioUv := vetParametri (kvCodParametroDataMinInvioUv).val_date;
                PCK_SMRGAA_LOG.LogInfo ('Parametro opzionale : ' || kvCodParametroDataMinInvioUv || ' presente ed uguale a : ' || TO_CHAR(dDataMinInvioUv,'DD/MM/YYYY'));
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     dDataMinInvioUv := NULL;
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroDataMinInvioUv || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
            END;

            BEGIN
                -- se c'è però deve essere ok
                dDataDa := vetParametri (kvCodParametroDataDa).val_date;
                PCK_SMRGAA_LOG.LogInfo ('Parametro opzionale : ' || kvCodParametroDataDa || ' presente ed uguale a : ' || TO_CHAR(dDataDa,'DD/MM/YYYY'));
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     dDataDa := NULL;
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroDataDa || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
            END;

            BEGIN
                vInviaParticelle := vetParametri (kvCodParametroInvioParticelle).val_varchar2;
                PCK_SMRGAA_LOG.LogInfo ('Parametro opzionale : ' || kvCodParametroInvioParticelle || ' presente ed uguale a : ' || vInviaParticelle);
            EXCEPTION
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroInvioParticelle || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
            END;

            BEGIN
                vTipoEsecuzione:= vetParametri (kvCodParametroTipoEsecuzione).val_varchar2;
                PCK_SMRGAA_LOG.LogInfo ('Parametro opzionale : ' || kvCodParametroTipoEsecuzione || ' presente ed uguale a : ' || vTipoEsecuzione);
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     vTipoEsecuzione := 'N';
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroTipoEsecuzione || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
            END;

            BEGIN
                vTipoEliminazione:= vetParametri (kvCodParametroTipoEliminazione).val_varchar2;
                PCK_SMRGAA_LOG.LogInfo ('Parametro opzionale : ' || kvCodParametroTipoEliminazione || ' presente ed uguale a : ' || vTipoEliminazione);
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     vTipoEliminazione := 'N';
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroTipoEliminazione || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
            END;

            -- aggiungo il reperimento dell'identificativo del documento istanza riesame x fotointerpratazione
            BEGIN
                nIdDocIstRiesFoto := vetParametri (kvCodParametroIdDocIstRieXFoto).val_number;
            EXCEPTION
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroIdDocIstRieXFoto || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
            END;

            -- prendo il numero di giorni massimo di sospensione per lavorazione istanza di riesame
            BEGIN
                nGGMaxSospLavIs := vetParametri (kvCodParametroGGMaxSospLavIst).val_number;
            EXCEPTION
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroGGMaxSospLavIst || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
            END;

            BEGIN
                recDTipoCategNot.ID_CATEGORIA_NOTIFICA := vetParametri (kvCodParametroCategNotIstRies).val_number;
                recDTipoCategNot := SelDCategoriaNotificaById (recDTipoCategNot.ID_CATEGORIA_NOTIFICA);
                PCK_SMRGAA_LOG.LogInfo ('Parametro obbligatorio : ' || kvCodParametroCategNotIstRies || ' presente ed uguale a : ' || recDTipoCategNot.ID_CATEGORIA_NOTIFICA);

            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    PCK_SMRGAA_LOG.LogAnomalia ('Parametro obbligatorio : ' || kvCodParametroCategNotIstRies || ' non valorizzato !! - Termino Elaborazione');
                    bParamOk := FALSE;
                WHEN OTHERS THEN
                    PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroCategNotIstRies || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                    bParamOk := FALSE;
            END;

        END IF;

        recDAltriDati := SelDAltroDatoByCodice (kvCodAltroDatoDtListaGIS);
        IF recDAltriDati.ID_ALTRI_DATI IS NULL THEN
           PCK_SMRGAA_LOG.LogAnomalia ('Altro dato con codice : ' || kvCodAltroDatoDtListaGIS || ' non presente !! - Termino Elaborazione');
           bParamOk := FALSE;
        ELSE
           IF recDAltriDati.VALORE_STRINGA IS NULL THEN
              PCK_SMRGAA_LOG.LogAnomalia ('Altro dato con codice : ' || kvCodAltroDatoDtListaGIS || ' non in formato corretto !! - Termino Elaborazione');
              bParamOk := FALSE;
           END IF;
        END IF;

        -- se non ho avuto problemi nel reperimento dei parametri del batch
        IF bParamOk THEN
           -- controllo se il parametro data c'è
           IF dDataDa IS NULL THEN
              -- se non c'è utilizzato la data_ultima_lavorazione
              /*SELECT MAX(DATA_ULTIMA_LAVORAZIONE)
                INTO dDataDa
                FROM DB_PARTICELLA_CERTIFICATA
               WHERE DATA_FINE_VALIDITA IS NULL
                 AND TRUNC(DATA_ULTIMA_LAVORAZIONE) < TRUNC(SYSDATE);*/
             dDataDa := recTLastEsecOk.DT_INIZIO_ESECUZIONE;
/*
           ELSE
              -- se c'è dopo averlo selezionato lo cancello in quanto vale solo per l'esecuzione corrente
              PCK_SMRGAA_LOG.EliminaParametroApplicazione (knIdApplBatchEleggibilita,kvCodParametroDataDa);
              PCK_SMRGAA_LOG.EliminaParametroApplicazione (knIdApplBatchEleggibilita,kvCodParametroTipoEsecuzione);
*/
           END IF;

           PCK_SMRGAA_LOG.LogInfo ('Inizio Elaborazione , dDataDa = ' || TO_CHAR(dDataDa,'DD-MM-YYYYHH24:MI:SS') || ', TIPO_ELABORAZIONE = ' || vTipoEsecuzione);
           -- scrivo la data in un file di testo che poi passerò al batch RPAIEA020
           -- mantenere il "-" come seperatore perchè altrimenti la functions SQLFUNZ di schedulazione
           -- considera la data come un numerico
           fFileData := UTL_FILE.FOPEN (recDApplicazione.path_file_esecuzione, pNomeFileData,'W',1000);
           vRiga := 'DATA_DA=' || TRIM(TO_CHAR(dDataDa,'DD-MM-YYYYHH24:MI:SS'));
           UTL_FILE.PUT_LINE(fFileData,vRiga);
           vRiga := 'MAXGGSOSP=' || TRIM(TO_CHAR(nGGMaxSospLavIs));
           UTL_FILE.PUT_LINE(fFileData,vRiga);

           SELECT TO_CHAR(VALORE_DATE,'YYYYMMDD')
           INTO   vData
           FROM   SMRGAA_R_PARAM_APPLICAZIONE
           WHERE  COD_PARAMETRO   = 'DTSOSIST'
           AND    ID_APPLICAZIONE = 1;

           vRiga := 'DTSOSIST='||vData;
           UTL_FILE.PUT_LINE(fFileData,vRiga);

           UTL_FILE.FCLOSE(fFileData);
           -- creo comunque il file anche se vuoto così l'external table
           -- SMRGAA_W_PARTICELLE_IN_RIESAME lato SITIPIOPR non darà errore
           fFileParticelle := UTL_FILE.FOPEN (recDApplicazione.path_file_esecuzione, pNomeFileParticelle,'W',1000);
           IF vInviaParticelle = 'S' THEN
                vRiga := NULL;
                FOR recParticelleDaInviare IN curParticelleDaInviare (nIdDocIstRiesFoto,
                                                                      recTLastEsecOk.DT_INIZIO_ESECUZIONE,
                                                                      recDAltriDati.VALORE_STRINGA) LOOP

                    vRiga := recParticelleDaInviare.ANNO_RIFERIMENTO || '|' ||
                             recParticelleDaInviare.COD_SETTORE || '|' ||
                             recParticelleDaInviare.PROV_RIF || '|' ||
                             recParticelleDaInviare.COD_PROV || '|' ||
                             recParticelleDaInviare.COD_COMU || '|' ||
                             recParticelleDaInviare.SEZIONE || '|' ||
                             recParticelleDaInviare.FOGLIO || '|' ||
                             recParticelleDaInviare.PARTICELLA || '|' ||
                             recParticelleDaInviare.SUBALTERNO || '|' ||
                             REPLACE(REPLACE(recParticelleDaInviare.NOTE,'|',' '), CHR(13) || CHR(10), ' ') || '|' ||
                             recParticelleDaInviare.LAVORAZIONE_PRIORITARIA || '|' ||
                             recParticelleDaInviare.TIPO || '|';
                    UTL_FILE.PUT_LINE(fFileParticelle,vRiga);

                    IF recParticelleDaInviare.ID_DICHIARAZIONE_CONSISTENZA <> nOldIDDich THEN
                       UpdateFlagRichiestaRiesame (recParticelleDaInviare.ID_DICHIARAZIONE_CONSISTENZA);
                       nOldIdDich := recParticelleDaInviare.ID_DICHIARAZIONE_CONSISTENZA;
                    END IF;

                    IF recParticelleDaInviare.ID_ISTANZA_RIESAME IS NOT NULL THEN

                       UPDATE DB_ISTANZA_RIESAME
                          SET DATA_INVIO_GIS = SYSDATE
                        WHERE ID_ISTANZA_RIESAME = recParticelleDaInviare.ID_ISTANZA_RIESAME;

                    END IF;

                    nNumPartInviate := nNumPartInviate + 1;

                END LOOP;

                IF nNumPartInviate > 0 THEN
                   Pck_SMRGAA_Log.LogInfo ('Elaborazione terminata , Accodate : ' || nNumPartInviate || ' particelle oggetto di riesame');
                ELSE
                   Pck_SMRGAA_Log.LogInfo ('Elaborazione terminata , non sono presenti particelle oggetto di riesame da accodare');
                END IF;

                -- scorro le particelle da eliminare da richiesta di riesame
                -- e le accodo nel file di testo con TIPO = C
                -- se il documento è stato storicizzato / cancellato
                -- dopo la data di ultima esecuzione del batch
                FOR recParticelleDaEliminare IN curParticelleDaEliminare (recTLastEsecOk.DT_INIZIO_ESECUZIONE) LOOP
                    vRiga := recParticelleDaEliminare.ANNO || '|' ||
                             recParticelleDaEliminare.COD_SETTORE || '|' ||
                             recParticelleDaEliminare.COD_SETTORE || recParticelleDaEliminare.ANNO || '|' ||
                             SUBSTR(recParticelleDaEliminare.COMUNE,1,3) || '|' ||
                             SUBSTR(recParticelleDaEliminare.COMUNE,4,3) || '|' ||
                             recParticelleDaEliminare.SEZIONE || '|' ||
                             recParticelleDaEliminare.FOGLIO || '|' ||
                             recParticelleDaEliminare.PARTICELLA || '|' ||
                             recParticelleDaEliminare.SUBALTERNO || '|' ||
                             'Eliminazione da batch RPAIEA' || '|' ||
                             'N' || '|' ||
                             'C' || '|';
                    UTL_FILE.PUT_LINE(fFileParticelle,vRiga);
                    -- scorro i documenti di riesame dell'azienda nell'anno dell'istanza
                    -- e per tipologia fotointerpretazione attivi che non hanno più
                    -- particelle con l'associazione al documento attiva
                    FOR recDocumentoDaChiudere IN curDocumentoDaChiudere (recParticelleDaEliminare.ID_AZIENDA,
                                                                          recParticelleDaEliminare.ANNO) LOOP
                        -- valorizzo la data di fine validità del documento
                        UPDATE DB_DOCUMENTO D
                           SET D.DATA_FINE_VALIDITA = SYSDATE
                         WHERE D.ID_DOCUMENTO = recDocumentoDaChiudere.ID_DOCUMENTO;
                        -- e controllo se per qualcuna delle sue particelle è mai
                        -- stata evasa l'istanza di fotointerpretazione
                        IF ExistsParticellaDocRieEvasa (recParticelleDaEliminare.ID_AZIENDA,
                                                        recParticelleDaEliminare.ANNO,
                                                        recDocumentoDaChiudere.ID_DOCUMENTO,
                                                        knIdFaseIstRiesameInLav) THEN
                           -- se per almeno una particella è stata evasa inserisco la notifica
                           SELECT SEQ_NOTIFICA.nextval
                             INTO recTNotifica.ID_NOTIFICA
                             FROM DUAL;

                           recTNotifica.ID_AZIENDA := recParticelleDaEliminare.ID_AZIENDA;
                           recTNotifica.ID_UTENTE_INSERIMENTO := 9999999999;
                           recTNotifica.ID_TIPOLOGIA_NOTIFICA := recDTipoCategNot.ID_TIPOLOGIA_NOTIFICA;
                           recTNotifica.ID_CATEGORIA_NOTIFICA := recDTipoCategNot.ID_CATEGORIA_NOTIFICA;
                           recTNotifica.ID_PROCEDIMENTO_MITTENTE := knIdProcedimentoSMRGAA;
                           recTNotifica.ID_PROCEDIMENTO_DESTINATARIO := knIdProcedimentoSMRGAA;
                           recTNotifica.DATA_INSERIMENTO := SYSDATE;
                           recTNotifica.DESCRIZIONE := 'Chiusura automatica per evasione fotinterpretazione gis';
                           recTNotifica.DATA_AGGIORNAMENTO := SYSDATE; 
                           recTNotifica.ID_UTENTE_AGGIORNAMENTO := 9999999999; 

                           InsertTNotifica (recTNotifica);

                        END IF;

                    END LOOP;

                    nNumPartDaEliminare := nNumPartDaEliminare + 1;
                END LOOP;

                IF nNumPartDaEliminare > 0 THEN
                   Pck_SMRGAA_Log.LogInfo ('Accodate : ' || nNumPartDaEliminare || ' particelle da eliminare da istanze di riesame per annullamento richiesta');
                END IF;

           ELSE
                Pck_SMRGAA_Log.LogInfo ('Elaborazione terminata , invio particelle oggetto di riesame non eseguito');
           END IF;
           UTL_FILE.FCLOSE(fFileParticelle);
        ELSE
            Pck_SMRGAA_Log.LogInfo ('Elaborazione terminata , errori bloccanti sui parametri');
        END IF;

        EXECUTE IMMEDIATE 'TRUNCATE TABLE SMRGAA_W_ELEGGIBILITA_GIS';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE SMRGAA_W_ELEGGIBILITA_GIS_DETT';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE SMRGAA_W_PARTICELLA_SOSPESA';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE SMRGAA_W_PARTICELLA_CAMPIONE';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE SMRGAA_W_ISTANZE_LAVORATE';

        COMMIT;

        RETURN 0;

  EXCEPTION
    WHEN OTHERS THEN
         ROLLBACK;
         PCK_SMRGAA_LOG.LogSqlError ('InviaDataUltimoRicalcolo');
         IF UTL_FILE.IS_OPEN(fFileData) THEN
            UTL_FILE.FCLOSE(fFileData);
         END IF;
         IF UTL_FILE.IS_OPEN(fFileParticelle) THEN
            UTL_FILE.FCLOSE(fFileParticelle);
         END IF;
         RETURN 1;
  END InviaDataUltimoRicalcolo;

END Pck_Aggiorna_Dati_Eleggibilita;

/
--------------------------------------------------------
--  DDL for Package Body PCK_AGGIORNA_ISOLE_PARCELLE
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_AGGIORNA_ISOLE_PARCELLE" AS

    /*********************************************************************
    Controlla se l'azienda legata alla validazione ha già consolidato
    lo schedario viticolo a livello GIS
    Tipo: function
    input: pIdDichiarazioneConsistenza
    output: null
    ritorno: TRUE / FALSE
    *********************************************************************/
    FUNCTION IsAziendaConSchedConsolidato (pIdDichiarazioneConsistenza IN DB_COMPENSAZIONE_AZIENDA.ID_DICHIARAZIONE_CONSISTENZA%TYPE)
    RETURN BOOLEAN IS
        nNumCompAzienda INTEGER:=0;
        bRet            BOOLEAN:=FALSE;
    BEGIN

        SELECT COUNT(CA.ID_COMPENSAZIONE_AZIENDA)
          INTO nNumCompAzienda
          FROM DB_COMPENSAZIONE_AZIENDA CA,
               DB_DICHIARAZIONE_CONSISTENZA DC
         WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichiarazioneConsistenza
           AND DC.ID_AZIENDA = CA.ID_AZIENDA
           AND CA.DATA_FINE_VALIDITA IS NULL
           AND CA.DATA_CONSOLIDAMENTO_GIS IS NOT NULL;

        IF nNumCompAzienda > 0 THEN
           bRet := TRUE;
        END IF;

        RETURN bRet;

    END IsAziendaConSchedConsolidato;

    /*********************************************************************
    Dati due codici fotografia terreni (si spera di stessa azienda) controlla
    se ci sono state variazioni di particelle, superficie utilizzata o varietà
    sul piano colturale
    Tipo: function
    input: pCodFotoNew, pCodFotoOld
    output: null
    ritorno: TRUE / FALSE
    *********************************************************************/
    FUNCTION ExistsVariazionePianoColturale (pCodFotoNew  IN DB_CONDUZIONE_DICHIARATA.CODICE_FOTOGRAFIA_TERRENI%TYPE,
                                             pCodFotoOld  IN DB_CONDUZIONE_DICHIARATA.CODICE_FOTOGRAFIA_TERRENI%TYPE
                                             ) RETURN BOOLEAN IS
        nRec    INTEGER:=0;
        bRet    BOOLEAN:=FALSE;
    BEGIN
        SELECT COUNT(*)
          INTO nRec
          FROM (
        SELECT CD.ID_PARTICELLA,
               UD.SUPERFICIE_UTILIZZATA,
               UD.ID_VARIETA
          FROM DB_CONDUZIONE_DICHIARATA CD,
               DB_UTILIZZO_DICHIARATO UD
         WHERE CD.CODICE_FOTOGRAFIA_TERRENI = pCodFotoNew
           AND CD.ID_CONDUZIONE_DICHIARATA = UD.ID_CONDUZIONE_DICHIARATA
         MINUS
        SELECT CD.ID_PARTICELLA,
               UD.SUPERFICIE_UTILIZZATA,
               UD.ID_VARIETA
          FROM DB_CONDUZIONE_DICHIARATA CD,
               DB_UTILIZZO_DICHIARATO UD
         WHERE CD.CODICE_FOTOGRAFIA_TERRENI = pCodFotoOld
           AND CD.ID_CONDUZIONE_DICHIARATA = UD.ID_CONDUZIONE_DICHIARATA);

        IF nRec = 0 THEN
           SELECT COUNT(*)
             INTO nRec
             FROM (
            SELECT CD.ID_PARTICELLA,
                   UD.SUPERFICIE_UTILIZZATA,
                   UD.ID_VARIETA
              FROM DB_CONDUZIONE_DICHIARATA CD,
                   DB_UTILIZZO_DICHIARATO UD
             WHERE CD.CODICE_FOTOGRAFIA_TERRENI = pCodFotoOld
               AND CD.ID_CONDUZIONE_DICHIARATA = UD.ID_CONDUZIONE_DICHIARATA
             MINUS
            SELECT CD.ID_PARTICELLA,
                   UD.SUPERFICIE_UTILIZZATA,
                   UD.ID_VARIETA
              FROM DB_CONDUZIONE_DICHIARATA CD,
                   DB_UTILIZZO_DICHIARATO UD
             WHERE CD.CODICE_FOTOGRAFIA_TERRENI = pCodFotoNew
               AND CD.ID_CONDUZIONE_DICHIARATA = UD.ID_CONDUZIONE_DICHIARATA);
        END IF;

        IF nRec > 0 THEN
           bRet := TRUE;
        END IF;

        RETURN bRet;

    END ExistsVariazionePianoColturale;

    /*********************************************************************
    Imposta la data di fine validita del record trovato per il parametro
    ID_ISOLA_DICHIARATA dato in input a SYSDATE
    Tipo:   procedure
    input:  pIdIsolaDichiarata
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE StoricizzaIsolaDichiarata (pIdIsolaDichiarata IN DB_ISOLA_DICHIARATA.ID_ISOLA_DICHIARATA%TYPE) IS
    BEGIN

        UPDATE DB_ISOLA_DICHIARATA
           SET DATA_FINE_VALIDITA = SYSDATE
         WHERE ID_ISOLA_DICHIARATA = pIdIsolaDichiarata;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('StoricizzaIsolaDichiarata - pIdIsolaDichiarata = ' || pIdIsolaDichiarata);
             RAISE;
    END StoricizzaIsolaDichiarata;

    /*********************************************************************
    Ricerca l'ultima dichiarazione di consistenza dell'azienda per l'anno campagna
    nella quale la generazione delle isole / parcelle è andata a buon fine
    Tipo: function
    input: pIdAzienda, pAnnoCamp
    output: null
    ritorno: DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE
    *********************************************************************/
    FUNCTION SelLastDichConsWithIsoleForAz (pIdAzienda IN DB_DICHIARAZIONE_CONSISTENZA.ID_AZIENDA%TYPE,
                                            pAnnoCamp  IN DB_DICHIARAZIONE_CONSISTENZA.ANNO%TYPE
                                            )
    RETURN DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE IS
        recTDichConsistenza DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE;
    BEGIN
        SELECT DC.*
          INTO recTDichConsistenza
          FROM DB_DICHIARAZIONE_CONSISTENZA DC
         WHERE DC.ID_AZIENDA = pIdAzienda
           AND DC.ANNO = pAnnoCamp
           AND DC.DATA_INSERIMENTO_DICHIARAZIONE =
               (SELECT MAX(DC1.DATA_INSERIMENTO_DICHIARAZIONE)
                  FROM DB_DICHIARAZIONE_CONSISTENZA DC1,
                       DB_TIPO_MOTIVO_DICHIARAZIONE TMC
                 WHERE DC1.ID_MOTIVO_DICHIARAZIONE = TMC.ID_MOTIVO_DICHIARAZIONE
                   AND DC1.ANNO = pAnnoCamp
                   AND TMC.TIPO_DICHIARAZIONE <> kvCodTipoMotivoDichCorrettiva
                   AND DC1.ID_AZIENDA = DC.ID_AZIENDA
                   AND DC1.FLAG_AGGIORNAMENTO_ISOLE ='S');

        RETURN recTDichConsistenza;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelLastDichConsWithIsoleForAz;

    /*********************************************************************
    Mi dice se per la dichiarazione di consistenza passata in input l'isola
    dichiarata attiva è da storicizzare o da cancellare
    Tipo: function
    input: pIdDichConsistenza
    output: bCancella
    ritorno: nessuno
    *********************************************************************/
    FUNCTION IsIsolaCancellabileForDich (pIdDichConsistenza  IN DB_ISOLA_DICHIARATA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                         bCancella          OUT BOOLEAN)
    RETURN DB_ISOLA_DICHIARATA.ID_ISOLA_DICHIARATA%TYPE IS
        recTIsolaDichiarata DB_ISOLA_DICHIARATA%ROWTYPE;
        nIdIsolaDichiarata  DB_ISOLA_DICHIARATA.ID_ISOLA_DICHIARATA%TYPE;
    BEGIN
        bCancella := FALSE;
        SELECT *
          INTO recTIsolaDichiarata
          FROM DB_ISOLA_DICHIARATA
         WHERE ID_DICHIARAZIONE_CONSISTENZA = pIdDichConsistenza
           AND DATA_FINE_VALIDITA IS NULL;

        IF recTIsolaDichiarata.FLAG_STORICIZZA = 'N' THEN
           bCancella := TRUE;
        END IF;

        nIdIsolaDichiarata := recTIsolaDichiarata.ID_ISOLA_DICHIARATA;

        RETURN nIdIsolaDichiarata;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             bCancella := FALSE;
             RETURN nIdIsolaDichiarata;
    END IsIsolaCancellabileForDich;

    /*********************************************************************
    Imposta il FLAG elaborata ad 'S' sulla tabella SMRGAA_W_ISOLE_PARTICELLE
    per l'ID_DICHIARAZIONE_CONSISTENZA dato in input
    Tipo:   procedure
    input:  pIdDichCons
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE EvadiDichiarazione (pIdDichCons IN SMRGAA_W_ISOLA.ID_DICHIARAZIONE_CONSISTENZA%TYPE) IS
    BEGIN
        UPDATE SMRGAA_W_ISOLA
           SET ELABORATA = 'S'
         WHERE ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons;
    END EvadiDichiarazione;

    /*********************************************************************
    Inserisce l'abbinamento tra percella e conduzione dichiarata
    Tipo:   procedure
    input:  pCodFoto, pIdIsola, pIdIlo
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTDBParcellaDichiarata (pCodFoto     IN DB_CONDUZIONE_DICHIARATA.CODICE_FOTOGRAFIA_TERRENI%TYPE,
                                           pIdIsola     IN DB_ISOLA.ID_ISOLA%TYPE,
                                           pIdIlo       IN DB_ISOLA.ID_ILO%TYPE
                                           ) IS
    BEGIN

        INSERT INTO DB_PARCELLA_CONDUZIONE
            (
            ID_PARCELLA_CONDUZIONE,
            ID_ISOLA_PARCELLA,
            ID_CONDUZIONE_DICHIARATA
            )
        SELECT SEQ_DB_PARCELLA_CONDUZIONE.nextval,
               ID_ISOLA_PARCELLA,
               ID_CONDUZIONE_DICHIARATA
          FROM (
        SELECT DISTINCT
               IP.ID_ISOLA_PARCELLA,
               CD.ID_CONDUZIONE_DICHIARATA
          FROM SMRGAA_W_PARCELLA_PARTICELLA PP,
               DB_ISOLA ISO,
               DB_ISOLA_PARCELLA IP,
               DB_TIPO_ELEGGIBILITA_FIT FIT ,
               DB_CONDUZIONE_DICHIARATA CD,
               DB_STORICO_PARTICELLA SP
         WHERE ISO.ID_ISOLA = pIdIsola
           AND ISO.ID_ILO = pIdIlo
           AND ISO.ID_ISOLA = IP.ID_ISOLA
           AND IP.ID_ELEGGIBILITA_FIT = FIT.ID_ELEGGIBILITA_FIT
           AND FIT.CODICE = PP.CLASSE_ELEG
           AND PP.ID_ILO = pIdIlo
           AND IP.ID_SUOLO = PP.ID_SUOLO
           AND CD.CODICE_FOTOGRAFIA_TERRENI = pCodFoto
           AND CD.ID_TITOLO_POSSESSO <> knIdTitoloPossessoAsservimento
           AND CD.ID_STORICO_PARTICELLA = SP.ID_STORICO_PARTICELLA
           AND SP.COMUNE = PP.ISTAT_COMUNE
           AND NVL(SP.SEZIONE,'#') = NVL(PP.SEZIONE,'#')
           AND SP.FOGLIO = PP.FOGLIO
           AND SP.PARTICELLA = PP.PARTICELLA
           AND NVL(SP.SUBALTERNO,'#') = NVL(PP.SUBALTERNO,'#'));

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertTDBParcellaDichiarata - pCodFoto/pIdIsola/pIdIlo = ' || pCodFoto || '/' || pIdIsola || '/' || pIdIlo );
             RAISE;
    END InsertTDBParcellaDichiarata;

    /*********************************************************************
    Inserisce l'abbinamento tra l'isola e l'eleggibilità
    Tipo:   procedure
    input:  pIdIsola, pIdIlo, pPerc
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTDBIsolaParcella (pIdIsola  IN DB_ISOLA.ID_ISOLA%TYPE,
                                      pIdIlo    IN DB_ISOLA.ID_ILO%TYPE,
                                      pPerc     IN NUMBER
                                      ) IS
    BEGIN

        INSERT INTO DB_ISOLA_PARCELLA
            (
            ID_ISOLA_PARCELLA,
            ID_ELEGGIBILITA_FIT,
            ID_ISOLA,
            ID_SUOLO,
            SUPERFICIE,
            SUPERFICIE_MIN,
            SUPERFICIE_MAX,
            TOLLERANZA
            )
        SELECT SEQ_ISOLA_PARCELLA.NEXTVAL,
               FIT.ID_ELEGGIBILITA_FIT,
               ISO.ID_ISOLA,
               PAR.ID_SUOLO,
               PAR.SUPERFICIE,
               PAR.SUPERFICIE - (TOLLERANZA * pPerc),
               PAR.SUPERFICIE + (TOLLERANZA * pPerc),
               PAR.TOLLERANZA
          FROM SMRGAA_W_PARCELLA PAR,
               DB_ISOLA ISO,
               DB_TIPO_ELEGGIBILITA_FIT FIT
         WHERE ISO.ID_ISOLA = pIdIsola
           AND ISO.ID_ILO = pIdIlo
           AND ISO.ID_ILO = PAR.ID_ILO
           AND PAR.CLASSE_ELEG = FIT.CODICE;
    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertTDBIsolaParcella - pIdIsola/pIdIlo/pPerc = ' || pIdIsola || '/' || pIdIlo || '/' || pPerc );
             RAISE;
    END InsertTDBIsolaParcella;

    /*********************************************************************
    Inserisce le anomalie presenti sull'isola
    Tipo:   procedure
    input:  pIdIsola, pIdIlo, pCuaa, pAnnoRiferimento
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTDbIsolaAnomalia (pIdIsola  IN DB_ISOLA.ID_ISOLA%TYPE,
                                      pIdIlo    IN DB_ISOLA.ID_ILO%TYPE
                                      ) IS
    BEGIN

        INSERT INTO DB_ISOLA_ANOMALIA
            (
            ID_ISOLA_ANOMALIA,
            ID_ISOLA,
            CODICE,
            DESCRIZIONE
            )
        SELECT SEQ_ISOLA_ANOMALIA.NEXTVAL,
               ISO.ID_ISOLA,
               AN.CODICE,
               AN.DESCRIZIONE_ANOMALIA
          FROM SMRGAA_W_ISOLA_ANOMALIA AN,
               DB_ISOLA ISO
         WHERE ISO.ID_ISOLA = pIdIsola
           AND ISO.ID_ILO = pIdIlo
           AND ISO.ID_ILO = AN.ID_ILO;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertTDbIsolaAnomalia - pIdIsola/pIdIlo/pCuaa/pAnnoRif = ' || pIdIsola || '/' || pIdIlo);
             RAISE;
    END InsertTDbIsolaAnomalia;

    /*********************************************************************
    Inserisce l'abbinamento dell'isola con le conduzioni dichiarate
    in pratica identifica le particelle dichiarate che compongono l'isola
    Tipo:   procedure
    input:  pIdIlo, pCuaa, pAnnoRiferimento
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTDbIsolaDichiarata (pRecTIsolaDichiarata IN DB_ISOLA_DICHIARATA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_ISOLA_DICHIARATA
            (
            ID_ISOLA_DICHIARATA,
            ID_DICHIARAZIONE_CONSISTENZA,
            FLAG_STORICIZZA,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA
            )
        VALUES
            (
            pRecTIsolaDichiarata.ID_ISOLA_DICHIARATA,
            pRecTIsolaDichiarata.ID_DICHIARAZIONE_CONSISTENZA,
            pRecTIsolaDichiarata.FLAG_STORICIZZA,
            pRecTIsolaDichiarata.DATA_INIZIO_VALIDITA,
            pRecTIsolaDichiarata.DATA_FINE_VALIDITA
            );
    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertTDbIsolaDichiarata - ID_DICHIARAZIONE_CONSISTENZA = ' || pRecTIsolaDichiarata.ID_DICHIARAZIONE_CONSISTENZA );
             RAISE;
    END InsertTDbIsolaDichiarata;

    /*********************************************************************
    Effettua la insert dell'isola creata sull'apposita tabella
    Tipo:   procedure
    input:  pRecDbIsola
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTDbIsola (pRecDbIsola IN OUT DB_ISOLA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_ISOLA
            (
            ID_ISOLA,
            ID_ISOLA_DICHIARATA,
            ID_ILO,
            SUPERFICIE,
            SUPE_PART_GIS,
            DATA_CALCOLO
            )
        VALUES
            (
            SEQ_ISOLA.nextval,
            pRecDbIsola.ID_ISOLA_DICHIARATA,
            pRecDbIsola.ID_ILO,
            pRecDbIsola.SUPERFICIE,
            pRecDbIsola.SUPE_PART_GIS,
            pRecDbIsola.DATA_CALCOLO
            )
        RETURN ID_ISOLA INTO pRecDbIsola.ID_ISOLA;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertTDbIsola - ID_ISOLA_DICHIARATA/ID_ILO/SUPERFICIE/SUPE_PART_GIS = ' || pRecDbIsola.ID_ISOLA_DICHIARATA || '/' || pRecDbIsola.ID_ILO || '/' || pRecDbIsola.SUPERFICIE || '/' || pRecDbIsola.SUPE_PART_GIS );
             RAISE;
    END InsertTDbIsola;

    /*********************************************************************
    Cancella tutte le anomalie delle isole legata alla dichiarazione
    di consistenza in elaborazione
    Tipo:   procedure
    input:  pIdDichConsistenza
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE CancellaIsolaAnomaliaDich (pIdIsolaDichiarata IN DB_ISOLA.ID_ISOLA_DICHIARATA%TYPE) IS
    BEGIN

        DELETE DB_ISOLA_ANOMALIA
         WHERE ID_ISOLA IN (SELECT ID_ISOLA
                              FROM DB_ISOLA
                             WHERE ID_ISOLA_DICHIARATA = pIdIsolaDichiarata);

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('CancellaIsolaAnomaliaDich - pIdIsolaDichiarata = ' || pIdIsolaDichiarata );
             RAISE;
    END CancellaIsolaAnomaliaDich;

    /*********************************************************************
    Cancella tutti records di DB_ISOLA legati ad un certo DB_ISOLA_DICHIARATA
    Tipo:   procedure
    input:  pIdIsolaDichiarata
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE CancellaIsola (pIdIsolaDichiarata IN DB_ISOLA.ID_ISOLA_DICHIARATA%TYPE) IS
    BEGIN
        DELETE
          FROM DB_ISOLA
         WHERE ID_ISOLA_DICHIARATA = pIdIsolaDichiarata;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('CancellaIsola - pIdIsolaDichiarata = ' || pIdIsolaDichiarata );
             RAISE;
    END CancellaIsola;

    /*********************************************************************
    Cancella tutte le coppie ID_ISOLA / ID_ELEGGIBILITA_FIT legate
    alle isole della dichiarazione di consistenza in elaborazione ed
    anche gli eventuali records associati presenti nella tabella DB_UNAR_PARCELLA
    Tipo:   procedure
    input:  pIdDichConsistenza
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE CancellaIsolaParcellaDich  (pIdIsolaDichiarata IN DB_ISOLA.ID_ISOLA_DICHIARATA%TYPE) IS
    BEGIN
        DELETE
          FROM DB_UNAR_PARCELLA
         WHERE ID_ISOLA_PARCELLA IN (SELECT IP.ID_ISOLA_PARCELLA
                                       FROM DB_ISOLA_PARCELLA IP,
                                            DB_ISOLA I
                                      WHERE I.ID_ISOLA_DICHIARATA = pIdIsolaDichiarata
                                        AND I.ID_ISOLA = IP.ID_ISOLA);

        DELETE
          FROM DB_ISOLA_PARCELLA
         WHERE ID_ISOLA IN (SELECT ID_ISOLA
                              FROM DB_ISOLA
                             WHERE ID_ISOLA_DICHIARATA = pIdIsolaDichiarata);

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('CancellaIsolaParcellaDich - pIdIsolaDichiarata = ' || pIdIsolaDichiarata);
             RAISE;
    END CancellaIsolaParcellaDich;

    /*********************************************************************
    Cancella tutte le accoppiate di conduzione dichiarata / isola legate
    alle isole della dichiarazione di consistenza in elaborazione
    Tipo:   procedure
    input:  pIdDichConsistenza
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE CancellaParcellaConduzioneDich (pIdIsolaDichiarata IN DB_ISOLA.ID_ISOLA_DICHIARATA%TYPE) IS
    BEGIN
            DELETE
              FROM DB_PARCELLA_CONDUZIONE
             WHERE ID_ISOLA_PARCELLA IN (SELECT ID_ISOLA_PARCELLA
                                           FROM DB_ISOLA_PARCELLA IP,
                                                DB_ISOLA I
                                          WHERE I.ID_ISOLA_DICHIARATA = pIdIsolaDichiarata
                                            AND I.ID_ISOLA = IP.ID_ISOLA);

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('CancellaParcellaConduzioneDich - pIdIsolaDichiarata = ' || pIdIsolaDichiarata );
             RAISE;
    END CancellaParcellaConduzioneDich;

    /*********************************************************************
    Cancella tutte le isole della dichiarazione di consistenza in
    elaborazione (cancellando eventualemente a monte le tabelle figlie)
    Tipo:   procedure
    input:  pIdDichConsistenza
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE CancellaIsoleDichiarazione (pIdIsolaDichiarata IN DB_ISOLA_DICHIARATA.ID_ISOLA_DICHIARATA%TYPE) IS
    BEGIN

        CancellaParcellaConduzioneDich (pIdIsolaDichiarata);
        CancellaIsolaParcellaDich (pIdIsolaDichiarata);
        CancellaIsolaAnomaliaDich (pIdIsolaDichiarata);
        CancellaIsola (pIdIsolaDichiarata);

        DELETE
          FROM DB_ISOLA_DICHIARATA
         WHERE ID_ISOLA_DICHIARATA = pIdIsolaDichiarata;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('CancellaIsoleDichiarazione - pIdIsolaDichiarata = ' || pIdIsolaDichiarata );
             RAISE;
    END CancellaIsoleDichiarazione;

    /*********************************************************************
    Effettua l'acquisizione delle isole generate dal GIS
    utilizzando le tabelle di lavoro (popolate con SQL-Loader)
    SMRGAA_W_ISOLE_PARTICELLE, SMRGAA_W_ISOLE_PARCELLE
    SMRGAA_W_ISOLE_ANOMALIE
    Tipo:    function
    input:  nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO)
    *********************************************************************/
    FUNCTION ELABORA_ISOLE RETURN NUMBER IS

        -- cursore delle dichiarazioni di consistenza
        -- distinte dell'elaborazione di isole in corso
        CURSOR curDichConsistenza IS
        SELECT DISTINCT ID_DICHIARAZIONE_CONSISTENZA,
                        ANNO_RIFERIMENTO,
                        CUAA,
                        DECODE(SUBSTR (ESITO,1,9),'ritorno=1','S','E') AS ESITO,
                        ESITO AS MESSAGGIO_ERRORE
          FROM SMRGAA_W_ISOLA
         WHERE ELABORATA IS NULL;

        -- cursore delle isole distinte per
        -- la dichiarazione di consistenza in corso
        -- di elaborazione passata in input
        CURSOR curIsoleDichiarazione (pIdDichCons   IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                      pAnnoRif      IN DB_DICHIARAZIONE_CONSISTENZA.ANNO%TYPE,
                                      pCuaa         IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE) IS
        SELECT *
          FROM SMRGAA_W_ISOLA
         WHERE ID_DICHIARAZIONE_CONSISTENZA    = pIdDichCons
           AND ANNO_RIFERIMENTO = pAnnoRif
           AND CUAA = pCuaa
           AND ID_ILO IS NOT NULL;

        recDBIsola              DB_ISOLA%ROWTYPE;-- record di appoggio per inserimento su DB_ISOLA
        nNumIsole               INTEGER:=0; -- contatore delle isole inserite
        nNumDichKo              INTEGER:=0; -- contatore delle dichiarazioni di consistenza elaborate con errore
        nNumDich                INTEGER:=0; -- contatore delle dichiarazioni di consistenza elaborate correttamente
        GENERAZIONE_ISOLA_KO    EXCEPTION;
        -- conterrà 0 = Elaborazione Ok e presenti record o 2 = Elaborazione Ok ma nessun record
        -- record di appoggio per il reperimento dei dati dell'applicazione corrente
        recDApplicazione        SMRGAA_D_APPLICAZIONI_BATCH%ROWTYPE;
        -- conterrà l'id esecuzione
        nIdEsecuzione           SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE;
        -- conterrà il codice di ritorno
        nRetCode                NUMBER(1):=0;

        nOldIsolaDichiarata     DB_ISOLA_DICHIARATA.ID_ISOLA_DICHIARATA%TYPE;
        bCancella               BOOLEAN:=FALSE;

        recTIsolaDichiarata     DB_ISOLA_DICHIARATA%ROWTYPE;
        vCodFoto                DB_DICHIARAZIONE_CONSISTENZA.CODICE_FOTOGRAFIA_TERRENI%TYPE;
        vetParametri            PCK_SMRGAA_LOG.TypVetParametriApplicazione;
        nPercTolleranza         NUMBER;
        vStoricizza             DB_ISOLA_DICHIARATA.FLAG_STORICIZZA%TYPE;
        vEscludiConsolidate     SMRGAA_R_PARAM_APPLICAZIONE.VALORE_VARCHAR2%TYPE;
        bEscludiDich            BOOLEAN:=FALSE;
    BEGIN
        nRetCode := Pck_SMRGAA_Log.VerificaAttivazioneBatch( knIdApplBatchIsoleParcelle ,recDApplicazione);

        IF nRetCode > 0 THEN
             -- Errore, Batch non attivo
            RETURN nRetCode;
        END IF;

        Pck_SMRGAA_Log.LeggiFileEsecuzione ( recDApplicazione.nomefile_esecuzione, recDApplicazione.path_file_esecuzione );

        Pck_SMRGAA_Log.SetLogLevel ( recDApplicazione.log_level );

        Pck_SMRGAA_Log.Init( knIdApplBatchIsoleParcelle,'ELABORA_ISOLE');

        -- carico il vettore di parametri per il batch
        vetParametri := PCK_SMRGAA_LOG.CaricaParametriApplicazione(knIdApplBatchIsoleParcelle);

        -- controllo se sono presenti parametri per il batch
        IF vetParametri.COUNT = 0 THEN
            -- se non ce ne sono segnalo l'informazione
            PCK_SMRGAA_LOG.LogInfo ('Parametri : ' || kvCodParametroPercTolleranza || '/' || kvCodParametroStoricizza || ' non presenti, utilizzo default (1.5/N)');
            nPercTolleranza := 1.5;
            vStoricizza := 'N';
        ELSE
            BEGIN
                -- se c'è però deve essere ok
                nPercTolleranza := vetParametri (kvCodParametroPercTolleranza).val_number;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    nPercTolleranza := 1.5;
                WHEN OTHERS THEN
                    PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroPercTolleranza || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
            END;

            BEGIN
                vStoricizza := vetParametri(kvCodParametroStoricizza).val_varchar2;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    vStoricizza := 'N';
                WHEN OTHERS THEN
                    PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroStoricizza || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
            END;

            BEGIN
                vEscludiConsolidate := vetParametri (kvCodParametroEsclConsolidate).val_varchar2;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    vEscludiConsolidate := 'N';
                WHEN OTHERS THEN
                    PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroEsclConsolidate || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
            END;


        END IF;

        PCK_SMRGAA_LOG.LogInfo ('Inizio Acquisizione Isole');

        -- scorro le dichiarazioni di consistenza elaborate
        FOR recDichConsistenza IN curDichConsistenza LOOP
            BEGIN
                IF vEscludiConsolidate = 'S' THEN
                   IF IsAziendaConSchedConsolidato (recDichConsistenza.ID_DICHIARAZIONE_CONSISTENZA) THEN
                      PCK_SMRGAA_LOG.LogAnomalia ('Dichiarazione : ' || recDichConsistenza.ID_DICHIARAZIONE_CONSISTENZA || ' scartata in quanto l''azienda ha già consolidato lo schedario viticolo a GIS' );
                      bEscludiDich := TRUE;
                   ELSE
                      bEscludiDich := FALSE;
                   END IF;
                ELSE
                   bEscludiDich := FALSE;
                END IF;

                IF NOT bEscludiDich THEN
                    -- aggiorno i campi sull'omonima tabella
                    -- per avere l'esito dell'elaborazione e l'eventuale messaggio di errore
                    UPDATE DB_DICHIARAZIONE_CONSISTENZA
                       SET FLAG_AGGIORNAMENTO_ISOLE = recDichConsistenza.esito,
                           ERRORE_AGGIORNAMENTO_ISOLE = DECODE(recDichConsistenza.esito,'E',recDichConsistenza.messaggio_errore,NULL),
                           DATA_AGGIORNAMENTO_ISOLE = (SELECT NVL(MAX(DATA_CALCOLO),SYSDATE)
                                                         FROM SMRGAA_W_ISOLA
                                                        WHERE ID_DICHIARAZIONE_CONSISTENZA = recDichConsistenza.ID_DICHIARAZIONE_CONSISTENZA)
                     WHERE ID_DICHIARAZIONE_CONSISTENZA = recDichConsistenza.ID_DICHIARAZIONE_CONSISTENZA
                 RETURNING CODICE_FOTOGRAFIA_TERRENI INTO vCodFoto;

                    IF recDichConsistenza.esito = 'E' THEN
                       RAISE GENERAZIONE_ISOLA_KO;
                    END IF;

                    -- controllo se per la dichiarazione di consistenza in questione
                    -- ci sono delle isole dichiarata che si possono cancellare
                    nOldIsolaDichiarata := IsIsolaCancellabileForDich (recDichConsistenza.ID_DICHIARAZIONE_CONSISTENZA,
                                                                       bCancella);

                    IF nOldIsolaDichiarata IS NOT NULL THEN
                       IF bCancella THEN
                          -- cancello le eventuali isole dichiarate già presenti in
                          -- SMRGAA per la dichiarazione di consistenza in elaborazione
                          CancellaIsoleDichiarazione (nOldIsolaDichiarata);
                       ELSE
                          -- altrimenti le storicizzo
                          StoricizzaIsolaDichiarata (nOldIsolaDichiarata);
                       END IF;
                    END IF;

                    SELECT SEQ_DB_ISOLA_DICHIARATA.nextval
                      INTO recTIsolaDichiarata.ID_ISOLA_DICHIARATA
                      FROM DUAL;

                    recTIsolaDichiarata.ID_DICHIARAZIONE_CONSISTENZA := recDichConsistenza.ID_DICHIARAZIONE_CONSISTENZA;
                    recTIsolaDichiarata.FLAG_STORICIZZA := vStoricizza;
                    recTIsolaDichiarata.DATA_INIZIO_VALIDITA := SYSDATE;
                    recTIsolaDichiarata.DATA_FINE_VALIDITA := NULL;
                    InsertTDbIsolaDichiarata (recTIsolaDichiarata);

                    -- conto la dichiarazione
                    nNumDich := nNumDich + 1;
                    -- scorro le isole della dichiarazione di consistenza in elaborazione
                    FOR recIsoleDichiarazione IN curIsoleDichiarazione (recDichConsistenza.ID_DICHIARAZIONE_CONSISTENZA,
                                                                        recDichConsistenza.ANNO_RIFERIMENTO,
                                                                        recDichConsistenza.CUAA
                                                                        ) LOOP
                            -- preparo il record di appoggio per l'inserimento su DB_ISOLA di SMRGAA
                            recDBIsola.ID_ISOLA_DICHIARATA := recTIsolaDichiarata.ID_ISOLA_DICHIARATA;
                            recDBIsola.ID_ILO := recIsoleDichiarazione.ID_ILO;
                            recDBIsola.SUPERFICIE := recIsoleDichiarazione.SUPERFICIE;
                            recDBIsola.SUPE_PART_GIS := recIsoleDichiarazione.SUPE_PART_GIS;
                            recDBIsola.DATA_CALCOLO := SYSDATE;
                            -- effettuo la insert
                            InsertTDbIsola (recDBIsola);
                            -- conto l'isola
                            nNumIsole := nNumIsole +1 ;

                            -- inserisco l'abbinamento tra isola e parcelle
                            InsertTDBIsolaParcella (recDBIsola.ID_ISOLA,
                                                    recIsoleDichiarazione.ID_ILO,
                                                    nPercTolleranza);
                            -- inserisco l'abbinamento tra parcelle e conduzione dichiarata
                            InsertTDBParcellaDichiarata (vCodFoto,
                                                         recDBIsola.ID_ISOLA,
                                                         recIsoleDichiarazione.ID_ILO);

                            -- inserisco le anomalie relative alle isole
                            InsertTDbIsolaAnomalia (recDBIsola.ID_ISOLA,
                                                    recIsoleDichiarazione.ID_ILO);


                    END LOOP;
                END IF;
                EvadiDichiarazione (recDichConsistenza.ID_DICHIARAZIONE_CONSISTENZA);

                COMMIT;

            EXCEPTION
                WHEN DUP_VAL_ON_INDEX THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Dichiarazione : ' || recDichConsistenza.ID_DICHIARAZIONE_CONSISTENZA || ' scartata per duplicazione di isole / parcelle!!' );
                     nNumDichKo := nNumDichKo + 1;
                     ROLLBACK;
                WHEN GENERAZIONE_ISOLA_KO THEN
                     nNumDichKo := nNumDichKo + 1;
                     PCK_SMRGAA_LOG.LogAnomalia ('Dichiarazione : ' || recDichConsistenza.ID_DICHIARAZIONE_CONSISTENZA || ' terminata con errore : ' || recDichConsistenza.messaggio_errore);
                     EvadiDichiarazione (recDichConsistenza.ID_DICHIARAZIONE_CONSISTENZA);
                     COMMIT;
            END;
        END LOOP;

        PCK_SMRGAA_LOG.LogInfo ('Fine Acquisizione Isole, elaborate : ' || nNumDich || ' dichiarazioni di consistenza ed acquisite : ' || nNumIsole || ' isole');

        PCK_SMRGAA_LOG.ValorizzaEsitoBatch;
        COMMIT;

        RETURN nRetCode;

    EXCEPTION
        WHEN OTHERS THEN
            PCK_SMRGAA_LOG.LogSqlError ('ELABORA_ISOLE');
            RETURN 1;
    END ELABORA_ISOLE;

    /*********************************************************************
    Crea un file di testo da caricare sul DB di abaco con i dati delle particelle
    delle dichiarazioni di consistenza per le quali non è ancora stata effettuata
    la generazione delle isole
    Tipo:    function
    input:  pPathName, pNomeFileParticelle, pNomeFileParametri
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO)
    *********************************************************************/
    FUNCTION SelecTMaxDataRicalcoloIsole RETURN DATE IS
        dDataUltimoCalcoloIsole DATE;
    BEGIN

        SELECT NVL(MAX(DATA_CALCOLO), TRUNC(SYSDATE) - 1)
          INTO dDataUltimoCalcoloIsole
          FROM DB_ISOLA;

        RETURN dDataUltimoCalcoloIsole;

    END SelecTMaxDataRicalcoloIsole;

    /*********************************************************************
    Crea un file di testo da caricare sul DB di abaco con i dati delle particelle
    delle dichiarazioni di consistenza per le quali non è ancora stata effettuata
    la generazione delle isole
    Tipo:  function
    input:  pNomeFileParticelle, pNomeFileParametri
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO)
    *********************************************************************/
    FUNCTION ScaricoPianiColturali(pNomeFileParticelle  IN VARCHAR2,
                                   pNomeFileParametri   IN VARCHAR2) RETURN NUMBER IS


        -- cursore che estrapola le particelle dichiarate da inviare
        -- al GIS per la creazione delle isole sulle dichiarazioni
        -- di consistenza per le quali non sono ancora state create
        CURSOR curParticelleDaInviare (pCtrlProtocollo IN VARCHAR2,
                                       pAnnoIsole      IN INTEGER,
                                       pEscludiCons    IN VARCHAR2
                                       ) IS
        SELECT DC.ID_DICHIARAZIONE_CONSISTENZA,
               DC.ANNO,
               AZ.ID_AZIENDA,
               AZ.CUAA,
               'PC' AS COD_SETTORE,
               DECODE(pAnnoIsole, NULL,TO_CHAR(DC.DATA_INSERIMENTO_DICHIARAZIONE,'YYYY'),
                      GREATEST (pAnnoIsole, TO_CHAR(DC.DATA_INSERIMENTO_DICHIARAZIONE,'YYYY'))) AS ANNO_RIFERIMENTO,
               DC.CODICE_FOTOGRAFIA_TERRENI,
               SP.ID_PARTICELLA, 
               SUBSTR(SP.COMUNE,1,3) AS COD_PROV,
               SUBSTR(SP.COMUNE,4,6) AS COD_COMU,
               SP.SEZIONE,
               SP.FOGLIO,
               SP.PARTICELLA,
               SP.SUBALTERNO,
               SP.ID_STORICO_PARTICELLA, 
               UT.CODICE AS CODICE_UTILIZZO,
               VAR.CODICE_VARIETA,
               MC.CODICE AS CODICE_MACRO_USO,
               UD.SUPERFICIE_UTILIZZATA,
               SP.SUP_CATASTALE,
               '0' AS COD_PREMIO,
               '000' AS CODICE_INTERVENTO,
               TO_CHAR(NVL(DATA_PROTOCOLLO,SYSDATE),'DD/MM/YYYY') AS DATA_PROTOCOLLO,
               SP.ID_CASO_PARTICOLARE AS CASO_PARTICOLARE,
               '0' CONTROLLO_LOCO
          FROM DB_TIPO_MOTIVO_DICHIARAZIONE MOT,
               DB_ANAGRAFICA_AZIENDA AZ,
               DB_DICHIARAZIONE_CONSISTENZA DC,
               DB_CONDUZIONE_DICHIARATA CD,
               DB_STORICO_PARTICELLA SP,
               DB_UTILIZZO_DICHIARATO UD,
               DB_TIPO_UTILIZZO UT,
               DB_TIPO_VARIETA VAR,
               DB_TIPO_MACRO_USO_VARIETA MCV,
               DB_TIPO_MACRO_USO MC
         WHERE MOT.TIPO_DICHIARAZIONE <> kvCodTipoMotivoDichCorrettiva
           AND DC.ID_MOTIVO_DICHIARAZIONE = MOT.ID_MOTIVO_DICHIARAZIONE
           AND DC.ID_MOTIVO_DICHIARAZIONE  <> knIdTipoMotivoDichSiccita2006
           AND DC.DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DIC2.DATA_INSERIMENTO_DICHIARAZIONE)
                                                      FROM DB_DICHIARAZIONE_CONSISTENZA DIC2,
                                                           DB_TIPO_MOTIVO_DICHIARAZIONE MOT2
                                                     WHERE DIC2.ID_AZIENDA = DC.ID_AZIENDA
                                                       AND DIC2.ID_MOTIVO_DICHIARAZIONE <> knIdTipoMotivoDichSiccita2006
                                                       AND MOT2.TIPO_DICHIARAZIONE <> kvCodTipoMotivoDichCorrettiva
                                                       AND DIC2.ID_MOTIVO_DICHIARAZIONE = MOT2.ID_MOTIVO_DICHIARAZIONE
                                                       -- AND DIC2.ANNO = DC.ANNO 
                                                       AND ((pCtrlProtocollo = 'S' AND DIC2.DATA_PROTOCOLLO IS NOT NULL) OR
                                                         NVL(pCtrlProtocollo,'N') = 'N'))
           AND ((pCtrlProtocollo = 'S' AND DC.DATA_PROTOCOLLO IS NOT NULL) OR NVL(pCtrlProtocollo,'N') = 'N')
           AND AZ.DATA_FINE_VALIDITA IS NULL
           AND AZ.ID_AZIENDA = DC.ID_AZIENDA
           AND CD.CODICE_FOTOGRAFIA_TERRENI = DC.CODICE_FOTOGRAFIA_TERRENI
           AND CD.ID_CONDUZIONE_DICHIARATA = UD.ID_CONDUZIONE_DICHIARATA
           AND CD.ID_STORICO_PARTICELLA = SP.ID_STORICO_PARTICELLA
           AND SP.PARTICELLA IS NOT NULL 
           AND UT.ID_UTILIZZO = UD.ID_UTILIZZO
           AND VAR.ID_VARIETA = UD.ID_VARIETA
           AND UD.ID_VARIETA = MCV.ID_VARIETA
           AND MCV.DATA_FINE_VALIDITA IS NULL
           AND MCV.ID_MACRO_USO = MC.ID_MACRO_USO
           AND AZ.DATA_CESSAZIONE IS NULL
           AND CD.ID_TITOLO_POSSESSO <> knIdTitoloPossessoAsservimento
           AND NVL(DC.FLAG_AGGIORNAMENTO_ISOLE,'E') = 'E'
           AND EXISTS (SELECT ID_UNITA_ARBOREA_DICHIARATA
                         FROM DB_UNITA_ARBOREA_DICHIARATA
                        WHERE CODICE_FOTOGRAFIA_TERRENI = DC.CODICE_FOTOGRAFIA_TERRENI
                          AND ID_TIPOLOGIA_UNAR = knIdTipologiaUnarVino
                          AND DATA_FINE_VALIDITA IS NULL
                          AND DATA_CESSAZIONE IS NULL) 
           AND (pEscludiCons = 'N' OR
               (pEscludiCons = 'S' AND NOT EXISTS (SELECT ID_COMPENSAZIONE_AZIENDA
                                                     FROM DB_COMPENSAZIONE_AZIENDA
                                                    WHERE ID_AZIENDA = AZ.ID_AZIENDA
                                                      AND DATA_FINE_VALIDITA IS NULL
                                                      AND DATA_CONSOLIDAMENTO_GIS IS NOT NULL))) 
      ORDER BY AZ.ID_AZIENDA;

        -- puntatore al file che conterrà le particelle delle nuove dichiarazioni
        -- per cui effettuare la creazione di Isole e Parcelle
        fFileParticelleNewDich  UTL_FILE.FILE_TYPE;
        -- conterrà i parametri da passare al batch RPAIIP020 lato SITIPIOPR
        fFileParametri          UTL_FILE.FILE_TYPE;
        -- variabile di appoggio per scrittura su file
        vRigaApp                VARCHAR2(500);
        -- conterrà la data di ultimo calcolo delle isole
        dDtUltRicIsole          DATE;
        -- numero di record accodati
        nNumRec                 INTEGER:=0;
        -- conterrà 0 = Elaborazione Ok e presenti record o 2 = Elaborazione Ok ma nessun record
        -- record di appoggio per il reperimento dei dati dell'applicazione corrente
        recDApplicazione        SMRGAA_D_APPLICAZIONI_BATCH%ROWTYPE;
        -- conterrà l'id esecuzione
        nIdEsecuzione           SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE;
        -- conterrà il codice di ritorno
        nRetCode                NUMBER(1):=0;
        -- vettore di parametri di input
        vetParametri            PCK_SMRGAA_LOG.TypVetParametriApplicazione;
        bParamOk                BOOLEAN:=TRUE;
        -- conterrà il parametro che mi dice se considerare le sole dichiarazioni di consistenza protocollate
        vProtocollazione        VARCHAR2(1):='N';
        -- contiene l'ID_AZIENDA elaborato precedentemente
        nOldAzienda             DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE:=0;
        -- flag che mi dice se accodare o meno le particelle estratte
        bAccoda                 BOOLEAN:=FALSE;
        -- contiene la vecchia eventuale dichiarazione di consistenza con le isole
        recDichConsistenza      DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE;
        -- conterrà l'eventuale valore del parametro ANNOISOLE se presente
        nAnnoIsole              INTEGER;
        -- indicatore per escludere le aziende che hanno eseguito il consolidamento a GIS
        -- dello schedario viticolo
        vEscludiConsolidate     SMRGAA_R_PARAM_APPLICAZIONE.VALORE_VARCHAR2%TYPE;

    BEGIN

        nRetCode := Pck_SMRGAA_Log.VerificaAttivazioneBatch( knIdApplBatchIsoleParcelle ,recDApplicazione);

        IF nRetCode > 0 THEN
             -- Errore, Batch non attivo
            RETURN nRetCode;
        END IF;

         -- Inserimento in tabella dell'identificativo di esecuzione
         -- nIdEsecuzione restituito in output
        Pck_SMRGAA_Log.InsertTEsecuzione ( knIdApplBatchIsoleParcelle, nIdEsecuzione );
        COMMIT;

         -- Scrittura nel file nomefile_esecuzione del nIdEsecuzione
        Pck_SMRGAA_Log.ScriviFileEsecuzione (  recDApplicazione.nomefile_esecuzione,
                                               recDApplicazione.path_file_esecuzione,
                                               nIdEsecuzione );

        Pck_SMRGAA_Log.LeggiFileEsecuzione ( recDApplicazione.nomefile_esecuzione, recDApplicazione.path_file_esecuzione );

        Pck_SMRGAA_Log.SetLogLevel ( recDApplicazione.log_level );

        Pck_SMRGAA_Log.Init( knIdApplBatchIsoleParcelle, 'ScaricoPianiColturali' );
        -- carico il vettore di parametri per il batch
        vetParametri := PCK_SMRGAA_LOG.CaricaParametriApplicazione(knIdApplBatchIsoleParcelle);

        EXECUTE IMMEDIATE 'TRUNCATE TABLE SMRGAA_W_ISOLA';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE SMRGAA_W_PARCELLA';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE SMRGAA_W_PARCELLA_PARTICELLA';
        EXECUTE IMMEDIATE 'TRUNCATE TABLE SMRGAA_W_ISOLA_ANOMALIA';

        -- controllo se sono presenti parametri per il batch
        IF vetParametri.COUNT = 0 THEN
            -- se non ce ne sono segnalo l'informazione
            PCK_SMRGAA_LOG.LogInfo ('Parametro : ' || kvCodParametroDataRicalcolo || ' non presente');
            -- e cerco la ultima data in cui è stato effettuato il calcolo delle isole
            dDtUltRicIsole := SelecTMaxDataRicalcoloIsole;
        ELSE
            BEGIN
                -- se c'è però deve essere ok
                dDtUltRicIsole := vetParametri (kvCodParametroDataRicalcolo).val_date;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    dDtUltRicIsole := SelecTMaxDataRicalcoloIsole;
                WHEN OTHERS THEN
                    PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroDataRicalcolo || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                    bParamOk := FALSE;
            END;

            BEGIN
                vProtocollazione := vetParametri (kvCodParametroProtocollazione).val_varchar2;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    vProtocollazione := 'N';
                WHEN OTHERS THEN
                    PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroProtocollazione || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                    bParamOk := FALSE;
            END;

            BEGIN
                nAnnoIsole := vetParametri (kvCodParametroAnnoIsole).val_number;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    nAnnoIsole := NULL;
                WHEN OTHERS THEN
                    PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroProtocollazione || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                    bParamOk := FALSE;
            END;

            BEGIN
                vEscludiConsolidate := vetParametri (kvCodParametroEsclConsolidate).val_varchar2;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    vEscludiConsolidate := 'N';
                WHEN OTHERS THEN
                    PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroEsclConsolidate || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                    bParamOk := FALSE;
            END;

        END IF;
        -- se i parametri sono ok inizio l'elaborazione
        IF bParamOk THEN

            PCK_SMRGAA_LOG.LogInfo ('Inizio Elaborazione , Data ultimo ricalcolo isole = ' || TO_CHAR(dDtUltRicIsole,'DD/MM/YYYY-HH24:MI:SS'));
            -- apro il file di testo che andrà a contenere la data ultimo ricalcolo
            fFileParametri := UTL_FILE.FOPEN (recDApplicazione.path_file_esecuzione, pNomeFileParametri,'W',100);
            -- apro il file di testo che andrà a contenere le particelle
            fFileParticelleNewDich := UTL_FILE.FOPEN (recDApplicazione.path_file_esecuzione, pNomeFileParticelle,'W',500);

            FOR recParticelleDaInviare IN curParticelleDaInviare (vProtocollazione, nAnnoIsole, vEscludiConsolidate)LOOP
                IF nOldAzienda <> recParticelleDaInviare.ID_AZIENDA THEN
                   bAccoda:=FALSE;
                   -- controllo se esiste una dichiarazione precedente dell'azienda con la generazione delle isole
                   recDichConsistenza := SelLastDichConsWithIsoleForAz (recParticelleDaInviare.ID_AZIENDA, recParticelleDaInviare.ANNO);
                   -- se non c'è posso accodare
                   IF recDichConsistenza.ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
                      bAccoda:= TRUE;
                   ELSE
                      -- se c'è controllo l'esistenza di una variazione del piano colturale
                      -- tra la dichiarazione con le isole e quella attuale
                      IF ExistsVariazionePianoColturale (recParticelleDaInviare.CODICE_FOTOGRAFIA_TERRENI,
                                                         recDichConsistenza.CODICE_FOTOGRAFIA_TERRENI) THEN
                         bAccoda:= TRUE;
                      END IF;
                   END IF;

                   IF bAccoda THEN
                      UPDATE DB_DICHIARAZIONE_CONSISTENZA
                         SET FLAG_AGGIORNAMENTO_ISOLE = 'I' -- Inviate
                       WHERE ID_DICHIARAZIONE_CONSISTENZA = recParticelleDaInviare.ID_DICHIARAZIONE_CONSISTENZA;
                   END IF;

                END IF;

                IF bAccoda THEN
                    vRigaApp := recParticelleDaInviare.ID_DICHIARAZIONE_CONSISTENZA || '|' ||
                                recParticelleDaInviare.CUAA || '|' ||
                                recParticelleDaInviare.COD_SETTORE || '|' ||
                                recParticelleDaInviare.ANNO_RIFERIMENTO || '|' ||
                                recParticelleDaInviare.ID_PARTICELLA || '|' ||
                                recParticelleDaInviare.COD_PROV || '|' ||
                                recParticelleDaInviare.COD_COMU || '|' ||
                                recParticelleDaInviare.SEZIONE || '|' ||
                                recParticelleDaInviare.FOGLIO || '|' ||
                                recParticelleDaInviare.PARTICELLA || '|' ||
                                recParticelleDaInviare.SUBALTERNO || '|' ||
                                recParticelleDaInviare.ID_STORICO_PARTICELLA || '|' ||
                                recParticelleDaInviare.CODICE_UTILIZZO || '|' ||
                                recParticelleDaInviare.CODICE_VARIETA || '|' ||
                                recParticelleDaInviare.CODICE_MACRO_USO || '|' ||
                                recParticelleDaInviare.SUPERFICIE_UTILIZZATA || '|' ||
                                recParticelleDaInviare.SUP_CATASTALE || '|' ||
                                recParticelleDaInviare.COD_PREMIO || '|' ||
                                recParticelleDaInviare.CODICE_INTERVENTO || '|' ||
                                recParticelleDaInviare.DATA_PROTOCOLLO || '|' ||
                                recParticelleDaInviare.CASO_PARTICOLARE || '|' ||
                                recParticelleDaInviare.CONTROLLO_LOCO;

                    UTL_FILE.PUT_LINE(fFileParticelleNewDich,vRigaApp);

                    nNumRec := nNumRec + 1;
                END IF;

                nOldAzienda := recParticelleDaInviare.ID_AZIENDA;

            END LOOP;

            UTL_FILE.FCLOSE( fFileParticelleNewDich );

            UTL_FILE.PUT_LINE (fFileParametri,'NUMREC=' || nNumRec);
            UTL_FILE.PUT_LINE (fFileParametri,'DATALASTRIC=' || TRIM(TO_CHAR(dDtUltRicIsole,'DD/MM/YYYY-HH24:MI:SS')));
            UTL_FILE.FCLOSE (fFileParametri);

            IF nNumRec = 0 THEN
               UTL_FILE.FREMOVE(recDApplicazione.path_file_esecuzione, pNomeFileParticelle);
               nRetCode := 2; -- nessuna particella da elaborare
               PCK_SMRGAA_LOG.LogInfo ('Fine elaborazione, nessuna nuova particella da inviare al GIS per la creazione delle isole !!! ');
            ELSE
               PCK_SMRGAA_LOG.LogInfo ('Fine elaborazione, accodate : ' || nNumRec  || ' particelle da inviare al GIS per la creazione delle isole');
            END IF;
        END IF;

        RETURN nRetCode;

    EXCEPTION
        WHEN OTHERS THEN
            PCK_SMRGAA_LOG.LogSqlError ('ScaricoPianiColturali');
            IF UTL_FILE.IS_OPEN(fFileParticelleNewDich) THEN
               UTL_FILE.FCLOSE(fFileParticelleNewDich);
            END IF;
            IF UTL_FILE.IS_OPEN(fFileParametri) THEN
               UTL_FILE.FCLOSE(fFileParametri);
            END IF;
            RETURN 1;
    END ScaricoPianiColturali;

END Pck_Aggiorna_Isole_Parcelle;

/
--------------------------------------------------------
--  DDL for Package Body PCK_AGGIORNA_PROCEDIMENTI_AZ
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_AGGIORNA_PROCEDIMENTI_AZ" AS

FUNCTION MAIN  RETURN NUMBER IS

   nMaxRec     NUMBER;
    nGiorni    NUMBER;

    CURSOR CUR_DIC IS     SELECT DISTINCT  DIC.ID_AZIENDA
                            FROM     DB_DICHIARAZIONE_CONSISTENZA DIC,
                                    DB_TIPO_MOTIVO_DICHIARAZIONE MOT
                            WHERE TRUNC(DIC.DATA_INSERIMENTO_DICHIARAZIONE) =     TRUNC(SYSDATE)
                            AND    DIC.ID_MOTIVO_DICHIARAZIONE                     =    MOT.ID_MOTIVO_DICHIARAZIONE
                            AND    MOT.TIPO_DICHIARAZIONE                            !=    'C'
                            AND    ROWNUM                                                <    (nMaxRec + 1);


    CURSOR CUR_ALT    IS SELECT  AZI.ID_AZIENDA
                            FROM DB_AZIENDA AZI
                            WHERE TRUNC(SYSDATE) - NVL(TRUNC(DATA_AGGIORNAMENTO_PRATICA),TO_DATE('01/01/1900','DD/MM/YYYY'))  > nGiorni
                            AND    ROWNUM                                                <    (nMaxRec + 1);

vDesErr    VARCHAR2(150);
vCodErr    VARCHAR2(150);

BEGIN

    SELECT TO_NUMBER(VALORE) INTO nGiorni
    FROM DB_PARAMETRO
    WHERE id_parametro='PRGG';

    SELECT TO_NUMBER(VALORE) INTO nMaxRec
    FROM DB_PARAMETRO
    WHERE id_parametro='PRAZ';

    FOR REC_DIC IN  CUR_DIC LOOP
        nMaxRec := nMaxRec - 1;
        Pack_Pratica_Azienda.AGGIORNA_PRATICA_AZIENDA(REC_DIC.ID_AZIENDA,vDesErr,vCodErr);
    END LOOP;

    FOR REC_ALT IN  CUR_ALT LOOP
        nMaxRec := nMaxRec - 1;
        Pack_Pratica_Azienda.AGGIORNA_PRATICA_AZIENDA(REC_ALT.ID_AZIENDA,vDesErr,vCodErr);
    END LOOP;

  COMMIT;

RETURN(0);

EXCEPTION
    WHEN OTHERS THEN
        COMMIT;
        DBMS_OUTPUT.PUT_LINE('ERRORE ORACLE: '||SUBSTR(SQLERRM,1,80)||' ELABORAZIONE INTERROTTA');
        RETURN(1);

END MAIN;

END Pck_Aggiorna_Procedimenti_Az;

/
--------------------------------------------------------
--  DDL for Package Body PCK_CALCOLO_EFA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_CALCOLO_EFA" AS
/*****************************************************************************
Package che espone tutte le function / stored procedure propedeutiche al
Calcolo delle EFA (Ecologic Focus Area - Aree Ecologiche)
******************************************************************************/

    /*********************************************************************
    Seleziona il record attivo di DB_AZIENDA_EFA dati ID_AZIENDA ed ID_TIPO_EFA
    Tipo: function
    input: pIdAzienda, pIdTipoEfa
    output: nessuno
    ritorno: DB_AZIENDA_EFA%ROWTYPE
    *********************************************************************/
    FUNCTION SelTAziendaEfaByIdAziendaIdEfa (pIdAzienda IN DB_AZIENDA_EFA.ID_AZIENDA%TYPE,
                                             pIdTipoEfa IN DB_AZIENDA_EFA.ID_TIPO_EFA%TYPE
                                             ) RETURN DB_AZIENDA_EFA%ROWTYPE IS
        recTAziendaEfa DB_AZIENDA_EFA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTAziendaEfa
          FROM DB_AZIENDA_EFA
         WHERE ID_AZIENDA = pIdAzienda
           AND ID_TIPO_EFA = pIdTipoEfa
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recTAziendaEfa;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTAziendaEfaByIdAziendaIdEfa;

    /*********************************************************************
    Inserisce un record di tipologia DB_AZIENDA_EFA sulla tabella omonima
    Tipo: procedure
    input: pRecTAziendaEfa
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTAziendaEfa (pRecTAziendaEfa IN DB_AZIENDA_EFA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_AZIENDA_EFA
            (
            ID_AZIENDA_EFA,
            ID_AZIENDA,
            ID_TIPO_EFA,
            VALORE_ORIGINALE,
            VALORE_DOPO_CONVERSIONE,
            VALORE_DOPO_PONDERAZIONE,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA,
            DATA_AGGIORNAMENTO,
            ID_UTENTE_AGGIORNAMENTO,
            ID_DICHIARAZIONE_CONSISTENZA,
            NOTE
            )
        VALUES
            (
            pRecTAziendaEfa.ID_AZIENDA_EFA,
            pRecTAziendaEfa.ID_AZIENDA,
            pRecTAziendaEfa.ID_TIPO_EFA,
            pRecTAziendaEfa.VALORE_ORIGINALE,
            pRecTAziendaEfa.VALORE_DOPO_CONVERSIONE,
            pRecTAziendaEfa.VALORE_DOPO_PONDERAZIONE,
            pRecTAziendaEfa.DATA_INIZIO_VALIDITA,
            pRecTAziendaEfa.DATA_FINE_VALIDITA,
            pRecTAziendaEfa.DATA_AGGIORNAMENTO,
            pRecTAziendaEfa.ID_UTENTE_AGGIORNAMENTO,
            pRecTAziendaEfa.ID_DICHIARAZIONE_CONSISTENZA,
            pRecTAziendaEfa.NOTE
            );
    END InsertTAziendaEfa;

    /*********************************************************************
    Calcola le EFA dell'azienda o al piano in lavorazione o alla dichiarazione
    di consistenza passata in input se presente
    Tipo: procedure
    input: pIdAzienda, pIdDichCons,  pIdUtenteIride
    output: pRisultato,pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE Calcola_Efa (pIdAzienda     IN DB_AZIENDA_EFA.ID_AZIENDA%TYPE,
                           pIdDichCons    IN DB_AZIENDA_EFA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                           pIdUtenteIride IN DB_AZIENDA_EFA.ID_UTENTE_AGGIORNAMENTO%TYPE,
                           pRisultato     OUT VARCHAR2,
                           pMessaggio     OUT VARCHAR2) IS

        nRec INTEGER:=0;

        CURSOR curTipologiaEfa IS
        SELECT UD.ID_TIPO_EFA, pIdDichCons AS ID_DICHIARAZIONE_CONSISTENZA
          FROM DB_DICHIARAZIONE_CONSISTENZA DC,
               DB_CONDUZIONE_DICHIARATA CD,
               DB_UTILIZZO_DICHIARATO UD
         WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
           AND DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
           AND CD.ID_CONDUZIONE_DICHIARATA = UD.ID_CONDUZIONE_DICHIARATA
           AND UD.ID_TIPO_EFA IS NOT NULL
         UNION
        SELECT UP.ID_TIPO_EFA, NULL
          FROM DB_CONDUZIONE_PARTICELLA CP,
               DB_UTE UT,
               DB_UTILIZZO_PARTICELLA UP
         WHERE UT.ID_AZIENDA = pIdAzienda
           AND UT.ID_UTE = CP.ID_UTE
           AND UT.DATA_FINE_ATTIVITA IS NULL
           AND CP.DATA_FINE_CONDUZIONE IS NULL
           AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
           AND UP.ID_TIPO_EFA IS NOT NULL
           AND pIdDichCons IS NULL;


        recTAziendaEfa      DB_AZIENDA_EFA%ROWTYPE;
        recTAziendaEfaOld   DB_AZIENDA_EFA%ROWTYPE;
        PARAMETRI_ASSENTI   EXCEPTION;
        PROCEDURA_IN_ERRORE EXCEPTION;

    BEGIN

        IF pIdAzienda IS NULL THEN
           pMessaggio := 'Identificativo dell''azienda non valorizzato';
           RAISE PARAMETRI_ASSENTI;
        END IF;

        IF pIdUtenteIride IS NULL THEN
           pMessaggio := 'Identificativo dell''utente di aggiornamento non valorizzato';
           RAISE PARAMETRI_ASSENTI;
        END IF;

        -- storicizzo le efa dell'azienda attive
        -- se era specificato l'ID_DICHIARAZIONE_CONSISTENZA
        UPDATE DB_AZIENDA_EFA
           SET DATA_FINE_VALIDITA = SYSDATE
         WHERE DATA_FINE_VALIDITA IS NULL
           AND ID_AZIENDA = pIdAzienda
           AND ID_DICHIARAZIONE_CONSISTENZA IS NOT NULL;

        nRec := SQL%ROWCOUNT;
        -- scorro le tipologie di EFA
        FOR recTipologiaEfa IN curTipologiaEfa LOOP

            recTAziendaEfa := NULL;
            recTAziendaEfa.ID_AZIENDA := pIdAzienda;
            -- se la dichiarazione di consistenza e' valorizzata passo di lì
            IF recTipologiaEfa.ID_DICHIARAZIONE_CONSISTENZA IS NOT NULL THEN

               SELECT NVL(SUM(UD.VALORE_ORIGINALE),0),
                      NVL(SUM(UD.VALORE_DOPO_CONVERSIONE),0),
                      NVL(SUM(UD.VALORE_DOPO_PONDERAZIONE),0),
                      UD.ID_TIPO_EFA
                 INTO recTAziendaEfa.VALORE_ORIGINALE,
                      recTAziendaEfa.VALORE_DOPO_CONVERSIONE,
                      recTAziendaEfa.VALORE_DOPO_PONDERAZIONE,
                      recTAziendaEfa.ID_TIPO_EFA
                 FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                      DB_CONDUZIONE_DICHIARATA CD,
                      DB_UTILIZZO_DICHIARATO UD
                WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
                  AND DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
                  AND CD.ID_CONDUZIONE_DICHIARATA = UD.ID_CONDUZIONE_DICHIARATA
                  AND UD.ID_TIPO_EFA = recTipologiaEfa.ID_TIPO_EFA
             GROUP BY UD.ID_TIPO_EFA;

            ELSE
                -- altrimenti passo dal piano in lavorazione
                SELECT NVL(SUM(UP.VALORE_ORIGINALE),0),
                       NVL(SUM(UP.VALORE_DOPO_CONVERSIONE),0),
                       NVL(SUM(UP.VALORE_DOPO_PONDERAZIONE),0),
                       UP.ID_TIPO_EFA
                  INTO recTAziendaEfa.VALORE_ORIGINALE,
                       recTAziendaEfa.VALORE_DOPO_CONVERSIONE,
                       recTAziendaEfa.VALORE_DOPO_PONDERAZIONE,
                       recTAziendaEfa.ID_TIPO_EFA
                  FROM DB_CONDUZIONE_PARTICELLA CP,
                       DB_UTE UT,
                       DB_UTILIZZO_PARTICELLA UP
                 WHERE UT.ID_AZIENDA = pIdAzienda
                   AND UT.ID_UTE = CP.ID_UTE
                   AND UT.DATA_FINE_ATTIVITA IS NULL
                   AND CP.DATA_FINE_CONDUZIONE IS NULL
                   AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
                   AND UP.ID_TIPO_EFA = recTipologiaEfa.ID_TIPO_EFA
              GROUP BY UP.ID_TIPO_EFA;

            END IF;

            recTAziendaEfa.ID_AZIENDA := pIdAzienda;
            recTAziendaEfa.DATA_INIZIO_VALIDITA := SYSDATE;
            recTAziendaEfa.DATA_FINE_VALIDITA := NULL;
            recTAziendaEfa.DATA_AGGIORNAMENTO := SYSDATE;
            recTAziendaEfa.ID_UTENTE_AGGIORNAMENTO := pIdUtenteIride;
            recTAziendaEfa.ID_DICHIARAZIONE_CONSISTENZA := pIdDichCons;

            -- se ho storicizzato devo sicuramente inserire un nuovo record
            IF nRec > 0 THEN

               SELECT SEQ_DB_AZIENDA_EFA.nextval
                 INTO recTAziendaEfa.ID_AZIENDA_EFA
                 FROM DUAL;

               InsertTAziendaEfa (recTAziendaEfa);

            ELSE
               -- se non ho storicizzato posso
               -- updatare se l'efa c'è gia' per l'azienda
               recTAziendaEfaOld := SelTAziendaEfaByIdAziendaIdEfa (recTAziendaEfa.ID_AZIENDA,
                                                                    recTAziendaEfa.ID_TIPO_EFA);
               -- oppure devo inserire
               IF recTAziendaEfaOld.ID_AZIENDA_EFA IS NULL THEN
                   SELECT SEQ_DB_AZIENDA_EFA.nextval
                     INTO recTAziendaEfa.ID_AZIENDA_EFA
                     FROM DUAL;

                   InsertTAziendaEfa (recTAziendaEfa);
               ELSE

                   UPDATE DB_AZIENDA_EFA
                      SET VALORE_ORIGINALE = recTAziendaEfa.VALORE_ORIGINALE,
                          VALORE_DOPO_CONVERSIONE = recTAziendaEfa.VALORE_DOPO_CONVERSIONE,
                          VALORE_DOPO_PONDERAZIONE = recTAziendaEfa.VALORE_DOPO_PONDERAZIONE,
                          DATA_INIZIO_VALIDITA = recTAziendaEfa.DATA_INIZIO_VALIDITA,
                          DATA_AGGIORNAMENTO = recTAziendaEfa.DATA_AGGIORNAMENTO,
                          ID_UTENTE_AGGIORNAMENTO = recTAziendaEfa.ID_UTENTE_AGGIORNAMENTO,
                          ID_DICHIARAZIONE_CONSISTENZA = recTAziendaEfa.ID_DICHIARAZIONE_CONSISTENZA
                    WHERE ID_AZIENDA_EFA = recTAziendaEfaOld.ID_AZIENDA_EFA;

               END IF;

            END IF;

        END LOOP;

        -- cesso le efa non più presenti senza ID_DICHIARAZIONE_CONSISTENZA
        UPDATE DB_AZIENDA_EFA AE
           SET AE.DATA_FINE_VALIDITA = SYSDATE
         WHERE AE.ID_AZIENDA = pIdAzienda
           AND AE.ID_DICHIARAZIONE_CONSISTENZA IS NULL
           AND AE.DATA_FINE_VALIDITA IS NULL
           AND NOT EXISTS (SELECT UD.ID_TIPO_EFA
                             FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                                  DB_CONDUZIONE_DICHIARATA CD,
                                  DB_UTILIZZO_DICHIARATO UD
                            WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
                              AND DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
                              AND CD.ID_CONDUZIONE_DICHIARATA = UD.ID_CONDUZIONE_DICHIARATA
                              AND UD.ID_TIPO_EFA IS NOT NULL
                              AND UD.ID_TIPO_EFA = AE.ID_TIPO_EFA
                            UNION
                           SELECT UP.ID_TIPO_EFA
                             FROM DB_CONDUZIONE_PARTICELLA CP,
                                  DB_UTE UT,
                                  DB_UTILIZZO_PARTICELLA UP
                            WHERE UT.ID_AZIENDA = pIdAzienda
                              AND UT.ID_UTE = CP.ID_UTE
                              AND UT.DATA_FINE_ATTIVITA IS NULL
                              AND CP.DATA_FINE_CONDUZIONE IS NULL
                              AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
                              AND UP.ID_TIPO_EFA IS NOT NULL
                              AND UP.ID_TIPO_EFA = AE.ID_TIPO_EFA
                              AND pIdDichCons IS NULL);

        pRisultato := '0';
        pMessaggio := NULL;


    EXCEPTION
        WHEN PARAMETRI_ASSENTI THEN
             pRisultato := '1';
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'Errore PL/SQL non gestito : ' || SUBSTR(SQLERRM,1,200);
    END Calcola_Efa;

END Pck_Calcolo_Efa;

/
--------------------------------------------------------
--  DDL for Package Body PCK_CALCOLO_ESITO_GREENING
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_CALCOLO_ESITO_GREENING" AS
/*****************************************************************************
Package che espone tutte le function / stored procedure propedeutiche al
Calcolo dell'esito del greening
******************************************************************************/

    /*********************************************************************
    Dati un'id_azienda ed una tipologia di greening ricerca
    se c'è un record attivo su DB_AZIENDA_GREENING e lo restituisce in output
    Tipo: function
    input: pIdDichCons, pIdTipoGreen
    output: nessuno
    ritorno: DB_AZIENDA_GREENING%ROWTYPE
    *********************************************************************/
    FUNCTION SelTDichConsistenzaById (pIdDichCons IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE)
    RETURN DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE IS
        recTDichCons DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTDichCons
          FROM DB_DICHIARAZIONE_CONSISTENZA
         WHERE ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons;

        RETURN recTDichCons;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTDichConsistenzaById;


    /*********************************************************************
    Dati un'id_azienda ed una tipologia di greening ricerca
    se c'è un record attivo su DB_AZIENDA_GREENING e lo restituisce in output
    Tipo: function
    input: pIdDichCons, pIdTipoGreen
    output: nessuno
    ritorno: DB_AZIENDA_GREENING%ROWTYPE
    *********************************************************************/
    FUNCTION SelTAziendaGreenByDcTipoGreen (pIdDichCons     IN DB_AZIENDA_GREENING.ID_AZIENDA%TYPE,
                                            pIdTipoGreen    IN DB_AZIENDA_GREENING.ID_TIPO_GREENING%TYPE
                                            ) RETURN DB_AZIENDA_GREENING%ROWTYPE IS
        recTAzGreening DB_AZIENDA_GREENING%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTAzGreening
          FROM DB_AZIENDA_GREENING
         WHERE ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
           AND ID_TIPO_GREENING = pIdTipoGreen;

        RETURN recTAzGreening;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTAziendaGreenByDcTipoGreen;

    /*********************************************************************
    Dato un ID_AZIENDA ricerca il totale di superficie a seminativo
    escludendo le particelle biologiche
    Tipo: function
    input: pIdAzienda
    output:  nessuno
    ritorno: DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE
    *********************************************************************/
    FUNCTION SelTotSeminativoByIdAzFlBio (pIdAzienda    IN DB_UTE.ID_AZIENDA%TYPE,
                                          pEscludiBio   IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE)
    RETURN DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE IS
        nTotSupSem DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
    BEGIN

        SELECT NVL(SUM(UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE),0)
          INTO nTotSupSem
          FROM DB_CONDUZIONE_PARTICELLA CP,
               DB_UTE UT,
               DB_UTILIZZO_PARTICELLA UP,DB_R_CATALOGO_MATRICE CM
         WHERE UT.ID_AZIENDA = pIdAzienda
           AND UT.ID_UTE = CP.ID_UTE
           AND UT.DATA_FINE_ATTIVITA IS NULL
           AND CP.DATA_FINE_CONDUZIONE IS NULL
           AND UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
           AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND CM.FLAG_SEMINATIVO IN ('A', 'S') 
           --AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
           --AND UP.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO
           --AND TDU.FLAG_SEMINATIVO IN ('A', 'S') 
           AND (pEscludiBio = 'N' OR
               (pEscludiBio = 'S'  AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                                     FROM DB_PARTICELLA_BIO PB
                                                    WHERE PB.ID_PARTICELLA = CP.ID_PARTICELLA
                                                      AND PB.ID_AZIENDA = pIdAzienda
                                                      AND (PB.SUP_BIOLOGICO > 0 OR
                                                           PB.SUP_IN_CONVERSIONE > 0) 
                                                      AND PB.DATA_FINE_VALIDITA IS NULL)));

        RETURN nTotSupSem;

    END SelTotSeminativoByIdAzFlBio;

    /*********************************************************************
    Dato un ID_AZIENDA ricerca il totale di superficie a seminativo
    escludendo le particelle biologiche
    Tipo: function
    input: pIdAzienda
    output:  nessuno
    ritorno: DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE
    *********************************************************************/
    FUNCTION SelTotSeminativoNoBioByIdDich (pIdDichCons IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                            pEscludiBio IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE)
    RETURN DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE IS
        nTotSupSem DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
    BEGIN

        SELECT NVL(SUM(UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE),0)
          INTO nTotSupSem
          FROM DB_DICHIARAZIONE_CONSISTENZA DC,
               DB_CONDUZIONE_DICHIARATA CP,
               DB_UTILIZZO_DICHIARATO UP,DB_R_CATALOGO_MATRICE CM
         WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
           AND DC.CODICE_FOTOGRAFIA_TERRENI = CP.CODICE_FOTOGRAFIA_TERRENI
           AND UP.ID_CONDUZIONE_DICHIARATA = CP.ID_CONDUZIONE_DICHIARATA
           AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND CM.FLAG_SEMINATIVO IN ('A', 'S') 
           AND (pEscludiBio = 'N' OR
               (pEscludiBio = 'S' AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                                    FROM DB_PARTICELLA_BIO PB
                                                   WHERE PB.ID_PARTICELLA = CP.ID_PARTICELLA
                                                     AND PB.ID_AZIENDA = DC.ID_AZIENDA
                                                     AND DC.DATA BETWEEN PB.DATA_INIZIO_VALIDITA AND NVL(PB.DATA_FINE_VALIDITA, DC.DATA)
                                                     AND (PB.SUP_BIOLOGICO > 0 OR PB.SUP_IN_CONVERSIONE > 0))));

        RETURN nTotSupSem;

    END SelTotSeminativoNoBioByIdDich;

    /*********************************************************************
    Dato un ID_AZIENDA ricerca il totale di superficie a seminativo
    escludendo le particelle biologiche
    Tipo: function
    input: pCodFotoTerreni
    output:  nessuno
    ritorno: DB_UTILIZZO_DICHIARATO.SUPERFICIE_UTILIZZATA%TYPE
    *********************************************************************/
    FUNCTION SelTotSeminativByCodFoto (pCodFotoTerreni IN DB_CONDUZIONE_DICHIARATA.CODICE_FOTOGRAFIA_TERRENI%TYPE)
    RETURN DB_UTILIZZO_DICHIARATO.SUPERFICIE_UTILIZZATA%TYPE IS
        nTotSupSem DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
    BEGIN

        SELECT NVL(SUM(UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE),0)
          INTO nTotSupSem
          FROM DB_CONDUZIONE_DICHIARATA CP,
               DB_UTILIZZO_DICHIARATO UP,DB_R_CATALOGO_MATRICE CM
         WHERE CP.CODICE_FOTOGRAFIA_TERRENI = pCodFotoTerreni
           AND UP.ID_CONDUZIONE_DICHIARATA = CP.ID_CONDUZIONE_DICHIARATA
           AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND CM.FLAG_SEMINATIVO = 'S'; 


        RETURN nTotSupSem;

    END SelTotSeminativByCodFoto;

    /*********************************************************************
    Inserisce un record di tipo DB_AZIENDA_GREENING_ESONERO
    sulla tabella omonima
    Tipo: procedure
    input: pRecTAziendaGreeningEsonero
    output:  nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InserTAziendaGreeningEsonero (pRecTAziendaGreeningEsonero IN DB_AZIENDA_GREENING_ESONERO%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_AZIENDA_GREENING_ESONERO
            (
            ID_AZIENDA_GREENING_ESONERO,
            ID_AZIENDA_GREENING,
            ID_TIPO_ESONERO_GREENING
            )
        VALUES
            (
            pRecTAziendaGreeningEsonero.ID_AZIENDA_GREENING_ESONERO,
            pRecTAziendaGreeningEsonero.ID_AZIENDA_GREENING,
            pRecTAziendaGreeningEsonero.ID_TIPO_ESONERO_GREENING
            );
    END InserTAziendaGreeningEsonero;

    /*********************************************************************
    Inserisce un record di tipo DB_AZIENDA_GREENING
    sulla tabella omonima
    Tipo: procedure
    input: pRecTAziendaGreening
    output:  nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTAziendaGreening (pRecTAziendaGreening IN DB_AZIENDA_GREENING%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_AZIENDA_GREENING
            (
            ID_AZIENDA_GREENING,
            ID_AZIENDA,
            ID_TIPO_GREENING,
            ID_ESITO_GREENING,
            TIPO_VALORE_CALCOLATO,
            VALORE_CALCOLATO_NUMBER,
            VALORE_CALCOLATO_VARCHAR2,
            VALORE_CALCOLATO_DATE,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA,
            DATA_AGGIORNAMENTO,
            ID_UTENTE_AGGIORNAMENTO,
            ID_DICHIARAZIONE_CONSISTENZA,
            NOTE,
            SUPERFICIE_SEMINATIVO,
            ID_PROCEDIMENTO,
            EXT_ID_PRATICA
            )
        VALUES
            (
            pRecTAziendaGreening.ID_AZIENDA_GREENING,
            pRecTAziendaGreening.ID_AZIENDA,
            pRecTAziendaGreening.ID_TIPO_GREENING,
            pRecTAziendaGreening.ID_ESITO_GREENING,
            pRecTAziendaGreening.TIPO_VALORE_CALCOLATO,
            pRecTAziendaGreening.VALORE_CALCOLATO_NUMBER,
            pRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2,
            pRecTAziendaGreening.VALORE_CALCOLATO_DATE,
            pRecTAziendaGreening.DATA_INIZIO_VALIDITA,
            pRecTAziendaGreening.DATA_FINE_VALIDITA,
            pRecTAziendaGreening.DATA_AGGIORNAMENTO,
            pRecTAziendaGreening.ID_UTENTE_AGGIORNAMENTO,
            pRecTAziendaGreening.ID_DICHIARAZIONE_CONSISTENZA,
            pRecTAziendaGreening.NOTE,
            pRecTAziendaGreening.SUPERFICIE_SEMINATIVO,
            pRecTAziendaGreening.ID_PROCEDIMENTO,
            pRecTAziendaGreening.EXT_ID_PRATICA
            );
    END InsertTAziendaGreening;

    /*********************************************************************
    Aggiorna a SYSDATE la data fine validita del record di DB_AZIENDA_GREENING
    trovato per primary key
    sulla tabella omonima
    Tipo: procedure
    input: pIdAziendaGreening
    output:  nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE StoricizzaAziendaGreening (pIdAziendaGreening IN DB_AZIENDA_GREENING.ID_AZIENDA_GREENING%TYPE) IS
    BEGIN

        UPDATE DB_AZIENDA_GREENING
           SET DATA_FINE_VALIDITA = SYSDATE
         WHERE ID_AZIENDA_GREENING = pIdAziendaGreening;

    END StoricizzaAziendaGreening;

    /*********************************************************************
    Seleziona la tipologia di esonero valida per il codice dato in input
    e ne restituisce il ROWTYPE
    Tipo: function
    input: pCodTipoEsonero
    output:  nessuno
    ritorno: DB_TIPO_ESONERO_GREENING%ROWTYPE
    *********************************************************************/
    FUNCTION SelDTipoEsoneroGreeningByCod (pCodTipoEsonero IN DB_TIPO_ESONERO_GREENING.CODICE_TIPO_ESONERO%TYPE)
    RETURN DB_TIPO_ESONERO_GREENING%ROWTYPE IS
        recTipoEsonero DB_TIPO_ESONERO_GREENING%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTipoEsonero
          FROM DB_TIPO_ESONERO_GREENING
         WHERE CODICE_TIPO_ESONERO = pCodTipoEsonero
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recTipoEsonero;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
              RETURN recTipoEsonero;
    END SelDTipoEsoneroGreeningByCod;

    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    mantenimento prati permanenti
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE MPP (pIdAzienda     IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                   pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                   pRisultato    OUT VARCHAR2,
                   pMessaggio    OUT VARCHAR2) IS
        nNumRec         INTEGER:=0;
        nNumCp          INTEGER:=0;
        nNumCpUtP       INTEGER:=0;
        nNumCpUtNoP     INTEGER:=0;
        nNumCpUtNoPD    INTEGER:=0;
        recDTipoEsGreen DB_TIPO_ESONERO_GREENING%ROWTYPE;
    BEGIN

        -- conto le conduzioni di particelle dove
        -- esiste una particella a prato permanente
        -- su DB_ESITO_PASCOLO_MAGRO
        SELECT COUNT(CP.ID_CONDUZIONE_PARTICELLA)
          INTO nNumRec
          FROM DB_CONDUZIONE_PARTICELLA CP,
               DB_UTE UT
         WHERE UT.ID_AZIENDA = pIdAzienda
           AND UT.ID_UTE = CP.ID_UTE
           AND UT.DATA_FINE_ATTIVITA IS NULL
           AND CP.DATA_FINE_CONDUZIONE IS NULL
           AND EXISTS (SELECT EPM.ID_ESITO_PASCOLO_MAGRO
                         FROM DB_PARTICELLA_CERTIFICATA PC,
                              DB_ESITO_PASCOLO_MAGRO EPM
                        WHERE PC.ID_PARTICELLA = CP.ID_PARTICELLA
                          AND PC.DATA_FINE_VALIDITA IS NULL
                          AND PC.ID_PARTICELLA_CERTIFICATA = EPM.ID_PARTICELLA_CERTIFICATA
                          AND EPM.ID_FONTE = knIdFontePratoPermanente
                          AND EPM.DATA_FINE_VALIDITA IS NULL
                          );
        -- se ne trovo almeno una
        IF nNumRec > 0 THEN

            -- conto il numero conduzione particelle che sono presenti su db_esisto_pascolo_magro per fonte prato permanente
            -- il numero di conduzioni particella che hanno almeno un utilizzo a prato permanente
            -- il numero di conduzioni particella che  hanno almeno un utilizzo non a prato permanente
            -- il numero di conduzioni particella associate ad un documento di deroga mantenimento prati
            SELECT COUNT(DISTINCT(CP.ID_CONDUZIONE_PARTICELLA)),
                   COUNT(DISTINCT(DECODE(CM.FLAG_PRATO_PERMANENTE,'S', UP.ID_CONDUZIONE_PARTICELLA))), 
                   COUNT(DISTINCT(DECODE(CM.FLAG_PRATO_PERMANENTE,'S', NULL, UP.ID_CONDUZIONE_PARTICELLA))), 
                   COUNT(DISTINCT(DOCON.ID_CONDUZIONE_PARTICELLA))
              INTO nNumCp,
                   nNumCpUtP,
                   nNumCpUtNoP,
                   nNumCpUtNoPD
              FROM DB_CONDUZIONE_PARTICELLA CP,
                   DB_UTE UT,
                   DB_UTILIZZO_PARTICELLA UP,DB_R_CATALOGO_MATRICE CM,
                  (
                   SELECT DC.ID_CONDUZIONE_PARTICELLA
                     FROM DB_DOCUMENTO D,
                          DB_DOCUMENTO_CONDUZIONE DC
                    WHERE D.EXT_ID_DOCUMENTO = knIdTipoDocDerogaMantenimPrati
                      AND D.ID_AZIENDA = pIdAzienda
                      AND D.ID_STATO_DOCUMENTO IS NULL
                      AND SYSDATE BETWEEN D.DATA_INIZIO_VALIDITA AND NVL(D.DATA_FINE_VALIDITA,SYSDATE)
                      AND D.ID_DOCUMENTO = DC.ID_DOCUMENTO
                      AND SYSDATE BETWEEN DC.DATA_INIZIO_VALIDITA AND NVL(DC.DATA_FINE_VALIDITA,SYSDATE)) DOCON
             WHERE UT.ID_AZIENDA = pIdAzienda
               AND UT.ID_UTE = CP.ID_UTE
               AND UT.DATA_FINE_ATTIVITA IS NULL
               AND CP.DATA_FINE_CONDUZIONE IS NULL
               AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
               AND CP.ID_CONDUZIONE_PARTICELLA = DOCON.ID_CONDUZIONE_PARTICELLA (+)
               AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
               AND EXISTS (SELECT EPM.ID_ESITO_PASCOLO_MAGRO
                             FROM DB_PARTICELLA_CERTIFICATA PC,
                                  DB_ESITO_PASCOLO_MAGRO EPM
                            WHERE PC.ID_PARTICELLA = CP.ID_PARTICELLA
                              AND PC.DATA_FINE_VALIDITA IS NULL
                              AND PC.ID_PARTICELLA_CERTIFICATA = EPM.ID_PARTICELLA_CERTIFICATA
                              AND EPM.ID_FONTE = knIdFontePratoPermanente
                              AND EPM.DATA_FINE_VALIDITA IS NULL
                              );

           -- se il numero di conduzioni con particella presente su DB_ESISTO_PASCOLO_MAGRO con fonte prato permanente
           -- coincide con li numero di conduzione con almeno un utilizzo a prato permanente sono a posto
           IF nNumCp = nNumCpUtP THEN
              glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningRispettato;
              glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
              glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Mantenimento prati effettuato su tutte le particelle del registro prati permanenti';
           ELSE
              -- altrimenti se coincide con li numero di conduzione con utilizzo non a prato permanente
              -- ma con ogni conduzione con associato il documento di deroga sono a posto ugualmente
              IF nNumCp = nNumCpUtNoP AND nNumCp = nNumCpUtNoPD THEN
                  glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningRispettato;
                  glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                  glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Uso del suolo modificato previa autorizzazione AGEA';
              ELSE
                  -- altrimenti guardo se ci sono situazioni parziali
                  -- ovvero se il numero di conduzione con particella su DB_ESITO_PASCOLO_MAGRO per fonte prato permanete
                  -- coincide con la somma delle conduzioni con almeno un utilizzo a prato permanente +
                  -- conduzione senza utilizza a prato permanete ma con documento di deroga
                  -- se si sono comunque a posto
                  IF nNumCp = (nNumCpUtP + nNumCpUtNoP) AND (nNumCpUtNoP = nNumCpUtNoPD) THEN
                     glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningRispettato;
                     glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                     glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Mantenimento prati effettuato su alcune particelle del registro prati permanenti ed uso del suolo modificato previa autorizzazione AGEA sulle altre';
                  ELSE
                     -- altrimenti sono anomalo
                     -- o parzialmente
                     IF nNumCpUtP + nNumCpUtNoPD > 0 THEN
                        glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningRispParzPP;
                        glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                        glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Mantenimento prati effettuato parzialmente e/o assenza autorizzazione AGEA su alcuni usi del suolo modificati';
                     ELSE
                        -- o totalmente
                        glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningNonRispettato;
                        glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                     END IF;
                  END IF;
              END IF;

           END IF;

        ELSE
           -- se l'azienda non ha particelle che ricadono nel registro prato permanete
           -- e' esente
           glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningEsente;
           glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
           glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
           SELECT SEQ_DB_AZIENDA_GREENING_ESON.nextval
             INTO glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING_ESONERO
             FROM DUAL;

           recDTipoEsGreen := SelDTipoEsoneroGreeningByCod (kvCodTipoEsoneroNoPratiPerm);

           glVetEsoneriAzGreening(1).ID_TIPO_ESONERO_GREENING := recDTipoEsGreen.ID_TIPO_ESONERO_GREENING;
           glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;
        END IF;

        pRisultato := '0';

    EXCEPTION
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'Errore pl/sql in procedure MPP : ' || SUBSTR(SQLERRM,1,150);
    END MPP;

    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    presenza di area ecologiche (Ecologic Focus Area)
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE EFA (pIdAzienda     IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                   pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                   pRisultato    OUT VARCHAR2,
                   pMessaggio    OUT VARCHAR2) IS

        nTotSupSem      DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nTotSupNoBio    DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nTotSupDiv      DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        recDTipoEsGreen DB_TIPO_ESONERO_GREENING%ROWTYPE;
        nTotSupEfa      DB_AZIENDA_EFA.VALORE_DOPO_PONDERAZIONE%TYPE;
        nPercCalc       NUMBER;
        nPercDiv        DB_TIPO_GREENING.PERC_RISPETTO%TYPE;
        bEsonera        BOOLEAN:=FALSE;
    BEGIN
        -- controllo se l'azienda ha superfici a seminativo
        nTotSupSem := SelTotSeminativoByIdAzFlBio (pIdAzienda,
                                                   pEscludiBio);

        -- se si
        IF nTotSupSem > 0 THEN
            -- se la superficie a seminativo supera una certa soglia (15ha)
            IF nTotSupSem >= glRecDTipoGreening.VALORE_DA_CUI_APPLICARE THEN

                -- guardo se per caso l'azienda puo' essere esonerata dalla
                -- verifica delle EFA
                -- controllo se ha più del 75% di prato foraggera , terreno a riposo o leguminose
                -- rispetto al totale a seminativo
                SELECT NVL(SUM(DECODE(CM.FLAG_SEMINATIVO,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE)),0) +
                       NVL(SUM(DECODE(CM.FLAG_SEMINATIVO,'A',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE)),0), 
                       NVL(SUM(
                       DECODE(CM.FLAG_PRATO_FORAGGERA,'S', UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,
                       DECODE(CM.FLAG_RIPOSO,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,
                       DECODE(CM.FLAG_LEGUMINOSA,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,0)))),0)
                  INTO nTotSupSem,
                       nTotSupDiv
                  FROM DB_CONDUZIONE_PARTICELLA CP,
                       DB_UTE UT,
                       DB_UTILIZZO_PARTICELLA UP,DB_R_CATALOGO_MATRICE CM
                 WHERE UT.ID_AZIENDA = pIdAzienda
                   AND UT.ID_UTE = CP.ID_UTE
                   AND UT.DATA_FINE_ATTIVITA IS NULL
                   AND CP.DATA_FINE_CONDUZIONE IS NULL
                   AND UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
                   AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
                   AND (pEscludiBio = 'N' OR (
                        pEscludiBio = 'S' AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                                            FROM DB_PARTICELLA_BIO PB
                                                           WHERE PB.ID_PARTICELLA = CP.ID_PARTICELLA
                                                             AND PB.ID_AZIENDA = pIdAzienda
                                                             AND (PB.SUP_BIOLOGICO > 0 OR
                                                                  PB.SUP_IN_CONVERSIONE > 0) 
                                                             AND PB.DATA_FINE_VALIDITA IS NULL)));

                -- se la differenza tra totale a seminativo e riposo + prato + leguminose e' inferiore ai 30ha
                IF nTotSupSem - nTotSupDiv <= knEttMaxDifSeminativoUsiVari THEN
                   -- calcolo la percentuale
                   nPercDiv := (nTotSupDiv * 100) /  nTotSupSem;
                   -- se e' di prato + riposo + leguminose rispetto al totale
                   -- se essa' e' maggiore del 75
                   IF nPercDiv >= knPercMinRispettoAltriUsiSem THEN
                      -- sono esonerato
                      bEsonera := TRUE;
                      glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningEsente;
                      glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                      glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                      glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;

                      SELECT SEQ_DB_AZIENDA_GREENING_ESON.nextval
                        INTO glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING_ESONERO
                        FROM DUAL;
                      recDTipoEsGreen := SelDTipoEsoneroGreeningByCod (kvCodTipoEsonero75PratoRipLeg);
                      glVetEsoneriAzGreening(1).ID_TIPO_ESONERO_GREENING := recDTipoEsGreen.ID_TIPO_ESONERO_GREENING;
                      glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;
                   END IF;
                END IF;
                -- se non sono esonerato
                IF NOT bEsonera THEN
                    -- controllo
                    -- se per caso ho le esonero per colture sommerse + prati + prati permanenti
                    -- somma la superficie totale dell'azienda escludendo
                    -- le coltura non ammissibili EFA
                    -- sommo il prato  , sommo le colture sommerse , sommo i prati permanenti
                    SELECT NVL(SUM(DECODE(CM.FLAG_NON_AMMISSIBILE_EFA,'S',0,UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE)),0),
                           NVL(SUM(
                           DECODE(CM.FLAG_PRATO_FORAGGERA,'S', UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,
                           DECODE(CM.FLAG_COLTURA_SOMMERSA,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,
                           DECODE(CM.FLAG_PRATO_PERMANENTE,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,
                           DECODE(CM.FLAG_PRATO_PERMANENTE,'A',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,0))))),0) 
                      INTO nTotSupNoBio,
                           nTotSupDiv
                      FROM DB_CONDUZIONE_PARTICELLA CP,
                           DB_UTE UT,
                           DB_UTILIZZO_PARTICELLA UP,DB_R_CATALOGO_MATRICE CM
                     WHERE UT.ID_AZIENDA = pIdAzienda
                       AND UT.ID_UTE = CP.ID_UTE
                       AND UT.DATA_FINE_ATTIVITA IS NULL
                       AND CP.DATA_FINE_CONDUZIONE IS NULL
                       AND UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
                       AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
                       AND (pEscludiBio = 'N' OR (
                            pEscludiBio = 'S' AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                                                FROM DB_PARTICELLA_BIO PB
                                                               WHERE PB.ID_PARTICELLA = CP.ID_PARTICELLA
                                                                 AND PB.ID_AZIENDA = pIdAzienda
                                                                 AND (PB.SUP_BIOLOGICO > 0 OR
                                                                      PB.SUP_IN_CONVERSIONE > 0) 
                                                                 AND PB.DATA_FINE_VALIDITA IS NULL)));

                    -- se il totla della superficie non bio -
                    -- il totale di colture sommerse + prati + prati permanenti
                    -- e' minore di 30 ha
                    IF nTotSupSem - nTotSupDiv <= knEttMaxDifSeminativoUsiVari THEN
                       -- se la percentuale di colture sommerse + prati + prati permanenti
                       -- e' maggiore del 75% della superficie aziendale non biologica
                       -- sono esonerato
                       nPercDiv := (nTotSupDiv * 100) /  nTotSupNoBio;
                       IF nPercDiv >= knPercMinRispettoAltriUsiSem THEN
                          bEsonera := TRUE;

                          glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningEsente;
                          glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                          glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                          glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                          SELECT SEQ_DB_AZIENDA_GREENING_ESON.nextval
                            INTO glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING_ESONERO
                            FROM DUAL;
                          recDTipoEsGreen := SelDTipoEsoneroGreeningByCod (kvCodTipoEsonero75PrSomPrPerm);
                          glVetEsoneriAzGreening(1).ID_TIPO_ESONERO_GREENING := recDTipoEsGreen.ID_TIPO_ESONERO_GREENING;
                          glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;

                       END IF;
                    END IF;
                END IF;
                -- altrimenti devo verificare le efa
                IF NOT bEsonera THEN

                    -- verifico se ha delle aree ecologiche
                    SELECT NVL(SUM(VALORE_DOPO_PONDERAZIONE),0)
                      INTO nTotSupEfa
                      FROM DB_AZIENDA_EFA
                     WHERE ID_AZIENDA = pIdAzienda
                       AND DATA_FINE_VALIDITA IS NULL;

                    -- per almeno un tot per cento della superficie che ha a seminativo
                    nPercCalc := (nTotSupEfa * 100) / nTotSupSem;
                    -- se si
                    IF nPercCalc >= glRecDTipoGreening.PERC_RISPETTO THEN
                       -- il tipo di greening EFA e' rispettato
                       glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningRispettato;
                       glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                       glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                       glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Superficie totale EFA : ' || TRIM(TO_CHAR(nTotSupEfa,'999G990D9999')) || ' ha a fronte di un seminativo totale di : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' ha';
                    ELSE
                       -- altrimenti non e' rispettato
                       glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningNonRispettato;
                       glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                       glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                       glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Superficie totale EFA : ' || TRIM(TO_CHAR(nTotSupEfa,'999G990D9999')) || ' ha a fronte di un seminativo totale di : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' ha';
                    END IF;
                END IF;
            ELSE
                -- se l'azienda ha meno di un tot di ettari (15ha) a seminativo e' esente
                glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningEsente;
                glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                SELECT SEQ_DB_AZIENDA_GREENING_ESON.nextval
                  INTO glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING_ESONERO
                  FROM DUAL;
                recDTipoEsGreen := SelDTipoEsoneroGreeningByCod (kvCodTipoEsoneroEttariMin15);
                glVetEsoneriAzGreening(1).ID_TIPO_ESONERO_GREENING := recDTipoEsGreen.ID_TIPO_ESONERO_GREENING;
                glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;
            END IF;
        ELSE
           -- se l'azienda non ha particella a seminativo e' esente
           glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningEsente;
           glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
           glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
           glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
           SELECT SEQ_DB_AZIENDA_GREENING_ESON.nextval
             INTO glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING_ESONERO
             FROM DUAL;
           recDTipoEsGreen := SelDTipoEsoneroGreeningByCod (kvCodTipoEsoneroNoSeminativo);
           glVetEsoneriAzGreening(1).ID_TIPO_ESONERO_GREENING := recDTipoEsGreen.ID_TIPO_ESONERO_GREENING;
           glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;
        END IF;

        pRisultato := '0';

    EXCEPTION
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'Errore pl/sql in procedure EFA - ESCLUDI_BIO = ' || pEscludiBio || ' : ' || SUBSTR(SQLERRM,1,150);
    END EFA;

    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    presenza di area ecologiche (Ecologic Focus Area)
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE EFA_VAL (pIdDichCons    IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                       pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                       pRisultato    OUT VARCHAR2,
                       pMessaggio    OUT VARCHAR2) IS

        nTotSupSem      DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nTotSupNoBio    DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nTotSupDiv      DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        recDTipoEsGreen DB_TIPO_ESONERO_GREENING%ROWTYPE;
        nTotSupEfa      DB_AZIENDA_EFA.VALORE_DOPO_PONDERAZIONE%TYPE;
        nPercCalc       NUMBER;
        nPercDiv        DB_TIPO_GREENING.PERC_RISPETTO%TYPE;
        bEsonera        BOOLEAN:=FALSE;
    BEGIN
        -- controllo se l'azienda ha superfici a seminativo
        nTotSupSem := SelTotSeminativoNoBioByIdDich (pIdDichCons,
                                                     pEscludiBio);

        -- se si
        IF nTotSupSem > 0 THEN
            -- se la superficie a seminativo supera una certa soglia (15ha)
            IF nTotSupSem >= glRecDTipoGreening.VALORE_DA_CUI_APPLICARE THEN

                -- guardo se per caso l'azienda puo' essere esonerata dalla
                -- verifica delle EFA
                -- controllo se ha più del 75% di prato foraggera , terreno a riposo o leguminose
                -- rispetto al totale a seminativo
                SELECT NVL(SUM(DECODE(CM.FLAG_SEMINATIVO,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE)),0) +
                       NVL(SUM(DECODE(CM.FLAG_SEMINATIVO,'A',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE)),0), 
                       NVL(SUM(
                       DECODE(CM.FLAG_PRATO_FORAGGERA,'S', UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,
                       DECODE(CM.FLAG_RIPOSO,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,
                       DECODE(CM.FLAG_LEGUMINOSA,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,0)))),0)
                  INTO nTotSupSem,
                       nTotSupDiv
                  FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                       DB_CONDUZIONE_DICHIARATA CD,
                       DB_UTILIZZO_DICHIARATO UP,DB_R_CATALOGO_MATRICE CM
                 WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
                   AND DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
                   AND UP.ID_CONDUZIONE_DICHIARATA = CD.ID_CONDUZIONE_DICHIARATA
                   AND CM.ID_CATALOGO_MATRICE = UP.ID_CATALOGO_MATRICE 
                   AND (pEscludiBio = 'N' OR
                       (pEscludiBio = 'S' AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                                            FROM DB_PARTICELLA_BIO PB
                                                           WHERE PB.ID_PARTICELLA = CD.ID_PARTICELLA
                                                             AND PB.ID_AZIENDA = DC.ID_AZIENDA
                                                             AND DC.DATA BETWEEN PB.DATA_INIZIO_VALIDITA AND NVL(PB.DATA_FINE_VALIDITA, DC.DATA)
                                                             AND (PB.SUP_BIOLOGICO > 0 OR PB.SUP_IN_CONVERSIONE > 0))));

                -- se la differenza tra totale a seminativo e riposo + prato + leguminose e' inferiore ai 30ha
                IF nTotSupSem - nTotSupDiv <= knEttMaxDifSeminativoUsiVari THEN
                   -- calcolo la percentuale
                   nPercDiv := (nTotSupDiv * 100) /  nTotSupSem;
                   -- se e' di prato + riposo + leguminose rispetto al totale
                   -- se essa' e' maggiore del 75
                   IF nPercDiv >= knPercMinRispettoAltriUsiSem THEN
                      -- sono esonerato
                      bEsonera := TRUE;
                      glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningEsente;
                      glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                      glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                      glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;

                      SELECT SEQ_DB_AZIENDA_GREENING_ESON.nextval
                        INTO glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING_ESONERO
                        FROM DUAL;
                      recDTipoEsGreen := SelDTipoEsoneroGreeningByCod (kvCodTipoEsonero75PratoRipLeg);
                      glVetEsoneriAzGreening(1).ID_TIPO_ESONERO_GREENING := recDTipoEsGreen.ID_TIPO_ESONERO_GREENING;
                      glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;
                   END IF;
                END IF;
                -- se non sono esonerato
                IF NOT bEsonera THEN
                    -- controllo
                    -- se per caso ho le esonero per colture sommerse + prati + prati permanenti
                    -- somma la superficie totale dell'azienda escludendo
                    -- le coltura non ammissibili EFA
                    -- sommo il prato  , sommo le colture sommerse , sommo i prati permanenti
                    SELECT NVL(SUM(DECODE(CM.FLAG_NON_AMMISSIBILE_EFA,'S',0,UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE)),0),
                           NVL(SUM(
                           DECODE(CM.FLAG_PRATO_FORAGGERA,'S', UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,
                           DECODE(CM.FLAG_COLTURA_SOMMERSA,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,
                           DECODE(CM.FLAG_PRATO_PERMANENTE,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,
                           DECODE(CM.FLAG_PRATO_PERMANENTE,'A',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,0))))),0) 
                      INTO nTotSupNoBio,
                           nTotSupDiv
                      FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                           DB_CONDUZIONE_DICHIARATA CP,
                           DB_UTILIZZO_DICHIARATO UP,DB_R_CATALOGO_MATRICE CM
                     WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
                       AND DC.CODICE_FOTOGRAFIA_TERRENI = CP.CODICE_FOTOGRAFIA_TERRENI
                       AND CP.ID_CONDUZIONE_DICHIARATA = UP.ID_CONDUZIONE_DICHIARATA
                       AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
                       AND (pEscludiBio = 'N' OR
                           (pEscludiBio = 'S' AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                                                FROM DB_PARTICELLA_BIO PB
                                                               WHERE PB.ID_PARTICELLA = CP.ID_PARTICELLA
                                                                 AND PB.ID_AZIENDA = DC.ID_AZIENDA
                                                                 AND DC.DATA BETWEEN PB.DATA_INIZIO_VALIDITA AND NVL(PB.DATA_FINE_VALIDITA, DC.DATA)
                                                                 AND (PB.SUP_BIOLOGICO > 0 OR PB.SUP_IN_CONVERSIONE > 0))));

                    -- se il totla della superficie non bio -
                    -- il totale di colture sommerse + prati + prati permanenti
                    -- e' minore di 30 ha
                    IF nTotSupSem - nTotSupDiv <= knEttMaxDifSeminativoUsiVari THEN
                       -- se la percentuale di colture sommerse + prati + prati permanenti
                       -- e' maggiore del 75% della superficie aziendale non biologica
                       -- sono esonerato
                       nPercDiv := (nTotSupDiv * 100) /  nTotSupNoBio;
                       IF nPercDiv >= knPercMinRispettoAltriUsiSem THEN
                          bEsonera := TRUE;

                          glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningEsente;
                          glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                          glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                          glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                          SELECT SEQ_DB_AZIENDA_GREENING_ESON.nextval
                            INTO glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING_ESONERO
                            FROM DUAL;
                          recDTipoEsGreen := SelDTipoEsoneroGreeningByCod (kvCodTipoEsonero75PrSomPrPerm);
                          glVetEsoneriAzGreening(1).ID_TIPO_ESONERO_GREENING := recDTipoEsGreen.ID_TIPO_ESONERO_GREENING;
                          glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;

                       END IF;
                    END IF;
                END IF;
                -- altrimenti devo verificare le efa
                IF NOT bEsonera THEN

                    -- verifico se ha delle aree ecologiche
                    SELECT NVL(SUM(VALORE_DOPO_PONDERAZIONE),0)
                      INTO nTotSupEfa
                      FROM DB_AZIENDA_EFA
                     WHERE ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons;
                       -- AND DATA_FINE_VALIDITA IS NULL;

                    -- per almeno un tot per cento della superficie che ha a seminativo
                    nPercCalc := (nTotSupEfa * 100) / nTotSupSem;
                    -- se si
                    IF nPercCalc >= glRecDTipoGreening.PERC_RISPETTO THEN
                       -- il tipo di greening EFA e' rispettato
                       glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningRispettato;
                       glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                       glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                       glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Superficie totale EFA : ' || TRIM(TO_CHAR(nTotSupEfa,'999G990D9999')) || ' ha a fronte di un seminativo totale di : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' ha';
                    ELSE
                       -- altrimenti non e' rispettato
                       glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningNonRispettato;
                       glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                       glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                       glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Superficie totale EFA : ' || TRIM(TO_CHAR(nTotSupEfa,'999G990D9999')) || ' ha a fronte di un seminativo totale di : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' ha';
                    END IF;
                END IF;
            ELSE
                -- se l'azienda ha meno di un tot di ettari (15ha) a seminativo e' esente
                glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningEsente;
                glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                SELECT SEQ_DB_AZIENDA_GREENING_ESON.nextval
                  INTO glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING_ESONERO
                  FROM DUAL;
                recDTipoEsGreen := SelDTipoEsoneroGreeningByCod (kvCodTipoEsoneroEttariMin15);
                glVetEsoneriAzGreening(1).ID_TIPO_ESONERO_GREENING := recDTipoEsGreen.ID_TIPO_ESONERO_GREENING;
                glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;
            END IF;
        ELSE
           -- se l'azienda non ha particella a seminativo e' esente
           glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningEsente;
           glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
           glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
           glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
           SELECT SEQ_DB_AZIENDA_GREENING_ESON.nextval
             INTO glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING_ESONERO
             FROM DUAL;
           recDTipoEsGreen := SelDTipoEsoneroGreeningByCod (kvCodTipoEsoneroNoSeminativo);
           glVetEsoneriAzGreening(1).ID_TIPO_ESONERO_GREENING := recDTipoEsGreen.ID_TIPO_ESONERO_GREENING;
           glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;
        END IF;

        pRisultato := '0';

    EXCEPTION
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'Errore pl/sql in procedure EFA_VAL - ESCLUDI_BIO = ' || pEscludiBio || ' : ' || SUBSTR(SQLERRM,1,150);
    END EFA_VAL;



    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    presenza di area ecologiche (Ecologic Focus Area)
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE EFA_CB (pIdAzienda     IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                      pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                      pRisultato    OUT VARCHAR2,
                      pMessaggio    OUT VARCHAR2) IS
    BEGIN

        EFA (pIdAzienda,
             pEscludiBio,
             pRisultato,
             pMessaggio);

    END EFA_CB;


    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    presenza di area ecologiche (Ecologic Focus Area)
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE EFA_VAL_CB (pIdDichCons    IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                          pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                          pRisultato    OUT VARCHAR2,
                          pMessaggio    OUT VARCHAR2) IS
    BEGIN

        EFA_VAL (pIdDichCons,
                 pEscludiBio,
                 pRisultato,
                 pMessaggio);

    END EFA_VAL_CB;


    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    azienda biologica
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE BIO (pIdAzienda     IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                   pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                   pRisultato    OUT VARCHAR2,
                   pMessaggio    OUT VARCHAR2) IS
        nNumRec     INTEGER:=0;
        nTotSupSau  DB_CONDUZIONE_PARTICELLA.SUPERFICIE_CONDOTTA%TYPE;
        nTotSupBio  DB_PARTICELLA_BIO.SUP_BIOLOGICO%TYPE;
    BEGIN
        -- verifico se l'azienda ha particella presenti su pratiche
        -- del biologico con superficie biologica > 0
        SELECT COUNT(CP.ID_CONDUZIONE_PARTICELLA)
          INTO nNumRec
          FROM DB_CONDUZIONE_PARTICELLA CP,
               DB_UTE UT
         WHERE UT.ID_AZIENDA = pIdAzienda
           AND UT.ID_UTE = CP.ID_UTE
           AND UT.DATA_FINE_ATTIVITA IS NULL
           AND CP.DATA_FINE_CONDUZIONE IS NULL
           AND EXISTS (SELECT UP.ID_UTILIZZO_PARTICELLA
                         FROM DB_UTILIZZO_PARTICELLA UP,
                              DB_R_CATALOGO_MATRICE CM
                        WHERE CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
                          AND CM.ID_CATALOGO_MATRICE = UP.ID_CATALOGO_MATRICE 
                          AND CM.FLAG_SAU = 'S'); 


        IF nNumRec = 0 THEN
           glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningNAPP;
           glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
           glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Azienda priva di particelle SAU';
        ELSE

            SELECT COUNT(CP.ID_CONDUZIONE_PARTICELLA)
              INTO nNumRec
              FROM DB_CONDUZIONE_PARTICELLA CP,
                   DB_UTE UT
             WHERE UT.ID_AZIENDA = pIdAzienda
               AND UT.ID_UTE = CP.ID_UTE
               AND UT.DATA_FINE_ATTIVITA IS NULL
               AND CP.DATA_FINE_CONDUZIONE IS NULL
               AND EXISTS (SELECT PB.ID_PARTICELLA_BIO
                             FROM DB_PARTICELLA_BIO PB
                            WHERE PB.ID_PARTICELLA = CP.ID_PARTICELLA
                              AND PB.ID_AZIENDA = pIdAzienda
                              AND (PB.SUP_BIOLOGICO > 0 OR
                                   PB.SUP_IN_CONVERSIONE > 0) 
                              AND PB.DATA_FINE_VALIDITA IS NULL
                              );

            -- se si
            IF nNumRec > 0 THEN
               -- sommo la condotta delle particelle
               -- sommo la biologica delle particelle
               WITH PART_SOM AS (
               SELECT CP.ID_PARTICELLA,
                      SUM(UP.SUPERFICIE_UTILIZZATA) AS SUP_SOM
                 FROM DB_CONDUZIONE_PARTICELLA CP,
                      DB_UTILIZZO_PARTICELLA UP,
                      DB_UTE UT,
                      DB_R_CATALOGO_MATRICE CM
                WHERE UT.ID_AZIENDA = pIdAzienda
                  AND UT.ID_UTE = CP.ID_UTE
                  AND UT.DATA_FINE_ATTIVITA IS NULL
                  AND CP.DATA_FINE_CONDUZIONE IS NULL
                  AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
                  AND CM.ID_CATALOGO_MATRICE = UP.ID_CATALOGO_MATRICE 
                  AND CM.FLAG_SAU = 'S'  
             GROUP BY CP.ID_PARTICELLA
             )
             SELECT SUM(PS.SUP_SOM),
                    NVL(SUM(PB.SUP_BIOLOGICO + PB.SUP_IN_CONVERSIONE),0) 
               INTO nTotSupSau,
                    nTotSupBio
               FROM PART_SOM PS,
                    DB_PARTICELLA_BIO PB
              WHERE PS.ID_PARTICELLA = PB.ID_PARTICELLA (+)
                AND PB.ID_AZIENDA (+) = pIdAzienda
                AND PB.DATA_FINE_VALIDITA (+) IS NULL;

               -- se la biologica e' maggiore uguale della condatta
               IF nTotSupBio >= nTotSupSau THEN
                  -- vuol dire che tutte le particelle sono biologiche
                  -- il tipo greening e' verificato
                  glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningSi;
                  glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                  glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Tutte le particelle dell''azienda sono biologiche, per un totale di ettari : ' || TRIM(TO_CHAR(nTotSupSau, '999G990D9999'));
               ELSE
                  -- vuol dire che NON tutte le particelle sono biologiche
                  -- il tipo greening e' verificato solo parzialmente
                  glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningParziale;
                  glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                  glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Non tutte le particelle dell''azienda sono biologiche,  ettari biologici : ' || TRIM(TO_CHAR(nTotSupBio, '999G990D9999')) || ' a fronte di un totale di ettari SAU : ' || TRIM(TO_CHAR(nTotSupSau, '999G990D9999'));
               END IF;

            ELSE
               -- se no il tipo greening azienda biologica non e' vericato
               glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningNo;
               glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
               glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Azienda senza particelle biologiche';
            END IF;
        END IF;
        pRisultato := '0';

    EXCEPTION
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'Errore pl/sql in procedure BIO : ' || SUBSTR(SQLERRM,1,150);
    END BIO;


    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    azienda biologica
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE BIO_VAL (pIdDichCons    IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                       pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                       pRisultato    OUT VARCHAR2,
                       pMessaggio    OUT VARCHAR2) IS
        nNumRec     INTEGER:=0;
        nTotSupSau  DB_CONDUZIONE_PARTICELLA.SUPERFICIE_CONDOTTA%TYPE;
        nTotSupBio  DB_PARTICELLA_BIO.SUP_BIOLOGICO%TYPE;
    BEGIN
        -- verifico se l'azienda ha particella superficie SAU alla validazione
        SELECT COUNT(CP.ID_CONDUZIONE_PARTICELLA)
          INTO nNumRec
          FROM DB_DICHIARAZIONE_CONSISTENZA DC,
               DB_CONDUZIONE_DICHIARATA CP
         WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
           AND DC.CODICE_FOTOGRAFIA_TERRENI = CP.CODICE_FOTOGRAFIA_TERRENI
           AND EXISTS (SELECT UP.ID_UTILIZZO_DICHIARATO
                         FROM DB_UTILIZZO_DICHIARATO UP,
                              DB_R_CATALOGO_MATRICE CM
                        WHERE CP.ID_CONDUZIONE_DICHIARATA = UP.ID_CONDUZIONE_DICHIARATA
                          AND CM.ID_CATALOGO_MATRICE = UP.ID_CATALOGO_MATRICE 
                          AND CM.FLAG_SAU = 'S'); 


        IF nNumRec = 0 THEN
           glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningNAPP;
           glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
           glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Azienda priva di particelle SAU';
        ELSE

            -- verifico se l'azienda ha particella presenti su pratiche
            -- del biologico con superficie biologica > 0
            SELECT COUNT(CP.ID_CONDUZIONE_DICHIARATA)
              INTO nNumRec
              FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                   DB_CONDUZIONE_DICHIARATA CP
             WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
               AND DC.CODICE_FOTOGRAFIA_TERRENI = CP.CODICE_FOTOGRAFIA_TERRENI
               AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                 FROM DB_PARTICELLA_BIO PB
                                WHERE PB.ID_PARTICELLA = CP.ID_PARTICELLA
                                  AND PB.ID_AZIENDA = DC.ID_AZIENDA
                                  AND DC.DATA BETWEEN PB.DATA_INIZIO_VALIDITA AND NVL(PB.DATA_FINE_VALIDITA, DC.DATA)
                                  AND (PB.SUP_BIOLOGICO > 0 OR PB.SUP_IN_CONVERSIONE > 0));

            -- se si
            IF nNumRec > 0 THEN
               -- sommo la condotta delle particelle
               -- sommo la biologica delle particelle
               WITH PART_SOM AS (
               SELECT DC.ID_AZIENDA,
                      DC.DATA,
                      CP.ID_PARTICELLA,
                      SUM(UP.SUPERFICIE_UTILIZZATA) AS SUP_SOM
                 FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                      DB_CONDUZIONE_DICHIARATA CP,
                      DB_UTILIZZO_DICHIARATO UP,
                      DB_R_CATALOGO_MATRICE CM
                WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
                  AND DC.CODICE_FOTOGRAFIA_TERRENI = CP.CODICE_FOTOGRAFIA_TERRENI
                  AND CP.ID_CONDUZIONE_DICHIARATA = UP.ID_CONDUZIONE_DICHIARATA
                  AND CM.ID_CATALOGO_MATRICE = UP.ID_CATALOGO_MATRICE 
                  AND CM.FLAG_SAU = 'S' 
             GROUP BY CP.ID_PARTICELLA, DC.ID_AZIENDA, DC.DATA
             )
             SELECT SUM(PS.SUP_SOM),
                    NVL(SUM(PB.SUP_BIOLOGICO + PB.SUP_IN_CONVERSIONE),0) 
               INTO nTotSupSau,
                    nTotSupBio
               FROM PART_SOM PS,
                    DB_PARTICELLA_BIO PB
              WHERE PS.ID_PARTICELLA = PB.ID_PARTICELLA (+)
                AND PB.ID_AZIENDA (+) = PS.ID_AZIENDA
                AND PB.DATA_INIZIO_VALIDITA (+) <= PS.DATA
                AND NVL(PB.DATA_FINE_VALIDITA (+),PS.DATA)  >= PS.DATA ;

               -- se la biologica e' maggiore uguale della condatta
               IF nTotSupBio >= nTotSupSau THEN
                  -- vuol dire che tutte le particelle sono biologiche
                  -- il tipo greening e' verificato
                  glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningSi;
                  glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                  glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Tutte le particelle dell''azienda sono biologiche, per un totale di ettari : ' || TRIM(TO_CHAR(nTotSupSau, '999G990D9999'));
               ELSE
                  -- vuol dire che NON tutte le particelle sono biologiche
                  -- il tipo greening e' verificato solo parzialmente
                  glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningParziale;
                  glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                  glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Non tutte le particelle dell''azienda sono biologiche,  ettari biologici : ' || TRIM(TO_CHAR(nTotSupBio, '999G990D9999')) || ' a fronte di un totale di ettari SAU : ' || TRIM(TO_CHAR(nTotSupSau, '999G990D9999'));
               END IF;

            ELSE
               -- se no il tipo greening azienda biologica non e' vericato
               glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningNo;
               glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
               glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Azienda senza particelle biologiche';
            END IF;
        END IF;
        pRisultato := '0';

    EXCEPTION
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'Errore pl/sql in procedure BIO_VAL : ' || SUBSTR(SQLERRM,1,150);
    END BIO_VAL;

    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    DIVERSIFICAZIONE
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE DIV (pIdAzienda     IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                   pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                   pRisultato    OUT VARCHAR2,
                   pMessaggio    OUT VARCHAR2) IS

        nTotSupSem          DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nTotSupSemSom       DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        recDTipoEsGreen     DB_TIPO_ESONERO_GREENING%ROWTYPE;
        nTotSupSemNoBio     DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nTotSupDiv          DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nPercDiv            NUMBER(5,2);
        bEsonera            BOOLEAN:=FALSE;
        bParziale           BOOLEAN:=FALSE;
        nNumGruppiDiv       INTEGER:=0;
        nMaxSupSem          DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nSommaSupGruppi     DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE:=0;
        nCont               INTEGER:=0;
        vAnomalo            VARCHAR2(10);
        bTrattato           BOOLEAN:=FALSE;
        nSupSemDivParC1     DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nSupSemDivParC2     DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        vCriterioCreativo   VARCHAR2(1);
        nTotSupFora         DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nTotSupRiposo       DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        vPrincipale         VARCHAR2(1);
        nAltraSup           DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nAltraSupNoRipNoFor DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        --nIdTipoSpGen        DB_TIPO_SPECIE.ID_TIPO_SPECIE%TYPE;
        --vCodTipoSpGen       DB_TIPO_SPECIE.CODICE%TYPE;
        vTipoDiv            DB_R_CATALOGO_MATRICE.CODICE_DIVERSIFICAZIONE%TYPE;
        nIdTipoPerSem       DB_TIPO_PERIODO_SEMINA.ID_TIPO_PERIODO_SEMINA%TYPE;
        nTotSup             DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;


        CURSOR curSupPerGruppoTpPerSemina (pCriterioCreativo IN VARCHAR2) IS
        SELECT NVL(SUM(UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE),0) AS TOT_UTILIZZATO,
               CM.ID_TIPO_SPECIE AS ID_SPECIE,
               TS.DESCRIZIONE AS DESC_SPECIE,
               --TG.TIPO_DIVERSIFICAZIONE,
               UP.ID_TIPO_PERIODO_SEMINA,
               TPS.DESCRIZIONE
          FROM DB_CONDUZIONE_PARTICELLA CP,
               DB_UTE UT,
               DB_UTILIZZO_PARTICELLA UP,
               --DB_TIPO_UTILIZZO TU,
               DB_TIPO_SPECIE TS,
               /*DB_TIPO_GENERE TG,
               DB_TIPO_FAMIGLIA TF,
               DB_TIPO_VARIETA TV,
               DB_TIPO_DETTAGLIO_USO TDU,*/
               DB_TIPO_PERIODO_SEMINA TPS,DB_R_CATALOGO_MATRICE CM
         WHERE UT.ID_AZIENDA = pIdAzienda
           AND UT.ID_UTE = CP.ID_UTE
           AND UT.DATA_FINE_ATTIVITA IS NULL
           AND CP.DATA_FINE_CONDUZIONE IS NULL
           AND UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
           --AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
           --AND UP.ID_VARIETA = TV.ID_VARIETA
           AND UP.ID_TIPO_PERIODO_SEMINA = TPS.ID_TIPO_PERIODO_SEMINA 
           AND CM.ID_TIPO_SPECIE = TS.ID_TIPO_SPECIE
           --AND UP.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO 
           AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND CM.FLAG_SEMINATIVO = 'S'
           AND CM.SOGGETTO_A_DIVERSIFICAZIONE = 'S'  
           --AND TS.ID_TIPO_GENERE = TG.ID_TIPO_GENERE
           --AND TG.ID_TIPO_FAMIGLIA = TF.ID_TIPO_FAMIGLIA
           AND (pEscludiBio = 'N' OR
               (pEscludiBio = 'S' AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                                    FROM DB_PARTICELLA_BIO PB
                                                   WHERE PB.ID_PARTICELLA = CP.ID_PARTICELLA
                                                     AND PB.ID_AZIENDA = pIdAzienda
                                                     AND (PB.SUP_BIOLOGICO > 0 OR
                                                          PB.SUP_IN_CONVERSIONE > 0) 
                                                     AND PB.DATA_FINE_VALIDITA IS NULL)))
           AND ((pCriterioCreativo IS NULL) OR
                (pCriterioCreativo = 'R' AND CM.FLAG_PRATO_FORAGGERA = 'N'
                                         AND CM.FLAG_RIPOSO = 'N') OR
                (pCriterioCreativo = 'S' AND CM.FLAG_PRATO_FORAGGERA = 'N'
                                         AND CM.FLAG_COLTURA_SOMMERSA = 'N'
                                         AND CM.FLAG_PRATO_PERMANENTE = 'N'))
      GROUP BY CM.ID_TIPO_SPECIE,
       TS.DESCRIZIONE,
               --TG.TIPO_DIVERSIFICAZIONE,
               UP.ID_TIPO_PERIODO_SEMINA,
               TPS.DESCRIZIONE
      ORDER BY NVL(SUM(UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE),0) DESC;


    BEGIN

        -- controllo se l'azienda ha superfici a seminativo
        SELECT NVL(SUM(UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE),0),
               NVL(SUM(DECODE(CM.FLAG_COLTURA_SOMMERSA,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE)),0),
               COUNT(DISTINCT(CM.CODICE_DIVERSIFICAZIONE))  
               /*COUNT(DISTINCT(DECODE(TG.TIPO_DIVERSIFICAZIONE,'S',TU.ID_TIPO_SPECIE + UP.ID_TIPO_PERIODO_SEMINA))) +
               COUNT(DISTINCT(DECODE(TG.TIPO_DIVERSIFICAZIONE,'G',TS.ID_TIPO_GENERE + UP.ID_TIPO_PERIODO_SEMINA)))*/
               /*COUNT(DISTINCT(UP.ID_TIPO_PERIODO_SEMINA)) AS NUM_GRUPPI*/ 
          INTO nTotSupSem,    -- totale seminativo
               nTotSupSemSom, -- totale seminativo con coltura sommersa
               nNumGruppiDiv
          FROM DB_CONDUZIONE_PARTICELLA CP,
               DB_UTE UT,
               DB_UTILIZZO_PARTICELLA UP,
               /*DB_TIPO_UTILIZZO TU,
               DB_TIPO_VARIETA TV,
               DB_TIPO_SPECIE TS,
               DB_TIPO_GENERE TG,
               DB_TIPO_DETTAGLIO_USO TDU,*/DB_R_CATALOGO_MATRICE CM
         WHERE UT.ID_AZIENDA = pIdAzienda
           AND UT.ID_UTE = CP.ID_UTE
           AND UT.DATA_FINE_ATTIVITA IS NULL
           AND CP.DATA_FINE_CONDUZIONE IS NULL
           AND UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
           /*AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
           AND UP.ID_VARIETA = TV.ID_VARIETA
           AND UP.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO
           AND TU.ID_TIPO_SPECIE = TS.ID_TIPO_SPECIE
           AND TS.ID_TIPO_GENERE = TG.ID_TIPO_GENERE*/
           AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND CM.FLAG_SEMINATIVO = 'S' 
           AND CM.SOGGETTO_A_DIVERSIFICAZIONE = 'S'  
           AND (pEscludiBio = 'N' OR
               (pEscludiBio = 'S' AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                                    FROM DB_PARTICELLA_BIO PB
                                                   WHERE PB.ID_PARTICELLA = CP.ID_PARTICELLA
                                                     AND PB.ID_AZIENDA = pIdAzienda
                                                     AND (PB.SUP_BIOLOGICO > 0 OR
                                                          PB.SUP_IN_CONVERSIONE > 0) 
                                                     AND PB.DATA_FINE_VALIDITA IS NULL)));

        -- se la superficie a seminativo supera una certa soglia (10ha)
        IF nTotSupSem >= glRecDTipoGreening.VALORE_DA_CUI_APPLICARE THEN
            -- se il seminativo e' tutto sommerso
            IF nTotSupSem = nTotSupSemSom THEN

                bEsonera := TRUE;

                glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningEsente;
                glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                SELECT SEQ_DB_AZIENDA_GREENING_ESON.nextval
                  INTO glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING_ESONERO
                  FROM DUAL;
                recDTipoEsGreen := SelDTipoEsoneroGreeningByCod (kvCodTipoEsoneroSoloRiso);
                glVetEsoneriAzGreening(1).ID_TIPO_ESONERO_GREENING := recDTipoEsGreen.ID_TIPO_ESONERO_GREENING;
                glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;
            ELSE

                SELECT NVL(SUM(DECODE(CM.FLAG_SEMINATIVO,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE)),0),
                       NVL(SUM(DECODE(CM.FLAG_PRATO_FORAGGERA,'S', UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE)),0),
                       NVL(SUM(DECODE(CM.FLAG_RIPOSO,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE)),0)
                  INTO nTotSupSemNoBio,
                       nTotSupFora,
                       nTotSupRiposo
                  FROM DB_CONDUZIONE_PARTICELLA CP,
                       DB_UTE UT,
                       DB_UTILIZZO_PARTICELLA UP,
                       /*DB_TIPO_UTILIZZO TU,
                       DB_TIPO_VARIETA TV,
                       DB_TIPO_DETTAGLIO_USO TDU,*/DB_R_CATALOGO_MATRICE CM
                 WHERE UT.ID_AZIENDA = pIdAzienda
                   AND UT.ID_UTE = CP.ID_UTE
                   AND UT.DATA_FINE_ATTIVITA IS NULL
                   AND CP.DATA_FINE_CONDUZIONE IS NULL
                   AND UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
                   /*AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
                   AND UP.ID_VARIETA = TV.ID_VARIETA
                   AND UP.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO*/
                   AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
                   AND CM.SOGGETTO_A_DIVERSIFICAZIONE = 'S'  
                   AND (pEscludiBio = 'N' OR
                       (pEscludiBio = 'S' AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                                            FROM DB_PARTICELLA_BIO PB
                                                           WHERE PB.ID_PARTICELLA = CP.ID_PARTICELLA
                                                             AND PB.ID_AZIENDA = pIdAzienda
                                                             AND (PB.SUP_BIOLOGICO > 0 OR
                                                                  PB.SUP_IN_CONVERSIONE > 0) 
                                                             AND PB.DATA_FINE_VALIDITA IS NULL)));

                nTotSupDiv := nTotSupFora + nTotSupRiposo;

                -- calcolo la percentuale a prescindere
                nPercDiv := (nTotSupDiv * 100) /  nTotSupSemNoBio;

                -- se la differenza tra totale a seminativo e riposo + prato + leguminose e' inferiore ai 30ha
                IF nTotSupSemNoBio - nTotSupDiv <= knEttMaxDifSeminativoUsiVari THEN
                   -- calcolo la percentuale
                   -- nPercDiv := (nTotSupDiv * 100) /  nTotSupSemNoBio;

                   -- se e' di prato + riposo + leguminose rispetto al totale
                   -- se essa' e' maggiore del 75
                   IF nPercDiv >= knPercMinRispettoAltriUsiSem THEN
                      -- sono esonerato
                      bEsonera := TRUE;
                      glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningEsente;
                      glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                      glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                      glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                      SELECT SEQ_DB_AZIENDA_GREENING_ESON.nextval
                        INTO glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING_ESONERO
                        FROM DUAL;
                      recDTipoEsGreen := SelDTipoEsoneroGreeningByCod (kvCodTipoEsonero75PratoRip);
                      glVetEsoneriAzGreening(1).ID_TIPO_ESONERO_GREENING := recDTipoEsGreen.ID_TIPO_ESONERO_GREENING;
                      glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;
                   END IF;
                ELSE
                   -- se rispetta la percentuale ma non rispetta la differenza
                   -- di 30 ha diciamo che e' esente parzile
                   IF nPercDiv >= knPercMinRispettoAltriUsiSem THEN
                      -- ovvero deve fare la diversificazione solo sul rimanente
                      -- (interpretazione folkloristica della normativa)
                      bParziale := TRUE;
                      -- superificie eccedente i 30 ha su cui devo diversificare
                      nSupSemDivParC1 := nTotSupSemNoBio - nTotSupDiv;
                   END IF;
                END IF;

                -- se non sono esonerato
                IF NOT bEsonera THEN
                    -- controllo
                    -- se per caso ho le esonero per colture sommerse + prati + prati permanenti
                    -- somma la superficie totale dell'azienda escludendo
                    -- le coltura non ammissibili EFA
                    -- sommo il prato  , sommo le colture sommerse , sommo i prati permanenti
                    SELECT NVL(SUM(DECODE(CM.FLAG_NON_AMMISSIBILE_EFA,'S',0,UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE)),0),
                           NVL(SUM(
                           DECODE(CM.FLAG_PRATO_FORAGGERA,'S', UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,
                           DECODE(CM.FLAG_COLTURA_SOMMERSA,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,
                           DECODE(CM.FLAG_PRATO_PERMANENTE,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,0)))),0)
                      INTO nTotSupSemNoBio,
                           nTotSupDiv
                      FROM DB_CONDUZIONE_PARTICELLA CP,
                           DB_UTE UT,
                           DB_UTILIZZO_PARTICELLA UP,
                           /*DB_TIPO_UTILIZZO TU,
                           DB_TIPO_VARIETA TV,
                           DB_TIPO_DETTAGLIO_USO VDU,*/DB_R_CATALOGO_MATRICE CM
                     WHERE UT.ID_AZIENDA = pIdAzienda
                       AND UT.ID_UTE = CP.ID_UTE
                       AND UT.DATA_FINE_ATTIVITA IS NULL
                       AND CP.DATA_FINE_CONDUZIONE IS NULL
                       AND UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
                      /* AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
                       AND UP.ID_VARIETA = TV.ID_VARIETA
                       AND UP.ID_TIPO_DETTAGLIO_USO = VDU.ID_TIPO_DETTAGLIO_USO*/
                       AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
                       AND CM.SOGGETTO_A_DIVERSIFICAZIONE = 'S'  
                       AND (pEscludiBio = 'N' OR
                           (pEscludiBio = 'S' AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                                                FROM DB_PARTICELLA_BIO PB
                                                               WHERE PB.ID_PARTICELLA = CP.ID_PARTICELLA
                                                                 AND PB.ID_AZIENDA = pIdAzienda
                                                                 AND (PB.SUP_BIOLOGICO > 0 OR
                                                                      PB.SUP_IN_CONVERSIONE > 0) 
                                                                 AND PB.DATA_FINE_VALIDITA IS NULL)));

                    -- calcolo la percentuale a prescindere
                    nPercDiv := (nTotSupDiv * 100) /  nTotSupSemNoBio;

                    -- se il totale della superficie non bio -
                    -- il totale di colture sommerse + prati + prati permanenti
                    -- e' minore di 30 ha
                    IF nTotSupSem - nTotSupDiv <= knEttMaxDifSeminativoUsiVari THEN
                       -- se la percentuale di colture sommerse + prati + prati permanenti
                       -- e' maggiore del 75% della superficie aziendale non biologica
                       -- sono esonerato

                       -- nPercDiv := (nTotSupDiv * 100) /  nTotSupSemNoBio;

                       IF nPercDiv >= knPercMinRispettoAltriUsiSem THEN
                          bEsonera := TRUE;

                          glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningEsente;
                          glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                          glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                          glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                          SELECT SEQ_DB_AZIENDA_GREENING_ESON.nextval
                            INTO glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING_ESONERO
                            FROM DUAL;
                          recDTipoEsGreen := SelDTipoEsoneroGreeningByCod (kvCodTipoEsonero75PrSomPrPerm);
                          glVetEsoneriAzGreening(1).ID_TIPO_ESONERO_GREENING := recDTipoEsGreen.ID_TIPO_ESONERO_GREENING;
                          glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;

                       END IF;
                    ELSE
                       IF nPercDiv >= knPercMinRispettoAltriUsiSem THEN
                          --bParziale := TRUE; dal 2016 l'eccedente di 30 ettari non viene controllato
                          nSupSemDivParC2 := nTotSupSemNoBio - nTotSupDiv;
                       END IF;
                    END IF;
                END IF;

            END IF;

            -- se non ho esoneri faccio la verifica vera e propria della
            -- diversificazione
            IF NOT bEsonera THEN
                IF nNumGruppiDiv > 1 THEN

                    -- se sono in caso di esonero parziale
                    IF bParziale THEN
                       -- cerco di capire qual'e' il criterio
                       -- che ha portato all'esonero parziale
                       IF nSupSemDivParC1 IS NULL THEN
                             nTotSupSem := nSupSemDivParC2;
                             vCriterioCreativo := 'S';
                          ELSE
                              -- in caso lo abbiano potenzialmente generato entrambi i
                              -- criteri di esonero sia quello per foraggerre + riposo
                              -- che quello di prati permanenti + colture sommerse + foraggere
                              -- prendo quello che supera per meno i 30ha come
                              -- differenza col seminativo totale (ovvero il più piccolo)
                              IF nSupSemDivParC2 > nSupSemDivParC1 THEN
                                 nTotSupSem := nSupSemDivParC1;
                                 vCriterioCreativo := 'R';
                              ELSE
                                 nTotSupSem := nSupSemDivParC2;
                                 vCriterioCreativo := 'S';
                              END IF;
                       END IF;

                       -- i gruppi diversificazione
                       -- solo sulle colture che non fanno parte dei criteri
                       SELECT COUNT(DISTINCT(CM.CODICE_DIVERSIFICAZIONE))
                         INTO nNumGruppiDiv
                         FROM DB_CONDUZIONE_PARTICELLA CP,
                              DB_UTE UT,
                              DB_UTILIZZO_PARTICELLA UP,
                              /*DB_TIPO_UTILIZZO TU,
                              DB_TIPO_VARIETA TV,
                              DB_TIPO_SPECIE TS,
                              DB_TIPO_GENERE TG,
                              DB_TIPO_DETTAGLIO_USO TDU,*/DB_R_CATALOGO_MATRICE CM
                        WHERE UT.ID_AZIENDA = pIdAzienda
                          AND UT.ID_UTE = CP.ID_UTE
                          AND UT.DATA_FINE_ATTIVITA IS NULL
                          AND CP.DATA_FINE_CONDUZIONE IS NULL
                          AND UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
                          /*AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
                          AND UP.ID_VARIETA = TV.ID_VARIETA
                          AND UP.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO
                          AND TU.ID_TIPO_SPECIE = TS.ID_TIPO_SPECIE
                          AND TS.ID_TIPO_GENERE = TG.ID_TIPO_GENERE*/
                          AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
                          AND CM.FLAG_SEMINATIVO = 'S'
                          AND CM.SOGGETTO_A_DIVERSIFICAZIONE = 'S'  
                          AND ((vCriterioCreativo = 'R' AND
                                CM.FLAG_PRATO_FORAGGERA = 'N'
                                AND CM.FLAG_RIPOSO = 'N') OR
                              (vCriterioCreativo = 'S'
                                AND CM.FLAG_PRATO_FORAGGERA = 'N'
                                AND CM.FLAG_COLTURA_SOMMERSA = 'N'
                                AND CM.FLAG_PRATO_PERMANENTE = 'N'))
                          AND (pEscludiBio = 'N' OR
                              (pEscludiBio = 'S' AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                                                   FROM DB_PARTICELLA_BIO PB
                                                                  WHERE PB.ID_PARTICELLA = CP.ID_PARTICELLA
                                                                    AND PB.ID_AZIENDA = pIdAzienda
                                                                    AND (PB.SUP_BIOLOGICO > 0 OR
                                                                         PB.SUP_IN_CONVERSIONE > 0) 
                                                                    AND PB.DATA_FINE_VALIDITA IS NULL)));

                    ELSE
                       vCriterioCreativo := NULL;
                    END IF;

                    IF nTotSupSem > knEttariFinoDueColtureDic THEN
                       nCont := 3;
                    ELSE
                       nCont := 2;
                    END IF;

                    IF nNumGruppiDiv >= nCont THEN

                        -- gestione particolare per quando ho 75% di foraggere o riposo
                        -- (non sommati)
                        IF (nTotSupFora * 100) / nTotSupSem  > knPercMinRispettoAltriUsiSem THEN
                           vPrincipale := 'F';
                        END IF;

                        IF (nTotSupRiposo * 100) / nTotSupSem > knPercMinRispettoAltriUsiSem THEN
                           vPrincipale := 'R';
                        END IF;

                        IF vPrincipale IS NOT NULL THEN

                               SELECT CODICE_DIVERSIFICAZIONE,
                                           ID_TIPO_PERIODO_SEMINA,
                                           TOT_SUP
                                  INTO vTipoDiv,
                                         nIdTipoPerSem,
                                         nTotSup
                                 FROM (
                               SELECT /*DECODE(TG.TIPO_DIVERSIFICAZIONE,'S',TS.ID_TIPO_SPECIE,'G', TS.ID_TIPO_GENERE) ID_IGNOTO,
                                           DECODE(TG.TIPO_DIVERSIFICAZIONE,'S',TS.CODICE,'G', TG.CODICE) CODICE_IGNOTO,
                                           TG.TIPO_DIVERSIFICAZIONE,*/
                                           CM.CODICE_DIVERSIFICAZIONE,
                                           UP.ID_TIPO_PERIODO_SEMINA,
                                           NVL(SUM(UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE),0) AS TOT_SUP
                                 FROM DB_CONDUZIONE_PARTICELLA CP,
                                      DB_UTE UT,
                                      DB_UTILIZZO_PARTICELLA UP,
                                      /*DB_TIPO_UTILIZZO TU,
                                      DB_TIPO_VARIETA TV,
                                      DB_TIPO_SPECIE TS,
                                      DB_TIPO_GENERE TG,
                                      DB_TIPO_DETTAGLIO_USO TDU,*/DB_R_CATALOGO_MATRICE CM
                                WHERE UT.ID_AZIENDA = pIdAzienda
                                  AND UT.ID_UTE = CP.ID_UTE
                                  AND UT.DATA_FINE_ATTIVITA IS NULL
                                  AND CP.DATA_FINE_CONDUZIONE IS NULL
                                  AND UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
                                 /* AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
                                  AND UP.ID_VARIETA = TV.ID_VARIETA
                                  AND UP.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO
                                  AND TU.ID_TIPO_SPECIE = TS.ID_TIPO_SPECIE
                                  AND TS.ID_TIPO_GENERE = TG.ID_TIPO_GENERE*/
                                  AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
                                  AND cm.FLAG_SEMINATIVO = 'S'
                                  AND CM.SOGGETTO_A_DIVERSIFICAZIONE = 'S'  
                                  AND (vPrincipale = 'F' AND CM.FLAG_PRATO_FORAGGERA ='N' OR
                                       vPrincipale = 'R' AND CM.FLAG_RIPOSO = 'N')
                                  AND (pEscludiBio = 'N' OR
                                      (pEscludiBio = 'S' AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                                                           FROM DB_PARTICELLA_BIO PB
                                                                          WHERE PB.ID_PARTICELLA = CP.ID_PARTICELLA
                                                                            AND PB.ID_AZIENDA = pIdAzienda
                                                                            AND (PB.SUP_BIOLOGICO > 0 OR
                                                                                 PB.SUP_IN_CONVERSIONE > 0) 
                                                                            AND PB.DATA_FINE_VALIDITA IS NULL)))
                            GROUP BY CM.CODICE_DIVERSIFICAZIONE,
                                           UP.ID_TIPO_PERIODO_SEMINA
                             ORDER BY TOT_SUP DESC) WHERE ROWNUM = 1;

                             /*IF vTipoDiv = 'S' THEN
                                glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                                glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningRispettato;
                                glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                                glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                             ELSE*/
                                IF vPrincipale = 'F' THEN
                                   nPercDiv := nTotSup * 100 /  (nTotSupSem - nTotSupFora);
                                ELSE
                                   nPercDiv := (nTotSup * 100) / (nTotSupSem - nTotSupRiposo);
                                END IF;

                                IF nPercDiv > knPercMinRispettoAltriUsiSem THEN
                                   glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                                   glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningNonRispettato;
                                   glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                                   glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Azienda con seminativo non biologico totale : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' ha sulla quale non insistono ' || nCont || ' colture diverse';
                                ELSE
                                   glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                                   glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningRispettato;
                                   glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                                   glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                                --glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Azienda con seminativo non biologico totale : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' ha sulla quale non insistono ' || nCont || ' colture diverse';
                                END IF;
                            -- END IF;

                        ELSE
                            -- scorro i gruppi diversificazione / periodo semina
                            -- con superficie sommata ordinati per superficie decrescente
                            FOR recSupPerGruppoTpPerSemina IN curSupPerGruppoTpPerSemina (vCriterioCreativo) LOOP
                                nSommaSupGruppi := nSommaSupGruppi + recSupPerGruppoTpPerSemina.TOT_UTILIZZATO;
                                nPercDiv := (recSupPerGruppoTpPerSemina.TOT_UTILIZZATO * 100) / nTotSupSem;
                                IF nPercDiv > knPercMinRispettoAltriUsiSem THEN
                                   -- non serve guardare se e' sopra i 30ha di seminativo
                                   -- e' anomalo comunque
                                   -- IF nTotSupSem > knEttariFinoDueColtureDic THEN
                                      glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                                      glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningNonRispettato;
                                      glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                                      glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Azienda con seminativo non biologico totale : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' ha per cui la coltura principale (' || recSupPerGruppoTpPerSemina.DESC_SPECIE || ' - ' || recSupPerGruppoTpPerSemina.DESCRIZIONE || ') , con ettari : ' || TRIM(TO_CHAR(recSupPerGruppoTpPerSemina.TOT_UTILIZZATO, '999G990D9999')) || ' supera il 75% di seminativi';
                                      glRecTAziendaGreening.NOTE := 'Azienda con seminativo non biologico totale : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' ha per cui la coltura principale (' || recSupPerGruppoTpPerSemina.DESC_SPECIE || ' - ' || recSupPerGruppoTpPerSemina.DESCRIZIONE || ') , con ettari : ' || TRIM(TO_CHAR(recSupPerGruppoTpPerSemina.TOT_UTILIZZATO, '999G990D9999')) || ' supera il 75% di seminativi';
                                      bTrattato := TRUE;
                                      EXIT;
                                   -- ELSE
                                      /*
                                      IF nTotSupSem <= knEttariFinoDueColtureDic THEN
                                         glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                                         glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningRispettato;
                                         glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                                         glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                                         glRecTAziendaGreening.NOTE := NULL;
                                         bTrattato := TRUE;
                                         EXIT;
                                      END IF;*/
                                   -- END IF;

                                END IF;

                                nCont := nCont - 1;
                                -- coltura più grossa
                                IF nCont = 1 THEN
                                   EXIT;
                                END IF;
                            END LOOP;

                            IF NOT bTrattato THEN
                               nPercDiv := (nSommaSupGruppi * 100) / nTotSupSem;
                               IF nPercDiv > knPercMinRispettoAltriUsiTSem THEN
                                  glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                                  glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningNonRispettato;
                                  glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                                  glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Azienda con seminativo non biologico totale : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' ha per cui le due colture principali superano il 95% di seminativi';
                                  glRecTAziendaGreening.NOTE := 'Azienda con seminativo non biologico totale : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' ha per cui le due colture principali superano il 95% di seminativi';
                               ELSE
                                  glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                                  glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningRispettato;
                                  glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                                  glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                                  glRecTAziendaGreening.NOTE := NULL;
                               END IF;
                            END IF;
                        END IF;
                    ELSE
                        glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                        glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningNonRispettato;
                        glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                        glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Azienda con seminativo non biologico totale : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' ha sulla quale non insistono ' || nCont || ' colture diverse';
                    END IF;
                ELSE
                     glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                     glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningNonRispettato;
                     glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                     glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Azienda con seminativo non biologico totale : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' sulla quale non insistono due o piu'' colture diverse';
                     glRecTAziendaGreening.NOTE := 'Azienda con seminativo non biologico totale : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' sulla quale non insistono due o piu'' colture diverse';
                END IF;
            END IF;

        ELSE
            glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
            glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningEsente;
            glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
            glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
            SELECT SEQ_DB_AZIENDA_GREENING_ESON.nextval
              INTO glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING_ESONERO
              FROM DUAL;
            recDTipoEsGreen := SelDTipoEsoneroGreeningByCod (kvCodTipoEsoneroEttariMin10);
            glVetEsoneriAzGreening(1).ID_TIPO_ESONERO_GREENING := recDTipoEsGreen.ID_TIPO_ESONERO_GREENING;
            glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;
        END IF;

        pRisultato := '0';

    EXCEPTION
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'Errore pl/sql in procedure DIV - ESCLUDI_BIO = ' || pEscludiBio || ' : ' || SUBSTR(SQLERRM,1,150)||' riga = '||dbms_utility.FORMAT_ERROR_BACKTRACE;
    END DIV;

    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    DIVERSIFICAZIONE
    Tipo: function
    input: pCodFoto
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE DIV_VAL (pIdDichCons    IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                       pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                       pRisultato    OUT VARCHAR2,
                       pMessaggio    OUT VARCHAR2) IS

        nTotSupSem          DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nTotSupSemSom       DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        recDTipoEsGreen     DB_TIPO_ESONERO_GREENING%ROWTYPE;
        nTotSupSemNoBio     DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nTotSupDiv          DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nPercDiv            NUMBER(5,2);
        bEsonera            BOOLEAN:=FALSE;
        bParziale           BOOLEAN:=FALSE;
        nNumGruppiDiv       INTEGER:=0;
        nMaxSupSem          DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nSommaSupGruppi     DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE:=0;
        nCont               INTEGER:=0;
        vAnomalo            VARCHAR2(10);
        bTrattato           BOOLEAN:=FALSE;
        nSupSemDivParC1     DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nSupSemDivParC2     DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        vCriterioCreativo   VARCHAR2(1);
        nTotSupFora         DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nTotSupRiposo       DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        vPrincipale         VARCHAR2(1);
        nAltraSup           DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nAltraSupNoRipNoFor DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nIdTipoSpGen        DB_TIPO_SPECIE.ID_TIPO_SPECIE%TYPE;
        vCodTipoSpGen       DB_TIPO_SPECIE.CODICE%TYPE;
        vTipoDiv            DB_TIPO_GENERE.TIPO_DIVERSIFICAZIONE%TYPE;
        nIdTipoPerSem       DB_TIPO_PERIODO_SEMINA.ID_TIPO_PERIODO_SEMINA%TYPE;
        nTotSup             DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;


        CURSOR curSupPerGruppoTpPerSemina (pCriterioCreativo IN VARCHAR2) IS
        SELECT NVL(SUM(UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE),0) AS TOT_UTILIZZATO,
               CM.ID_TIPO_SPECIE AS ID_SPECIE,
               TS.DESCRIZIONE AS DESC_SPECIE,
               UP.ID_TIPO_PERIODO_SEMINA,
               TPS.DESCRIZIONE
          FROM DB_CONDUZIONE_DICHIARATA CP,
               DB_DICHIARAZIONE_CONSISTENZA DC,
               DB_UTILIZZO_DICHIARATO UP,
               --DB_TIPO_UTILIZZO TU,
               DB_TIPO_SPECIE TS,
               /*DB_TIPO_GENERE TG,
               DB_TIPO_FAMIGLIA TF,
               DB_TIPO_VARIETA TV,
               DB_TIPO_DETTAGLIO_USO TDU,*/
               DB_TIPO_PERIODO_SEMINA TPS,DB_R_CATALOGO_MATRICE CM
         WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
           AND CP.CODICE_FOTOGRAFIA_TERRENI = DC.CODICE_FOTOGRAFIA_TERRENI
           AND UP.ID_CONDUZIONE_DICHIARATA = CP.ID_CONDUZIONE_DICHIARATA
           --AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
           --AND UP.ID_VARIETA = TV.ID_VARIETA
           AND UP.ID_TIPO_PERIODO_SEMINA = TPS.ID_TIPO_PERIODO_SEMINA 
           AND CM.ID_TIPO_SPECIE = TS.ID_TIPO_SPECIE
           AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           --AND UP.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO 
           AND CM.FLAG_SEMINATIVO = 'S'  
           AND CM.SOGGETTO_A_DIVERSIFICAZIONE = 'S'  
           --AND TS.ID_TIPO_GENERE = TG.ID_TIPO_GENERE
           --AND TG.ID_TIPO_FAMIGLIA = TF.ID_TIPO_FAMIGLIA
           AND (pEscludiBio = 'N' OR
               (pEscludiBio = 'S' AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                                    FROM DB_PARTICELLA_BIO PB
                                                   WHERE PB.ID_PARTICELLA = CP.ID_PARTICELLA
                                                     AND PB.ID_AZIENDA = DC.ID_AZIENDA
                                                     AND DC.DATA BETWEEN PB.DATA_INIZIO_VALIDITA AND NVL(PB.DATA_FINE_VALIDITA, DC.DATA)
                                                     AND (PB.SUP_BIOLOGICO > 0 OR PB.SUP_IN_CONVERSIONE > 0)))) 
           AND ((pCriterioCreativo IS NULL) OR
                (pCriterioCreativo = 'R' AND CM.FLAG_PRATO_FORAGGERA = 'N'
                                         AND CM.FLAG_RIPOSO = 'N') OR
                (pCriterioCreativo = 'S' AND CM.FLAG_PRATO_FORAGGERA = 'N'
                                         AND CM.FLAG_COLTURA_SOMMERSA = 'N'
                                         AND CM.FLAG_PRATO_PERMANENTE = 'N'))
      GROUP BY CM.ID_TIPO_SPECIE,
       TPS.DESCRIZIONE,
               --TG.TIPO_DIVERSIFICAZIONE,
               UP.ID_TIPO_PERIODO_SEMINA,
               TPS.DESCRIZIONE
      ORDER BY NVL(SUM(UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE),0) DESC;


    BEGIN

        -- controllo se l'azienda ha superfici a seminativo
        SELECT NVL(SUM(UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE),0),
               NVL(SUM(DECODE(CM.FLAG_COLTURA_SOMMERSA,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE)),0),
               COUNT(DISTINCT(CM.CODICE_DIVERSIFICAZIONE))  
          INTO nTotSupSem,
               nTotSupSemSom,
               nNumGruppiDiv
          FROM DB_DICHIARAZIONE_CONSISTENZA DC,
               DB_CONDUZIONE_DICHIARATA CP,
               DB_UTILIZZO_DICHIARATO UP,
               /*DB_TIPO_UTILIZZO TU,
               DB_TIPO_VARIETA TV,
               DB_TIPO_SPECIE TS,
               DB_TIPO_GENERE TG,
               DB_TIPO_DETTAGLIO_USO TDU*/ DB_R_CATALOGO_MATRICE CM
         WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
           AND DC.CODICE_FOTOGRAFIA_TERRENI = CP.CODICE_FOTOGRAFIA_TERRENI
           AND UP.ID_CONDUZIONE_DICHIARATA = CP.ID_CONDUZIONE_DICHIARATA
           /*AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
           AND UP.ID_VARIETA = TV.ID_VARIETA
           AND UP.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO
           AND TU.ID_TIPO_SPECIE = TS.ID_TIPO_SPECIE
           AND TS.ID_TIPO_GENERE = TG.ID_TIPO_GENERE*/
           AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND CM.FLAG_SEMINATIVO = 'S' 
           AND CM.SOGGETTO_A_DIVERSIFICAZIONE = 'S'  
           AND (pEscludiBio = 'N' OR
               (pEscludiBio = 'S' AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                                    FROM DB_PARTICELLA_BIO PB
                                                   WHERE PB.ID_PARTICELLA = CP.ID_PARTICELLA
                                                     AND PB.ID_AZIENDA = DC.ID_AZIENDA
                                                     AND DC.DATA BETWEEN PB.DATA_INIZIO_VALIDITA AND NVL(PB.DATA_FINE_VALIDITA, DC.DATA)
                                                     AND (PB.SUP_BIOLOGICO > 0 OR PB.SUP_IN_CONVERSIONE > 0)))); 


        -- se la superficie a seminativo supera una certa soglia (10ha)
        IF nTotSupSem >= glRecDTipoGreening.VALORE_DA_CUI_APPLICARE THEN
            IF nTotSupSem = nTotSupSemSom THEN

                -- sono esonerato e la booleana va settata
                bEsonera := TRUE;

                glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningEsente;
                glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                SELECT SEQ_DB_AZIENDA_GREENING_ESON.nextval
                  INTO glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING_ESONERO
                  FROM DUAL;
                recDTipoEsGreen := SelDTipoEsoneroGreeningByCod (kvCodTipoEsoneroSoloRiso);
                glVetEsoneriAzGreening(1).ID_TIPO_ESONERO_GREENING := recDTipoEsGreen.ID_TIPO_ESONERO_GREENING;
                glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;
            ELSE

                SELECT NVL(SUM(DECODE(CM.FLAG_SEMINATIVO,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE)),0),
                       NVL(SUM(DECODE(CM.FLAG_PRATO_FORAGGERA,'S', UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE)),0),
                       NVL(SUM(DECODE(CM.FLAG_RIPOSO,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE)),0)
                  INTO nTotSupSemNoBio,
                       nTotSupFora,
                       nTotSupRiposo
                  FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                       DB_CONDUZIONE_DICHIARATA CP,
                       DB_UTILIZZO_DICHIARATO UP,DB_R_CATALOGO_MATRICE CM
                       /*DB_TIPO_UTILIZZO TU,
                       DB_TIPO_VARIETA TV,
                       DB_TIPO_DETTAGLIO_USO TDU*/
                   WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
                   AND DC.CODICE_FOTOGRAFIA_TERRENI = CP.CODICE_FOTOGRAFIA_TERRENI
                   AND UP.ID_CONDUZIONE_DICHIARATA = CP.ID_CONDUZIONE_DICHIARATA
                   /*AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
                   AND UP.ID_VARIETA = TV.ID_VARIETA
                   AND UP.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO*/
                   AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
                   AND CM.SOGGETTO_A_DIVERSIFICAZIONE = 'S'  
                   AND (pEscludiBio = 'N' OR
                       (pEscludiBio = 'S' AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                                            FROM DB_PARTICELLA_BIO PB
                                                           WHERE PB.ID_PARTICELLA = CP.ID_PARTICELLA
                                                             AND PB.ID_AZIENDA = DC.ID_AZIENDA
                                                             AND DC.DATA BETWEEN PB.DATA_INIZIO_VALIDITA AND NVL(PB.DATA_FINE_VALIDITA, DC.DATA)
                                                             AND (PB.SUP_BIOLOGICO > 0 OR PB.SUP_IN_CONVERSIONE > 0)))); 

                nTotSupDiv := nTotSupFora + nTotSupRiposo;

                -- calcolo la percentuale a prescindere
                nPercDiv := (nTotSupDiv * 100) /  nTotSupSemNoBio;

                -- se la differenza tra totale a seminativo e riposo + prato + leguminose e' inferiore ai 30ha
                IF nTotSupSemNoBio - nTotSupDiv <= knEttMaxDifSeminativoUsiVari THEN
                   -- calcolo la percentuale
                   -- nPercDiv := (nTotSupDiv * 100) /  nTotSupSemNoBio;

                   -- se e' di prato + riposo + leguminose rispetto al totale
                   -- se essa' e' maggiore del 75
                   IF nPercDiv >= knPercMinRispettoAltriUsiSem THEN
                      -- sono esonerato
                      bEsonera := TRUE;
                      glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningEsente;
                      glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                      glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                      glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                      SELECT SEQ_DB_AZIENDA_GREENING_ESON.nextval
                        INTO glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING_ESONERO
                        FROM DUAL;
                      recDTipoEsGreen := SelDTipoEsoneroGreeningByCod (kvCodTipoEsonero75PratoRip);
                      glVetEsoneriAzGreening(1).ID_TIPO_ESONERO_GREENING := recDTipoEsGreen.ID_TIPO_ESONERO_GREENING;
                      glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;
                   END IF;
                ELSE
                   -- se rispetta la percentuale ma non rispetta la differenza
                   -- di 30 ha diciamo che e' esente parzile
                   IF nPercDiv >= knPercMinRispettoAltriUsiSem THEN
                      -- ovvero deve fare la diversificazione solo sul rimanente
                      -- (interpretazione folkloristica della normativa)
                      bParziale := TRUE;
                      nSupSemDivParC1 := nTotSupSemNoBio - nTotSupDiv;
                   END IF;
                END IF;

                -- se non sono esonerato
                IF NOT bEsonera THEN
                    -- controllo
                    -- se per caso ho le esonero per colture sommerse + prati + prati permanenti
                    -- somma la superficie totale dell'azienda escludendo
                    -- le coltura non ammissibili EFA
                    -- sommo il prato  , sommo le colture sommerse , sommo i prati permanenti
                    SELECT NVL(SUM(DECODE(CM.FLAG_NON_AMMISSIBILE_EFA,'S',0,UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE)),0),
                           NVL(SUM(
                           DECODE(CM.FLAG_PRATO_FORAGGERA,'S', UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,
                           DECODE(CM.FLAG_COLTURA_SOMMERSA,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,
                           DECODE(CM.FLAG_PRATO_PERMANENTE,'S',UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE,0)))),0)
                      INTO nTotSupSemNoBio,
                           nTotSupDiv
                      FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                           DB_CONDUZIONE_DICHIARATA CD,
                           DB_UTILIZZO_DICHIARATO UP,DB_R_CATALOGO_MATRICE CM
                           /*DB_TIPO_UTILIZZO TU,
                           DB_TIPO_VARIETA TV,
                           DB_TIPO_DETTAGLIO_USO VDU*/
                     WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
                       AND DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
                       AND CD.ID_CONDUZIONE_DICHIARATA = UP.ID_CONDUZIONE_DICHIARATA
                       /*AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
                       AND UP.ID_VARIETA = TV.ID_VARIETA
                       AND UP.ID_TIPO_DETTAGLIO_USO = VDU.ID_TIPO_DETTAGLIO_USO*/
                       AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
                       AND CM.SOGGETTO_A_DIVERSIFICAZIONE = 'S' 
                       AND (pEscludiBio = 'N' OR
                           (pEscludiBio = 'S' AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                                                FROM DB_PARTICELLA_BIO PB
                                                               WHERE PB.ID_PARTICELLA = CD.ID_PARTICELLA
                                                                 AND PB.ID_AZIENDA = DC.ID_AZIENDA
                                                                 AND DC.DATA BETWEEN PB.DATA_INIZIO_VALIDITA AND NVL(PB.DATA_FINE_VALIDITA, DC.DATA)
                                                                 AND (PB.SUP_BIOLOGICO > 0 OR PB.SUP_IN_CONVERSIONE > 0)))); 

                    -- calcolo la percentuale a prescindere
                    nPercDiv := (nTotSupDiv * 100) /  nTotSupSemNoBio;

                    -- se il totale della superficie non bio -
                    -- il totale di colture sommerse + prati + prati permanenti
                    -- e' minore di 30 ha
                    IF nTotSupSem - nTotSupDiv <= knEttMaxDifSeminativoUsiVari THEN
                       -- se la percentuale di colture sommerse + prati + prati permanenti
                       -- e' maggiore del 75% della superficie aziendale non biologica
                       -- sono esonerato

                       -- nPercDiv := (nTotSupDiv * 100) /  nTotSupSemNoBio;

                       IF nPercDiv >= knPercMinRispettoAltriUsiSem THEN
                          bEsonera := TRUE;

                          glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningEsente;
                          glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                          glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                          glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                          SELECT SEQ_DB_AZIENDA_GREENING_ESON.nextval
                            INTO glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING_ESONERO
                            FROM DUAL;
                          recDTipoEsGreen := SelDTipoEsoneroGreeningByCod (kvCodTipoEsonero75PrSomPrPerm);
                          glVetEsoneriAzGreening(1).ID_TIPO_ESONERO_GREENING := recDTipoEsGreen.ID_TIPO_ESONERO_GREENING;
                          glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;

                       END IF;
                    ELSE
                       IF nPercDiv >= knPercMinRispettoAltriUsiSem THEN
                          --bParziale := TRUE; dal 2016 l'eccedente di 30 ettari non viene controllato
                          nSupSemDivParC2 := nTotSupSemNoBio - nTotSupDiv;
                       END IF;
                    END IF;
                END IF;

            END IF;

            -- se non ho esoneri faccio la verifica vera e propria della
            -- diversificazione
            IF NOT bEsonera THEN
                IF nNumGruppiDiv > 1 THEN

                    -- se sono in caso di esonero parziale
                    IF bParziale THEN
                       -- cerco di capire qual'e' il criterio
                       -- che ha portato all'esonero parziale
                       IF nSupSemDivParC1 IS NULL THEN
                             nTotSupSem := nSupSemDivParC2;
                             vCriterioCreativo := 'S';
                          ELSE
                              -- in caso lo abbiano potenzialmente generato entrambi i
                              -- criteri di esonero sia quello per foraggerre + riposo
                              -- che quello di prati permanenti + colture sommerse + foraggere
                              -- prendo quello che supera per meno i 30ha come
                              -- differenza col seminativo totale (ovvero il più piccolo)
                              IF nSupSemDivParC2 > nSupSemDivParC1 THEN
                                 nTotSupSem := nSupSemDivParC1;
                                 vCriterioCreativo := 'R';
                              ELSE
                                 nTotSupSem := nSupSemDivParC2;
                                 vCriterioCreativo := 'S';
                              END IF;
                       END IF;

                       -- i gruppi diversificazione
                       -- solo sulle colture che non fanno parte dei criteri
                       SELECT COUNT(DISTINCT(CM.CODICE_DIVERSIFICAZIONE))
                         INTO nNumGruppiDiv
                         FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                              DB_CONDUZIONE_DICHIARATA CP,
                              DB_UTILIZZO_DICHIARATO UP,DB_R_CATALOGO_MATRICE CM
                              /*DB_TIPO_UTILIZZO TU,
                              DB_TIPO_VARIETA TV,
                              DB_TIPO_SPECIE TS,
                              DB_TIPO_GENERE TG,
                              DB_TIPO_DETTAGLIO_USO TDU*/
                        WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
                          AND DC.CODICE_FOTOGRAFIA_TERRENI = CP.CODICE_FOTOGRAFIA_TERRENI
                          AND UP.ID_CONDUZIONE_DICHIARATA = CP.ID_CONDUZIONE_DICHIARATA
                          /*AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
                          AND UP.ID_VARIETA = TV.ID_VARIETA
                          AND UP.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO
                          AND TU.ID_TIPO_SPECIE = TS.ID_TIPO_SPECIE
                          AND TS.ID_TIPO_GENERE = TG.ID_TIPO_GENERE*/
                          AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
                          AND CM.FLAG_SEMINATIVO = 'S' 
                          AND CM.SOGGETTO_A_DIVERSIFICAZIONE = 'S'  
                          AND ((vCriterioCreativo = 'R' AND
                                CM.FLAG_PRATO_FORAGGERA = 'N'
                                AND CM.FLAG_RIPOSO = 'N') OR
                              (vCriterioCreativo = 'S'
                                AND CM.FLAG_PRATO_FORAGGERA = 'N'
                                AND CM.FLAG_COLTURA_SOMMERSA = 'N'
                                AND CM.FLAG_PRATO_PERMANENTE = 'N'))
                          AND (pEscludiBio = 'N' OR
                              (pEscludiBio = 'S' AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                                                   FROM DB_PARTICELLA_BIO PB
                                                                  WHERE PB.ID_PARTICELLA = CP.ID_PARTICELLA
                                                                    AND PB.ID_AZIENDA = DC.ID_AZIENDA
                                                                    AND DC.DATA BETWEEN PB.DATA_INIZIO_VALIDITA AND NVL(PB.DATA_FINE_VALIDITA, DC.DATA)
                                                                    AND (PB.SUP_BIOLOGICO > 0 OR PB.SUP_IN_CONVERSIONE > 0)))); 


                    ELSE
                       vCriterioCreativo := NULL;
                    END IF;

                    IF nTotSupSem > knEttariFinoDueColtureDic THEN
                       nCont := 3;
                    ELSE
                       nCont := 2;
                    END IF;

                    IF nNumGruppiDiv >= nCont THEN

                        -- gestione particolare per quando ho 75% di foraggere o riposo
                        -- (non sommati)
                        IF (nTotSupFora * 100) / nTotSupSem  > knPercMinRispettoAltriUsiSem THEN
                           vPrincipale := 'F';
                        END IF;

                        IF (nTotSupRiposo * 100) / nTotSupSem > knPercMinRispettoAltriUsiSem THEN
                           vPrincipale := 'R';
                        END IF;

                        IF vPrincipale IS NOT NULL THEN

                               SELECT CODICE_DIVERSIFICAZIONE,
                                           ID_TIPO_PERIODO_SEMINA,
                                           TOT_SUP
                                 INTO vTipoDiv,
                                      nIdTipoPerSem,
                                      nTotSup
                                 FROM (
                               SELECT CM.CODICE_DIVERSIFICAZIONE,
                                      UP.ID_TIPO_PERIODO_SEMINA,
                                      NVL(SUM(UP.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE),0) AS TOT_SUP
                                 FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                                      DB_CONDUZIONE_DICHIARATA CP,
                                      DB_UTILIZZO_DICHIARATO UP,DB_R_CATALOGO_MATRICE CM
                                      /*DB_TIPO_UTILIZZO TU,
                                      DB_TIPO_VARIETA TV,
                                      DB_TIPO_SPECIE TS,
                                      DB_TIPO_GENERE TG,
                                      DB_TIPO_DETTAGLIO_USO TDU*/
                                WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
                                  AND DC.CODICE_FOTOGRAFIA_TERRENI = CP.CODICE_FOTOGRAFIA_TERRENI
                                  AND UP.ID_CONDUZIONE_DICHIARATA = CP.ID_CONDUZIONE_DICHIARATA
                                  /*AND UP.ID_UTILIZZO = TU.ID_UTILIZZO
                                  AND UP.ID_VARIETA = TV.ID_VARIETA
                                  AND UP.ID_TIPO_DETTAGLIO_USO = TDU.ID_TIPO_DETTAGLIO_USO
                                  AND TU.ID_TIPO_SPECIE = TS.ID_TIPO_SPECIE
                                  AND TS.ID_TIPO_GENERE = TG.ID_TIPO_GENERE*/
                                  AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
                                  AND cm.FLAG_SEMINATIVO = 'S'
                                  AND CM.SOGGETTO_A_DIVERSIFICAZIONE = 'S'  
                                  AND (vPrincipale = 'F' AND CM.FLAG_PRATO_FORAGGERA ='N' OR
                                       vPrincipale = 'R' AND CM.FLAG_RIPOSO = 'N')
                                  AND (pEscludiBio = 'N' OR
                                      (pEscludiBio = 'S' AND NOT EXISTS (SELECT PB.ID_PARTICELLA_BIO
                                                                           FROM DB_PARTICELLA_BIO PB
                                                                          WHERE PB.ID_PARTICELLA = CP.ID_PARTICELLA
                                                                            AND PB.ID_AZIENDA = DC.ID_AZIENDA
                                                                            AND DC.DATA BETWEEN PB.DATA_INIZIO_VALIDITA AND NVL(PB.DATA_FINE_VALIDITA, DC.DATA)
                                                                            AND (PB.SUP_BIOLOGICO > 0 OR PB.SUP_IN_CONVERSIONE > 0)))) 
                     GROUP BY CM.CODICE_DIVERSIFICAZIONE,
                                           UP.ID_TIPO_PERIODO_SEMINA
                             ORDER BY TOT_SUP DESC) WHERE ROWNUM = 1;

                             IF vTipoDiv = 'S' AND  vCodTipoSpGen IN ( '333', '444') THEN
                                glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                                glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningRispettato;
                                glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                                glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                             ELSE
                                IF vPrincipale = 'F' THEN
                                   nPercDiv := nTotSup * 100 /  (nTotSupSem - nTotSupFora);
                                ELSE
                                   nPercDiv := (nTotSup * 100) / (nTotSupSem - nTotSupRiposo);
                                END IF;

                                IF nPercDiv > knPercMinRispettoAltriUsiSem THEN
                                   glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                                   glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningNonRispettato;
                                   glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                                   glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Azienda con seminativo non biologico totale : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' ha sulla quale non insistono ' || nCont || ' colture diverse';
                                ELSE
                                   glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                                   glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningRispettato;
                                   glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                                   glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                                --glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Azienda con seminativo non biologico totale : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' ha sulla quale non insistono ' || nCont || ' colture diverse';
                                END IF;
                             END IF;

                        ELSE
                            -- scorro i gruppi diversificazione / periodo semina
                            -- con superficie sommata ordinati per superficie decrescente
                            FOR recSupPerGruppoTpPerSemina IN curSupPerGruppoTpPerSemina (vCriterioCreativo) LOOP
                                nSommaSupGruppi := nSommaSupGruppi + recSupPerGruppoTpPerSemina.TOT_UTILIZZATO;
                                nPercDiv := (recSupPerGruppoTpPerSemina.TOT_UTILIZZATO * 100) / nTotSupSem;
                                IF nPercDiv > knPercMinRispettoAltriUsiSem THEN
                                   -- non serve guardare se e' sopra i 30ha di seminativo
                                   -- e' anomalo comunque
                                   -- IF nTotSupSem > knEttariFinoDueColtureDic THEN
                                      glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                                      glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningNonRispettato;
                                      glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                                      glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Azienda con seminativo non biologico totale : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' ha per cui la coltura principale (' || recSupPerGruppoTpPerSemina.DESC_SPECIE || ' - ' || recSupPerGruppoTpPerSemina.DESCRIZIONE || ') , con ettari : ' || TRIM(TO_CHAR(recSupPerGruppoTpPerSemina.TOT_UTILIZZATO, '999G990D9999')) || ' supera il 75% di seminativi';
                                      glRecTAziendaGreening.NOTE := 'Azienda con seminativo non biologico totale : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' ha per cui la coltura principale (' || recSupPerGruppoTpPerSemina.DESC_SPECIE || ' - ' || recSupPerGruppoTpPerSemina.DESCRIZIONE || ') , con ettari : ' || TRIM(TO_CHAR(recSupPerGruppoTpPerSemina.TOT_UTILIZZATO, '999G990D9999')) || ' supera il 75% di seminativi';
                                      bTrattato := TRUE;
                                      EXIT;
                                   -- ELSE
                                      /*
                                      IF nTotSupSem <= knEttariFinoDueColtureDic THEN
                                         glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                                         glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningRispettato;
                                         glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                                         glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                                         glRecTAziendaGreening.NOTE := NULL;
                                         bTrattato := TRUE;
                                         EXIT;
                                      END IF;*/
                                   -- END IF;

                                END IF;

                                nCont := nCont - 1;
                                -- coltura più grossa
                                IF nCont = 1 THEN
                                   EXIT;
                                END IF;
                            END LOOP;

                            IF NOT bTrattato THEN
                               nPercDiv := (nSommaSupGruppi * 100) / nTotSupSem;
                               IF nPercDiv > knPercMinRispettoAltriUsiTSem THEN
                                  glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                                  glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningNonRispettato;
                                  glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                                  glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Azienda con seminativo non biologico totale : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' ha per cui le due colture principali superano il 95% di seminativi';
                                  glRecTAziendaGreening.NOTE := 'Azienda con seminativo non biologico totale : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' ha per cui le due colture principali superano il 95% di seminativi';
                               ELSE
                                  glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                                  glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningRispettato;
                                  glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                                  glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
                                  glRecTAziendaGreening.NOTE := NULL;
                               END IF;
                            END IF;
                        END IF;
                    ELSE
                        glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                        glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningNonRispettato;
                        glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                        glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Azienda con seminativo non biologico totale : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' ha sulla quale non insistono ' || nCont || ' colture diverse';
                    END IF;
                ELSE
                     glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
                     glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningNonRispettato;
                     glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
                     glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Azienda con seminativo non biologico totale : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' sulla quale non insistono due o piu'' colture diverse';
                     glRecTAziendaGreening.NOTE := 'Azienda con seminativo non biologico totale : ' || TRIM(TO_CHAR(nTotSupSem,'999G990D9999')) || ' sulla quale non insistono due o piu'' colture diverse';
                END IF;
            END IF;

        ELSE
            glRecTAziendaGreening.SUPERFICIE_SEMINATIVO := nTotSupSem;
            glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningEsente;
            glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
            glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
            SELECT SEQ_DB_AZIENDA_GREENING_ESON.nextval
              INTO glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING_ESONERO
              FROM DUAL;
            recDTipoEsGreen := SelDTipoEsoneroGreeningByCod (kvCodTipoEsoneroEttariMin10);
            glVetEsoneriAzGreening(1).ID_TIPO_ESONERO_GREENING := recDTipoEsGreen.ID_TIPO_ESONERO_GREENING;
            glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;
        END IF;

        pRisultato := '0';

    EXCEPTION
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'Errore pl/sql in procedure DIV_VAL - ESCLUDI_BIO = ' || pEscludiBio || ' : ' || SUBSTR(SQLERRM,1,150);
    END DIV_VAL;

    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    DIVERSIFICAZIONE alla validazione non escludendo la parte biologica
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE DIV_CB (pIdAzienda     IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                      pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                      pRisultato     OUT VARCHAR2,
                      pMessaggio     OUT VARCHAR2) IS
    BEGIN

        DIV (pIdAzienda,
             pEscludiBio,
             pRisultato,
             pMessaggio);

    END DIV_CB;

    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    DIVERSIFICAZIONE alla validazione non escludendo la parte biologica
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE DIV_VAL_CB (pIdDichCons    IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                          pEscludiBio    IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                          pRisultato     OUT VARCHAR2,
                          pMessaggio     OUT VARCHAR2) IS
    BEGIN

        DIV_VAL (pIdDichCons,
                 pEscludiBio,
                 pRisultato,
                 pMessaggio);

    END DIV_VAL_CB;


    /*********************************************************************
    Effettua il calcolo delle esito greening per la tipologia di greening
    azienda con particelle FUORI PIEMONTE
    Tipo: function
    input: pIdAzienda
    output:  pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE FUOPIEMONT (pIdAzienda    IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                          pEscludiBio   IN DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                          pRisultato    OUT VARCHAR2,
                          pMessaggio    OUT VARCHAR2
                          ) IS
        nRec INTEGER:=0;
    BEGIN

        SELECT COUNT (UP.ID_UTILIZZO_PARTICELLA)
          INTO nRec
          FROM DB_CONDUZIONE_PARTICELLA CP,
               DB_STORICO_PARTICELLA SP,
               COMUNE C,
               PROVINCIA P,
               DB_UTE UT,
               DB_UTILIZZO_PARTICELLA UP
         WHERE UT.ID_AZIENDA = pIdAzienda
           AND UT.ID_UTE = CP.ID_UTE
           AND UT.DATA_FINE_ATTIVITA IS NULL
           AND CP.DATA_FINE_CONDUZIONE IS NULL
           AND UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
           AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
           AND SP.DATA_FINE_VALIDITA IS NULL
           AND SP.COMUNE = C.ISTAT_COMUNE
           AND C.ISTAT_PROVINCIA = P.ISTAT_PROVINCIA
           AND P.ID_REGIONE <> kvIdRegionePiemonte
           AND ROWNUM < 2;

        IF nRec > 0 THEN
           glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningSi;
           glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
           glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Azienda con particelle fuori Piemonte';
        ELSE
           glRecTAziendaGreening.ID_ESITO_GREENING := knIdEsitoGreeningNo;
           glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
           glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Azienda senza particelle fuori Piemonte';
        END IF;

        pRisultato := '0';

    EXCEPTION
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'Errore pl/sql in procedure FUOPIEMONT : ' || SUBSTR(SQLERRM,1,150);
    END FUOPIEMONT;

    /*********************************************************************
    Dati un'id_azienda ed una tipologia di greening ricerca
    se c'è un record attivo su DB_AZIENDA_GREENING e lo restituisce in output
    Tipo: function
    input: pIdAzienda, pIdTipoGreen
    output: nessuno
    ritorno: DB_AZIENDA_GREENING%ROWTYPE
    *********************************************************************/
    FUNCTION SelTAziendaGreenByAzTipoGreen (pIdAzienda      IN DB_AZIENDA_GREENING.ID_AZIENDA%TYPE,
                                            pIdTipoGreen    IN DB_AZIENDA_GREENING.ID_TIPO_GREENING%TYPE
                                            ) RETURN DB_AZIENDA_GREENING%ROWTYPE IS
        recTAzGreening DB_AZIENDA_GREENING%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTAzGreening
          FROM DB_AZIENDA_GREENING
         WHERE ID_AZIENDA = pIdAzienda
           AND ID_TIPO_GREENING = pIdTipoGreen
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recTAzGreening;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTAziendaGreenByAzTipoGreen;


    /*********************************************************************
    Effettua il calcolo degli esiti del rispetto del greening per ogni tipologia
    andando ad aggiornare la tabella DB_AZIENDA_GREENING
    Tipo: procedure
    input: pIdAzienda, pIdDichCons, pIdUtenteIride
    output: pRisultato,pMessaggio
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE Calcola_Esito_Greening (pIdAzienda        IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                                      pIdDichCons       IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                      pIdUtenteIride    IN DB_AZIENDA_GREENING.ID_UTENTE_AGGIORNAMENTO%TYPE,
                                      pRisultato       OUT VARCHAR2,
                                      pMessaggio       OUT VARCHAR2
                                      ) IS


        CURSOR curTipologiaGreening (pIdDc IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE) IS
        SELECT TP.*
          FROM DB_TIPO_GREENING TP
         WHERE DATA_FINE_VALIDITA IS NULL
           AND ((pIdDc = 0 AND FLAG_VISIBILE = 'S') OR
                (pIdDc > 0 AND CODICE_TIPO_GREENING LIKE '%VAL%'));

        PARAMETRI_ASSENTI   EXCEPTION;
        PROCEDURA_IN_ERRORE EXCEPTION;
        recTAzGreening      DB_AZIENDA_GREENING%ROWTYPE;
        recTAzGreeningNew   DB_AZIENDA_GREENING%ROWTYPE;
        nNumVal             INTEGER;
        VetEsoneriAzienda   TypVetEsoneriGreening;
        PROCEDURA_MANCANTE  EXCEPTION;
        PRAGMA EXCEPTION_INIT (PROCEDURA_MANCANTE, -6550);

  nContInea  SIMPLE_INTEGER := 0;

BEGIN

        IF pIdAzienda IS NULL THEN
           pMessaggio := 'Identificativo dell''azienda non valorizzato';
           RAISE PARAMETRI_ASSENTI;
        END IF;

        IF pIdUtenteIride IS NULL THEN
           pMessaggio := 'Identificativo dell''utente di aggiornamento non valorizzato';
           RAISE PARAMETRI_ASSENTI;
        END IF;

        SELECT COUNT(*)
          INTO nNumVal
          FROM DB_AZIENDA_GREENING
         WHERE ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
           AND EXT_ID_PRATICA IS NULL;

  IF pIdDichCons IS NOT NULL THEN
    SELECT COUNT(*)
    INTO   nContInea
    FROM   DB_TIPO_GREENING TP,DB_DICHIARAZIONE_CONSISTENZA DC
    WHERE  DC.ID_DICHIARAZIONE_CONSISTENZA   = pIdDichCons
    AND    DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN TP.DATA_INIZIO_VALIDITA AND NVL(TP.DATA_FINE_VALIDITA,SYSDATE)
    AND    FLAG_INEA                         = 'S';
  ELSE
    SELECT COUNT(*)
    INTO   nContInea
    FROM   DB_TIPO_GREENING TP
    WHERE  TP.DATA_FINE_VALIDITA IS NULL
    AND    FLAG_INEA             = 'S';
  END IF;

  IF nContInea != 0 THEN
    PACK_INEA.CALCOLO_INEA(pIdAzienda,NULL,pIdDichCons,
                           gnRls,gnUde,gnOte,gnPs,gnReturnValInea,gvDescErrInea);  -- out
  END IF;

        FOR recTipologiaGreening IN curTipologiaGreening (nNumVal) LOOP

            recTAzGreening := SelTAziendaGreenByAzTipoGreen (pIdAzienda,
                                                             recTipologiaGreening.ID_TIPO_GREENING);

            glRecTAziendaGreening := recTAzGreening;

            glRecTAziendaGreening.ID_ESITO_GREENING := NULL;
            glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := NULL;
            glRecTAziendaGreening.VALORE_CALCOLATO_NUMBER := NULL;
            glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
            glRecTAziendaGreening.VALORE_CALCOLATO_DATE := NULL;


            glRecDTipoGreening := recTipologiaGreening;
            glVetEsoneriAzGreening := VetEsoneriAzienda;

            IF recTipologiaGreening.PROCEDURA_CALCOLO IS NOT NULL THEN

               EXECUTE IMMEDIATE dbms_lob.SUBSTR(recTipologiaGreening.PROCEDURA_CALCOLO,32765,1)
                 USING IN pIdAzienda, IN CASE WHEN recTipologiaGreening.ESCLUDI_ESONERO_BIO = 'S' THEN 'N' ELSE 'S' END, OUT pRisultato, OUT pMessaggio;

            ELSE

               IF nNumVal = 0 THEN

                   BEGIN
                       EXECUTE IMMEDIATE 'begin Pck_Calcolo_Esito_Greening.'
                                               || recTipologiaGreening.CODICE_TIPO_GREENING
                                               || '(:1, :2, :3, :4); end;'
                                         USING IN pIdAzienda, IN CASE WHEN recTipologiaGreening.ESCLUDI_ESONERO_BIO = 'S' THEN 'N' ELSE 'S' END, OUT pRisultato, OUT pMessaggio;
                   EXCEPTION
                       WHEN PROCEDURA_MANCANTE THEN
                            pRisultato := '2';
                            pMEssaggio := 'MancanteAutorizzata';
                       WHEN OTHERS THEN
                            pRisultato := '1';
                            pMessaggio := 'Errore nel richiamo procedure : ' ||  recTipologiaGreening.CODICE_TIPO_GREENING || ' - ' || SUBSTR(SQLERRM,1,150);
                   END;
               ELSE

                   BEGIN
                       EXECUTE IMMEDIATE 'begin Pck_Calcolo_Esito_Greening.'
                                               || recTipologiaGreening.CODICE_TIPO_GREENING
                                               || '(:1, :2, :3, :4); end;'
                                         USING IN pIdDichCons, IN CASE WHEN recTipologiaGreening.ESCLUDI_ESONERO_BIO = 'S' THEN 'N' ELSE 'S' END, OUT pRisultato, OUT pMessaggio;
                   EXCEPTION
                       WHEN PROCEDURA_MANCANTE THEN
                            pRisultato := '2';
                            pMEssaggio := 'MancanteAutorizzata';
                       WHEN OTHERS THEN
                            pRisultato := '1';
                            pMessaggio := 'Errore nel richiamo procedure : ' ||  recTipologiaGreening.CODICE_TIPO_GREENING || ' - ' || SUBSTR(SQLERRM,1,150);
                   END;

               END IF;
            END IF;

            IF pRisultato = '0' THEN

                IF recTAzGreening.ID_DICHIARAZIONE_CONSISTENZA IS NOT NULL OR
                   recTAzGreening.ID_AZIENDA_GREENING IS NULL THEN

                   IF recTAzGreening.ID_DICHIARAZIONE_CONSISTENZA IS NOT NULL THEN
                      StoricizzaAziendaGreening (recTAzGreening.ID_AZIENDA_GREENING);
                   END IF;

                   SELECT SEQ_DB_AZIENDA_GREENING.nextval
                     INTO glRecTAziendaGreening.ID_AZIENDA_GREENING
                     FROM DUAL;

                   glRecTAziendaGreening.ID_AZIENDA := pIdAzienda;
                   glRecTAziendaGreening.ID_TIPO_GREENING := recTipologiaGreening.ID_TIPO_GREENING;
                   glRecTAziendaGreening.DATA_INIZIO_VALIDITA := SYSDATE;
                   glRecTAziendaGreening.DATA_FINE_VALIDITA := NULL;
                   glRecTAziendaGreening.DATA_AGGIORNAMENTO:= SYSDATE;
                   glRecTAziendaGreening.ID_UTENTE_AGGIORNAMENTO := pIdUtenteIride;
                   glRecTAziendaGreening.ID_DICHIARAZIONE_CONSISTENZA := pIdDichCons;
                   glRecTAziendaGreening.NOTE := NULL;
                   InsertTAziendaGreening (glRecTAziendaGreening);

                   FOR I IN 1..glVetEsoneriAzGreening.COUNT LOOP
                       glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;
                       InserTAziendaGreeningEsonero (glVetEsoneriAzGreening(1));
                   END LOOP;

                ELSE
                   DELETE
                     FROM DB_AZIENDA_GREENING_ESONERO
                    WHERE ID_AZIENDA_GREENING = glRecTAziendaGreening.ID_AZIENDA_GREENING;

                   UPDATE DB_AZIENDA_GREENING
                      SET ID_ESITO_GREENING  = glRecTAziendaGreening.ID_ESITO_GREENING,
                          TIPO_VALORE_CALCOLATO = glRecTAziendaGreening.TIPO_VALORE_CALCOLATO,
                          VALORE_CALCOLATO_NUMBER = glRecTAziendaGreening.VALORE_CALCOLATO_NUMBER,
                          VALORE_CALCOLATO_VARCHAR2 = glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2,
                          VALORE_CALCOLATO_DATE = glRecTAziendaGreening.VALORE_CALCOLATO_DATE,
                          DATA_INIZIO_VALIDITA = SYSDATE,
                          DATA_FINE_VALIDITA = NULL,
                          DATA_AGGIORNAMENTO = SYSDATE,
                          ID_UTENTE_AGGIORNAMENTO = pIdUtenteIride,
                          ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons,
                          NOTE = NULL
                    WHERE ID_AZIENDA_GREENING = glRecTAziendaGreening.ID_AZIENDA_GREENING;

                   FOR I IN 1..glVetEsoneriAzGreening.COUNT LOOP
                       glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;
                       InserTAziendaGreeningEsonero (glVetEsoneriAzGreening(1));
                   END LOOP;

                END IF;
            ELSE
                IF pRisultato = '1' THEN
                   RAISE PROCEDURA_IN_ERRORE;
                END IF;
            END IF;

        END LOOP;

        pRisultato := '0';
        pMessaggio := NULL;

    EXCEPTION
        WHEN PROCEDURA_IN_ERRORE THEN
             pRisultato := '1';
        WHEN PARAMETRI_ASSENTI THEN
             pRisultato := '1';
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'Errore PL/SQL non gestito : ' || SUBSTR(SQLERRM,1,200)||' riga = '||dbms_utility.FORMAT_ERROR_BACKTRACE;
    END Calcola_Esito_Greening;


    /*********************************************************************
    Effettua il calcolo degli esiti del rispetto del greening per ogni tipologia
    andando ad aggiornare la tabella DB_AZIENDA_GREENING per il procedimento
    richiamante e per la pratica richiamante
    Tipo: procedure
    input:  pIdDichCons, pIdUtenteIride, pIdProcedimento,pExtIdPratica,pSumRimastaInEfa
    output: pRisultato,pMessaggio
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE Calcola_Esito_Greening_Proc (pIdDichCons          IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                           pIdUtenteIride       IN DB_AZIENDA_GREENING.ID_UTENTE_AGGIORNAMENTO%TYPE,
                                           pIdProcedimento      IN DB_AZIENDA_GREENING.ID_PROCEDIMENTO%TYPE,
                                           pExtIdPratica        IN DB_AZIENDA_GREENING.EXT_ID_PRATICA%TYPE,
                                           pSumRimastaInEfa     IN DB_UTILIZZO_DICHIARATO.SUPERFICIE_UTILIZZATA%TYPE,
                                           pRisultato          OUT VARCHAR2,
                                           pMessaggio          OUT VARCHAR2
                                           ) IS


        CURSOR curTipologiaGreening (pDataDich IN DATE) IS
        SELECT *
          FROM DB_TIPO_GREENING
         WHERE pDataDich BETWEEN DATA_INIZIO_VALIDITA
                             AND NVL(DATA_FINE_VALIDITA, pDataDich);

        PARAMETRI_ASSENTI   EXCEPTION;
        PROCEDURA_IN_ERRORE EXCEPTION;
        recTAzGreening      DB_AZIENDA_GREENING%ROWTYPE;
        recTAzGreeningNew   DB_AZIENDA_GREENING%ROWTYPE;
        recTDichCons        DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE;
        VetEsoneriAzienda   TypVetEsoneriGreening;
        PROCEDURA_MANCANTE  EXCEPTION;
        PRAGMA EXCEPTION_INIT (PROCEDURA_MANCANTE, -6550);

    BEGIN

        IF pIdUtenteIride IS NULL THEN
           pMessaggio := 'Identificativo dell''utente di aggiornamento non valorizzato';
           RAISE PARAMETRI_ASSENTI;
        END IF;

        IF pIdProcedimento IS NULL THEN
           pMessaggio := 'Identificativo del procedimento non valorizzato';
           RAISE PARAMETRI_ASSENTI;
        END IF;

        IF pExtIdPratica IS NULL THEN
           pMessaggio := 'Identificativo della pratica non valorizzato';
           RAISE PARAMETRI_ASSENTI;
        END IF;

        IF pIdDichCons IS NULL THEN
           pMessaggio := 'Identificativo della dichiarazione di consistenza non valorizzato';
           RAISE PARAMETRI_ASSENTI;
        ELSE
           recTDichCons := SelTDichConsistenzaById (pIdDichCons);
           IF recTDichCons.ID_DICHIARAZIONE_CONSISTENZA IS NULL THEN
              pMessaggio := 'Validazione con identificativo : ' || pIdDichCons || ' non presente in anagrafe';
              RAISE PARAMETRI_ASSENTI;
           END IF;
        END IF;

        DELETE
          FROM DB_AZIENDA_GREENING
         WHERE ID_PROCEDIMENTO = pIdProcedimento
           AND EXT_ID_PRATICA = pExtIdPratica;


        FOR recTipologiaGreening IN curTipologiaGreening (recTDichCons.DATA_INSERIMENTO_DICHIARAZIONE) LOOP

            recTAzGreening := SelTAziendaGreenByDcTipoGreen (pIdDichCons,
                                                             recTipologiaGreening.ID_TIPO_GREENING);


            IF recTipologiaGreening.ESCLUDI_ESONERO_BIO = 'N' THEN
               recTAzGreeningNew := recTAzGreening;
               recTAzGreeningNew.DATA_INIZIO_VALIDITA := SYSDATE;
               recTAzGreeningNew.ID_DICHIARAZIONE_CONSISTENZA := NULL;
               recTAzGreeningNew.DATA_FINE_VALIDITA := recTAzGreeningNew.DATA_INIZIO_VALIDITA;
               recTAzGreeningNew.DATA_AGGIORNAMENTO := SYSDATE;
               recTAzGreeningNew.ID_UTENTE_AGGIORNAMENTO := pIdUtenteIride;
               recTAzGreeningNew.ID_PROCEDIMENTO := pIdProcedimento;
               recTAzGreeningNew.EXT_ID_PRATICA := pExtIdPratica;

               SELECT SEQ_DB_AZIENDA_GREENING.nextval
                 INTO recTAzGreeningNew.ID_AZIENDA_GREENING
                 FROM DUAL;

               InsertTAziendaGreening (recTAzGreeningNew);

               INSERT INTO DB_AZIENDA_GREENING_ESONERO
                    (
                    ID_AZIENDA_GREENING_ESONERO,
                    ID_AZIENDA_GREENING,
                    ID_TIPO_ESONERO_GREENING
                    )
               SELECT SEQ_DB_AZIENDA_GREENING_ESON.nextval,
                      recTAzGreeningNew.ID_AZIENDA_GREENING,
                      ID_TIPO_ESONERO_GREENING
                 FROM DB_AZIENDA_GREENING_ESONERO
                WHERE ID_AZIENDA_GREENING = recTAzGreening.ID_AZIENDA_GREENING;

            ELSE
               glRecTAziendaGreening := recTAzGreening;

               glRecTAziendaGreening.ID_ESITO_GREENING := NULL;
               glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := NULL;
               glRecTAziendaGreening.VALORE_CALCOLATO_NUMBER := NULL;
               glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := NULL;
               glRecTAziendaGreening.VALORE_CALCOLATO_DATE := NULL;


               glRecDTipoGreening := recTipologiaGreening;
               glVetEsoneriAzGreening := VetEsoneriAzienda;

                IF recTipologiaGreening.PROCEDURA_CALCOLO IS NOT NULL THEN

                   EXECUTE IMMEDIATE dbms_lob.SUBSTR(recTipologiaGreening.PROCEDURA_CALCOLO,32765,1)
                     USING IN recTDichCons.CODICE_FOTOGRAFIA_TERRENI, OUT pRisultato, OUT pMessaggio;

                ELSE

                   IF recTipologiaGreening.CODICE_TIPO_GREENING = 'EFANOBIO' THEN
                       BEGIN
                           EXECUTE IMMEDIATE 'begin Pck_Calcolo_Esito_Greening.'
                                                   || recTipologiaGreening.CODICE_TIPO_GREENING
                                                   || '(:1, :2, :3, :4, :5); end;'
                                             USING IN recTDichCons.ID_DICHIARAZIONE_CONSISTENZA,
                                                   IN recTDichCons.CODICE_FOTOGRAFIA_TERRENI,
                                                   IN pSumRimastaInEfa,
                                                  OUT pRisultato,
                                                  OUT pMessaggio;
                       EXCEPTION
                           WHEN PROCEDURA_MANCANTE THEN
                                pRisultato := '2';
                                pMEssaggio := 'MancanteAutorizzata';
                           WHEN OTHERS THEN
                                pRisultato := '1';
                                pMessaggio := 'Errore nel richiamo procedure : ' ||  recTipologiaGreening.CODICE_TIPO_GREENING || ' - ' || SUBSTR(SQLERRM,1,150);
                       END;

                   ELSE

                       BEGIN
                           EXECUTE IMMEDIATE 'begin Pck_Calcolo_Esito_Greening.'
                                                   || recTipologiaGreening.CODICE_TIPO_GREENING
                                                   || '(:1, :2, :3); end;'
                                             USING IN recTDichCons.CODICE_FOTOGRAFIA_TERRENI, OUT pRisultato, OUT pMessaggio;
                       EXCEPTION
                           WHEN PROCEDURA_MANCANTE THEN
                                pRisultato := '2';
                                pMEssaggio := 'MancanteAutorizzata';
                           WHEN OTHERS THEN
                                pRisultato := '1';
                                pMessaggio := 'Errore nel richiamo procedure : ' ||  recTipologiaGreening.CODICE_TIPO_GREENING || ' - ' || SUBSTR(SQLERRM,1,150);
                       END;
                   END IF;

                END IF;

                IF pRisultato = '0' THEN

                    IF recTAzGreening.ID_DICHIARAZIONE_CONSISTENZA IS NOT NULL OR
                       recTAzGreening.ID_AZIENDA_GREENING IS NULL THEN

                       IF recTAzGreening.ID_DICHIARAZIONE_CONSISTENZA IS NOT NULL THEN
                          StoricizzaAziendaGreening (recTAzGreening.ID_AZIENDA_GREENING);
                       END IF;

                       SELECT SEQ_DB_AZIENDA_GREENING.nextval
                         INTO glRecTAziendaGreening.ID_AZIENDA_GREENING
                         FROM DUAL;

                       glRecTAziendaGreening.ID_AZIENDA := recTDichCons.ID_AZIENDA;
                       glRecTAziendaGreening.ID_TIPO_GREENING := recTipologiaGreening.ID_TIPO_GREENING;
                       glRecTAziendaGreening.DATA_INIZIO_VALIDITA := SYSDATE;
                       glRecTAziendaGreening.DATA_FINE_VALIDITA := glRecTAziendaGreening.DATA_INIZIO_VALIDITA;
                       glRecTAziendaGreening.DATA_AGGIORNAMENTO:= SYSDATE;
                       glRecTAziendaGreening.ID_UTENTE_AGGIORNAMENTO := pIdUtenteIride;
                       glRecTAziendaGreening.ID_DICHIARAZIONE_CONSISTENZA := NULL;
                       glRecTAziendaGreening.ID_PROCEDIMENTO := pIdProcedimento;
                       glRecTAziendaGreening.EXT_ID_PRATICA := pExtIdPratica;
                       glRecTAziendaGreening.NOTE := NULL;
                       InsertTAziendaGreening (glRecTAziendaGreening);

                       FOR I IN 1..glVetEsoneriAzGreening.COUNT LOOP
                           glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;
                           InserTAziendaGreeningEsonero (glVetEsoneriAzGreening(1));
                       END LOOP;

                    ELSE
                       DELETE
                         FROM DB_AZIENDA_GREENING_ESONERO
                        WHERE ID_AZIENDA_GREENING = glRecTAziendaGreening.ID_AZIENDA_GREENING;

                       UPDATE DB_AZIENDA_GREENING
                          SET ID_ESITO_GREENING  = glRecTAziendaGreening.ID_ESITO_GREENING,
                              TIPO_VALORE_CALCOLATO = glRecTAziendaGreening.TIPO_VALORE_CALCOLATO,
                              VALORE_CALCOLATO_NUMBER = glRecTAziendaGreening.VALORE_CALCOLATO_NUMBER,
                              VALORE_CALCOLATO_VARCHAR2 = glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2,
                              VALORE_CALCOLATO_DATE = glRecTAziendaGreening.VALORE_CALCOLATO_DATE,
                              DATA_INIZIO_VALIDITA = SYSDATE,
                              DATA_FINE_VALIDITA = NULL,
                              DATA_AGGIORNAMENTO = SYSDATE,
                              ID_UTENTE_AGGIORNAMENTO = pIdUtenteIride,
                              ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons,
                              NOTE = NULL
                        WHERE ID_AZIENDA_GREENING = glRecTAziendaGreening.ID_AZIENDA_GREENING;

                       FOR I IN 1..glVetEsoneriAzGreening.COUNT LOOP
                           glVetEsoneriAzGreening(1).ID_AZIENDA_GREENING := glRecTAziendaGreening.ID_AZIENDA_GREENING;
                           InserTAziendaGreeningEsonero (glVetEsoneriAzGreening(1));
                       END LOOP;

                    END IF;
                ELSE
                    IF pRisultato = '1' THEN
                       RAISE PROCEDURA_IN_ERRORE;
                    END IF;
                END IF;
            END IF;
        END LOOP;

        pRisultato := '0';
        pMessaggio := NULL;

    EXCEPTION
        WHEN PROCEDURA_IN_ERRORE THEN
             pRisultato := '1';
        WHEN PARAMETRI_ASSENTI THEN
             pRisultato := '1';
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'Errore PL/SQL non gestito : ' || SUBSTR(SQLERRM,1,200);
    END Calcola_Esito_Greening_Proc;

PROCEDURE OTE(pIdAzienda       DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
              pEscludiBio      DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
              pRisultato   OUT VARCHAR2,
              pMessaggio   OUT VARCHAR2) IS
BEGIN

  IF gnReturnValInea = 0 THEN

    BEGIN
      SELECT DESCRIZIONE||' ('||CODICE||')'
      INTO   glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2
      FROM   DB_TIPO_ATTIVITA_OTE
      WHERE  ID_ATTIVITA_OTE = gnOte;

      glRecTAziendaGreening.ID_ESITO_GREENING     := knIdEsitoGreeningCalc;
      glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
    EXCEPTION
      WHEN OTHERS THEN
        glRecTAziendaGreening.ID_ESITO_GREENING         := knIdEsitoGreeningCalcErr;
        glRecTAziendaGreening.TIPO_VALORE_CALCOLATO     := 'S';
        glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Errore nel calcolo '||SUBSTR(SQLERRM,1,150);
    END;
  ELSE
    glRecTAziendaGreening.ID_ESITO_GREENING         := knIdEsitoGreeningCalcErr;
    glRecTAziendaGreening.TIPO_VALORE_CALCOLATO     := 'S';
    glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := gvDescErrInea;
  END IF;

  pRisultato := '0';
EXCEPTION
  WHEN OTHERS THEN
    pRisultato := '1';
    pMessaggio := 'Errore pl/sql in procedure OTE : ' || SUBSTR(SQLERRM,1,150)||' RIGA = '||dbms_utility.FORMAT_ERROR_BACKTRACE;
END OTE;

PROCEDURE PS(pIdAzienda       DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
             pEscludiBio      DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
             pRisultato   OUT VARCHAR2,
             pMessaggio   OUT VARCHAR2) IS
BEGIN

  IF gnReturnValInea = 0 THEN
    glRecTAziendaGreening.ID_ESITO_GREENING       := knIdEsitoGreeningCalc;
    glRecTAziendaGreening.TIPO_VALORE_CALCOLATO   := 'N';
    glRecTAziendaGreening.VALORE_CALCOLATO_NUMBER := gnPs;
  ELSE
    glRecTAziendaGreening.ID_ESITO_GREENING         := knIdEsitoGreeningCalcErr;
    glRecTAziendaGreening.TIPO_VALORE_CALCOLATO     := 'S';
    glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := gvDescErrInea;
  END IF;

  pRisultato := '0';
EXCEPTION
  WHEN OTHERS THEN
    pRisultato := '1';
    pMessaggio := 'Errore pl/sql in procedure PS : ' || SUBSTR(SQLERRM,1,150)||' RIGA = '||dbms_utility.FORMAT_ERROR_BACKTRACE;
END PS;

PROCEDURE RLS(pIdAzienda       DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
              pEscludiBio      DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
              pRisultato   OUT VARCHAR2,
              pMessaggio   OUT VARCHAR2) IS
BEGIN

  IF gnReturnValInea = 0 THEN
    glRecTAziendaGreening.ID_ESITO_GREENING       := knIdEsitoGreeningCalc;
    glRecTAziendaGreening.TIPO_VALORE_CALCOLATO   := 'N';
    glRecTAziendaGreening.VALORE_CALCOLATO_NUMBER := gnRls;
  ELSE
    glRecTAziendaGreening.ID_ESITO_GREENING         := knIdEsitoGreeningCalcErr;
    glRecTAziendaGreening.TIPO_VALORE_CALCOLATO     := 'S';
    glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := gvDescErrInea;
  END IF;

  pRisultato := '0';
EXCEPTION
  WHEN OTHERS THEN
    pRisultato := '1';
    pMessaggio := 'Errore pl/sql in procedure RLS : ' || SUBSTR(SQLERRM,1,150)||' RIGA = '||dbms_utility.FORMAT_ERROR_BACKTRACE;
END RLS;

PROCEDURE UDE(pIdAzienda       DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
              pEscludiBio      DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
              pRisultato   OUT VARCHAR2,
              pMessaggio   OUT VARCHAR2) IS
BEGIN

  IF gnReturnValInea = 0 THEN
    glRecTAziendaGreening.ID_ESITO_GREENING       := knIdEsitoGreeningCalc;
    glRecTAziendaGreening.TIPO_VALORE_CALCOLATO   := 'N';

    SELECT CLASSE_UDE
    INTO   glRecTAziendaGreening.VALORE_CALCOLATO_NUMBER
    FROM   DB_TIPO_UDE
    WHERE  ID_UDE = gnUde;

  ELSE
    glRecTAziendaGreening.ID_ESITO_GREENING         := knIdEsitoGreeningCalcErr;
    glRecTAziendaGreening.TIPO_VALORE_CALCOLATO     := 'S';
    glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := gvDescErrInea;
  END IF;

  pRisultato := '0';
EXCEPTION
  WHEN OTHERS THEN
    pRisultato := '1';
    pMessaggio := 'Errore pl/sql in procedure UDE : ' || SUBSTR(SQLERRM,1,150)||' RIGA = '||dbms_utility.FORMAT_ERROR_BACKTRACE;
END UDE;

PROCEDURE ULU(pIdAzienda       DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
              pEscludiBio      DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
              pRisultato   OUT VARCHAR2,
              pMessaggio   OUT VARCHAR2) IS

  nUlu  NUMBER;
BEGIN

  IF gnReturnValInea = 0 THEN
    PCK_CALCOLO_ULU.MAIN(pIdAzienda,gnUde,
                         nUlu,pRisultato,pMessaggio);

    IF pRisultato = '0' THEN
      glRecTAziendaGreening.ID_ESITO_GREENING       := knIdEsitoGreeningCalc;
      glRecTAziendaGreening.TIPO_VALORE_CALCOLATO   := 'N';
      glRecTAziendaGreening.VALORE_CALCOLATO_NUMBER := nUlu;
    ELSE
      glRecTAziendaGreening.ID_ESITO_GREENING         := knIdEsitoGreeningCalcErr;
      glRecTAziendaGreening.TIPO_VALORE_CALCOLATO     := 'S';
      glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := pMessaggio;
    END IF;
  ELSE
    glRecTAziendaGreening.ID_ESITO_GREENING         := knIdEsitoGreeningCalcErr;
    glRecTAziendaGreening.TIPO_VALORE_CALCOLATO     := 'S';
    glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := gvDescErrInea;
  END IF;

  pRisultato := '0';
EXCEPTION
  WHEN OTHERS THEN
    pRisultato := '1';
    pMessaggio := 'Errore pl/sql in procedure ULU : ' || SUBSTR(SQLERRM,1,150)||' RIGA = '||dbms_utility.FORMAT_ERROR_BACKTRACE;
END ULU;

PROCEDURE DIM_AZ(pIdAzienda       DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                 pEscludiBio      DB_TIPO_GREENING.ESCLUDI_ESONERO_BIO%TYPE,
                 pRisultato   OUT VARCHAR2,
                 pMessaggio   OUT VARCHAR2) IS
BEGIN
  IF gnReturnValInea = 0 THEN
    BEGIN
      SELECT DESCRIZIONE_CLASSE
      INTO   glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2
      FROM   DB_TIPO_CLASSE_DIMENSIONE_AZ
      WHERE  gnPs BETWEEN LIMITE_INFERIORE AND LIMITE_SUPERIORE;

      glRecTAziendaGreening.ID_ESITO_GREENING     := knIdEsitoGreeningCalc;
      glRecTAziendaGreening.TIPO_VALORE_CALCOLATO := 'S';
    EXCEPTION
      WHEN OTHERS THEN
        glRecTAziendaGreening.ID_ESITO_GREENING         := knIdEsitoGreeningCalcErr;
        glRecTAziendaGreening.TIPO_VALORE_CALCOLATO     := 'S';
        glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := 'Errore nel calcolo '||SUBSTR(SQLERRM,1,150);
    END;
  ELSE
    glRecTAziendaGreening.ID_ESITO_GREENING         := knIdEsitoGreeningCalcErr;
    glRecTAziendaGreening.TIPO_VALORE_CALCOLATO     := 'S';
    glRecTAziendaGreening.VALORE_CALCOLATO_VARCHAR2 := gvDescErrInea;
  END IF;

  pRisultato := '0';
EXCEPTION
  WHEN OTHERS THEN
    pRisultato := '1';
    pMessaggio := 'Errore pl/sql in procedure DIM_AZ : ' || SUBSTR(SQLERRM,1,150)||' RIGA = '||dbms_utility.FORMAT_ERROR_BACKTRACE;
END DIM_AZ;

END Pck_Calcolo_Esito_Greening;

/
--------------------------------------------------------
--  DDL for Package Body PCK_CALCOLO_ULU
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_CALCOLO_ULU" AS

PROCEDURE MAIN (     pIdAzienda     IN     NUMBER,
                        pIdUde        IN     NUMBER,
                        pUlu            OUT     NUMBER,
                         pRetVal         OUT     NUMBER,
                        pDeserr        OUT     VARCHAR2
                    ) IS

    CURSOR CUR_PIANO     IS                             SELECT     UTL.ID_UTILIZZO,
                                                                        NVL(STO.ID_ZONA_ALTIMETRICA,1)                    ID_ZONA_ALTIMETRICA,
                                                                        NVL(SUM(NVL(UTL.SUPERFICIE_UTILIZZATA,0)),0)    SUPERFICIE_UTILIZZATA,
                                                                        NVL(PAR.BIOLOGICO,'N')                                BIOLOGICO,
                                                                        ID_CLASSE_ULU,
                                                                        FLAG_FORAGGERA,
                                                                        FLAG_AUTUNNO_VERNINI
                                                            FROM DB_CONDUZIONE_PARTICELLA CON,
                                                                  DB_UTILIZZO_PARTICELLA     UTL,
                                                                  DB_STORICO_PARTICELLA     STO,
                                                                  DB_PARTICELLA                PAR,
                                                                  DB_UTE                         UTE,
                                                                  DB_TIPO_UTILIZZO            TTL
                                                            WHERE      UTE.ID_AZIENDA                        =    pIdAzienda                                                            AND         UTE.DATA_FINE_ATTIVITA             IS NULL
                                                            AND        CON.ID_UTE                            = UTE.ID_UTE
                                                            AND        UTL.ID_UTILIZZO                    IS NOT NULL
                                                            AND         UTL.ID_UTILIZZO                    =     TTL.ID_UTILIZZO
                                                            AND        TTL.ANNO_FINE_VALIDITA            IS NULL
                                                            AND         CON.DATA_FINE_CONDUZIONE         IS NULL
                                                            AND         CON.ID_TITOLO_POSSESSO            <>    5
                                                            AND         UTL.ID_CONDUZIONE_PARTICELLA    =    CON.ID_CONDUZIONE_PARTICELLA
                                                            AND         CON.ID_PARTICELLA                    =    STO.ID_PARTICELLA
                                                            AND         STO.DATA_FINE_VALIDITA             IS NULL
                                                            AND        STO.ID_PARTICELLA                    = PAR.ID_PARTICELLA
                                                            GROUP BY UTL.ID_UTILIZZO,NVL(STO.ID_ZONA_ALTIMETRICA,1),PAR.BIOLOGICO,ID_CLASSE_ULU,FLAG_FORAGGERA,FLAG_AUTUNNO_VERNINI;



CURSOR CUR_ALV   IS            SELECT     SOT.ID_SOTTOCATEGORIA_ANIMALE,
                                    STA.ID_STABULAZIONE,
                                    COM.ZONAALT,
                                    FLAG_BIOLOGICO,
                                    NVL2(STA.ID_STABULAZIONE,NVL(SUM(STA.QUANTITA_STABULATI),0),NVL(SUM(SOT.QUANTITA),0)) QUANTITA,
--                                    NVL(SUM(SOT.QUANTITA),0)                QUANTITA_NO_STA,
--                                    NVL(SUM(STA.QUANTITA_STABULATI),0)    QUANTITA_STA
                                    ID_CLASSE_ULU
                        FROM  DB_ALLEVAMENTO                            ALV,
                                DB_CATEGORIE_ALLEVAMENTO             CAT,
                                DB_SOTTOCATEGORIA_ALLEVAMENTO     SOT,
                                DB_STABULAZIONE_TRATTAMENTO         STA,
                                COMUNE                                     COM,
                                DB_UTE                                     UTE,
                                DB_TIPO_SOTTOCATEGORIA_ANIMALE    SAN
                        WHERE      UTE.ID_AZIENDA                                =    pIdAzienda
                        AND         UTE.DATA_FINE_ATTIVITA                     IS    NULL
                        AND        ALV.ID_UTE                                    =     UTE.ID_UTE
                        AND        ALV.DATA_FINE                                 IS NULL
                        AND        SAN.ID_SOTTOCATEGORIA_ANIMALE            =     SOT.ID_SOTTOCATEGORIA_ANIMALE
                        AND        SAN.DATA_FINE_VALIDITA                     IS NULL
                        AND        SOT.ID_SOTTOCATEGORIA_ANIMALE            IS NOT NULL
                        AND         CAT.ID_ALLEVAMENTO                        =    ALV.ID_ALLEVAMENTO
                        AND         SOT.ID_CATEGORIE_ALLEVAMENTO            =    CAT.ID_CATEGORIE_ALLEVAMENTO
                        AND         SOT.ID_SOTTOCATEGORIA_ALLEVAMENTO     =    STA.ID_SOTTOCATEGORIA_ALLEVAMENTO(+)
                        AND         ALV.ISTAT_COMUNE                            =    COM.ISTAT_COMUNE
                        GROUP BY SOT.ID_SOTTOCATEGORIA_ANIMALE, STA.ID_STABULAZIONE,COM.ZONAALT,FLAG_BIOLOGICO,ID_CLASSE_ULU;

nTot                                NUMBER;
nIdUde                            NUMBER;
nCoefficenteUnitaMisura        DB_TIPO_CLASSE_ULU.COEFFICENTE_UNITA_MISURA%TYPE;
nValoreUlu                        DB_DETTAGLIO_CLASSE_ULU.VALORE_ULU%TYPE;

EXC_UDE                            EXCEPTION;
BEGIN


    IF pIdUde    IS NULL THEN
        SELECT ID_UDE
        INTO nIdUde
        FROM     DB_ANAGRAFICA_AZIENDA
        WHERE    ID_AZIENDA                        =    pIdAzienda
        AND     DATA_FINE_VALIDITA             IS NULL;
    ELSE
        nIdUde := pIdUde;
    END IF;

    IF nIdUde IS NULL THEN
        RAISE EXC_UDE;
    END IF;

    nTot := 0;

    FOR REC_P IN CUR_PIANO LOOP

        BEGIN
            SELECT     DET.VALORE_ULU,CLA.COEFFICENTE_UNITA_MISURA
            INTO nCoefficenteUnitaMisura,nValoreUlu
            FROM     DB_TIPO_CLASSE_ULU             CLA,
                    DB_DETTAGLIO_CLASSE_ULU        DET,
                    DB_TIPO_UDE                     UDE,
                    DB_TIPO_ZONA_ALTIMETRICA    ALT
            WHERE CLA.ID_CLASSE_ULU             =  REC_P.ID_CLASSE_ULU
            AND    DET.ID_CLASSE_ULU                =     CLA.ID_CLASSE_ULU
            AND    UDE.id_ude                        =    nIdUde
            AND    UDE.ID_CLASSE_AZIENDA_ULU    =    DET.ID_CLASSE_AZIENDA_ULU
            AND    DET.DATA_FINE_VALIDITA        IS NULL
            AND    DET.ID_STABULAZIONE            IS NULL
            AND    ALT.ID_ZONA_ALTIMETRICA        =     REC_P.ID_ZONA_ALTIMETRICA
            AND    DET.ID_ZONA_ALT_ULU            =     ALT.ID_ZONA_ALT_ULU;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                nCoefficenteUnitaMisura    :=    0;
                nValoreUlu                    :=    0;
        END;

        IF REC_P.BIOLOGICO = 'S' THEN
            IF REC_P.FLAG_FORAGGERA!= 'N' AND    rec_p.FLAG_AUTUNNO_VERNINI != 'N' THEN
                nValoreUlu := nValoreUlu + (nValoreUlu * 30 / 100);
            END IF;
         END IF;

        nTot := nTot + (REC_P.SUPERFICIE_UTILIZZATA * nCoefficenteUnitaMisura * nValoreUlu );

    END LOOP;

    FOR REC_A IN CUR_ALV LOOP


        BEGIN
            IF REC_A.ID_STABULAZIONE IS NULL THEN
                SELECT     DET.VALORE_ULU,CLA.COEFFICENTE_UNITA_MISURA
                INTO nCoefficenteUnitaMisura,nValoreUlu
                FROM     DB_TIPO_CLASSE_ULU             CLA,
                        DB_DETTAGLIO_CLASSE_ULU        DET,
                        DB_TIPO_UDE                     UDE,
                        DB_TIPO_ZONA_ALTIMETRICA    ALT
                WHERE CLA.ID_CLASSE_ULU             =  REC_A.ID_CLASSE_ULU
                AND    DET.ID_CLASSE_ULU                =     CLA.ID_CLASSE_ULU
                AND    UDE.id_ude                        =    nIdUde
                AND    UDE.ID_CLASSE_AZIENDA_ULU    =    DET.ID_CLASSE_AZIENDA_ULU
                AND    DET.DATA_FINE_VALIDITA        IS NULL
                AND    DET.ID_STABULAZIONE            IS NULL
                AND    ALT.ID_ZONA_ALTIMETRICA        =     REC_A.ZONAALT
                AND    DET.ID_ZONA_ALT_ULU            =     ALT.ID_ZONA_ALT_ULU;
            ELSE
                SELECT     DET.VALORE_ULU,CLA.COEFFICENTE_UNITA_MISURA
                INTO nCoefficenteUnitaMisura,nValoreUlu
                FROM     DB_TIPO_CLASSE_ULU             CLA,
                        DB_DETTAGLIO_CLASSE_ULU        DET,
                        DB_TIPO_UDE                     UDE,
                        DB_TIPO_ZONA_ALTIMETRICA    ALT
                WHERE CLA.ID_CLASSE_ULU             =  REC_A.ID_CLASSE_ULU
                AND    DET.ID_CLASSE_ULU                =     CLA.ID_CLASSE_ULU
                AND    UDE.id_ude                        =    nIdUde
                AND    UDE.ID_CLASSE_AZIENDA_ULU    =    DET.ID_CLASSE_AZIENDA_ULU
                AND    DET.DATA_FINE_VALIDITA        IS NULL
                AND    DET.ID_STABULAZIONE            =  REC_A.ID_STABULAZIONE
                AND    ALT.ID_ZONA_ALTIMETRICA        =     REC_A.ZONAALT
                AND    DET.ID_ZONA_ALT_ULU            =     ALT.ID_ZONA_ALT_ULU;

            END IF;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                nCoefficenteUnitaMisura    :=    0;
                nValoreUlu                    :=    0;
        END;

        IF REC_A.FLAG_BIOLOGICO = 'S' THEN
            nValoreUlu := nValoreUlu + (nValoreUlu * 30 / 100);
         END IF;

        nTot := nTot + (REC_A.QUANTITA * nCoefficenteUnitaMisura * nValoreUlu );

    END LOOP;


    pUlu             := ROUND((nTot/287),1);
    pRetVal         := 0;
    pDeserr        := NULL;

EXCEPTION
    WHEN EXC_UDE THEN
        pUlu             := NULL;
        pRetVal         := 0;
        pDeserr        := NULL;

    WHEN OTHERS THEN
        pUlu             := NULL;
        pRetVal         := 1;
        pDeserr        := 'ERRORE ORACLE NON GESTITO '||SUBSTR(SQLERRM,1,100);
END MAIN;

END Pck_Calcolo_Ulu;

/
--------------------------------------------------------
--  DDL for Package Body PCK_CARICA_MISURA_H
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_CARICA_MISURA_H" IS

    /*********************************************************************
    Dato un record di tipo DB_STORICO_PARTICELLA%ROWTYPE
    lo inserisce sulla stessa
    Tipo:   procedure
    input:  pRecStorPart
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InsertTStoricoParticella (pRecStorPart IN DB_STORICO_PARTICELLA%ROWTYPE) IS
    BEGIN
        INSERT INTO DB_STORICO_PARTICELLA (
                    ID_PARTICELLA,
                    ID_STORICO_PARTICELLA,
                    SEZIONE,
                    COMUNE,
                    DATA_INIZIO_VALIDITA,
                    FOGLIO,
                    DATA_FINE_VALIDITA,
                    PARTICELLA,
                    SUP_CATASTALE,
                    SUBALTERNO,
                    ID_AREA_A,
                    ID_ZONA_ALTIMETRICA,
                    FLAG_IRRIGABILE,
                    ID_AREA_B,
                    ID_CASO_PARTICOLARE,
                    ID_AREA_C,
                    ID_AREA_D,
                    DATA_AGGIORNAMENTO,
                    ID_UTENTE_AGGIORNAMENTO,
                    ID_CAUSALE_MOD_PARTICELLA,
                    FLAG_CAPTAZIONE_POZZI,
                    MOTIVO_MODIFICA,
                    SUP_NON_ELEGGIBILE,
                    SUP_NE_BOSCO_ACQUE_FABBRICATO,
                    SUP_NE_FORAGGIERE,
                    SUP_EL_FRUTTA_GUSCIO,
                    SUP_EL_PRATO_PASCOLO,
                    SUP_EL_COLTURE_MISTE,
                    SUP_COLTIVAZ_ARBOREA_CONS,
                    SUP_COLTIVAZ_ARBOREA_SPEC,
                    DATA_FOTO,
                    ID_FONTE,
                    TIPO_FOTO,
                    ID_DOCUMENTO,
                    ID_IRRIGAZIONE,
                    ID_DOCUMENTO_PROTOCOLLATO,
                    ID_FASCIA_FLUVIALE,
                    ID_AREA_G,
                    ID_AREA_H,
                    SUPERFICIE_GRAFICA,
                    ID_POTENZIALITA_IRRIGUA,
                    ID_TERRAZZAMENTO,
                    ID_ROTAZIONE_COLTURALE,
                    ID_AREA_L,
                    ID_AREA_I)
             VALUES
                   (
                    pRecStorPart.ID_PARTICELLA,
                    pRecStorPart.ID_STORICO_PARTICELLA,
                    pRecStorPart.SEZIONE,
                    pRecStorPart.COMUNE,
                    pRecStorPart.DATA_INIZIO_VALIDITA,
                    pRecStorPart.FOGLIO,
                    pRecStorPart.DATA_FINE_VALIDITA,
                    pRecStorPart.PARTICELLA,
                    pRecStorPart.SUP_CATASTALE,
                    pRecStorPart.SUBALTERNO,
                    pRecStorPart.ID_AREA_A,
                    pRecStorPart.ID_ZONA_ALTIMETRICA,
                    pRecStorPart.FLAG_IRRIGABILE,
                    pRecStorPart.ID_AREA_B,
                    pRecStorPart.ID_CASO_PARTICOLARE,
                    pRecStorPart.ID_AREA_C,
                    pRecStorPart.ID_AREA_D,
                    pRecStorPart.DATA_AGGIORNAMENTO,
                    pRecStorPart.ID_UTENTE_AGGIORNAMENTO,
                    pRecStorPart.ID_CAUSALE_MOD_PARTICELLA,
                    pRecStorPart.FLAG_CAPTAZIONE_POZZI,
                    pRecStorPart.MOTIVO_MODIFICA,
                    pRecStorPart.SUP_NON_ELEGGIBILE,
                    pRecStorPart.SUP_NE_BOSCO_ACQUE_FABBRICATO,
                    pRecStorPart.SUP_NE_FORAGGIERE,
                    pRecStorPart.SUP_EL_FRUTTA_GUSCIO,
                    pRecStorPart.SUP_EL_PRATO_PASCOLO,
                    pRecStorPart.SUP_EL_COLTURE_MISTE,
                    pRecStorPart.SUP_COLTIVAZ_ARBOREA_CONS,
                    pRecStorPart.SUP_COLTIVAZ_ARBOREA_SPEC,
                    pRecStorPart.DATA_FOTO,
                    pRecStorPart.ID_FONTE,
                    pRecStorPart.TIPO_FOTO,
                    pRecStorPart.ID_DOCUMENTO,
                    pRecStorPart.ID_IRRIGAZIONE,
                    pRecStorPart.ID_DOCUMENTO_PROTOCOLLATO,
                    pRecStorPart.ID_FASCIA_FLUVIALE,
                    pRecStorPart.ID_AREA_G,
                    pRecStorPart.ID_AREA_H,
                    pRecStorPart.SUPERFICIE_GRAFICA,
                    pRecStorPart.ID_POTENZIALITA_IRRIGUA,
                    pRecStorPart.ID_TERRAZZAMENTO,
                    pRecStorPart.ID_ROTAZIONE_COLTURALE,
                    pRecStorPart.ID_AREA_L,
                    pRecStorPart.ID_AREA_I);
    END InsertTStoricoParticella;

    /*********************************************************************
    Dato un record di tipo DB_PARTICELLA%ROWTYPE
    lo inserisce sulla stessa
    Tipo:   procedure
    input:  pRecConduzPart
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InsertTParticella (pRecPart IN DB_PARTICELLA%ROWTYPE) IS
    BEGIN
        INSERT INTO DB_PARTICELLA
                    (
                    ID_PARTICELLA,
                    DATA_CREAZIONE,
                    DATA_CESSAZIONE,
                    BIOLOGICO,
                    DATA_INIZIO_VALIDITA,
                    FLAG_SCHEDARIO
                    )
             VALUES (
                    pRecPart.ID_PARTICELLA,
                    pRecPart.DATA_CREAZIONE,
                    pRecPart.DATA_CESSAZIONE,
                    pRecPart.BIOLOGICO,
                    pRecPart.DATA_INIZIO_VALIDITA,
                    pRecPart.FLAG_SCHEDARIO
                    );
    END InsertTParticella;

    /*********************************************************************
    Dato un record di tipo DB_CONDUZIONE_PARTICELLA%ROWTYPE
    lo inserisce sulla stessa
    Tipo:   procedure
    input:  pRecConduzPart
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InsertTConduzioneParticella (pRecConduzPart IN DB_CONDUZIONE_PARTICELLA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_CONDUZIONE_PARTICELLA
                    (
                    ID_CONDUZIONE_PARTICELLA,
                    ID_PARTICELLA,
                    ID_TITOLO_POSSESSO,
                    ID_UTE,
                    SUPERFICIE_CONDOTTA,
                    FLAG_UTILIZZO_PARTE,
                    DATA_INIZIO_CONDUZIONE,
                    DATA_FINE_CONDUZIONE,
                    NOTE,
                    DATA_AGGIORNAMENTO,
                    ID_UTENTE_AGGIORNAMENTO,
                    ESITO_CONTROLLO,
                    DATA_ESECUZIONE,
                    RECORD_MODIFICATO,
                    DICHIARAZIONE_RIPRISTINATA,
                    ID_DICHIARAZIONE_CONSISTENZA--,
                 -- paolo 14/04/08 su indicazione di Ernesto, commento questa colonna, dato che in produzione non è presente        SUPERFICIE_AGRONOMICA
                    )
        VALUES (
                pRecConduzPart.ID_CONDUZIONE_PARTICELLA,
                pRecConduzPart.ID_PARTICELLA,
                pRecConduzPart.ID_TITOLO_POSSESSO,
                pRecConduzPart.ID_UTE,
                pRecConduzPart.SUPERFICIE_CONDOTTA,
                pRecConduzPart.FLAG_UTILIZZO_PARTE,
                pRecConduzPart.DATA_INIZIO_CONDUZIONE,
                pRecConduzPart.DATA_FINE_CONDUZIONE,
                pRecConduzPart.NOTE,
                pRecConduzPart.DATA_AGGIORNAMENTO,
                pRecConduzPart.ID_UTENTE_AGGIORNAMENTO,
                pRecConduzPart.ESITO_CONTROLLO,
                pRecConduzPart.DATA_ESECUZIONE,
                pRecConduzPart.RECORD_MODIFICATO,
                pRecConduzPart.DICHIARAZIONE_RIPRISTINATA,
                pRecConduzPart.ID_DICHIARAZIONE_CONSISTENZA --,
                -- paolo 14/04/08 su indicazione di Ernesto, commento questa colonna, dato che in produzione non è presentepRecConduzPart.SUPERFICIE_AGRONOMICA
                );

    END InsertTConduzioneParticella;

    /*********************************************************************
    Dati un id_conduzione_particella ed una superficie condotta
    aggiorna l'omonimo campo per quell'id_conduzione
    Tipo:   procedure
    input:  pnIdCondPart , pnTotSupCond
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE AggiornaConduzioneParticella (pnIdCondPart IN DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE,
                                            pnTotSupCond IN DB_CONDUZIONE_PARTICELLA.SUPERFICIE_CONDOTTA%TYPE) IS
    BEGIN
        UPDATE DB_CONDUZIONE_PARTICELLA
           SET SUPERFICIE_CONDOTTA = pnTotSupCond
         WHERE ID_CONDUZIONE_PARTICELLA = pnIdCondPart;
    END AggiornaConduzioneParticella;

    /*********************************************************************
    Dato un record di tipo DB_UTILIZZO_PARTICELLA%ROWTYPE
    lo inserisce sulla stessa
    Tipo:   procedure
    input:  pRecUtilizzoPart
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InsertTUtilizzoParticella (pRecUtilizzoPart IN DB_UTILIZZO_PARTICELLA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_UTILIZZO_PARTICELLA
                    (
                    ID_UTILIZZO_PARTICELLA,
                    ID_UTILIZZO,
                    ID_CONDUZIONE_PARTICELLA,
                    SUPERFICIE_UTILIZZATA,
                    DATA_AGGIORNAMENTO,
                    ID_UTENTE_AGGIORNAMENTO,
                    ANNO,
                    NOTE,
                    ID_UTILIZZO_SECONDARIO,
                    SUP_UTILIZZATA_SECONDARIA,
                    ID_VARIETA,
                    ID_VARIETA_SECONDARIA,
                    ANNO_IMPIANTO,
                    ID_IMPIANTO,
                    SESTO_SU_FILE,
                    SESTO_TRA_FILE,
                    NUMERO_PIANTE_CEPPI
                    )
        VALUES (
                pRecUtilizzoPart.ID_UTILIZZO_PARTICELLA,
                pRecUtilizzoPart.ID_UTILIZZO,
                pRecUtilizzoPart.ID_CONDUZIONE_PARTICELLA,
                pRecUtilizzoPart.SUPERFICIE_UTILIZZATA,
                pRecUtilizzoPart.DATA_AGGIORNAMENTO,
                pRecUtilizzoPart.ID_UTENTE_AGGIORNAMENTO,
                pRecUtilizzoPart.ANNO,
                pRecUtilizzoPart.NOTE,
                pRecUtilizzoPart.ID_UTILIZZO_SECONDARIO,
                pRecUtilizzoPart.SUP_UTILIZZATA_SECONDARIA,
                pRecUtilizzoPart.ID_VARIETA,
                pRecUtilizzoPart.ID_VARIETA_SECONDARIA,
                pRecUtilizzoPart.ANNO_IMPIANTO,
                pRecUtilizzoPart.ID_IMPIANTO,
                pRecUtilizzoPart.SESTO_SU_FILE,
                pRecUtilizzoPart.SESTO_TRA_FILE,
                pRecUtilizzoPart.NUMERO_PIANTE_CEPPI
                );
    END InsertTUtilizzoParticella;

    /*********************************************************************
    Prepara il record d'appoggio per l'inserimento su DB_PARTICELLA
    ed lo effettua ritornando l'identificativo della particella
    appena creato
    Tipo:   function
    input:  nessuno
    output: nessuno
    ritorno:DB_PARTICELLA.ID_PARTICELLA%TYPE
    *********************************************************************/
    FUNCTION InserimentoParticella RETURN DB_PARTICELLA.ID_PARTICELLA%TYPE IS
        recParticella DB_PARTICELLA%ROWTYPE;
    BEGIN

        SELECT SEQ_PARTICELLA.NEXTVAL
          INTO recParticella.id_particella
          FROM dual;

        recParticella.data_creazione := TRUNC(SYSDATE);
        recParticella.data_inizio_validita := TRUNC(SYSDATE);
        recParticella.flag_schedario := 'N';

        InsertTParticella (recParticella);

        RETURN recParticella.id_particella;
    END InserimentoParticella;
    /*********************************************************************
    Prepara il record d'appoggio per l'inserimento su DB_STORICO_PARTICELLA
    prelevando le informazioni dai record di appoggio ed effettua l'inserimento
    restituendo i valori inseriti in OUT nel record di appoggio
    Tipo:   procedure
    input:  pRecStoricoPart , pRecPartCert, pRecFoglio , pRecUte
    output: pRecStoricoPart
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InserimentoStoricoParticella (pRecStoricoPart IN OUT DB_STORICO_PARTICELLA%ROWTYPE,
                                            pRecPartCert    IN     DB_PARTICELLA_CERTIFICATA%ROWTYPE,
                                            pRecFoglio      IN     DB_FOGLIO%ROWTYPE,
                                            pRecUte         IN     DB_UTE%ROWTYPE) IS
    BEGIN
        SELECT SEQ_STORICO_PARTICELLA.NEXTVAL
          INTO pRecStoricoPart.id_storico_particella
          FROM dual;

        pRecStoricoPart.sezione := pRecPartCert.sezione;
        pRecStoricoPart.COMUNE := pRecPartCert.COMUNE;
        pRecStoricoPart.data_inizio_validita := TRUNC(SYSDATE);
        pRecStoricoPart.foglio := pRecPartCert.foglio;
        pRecStoricoPart.particella := pRecPartCert.particella;
        pRecStoricoPart.sup_catastale := pRecPartCert.sup_catastale;
        pRecStoricoPart.subalterno := pRecPartCert.subalterno;
        pRecStoricoPart.id_area_a := pRecFoglio.id_area_a;
        pRecStoricoPart.id_zona_altimetrica := pRecPartCert.id_zona_altimetrica;
        pRecStoricoPart.flag_irrigabile := 'N';
        pRecStoricoPart.id_area_b := pRecFoglio.id_area_b;
        pRecStoricoPart.id_caso_particolare := 99;
        pRecStoricoPart.id_area_c := pRecFoglio.id_area_c;
        pRecStoricoPart.id_area_d := pRecFoglio.id_area_d;
        pRecStoricoPart.id_area_g := pRecFoglio.id_area_g; 
        pRecStoricoPart.id_area_i := pRecFoglio.id_area_i; 
        pRecStoricoPart.id_area_l := pRecFoglio.id_area_l; 
        pRecStoricoPart.superficie_grafica := pRecPartCert.sup_grafica; 
        pRecStoricoPart.id_potenzialita_irrigua :=3; 
        pRecStoricoPart.id_terrazzamento := 1; 
        pRecStoricoPart.id_rotazione_colturale := 4; dichiarata
        pRecStoricoPart.data_aggiornamento := SYSDATE;
        pRecStoricoPart.id_utente_aggiornamento := pRecUte.id_utente_aggiornamento;
        pRecStoricoPart.flag_captazione_pozzi := 'N';

        InsertTStoricoParticella (pRecStoricoPart);

    END InserimentoStoricoParticella;

    /*********************************************************************
    Dato un record di tipo SMRGAA_WRK_MIGRAZIONE_H_P2%ROWTYPE
    ricerca sulla tavola SMRGAA_WRK_MIGR_H_TIPO_COLTURA per gli identificativi
    COD_INT, COD_MISURA E COD_SMIS
    Tipo:   function
    input:  pRecMisureH
    output: nessuno
    ritorno:SMRGAA_WRK_MIGR_H_TIPO_COLTURA%ROWTYPE
    *********************************************************************/
    FUNCTION SelectTTmpMigrHTipoColtura (pRecMisureH IN SMRGAA_WRK_MIGRAZIONE_H_P2%ROWTYPE)
    RETURN SMRGAA_WRK_MIGR_H_TIPO_COLTURA%ROWTYPE IS
        recTmpMigrHTpColt SMRGAA_WRK_MIGR_H_TIPO_COLTURA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTmpMigrHTpColt
          FROM SMRGAA_WRK_MIGR_H_TIPO_COLTURA
         WHERE IM_TSM_COD_INT = pRecMisureH.Cod_Int
           AND IM_TSM_COD_MIS = pRecMisureH.Cod_Misura
           AND IM_TSM_COD_SMIS = pRecMisureH.Cod_Smis
              AND    ANNO_FINE_VALIDITA IS NULL;

        RETURN recTmpMigrHTpColt;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
    END SelectTTmpMigrHTipoColtura;

    /*********************************************************************
    Valorizza ed inserisce il record su DB_CONDUZIONE_PARTICELLA prelevando i
    valori dai record di appoggio , restituisce l'id_conduzione_particella
    appena creato
    Tipo:   function
    input:  pRecAnagAzienda, pRecUteAzienda, pRecStoricoPart, pRecMisureH
    output: nessuno
    ritorno:NUMBER
    *********************************************************************/
    FUNCTION GestioneConduzioneParticella (pRecAnagAzienda IN DB_ANAGRAFICA_AZIENDA%ROWTYPE,
                                           pRecUteAzienda  IN DB_UTE%ROWTYPE,
                                           pRecStoricoPart IN DB_STORICO_PARTICELLA%ROWTYPE,
                                           pRecMisureH     IN SMRGAA_WRK_MIGRAZIONE_H_P2%ROWTYPE)
    RETURN NUMBER IS
        recTConduzionePart DB_CONDUZIONE_PARTICELLA%ROWTYPE;
    BEGIN

        SELECT SEQ_CONDUZIONE_PARTICELLA.NEXTVAL
          INTO recTConduzionePart.id_conduzione_particella
          FROM dual;

        recTConduzionePart.id_particella := pRecStoricoPart.id_particella;
        recTConduzionePart.id_titolo_possesso := NVL(TRIM(SUBSTR(pRecMisureH.Conduzione,1,1)),4);
        recTConduzionePart.id_ute := pRecUteAzienda.id_ute;
        recTConduzionePart.superficie_condotta := 0 ;
        recTConduzionePart.data_inizio_conduzione := SYSDATE;
        recTConduzionePart.note := 'IMPORTAZIONE DA PRATICHE DI MISURA H';
        recTConduzionePart.data_aggiornamento := SYSDATE;
        recTConduzionePart.id_utente_aggiornamento := pRecUteAzienda.id_utente_aggiornamento;

        InsertTConduzioneParticella (recTConduzionePart);

        RETURN recTConduzionePart.id_conduzione_particella;

    END GestioneConduzioneParticella;

   /*********************************************************************
    Valorizza ed inserisce il record su DB_UTILIZZO_PARTICELLA prelevando i
    valori dai record di appoggio.
    Tipo:   procedure
    input:  pnIdConduzPart, pRecUteAzienda, pRecMisureH
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE AggiungiUtilizzoParticella(pnIdConduzPart DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE,
                                         pRecUteAzienda DB_UTE%ROWTYPE,
                                         pRecMisureH    SMRGAA_WRK_MIGRAZIONE_H_P2%ROWTYPE) IS
        recTUtilPart            DB_UTILIZZO_PARTICELLA%ROWTYPE;
        recTmpMigrHTipoColtura  SMRGAA_WRK_MIGR_H_TIPO_COLTURA%ROWTYPE;
    BEGIN
        SELECT SEQ_UTILIZZO_PARTICELLA.NEXTVAL
          INTO recTUtilPart.id_utilizzo_particella
          FROM dual;

        recTmpMigrHTipoColtura := SelectTTmpMigrHTipoColtura(pRecMisureH);

        recTUtilPart.id_utilizzo := recTmpMigrHTipoColtura.id_utilizzo;
        recTUtilPart.id_varieta := recTmpMigrHTipoColtura.id_varieta;
        recTUtilPart.id_conduzione_particella := pnIdConduzPart;
        recTUtilPart.superficie_utilizzata := pRecMisureH.sup_amm;
        recTUtilPart.data_aggiornamento := SYSDATE;
        recTUtilPart.id_utente_aggiornamento := pRecUteAzienda.id_utente_aggiornamento;
        recTUtilPart.anno := TO_CHAR(SYSDATE,'YYYY');

        InsertTUtilizzoParticella (recTUtilPart);

    END AggiungiUtilizzoParticella;

    /*********************************************************************
    Dato un id_azienda ricerca gli ultimi dati anagrafici
    Tipo:   function
    input:  pIdAzienda
    output: nessuno
    ritorno:DB_ANAGRAFICA_AZIENDA%ROWTYPE
    *********************************************************************/
    FUNCTION SelectTAnagraficaAzienda (pIdAzienda DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE)
    RETURN DB_ANAGRAFICA_AZIENDA%ROWTYPE IS
        recAnagrAzienda DB_ANAGRAFICA_AZIENDA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recAnagrAzienda
          FROM DB_ANAGRAFICA_AZIENDA
         WHERE ID_AZIENDA = pIdAzienda
           AND TRUNC(SYSDATE) BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,TRUNC(SYSDATE));

        RETURN recAnagrAzienda;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelectTAnagraficaAzienda;

    /*********************************************************************
    Dato un id_azienda ricerco la corrispettiva unità tecnico economica
    sono nel caso in cui l'azienda è appena stata creata quindi ha una sola
    UTE oppure nessuna
    Tipo:   function
    input:  pIdAzienda
    output: nessuno
    ritorno:DB_UTE%ROWTYPE
    *********************************************************************/
    FUNCTION SelectTUnitaTecnicoEconomica (pIdAzienda DB_UTE.ID_AZIENDA%TYPE)
    RETURN DB_UTE%ROWTYPE IS
        recUTE DB_UTE%ROWTYPE;
    BEGIN

        SELECT *
          INTO recUTE
          FROM DB_UTE
         WHERE ID_AZIENDA = pIdAzienda
           AND TRUNC(SYSDATE) BETWEEN DATA_INIZIO_ATTIVITA AND NVL(DATA_FINE_ATTIVITA,TRUNC(SYSDATE));

        RETURN recUTE;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelectTUnitaTecnicoEconomica;

    /*********************************************************************
    Controlla se c'è stato un cambio di chiave catastale fra il record corrente
    (pRecMisureH) e quello elaborato precedentemente (pvAppIstatComu, pvAppSezione, etc)
    Tipo:   function
    input:  pRecMisureH,pvAppIstatComu,pvAppSezione,pnAppFoglio,pnAppParticel
    output: nessuno
    ritorno:TRUE/FALSE
    *********************************************************************/
    FUNCTION CambioChiaveCatastale (pRecMisureH     SMRGAA_WRK_MIGRAZIONE_H_P2%ROWTYPE,
                                    pvAppIstatComu  SMRGAA_WRK_MIGRAZIONE_H_P2.ISTAT_COMUNE%TYPE,
                                    pvAppSezione    SMRGAA_WRK_MIGRAZIONE_H_P2.SEZIONE%TYPE,
                                    pnAppFoglio     SMRGAA_WRK_MIGRAZIONE_H_P2.FOGLIO%TYPE,
                                    pnAppParticel   SMRGAA_WRK_MIGRAZIONE_H_P2.PARTICELLA%TYPE) RETURN BOOLEAN IS

    BEGIN

        IF pRecMisureH.ISTAT_COMUNE <> pvAppIstatComu OR
           NVL(pRecMisureH.sezione,'?') <> NVL(pvAppSezione,'?') OR
           pRecMisureH.foglio <> pnAppFoglio OR
           pRecMisureH.particella  <> pnAppParticel THEN

           RETURN TRUE;
        ELSE
           RETURN FALSE;
        END IF;
    END CambioChiaveCatastale;

    /*********************************************************************
    Effettua la ricerca (per chiave catastale) della particella su DB_STORICO_PARTICELLA
    Tipo:   function
    input:  pRecMisureH
    output: nessuno
    ritorno:DB_STORICO_PARTICELLA%ROWTYPE
    *********************************************************************/
    FUNCTION RicercaStoricoParticella (pRecMisureH SMRGAA_WRK_MIGRAZIONE_H_P2%ROWTYPE)
    RETURN DB_STORICO_PARTICELLA%ROWTYPE IS
        recStorPart DB_STORICO_PARTICELLA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recStorPart
          FROM DB_STORICO_PARTICELLA
         WHERE COMUNE =  pRecMisureH.ISTAT_COMUNE
           AND FOGLIO = pRecMisureH.foglio
           AND NVL(SEZIONE,'?') = NVL(pRecMisureH.sezione,'?')
           AND PARTICELLA = pRecMisureH.particella
           AND SUBALTERNO IS NULL
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recStorPart;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
        WHEN TOO_MANY_ROWS THEN
             RETURN NULL;
    END RicercaStoricoParticella;

    /*********************************************************************
    Effettua una selezione su DB_FOGLIO per istat_comune, foglio e sezione
    Tipo:   function
    input:  pRecMisureH
    output: nessuno
    ritorno:DB_FOGLIO%ROWTYPE
    *********************************************************************/
    FUNCTION SelectTFoglio (pRecPartCert IN DB_PARTICELLA_CERTIFICATA%ROWTYPE)
    RETURN DB_FOGLIO%ROWTYPE IS
        recFoglio DB_FOGLIO%ROWTYPE;
    BEGIN

        SELECT *
          INTO recFoglio
          FROM DB_FOGLIO
         WHERE COMUNE =  pRecPartCert.COMUNE
           AND FOGLIO = pRecPartCert.foglio
           AND NVL(SEZIONE,'?') = NVL(pRecPartCert.sezione,'?');

        RETURN recFoglio;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
    END SelectTFoglio;


    /*********************************************************************
    Effettua la ricerca (per chiave catastale) della particella su DB_PARTICELLA_CERTIFICATA
    Tipo:   function
    input:  pRecMisureH
    output: nessuno
    ritorno:DB_PARTICELLA_CERTIFICATA%ROWTYPE
    *********************************************************************/
    FUNCTION RicercaParticellaCertificata (pRecMisureH SMRGAA_WRK_MIGRAZIONE_H_P2%ROWTYPE)
    RETURN DB_PARTICELLA_CERTIFICATA%ROWTYPE IS
        recPartCert DB_PARTICELLA_CERTIFICATA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recPartCert
          FROM DB_PARTICELLA_CERTIFICATA
         WHERE COMUNE =  pRecMisureH.ISTAT_COMUNE
           AND FOGLIO = pRecMisureH.foglio
           AND NVL(SEZIONE,'?') = NVL(pRecMisureH.sezione,'?')
           AND PARTICELLA = pRecMisureH.particella
           AND SUBALTERNO IS NULL
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recPartCert;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
        WHEN TOO_MANY_ROWS THEN
             RETURN NULL;
    END RicercaParticellaCertificata;

    /*********************************************************************
    Dato un ID_AZIENDA inserisco tutti gli utilizzi e le condizioni
    reperite tramite il CUAA su SMRGAA_WRK_MIGRAZIONE_H_P2 nelle tavole
    DB_CONDUZIONE_PARTICELLA e DB_UTILIZZO_PARTICELLA
    Tipo:   function
    input:  pIdAzienda
    output: nessuno
    ritorno: TRUE / FALSE
    *********************************************************************/
    PROCEDURE MAIN (pIdAzienda IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                    pCodErr       IN OUT VARCHAR2,
                     pMsgErr    IN OUT VARCHAR2) IS

        recAnagAzienda DB_ANAGRAFICA_AZIENDA%ROWTYPE;
        recUteAzienda  DB_UTE%ROWTYPE;
        recStoricoPart DB_STORICO_PARTICELLA%ROWTYPE;
        recPartCertif  DB_PARTICELLA_CERTIFICATA%ROWTYPE;
        recFoglio      DB_FOGLIO%ROWTYPE;

        vAppIstatComu  SMRGAA_WRK_MIGRAZIONE_H_P2.ISTAT_COMUNE%TYPE:= '######';
        vAppSezione    SMRGAA_WRK_MIGRAZIONE_H_P2.SEZIONE%TYPE:= '#';
        nAppFoglio     SMRGAA_WRK_MIGRAZIONE_H_P2.FOGLIO%TYPE := -9999;
        nAppParticel   SMRGAA_WRK_MIGRAZIONE_H_P2.PARTICELLA%TYPE := -99999;

        nIdConduzPart  DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
        nTotSupCond    DB_CONDUZIONE_PARTICELLA.SUPERFICIE_CONDOTTA%TYPE;

        bFoundPart     BOOLEAN:=FALSE;


        CURSOR curMisureH (pCuaa IN VARCHAR2) IS
        SELECT *
          FROM SMRGAA_WRK_MIGRAZIONE_H_P2
         WHERE CUAA = pCuaa
        ORDER BY Istat_Comune, Sezione, Foglio, Particella;

    BEGIN
        -- mi cerco il CUAA su DB_ANAGRAFICA_AZIENDA
        recAnagAzienda := SelectTAnagraficaAzienda(pIdAzienda);
        -- se l'ho trovo
        IF recAnagAzienda.CUAA IS NOT NULL THEN
           -- mi cerco l'ID_UTE su DB_UTE
           recUteAzienda :=  SelectTUnitaTecnicoEconomica(pIdAzienda);
           -- se trovo anche questo
           IF recUteAzienda.ID_UTE IS NOT NULL THEN
               -- seleziono tutte i record su SMRGAA_WRK_MIGRAZIONE_H_P2
               -- per il CUAA ordinandole per chiave catastale
               FOR recMisureH IN curMisureH (recAnagAzienda.CUAA) LOOP
                   -- a rottura di chiave catastale
                   IF CambioChiaveCatastale (recMisureH,
                                             vAppIstatComu,
                                             vAppSezione,
                                             nAppFoglio,
                                             nAppParticel) THEN
                       -- se non sono appena entrato nel ciclo
                       IF vAppIstatComu <> '######' THEN
                          -- se avevo trovato la particella su DB_STORICO_PARTICELLA
                          IF bFoundPart THEN
                            -- aggiorno la superficie condotta con la somma
                            -- delle superficie utilizzate a rottura di chiave catastale
                            AggiornaConduzioneParticella (nIdConduzPart,nTotSupCond);
                          END IF;
                       END IF;
                       -- mi salvo la vecchia chiave catastale
                       vAppIstatComu := recMisureH.istat_comune;
                       vAppSezione := recMisureH.sezione;
                       nAppFoglio := recMisureH.foglio;
                       nAppParticel := recMisureH.particella;
                       -- ricerco per chiave catastale su DB_STORICO_PARTICELLA
                       recStoricoPart := RicercaStoricoParticella (recMisureH);
                       -- se ho trovato qualcosa
                       IF recStoricoPart.id_storico_particella IS NOT NULL THEN
                          -- assegno alla boolena TRUE
                          bFoundPart := TRUE;
                       ELSE
                          -- altrimenti ricerco su DB_PARTICELLA_CERTIFICATA
                          recPartCertif := RicercaParticellaCertificata (recMisureH);
                          -- se trovo una corrispondenza
                          IF recPartCertif.id_particella_certificata IS NOT NULL THEN
                             -- cerco il corrispondente record su DB_FOGLIO
                             recFoglio := SelectTFoglio (recPartCertif);
                             -- inserisco la particella su DB_PARTICELLA
                             recStoricoPart.id_particella := InserimentoParticella;
                             -- inserisco lo storico particella su DB_PARTICELLA_STORICO
                             InserimentoStoricoParticella (recStoricoPart, recPartCertif, recFoglio,recUteAzienda);
                             bFoundPart := TRUE;
                          ELSE
                             bFoundPart := FALSE;
                          END IF;
                       END IF;

                       IF bFoundPart THEN
                          -- inserisco il record su DB_CONDUZIONE_PARTICELLA con
                          -- superficie condotta a 0 e mi salvo l'id in una variabile di appoggio
                          nIdConduzPart := GestioneConduzioneParticella(recAnagAzienda,recUteAzienda,recStoricoPart,recMisureH);
                       END IF;
                       -- azzero la variabile di appoggio per la somma delle superficie utilizzate dei
                       -- singoli utilizzi
                       nTotSupCond := 0;
                   END IF;
                   -- se avevo trovato la particella su
                   -- DB_STORICO_PARTICELLA
                   IF bFoundPart THEN
                      -- sommo la superficie del singolo utilizzo
                      nTotSupCond := nTotSupCond + recMisureH.sup_amm;
                      -- inserisco il singolo utilizzo associandola alla
                      -- conduzione inserita precedentemente
                      AggiungiUtilizzoParticella(nIdConduzPart,recUteAzienda,recMisureH);
                   END IF;

               END LOOP;
               -- devo aggiornare l'ultima superficie utilizzata
               -- fuori ciclo
               IF bFoundPart THEN
                  -- aggiorno la superficie condotta con la somma
                  -- delle superficie utilizzate a rottura di chiave catastale
                  AggiornaConduzioneParticella (nIdConduzPart,nTotSupCond);
               END IF;

           END IF;

        END IF;

        --COMMIT;


    EXCEPTION
        WHEN OTHERS THEN
           --ROLLBACK;
             pCodErr := SQLCODE;
             pMsgErr := 'Errore nella procedure PCK_CARICA_MISURA_H.MAIN : ' || SUBSTR(SQLERRM,1,250);
    END MAIN;

END Pck_Carica_Misura_H;

/
--------------------------------------------------------
--  DDL for Package Body PCK_CARICA_MISURA_H_ALTRO_CUAA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_CARICA_MISURA_H_ALTRO_CUAA" IS

    /*********************************************************************
    Dato un record di tipo DB_STORICO_PARTICELLA%ROWTYPE
    lo inserisce sulla stessa
    Tipo:   procedure
    input:  pRecStorPart
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InsertTStoricoParticella (pRecStorPart IN DB_STORICO_PARTICELLA%ROWTYPE) IS
    BEGIN
        INSERT INTO DB_STORICO_PARTICELLA (
                    ID_PARTICELLA,
                    ID_STORICO_PARTICELLA,
                    SEZIONE,
                    COMUNE,
                    DATA_INIZIO_VALIDITA,
                    FOGLIO,
                    DATA_FINE_VALIDITA,
                    PARTICELLA,
                    SUP_CATASTALE,
                    SUBALTERNO,
                    ID_AREA_A,
                    ID_ZONA_ALTIMETRICA,
                    FLAG_IRRIGABILE,
                    ID_AREA_B,
                    ID_CASO_PARTICOLARE,
                    ID_AREA_C,
                    ID_AREA_D,
                    DATA_AGGIORNAMENTO,
                    ID_UTENTE_AGGIORNAMENTO,
                    ID_CAUSALE_MOD_PARTICELLA,
                    FLAG_CAPTAZIONE_POZZI,
                    MOTIVO_MODIFICA,
                    SUP_NON_ELEGGIBILE,
                    SUP_NE_BOSCO_ACQUE_FABBRICATO,
                    SUP_NE_FORAGGIERE,
                    SUP_EL_FRUTTA_GUSCIO,
                    SUP_EL_PRATO_PASCOLO,
                    SUP_EL_COLTURE_MISTE,
                    SUP_COLTIVAZ_ARBOREA_CONS,
                    SUP_COLTIVAZ_ARBOREA_SPEC,
                    DATA_FOTO,
                    ID_FONTE,
                    TIPO_FOTO,
                    ID_DOCUMENTO,
                    ID_IRRIGAZIONE,
                    ID_DOCUMENTO_PROTOCOLLATO,
                    ID_FASCIA_FLUVIALE,
                    ID_AREA_G,
                    ID_AREA_H,
                    SUPERFICIE_GRAFICA,
                    ID_POTENZIALITA_IRRIGUA,
                    ID_TERRAZZAMENTO,
                    ID_ROTAZIONE_COLTURALE,
                    ID_AREA_L,
                    ID_AREA_I
                    )
             VALUES
                   (
                    pRecStorPart.ID_PARTICELLA,
                    pRecStorPart.ID_STORICO_PARTICELLA,
                    pRecStorPart.SEZIONE,
                    pRecStorPart.COMUNE,
                    pRecStorPart.DATA_INIZIO_VALIDITA,
                    pRecStorPart.FOGLIO,
                    pRecStorPart.DATA_FINE_VALIDITA,
                    pRecStorPart.PARTICELLA,
                    pRecStorPart.SUP_CATASTALE,
                    pRecStorPart.SUBALTERNO,
                    pRecStorPart.ID_AREA_A,
                    pRecStorPart.ID_ZONA_ALTIMETRICA,
                    pRecStorPart.FLAG_IRRIGABILE,
                    pRecStorPart.ID_AREA_B,
                    pRecStorPart.ID_CASO_PARTICOLARE,
                    pRecStorPart.ID_AREA_C,
                    pRecStorPart.ID_AREA_D,
                    pRecStorPart.DATA_AGGIORNAMENTO,
                    pRecStorPart.ID_UTENTE_AGGIORNAMENTO,
                    pRecStorPart.ID_CAUSALE_MOD_PARTICELLA,
                    pRecStorPart.FLAG_CAPTAZIONE_POZZI,
                    pRecStorPart.MOTIVO_MODIFICA,
                    pRecStorPart.SUP_NON_ELEGGIBILE,
                    pRecStorPart.SUP_NE_BOSCO_ACQUE_FABBRICATO,
                    pRecStorPart.SUP_NE_FORAGGIERE,
                    pRecStorPart.SUP_EL_FRUTTA_GUSCIO,
                    pRecStorPart.SUP_EL_PRATO_PASCOLO,
                    pRecStorPart.SUP_EL_COLTURE_MISTE,
                    pRecStorPart.SUP_COLTIVAZ_ARBOREA_CONS,
                    pRecStorPart.SUP_COLTIVAZ_ARBOREA_SPEC,
                    pRecStorPart.DATA_FOTO,
                    pRecStorPart.ID_FONTE,
                    pRecStorPart.TIPO_FOTO,
                    pRecStorPart.ID_DOCUMENTO,
                    pRecStorPart.ID_IRRIGAZIONE,
                    pRecStorPart.ID_DOCUMENTO_PROTOCOLLATO,
                    pRecStorPart.ID_FASCIA_FLUVIALE,
                    pRecStorPart.ID_AREA_G,
                    pRecStorPart.ID_AREA_H,
                    pRecStorPart.SUPERFICIE_GRAFICA,
                    pRecStorPart.ID_POTENZIALITA_IRRIGUA,
                    pRecStorPart.ID_TERRAZZAMENTO,
                    pRecStorPart.ID_ROTAZIONE_COLTURALE,
                    pRecStorPart.ID_AREA_L,
                    pRecStorPart.ID_AREA_I
                    );
    END InsertTStoricoParticella;

    /*********************************************************************
    Dato un record di tipo DB_PARTICELLA%ROWTYPE
    lo inserisce sulla stessa
    Tipo:   procedure
    input:  pRecConduzPart
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InsertTParticella (pRecPart IN DB_PARTICELLA%ROWTYPE) IS
    BEGIN
        INSERT INTO DB_PARTICELLA
                    (
                    ID_PARTICELLA,
                    DATA_CREAZIONE,
                    DATA_CESSAZIONE,
                    BIOLOGICO,
                    DATA_INIZIO_VALIDITA,
                    FLAG_SCHEDARIO
                    )
             VALUES (
                    pRecPart.ID_PARTICELLA,
                    pRecPart.DATA_CREAZIONE,
                    pRecPart.DATA_CESSAZIONE,
                    pRecPart.BIOLOGICO,
                    pRecPart.DATA_INIZIO_VALIDITA,
                    pRecPart.FLAG_SCHEDARIO
                    );
    END InsertTParticella;

    /*********************************************************************
    Dato un record di tipo DB_CONDUZIONE_PARTICELLA%ROWTYPE
    lo inserisce sulla stessa
    Tipo:   procedure
    input:  pRecConduzPart
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InsertTConduzioneParticella (pRecConduzPart IN DB_CONDUZIONE_PARTICELLA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_CONDUZIONE_PARTICELLA
                    (
                    ID_CONDUZIONE_PARTICELLA,
                    ID_PARTICELLA,
                    ID_TITOLO_POSSESSO,
                    ID_UTE,
                    SUPERFICIE_CONDOTTA,
                    FLAG_UTILIZZO_PARTE,
                    DATA_INIZIO_CONDUZIONE,
                    DATA_FINE_CONDUZIONE,
                    NOTE,
                    DATA_AGGIORNAMENTO,
                    ID_UTENTE_AGGIORNAMENTO,
                    ESITO_CONTROLLO,
                    DATA_ESECUZIONE,
                    RECORD_MODIFICATO,
                    DICHIARAZIONE_RIPRISTINATA,
                    ID_DICHIARAZIONE_CONSISTENZA --,
                    -- paolo 14/04/08 su indicazione di Ernesto, commento questa colonna, dato che in produzione non è presente  SUPERFICIE_AGRONOMICA
                    )
        VALUES (
                pRecConduzPart.ID_CONDUZIONE_PARTICELLA,
                pRecConduzPart.ID_PARTICELLA,
                pRecConduzPart.ID_TITOLO_POSSESSO,
                pRecConduzPart.ID_UTE,
                pRecConduzPart.SUPERFICIE_CONDOTTA,
                pRecConduzPart.FLAG_UTILIZZO_PARTE,
                pRecConduzPart.DATA_INIZIO_CONDUZIONE,
                pRecConduzPart.DATA_FINE_CONDUZIONE,
                pRecConduzPart.NOTE,
                pRecConduzPart.DATA_AGGIORNAMENTO,
                pRecConduzPart.ID_UTENTE_AGGIORNAMENTO,
                pRecConduzPart.ESITO_CONTROLLO,
                pRecConduzPart.DATA_ESECUZIONE,
                pRecConduzPart.RECORD_MODIFICATO,
                pRecConduzPart.DICHIARAZIONE_RIPRISTINATA,
                pRecConduzPart.ID_DICHIARAZIONE_CONSISTENZA --,
                -- paolo 14/04/08 su indicazione di Ernesto, commento questa colonna, dato che in produzione non è presente    pRecConduzPart.SUPERFICIE_AGRONOMICA
                );

    END InsertTConduzioneParticella;

    /*********************************************************************
    Dati un id_conduzione_particella ed una superficie condotta
    aggiorna l'omonimo campo per quell'id_conduzione
    Tipo:   procedure
    input:  pnIdCondPart , pnTotSupCond
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE AggiornaConduzioneParticella (pnIdCondPart IN DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE,
                                            pnTotSupCond IN DB_CONDUZIONE_PARTICELLA.SUPERFICIE_CONDOTTA%TYPE) IS
    BEGIN
        UPDATE DB_CONDUZIONE_PARTICELLA
           SET SUPERFICIE_CONDOTTA = pnTotSupCond
         WHERE ID_CONDUZIONE_PARTICELLA = pnIdCondPart;
    END AggiornaConduzioneParticella;

    /*********************************************************************
    Dato un record di tipo DB_UTILIZZO_PARTICELLA%ROWTYPE
    lo inserisce sulla stessa
    Tipo:   procedure
    input:  pRecUtilizzoPart
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InsertTUtilizzoParticella (pRecUtilizzoPart IN DB_UTILIZZO_PARTICELLA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_UTILIZZO_PARTICELLA
                    (
                    ID_UTILIZZO_PARTICELLA,
                    ID_UTILIZZO,
                    ID_CONDUZIONE_PARTICELLA,
                    SUPERFICIE_UTILIZZATA,
                    DATA_AGGIORNAMENTO,
                    ID_UTENTE_AGGIORNAMENTO,
                    ANNO,
                    NOTE,
                    ID_UTILIZZO_SECONDARIO,
                    SUP_UTILIZZATA_SECONDARIA,
                    ID_VARIETA,
                    ID_VARIETA_SECONDARIA,
                    ANNO_IMPIANTO,
                    ID_IMPIANTO,
                    SESTO_SU_FILE,
                    SESTO_TRA_FILE,
                    NUMERO_PIANTE_CEPPI
                    )
        VALUES (
                pRecUtilizzoPart.ID_UTILIZZO_PARTICELLA,
                pRecUtilizzoPart.ID_UTILIZZO,
                pRecUtilizzoPart.ID_CONDUZIONE_PARTICELLA,
                pRecUtilizzoPart.SUPERFICIE_UTILIZZATA,
                pRecUtilizzoPart.DATA_AGGIORNAMENTO,
                pRecUtilizzoPart.ID_UTENTE_AGGIORNAMENTO,
                pRecUtilizzoPart.ANNO,
                pRecUtilizzoPart.NOTE,
                pRecUtilizzoPart.ID_UTILIZZO_SECONDARIO,
                pRecUtilizzoPart.SUP_UTILIZZATA_SECONDARIA,
                pRecUtilizzoPart.ID_VARIETA,
                pRecUtilizzoPart.ID_VARIETA_SECONDARIA,
                pRecUtilizzoPart.ANNO_IMPIANTO,
                pRecUtilizzoPart.ID_IMPIANTO,
                pRecUtilizzoPart.SESTO_SU_FILE,
                pRecUtilizzoPart.SESTO_TRA_FILE,
                pRecUtilizzoPart.NUMERO_PIANTE_CEPPI
                );
    END InsertTUtilizzoParticella;

    /*********************************************************************
    Prepara il record d'appoggio per l'inserimento su DB_PARTICELLA
    ed lo effettua ritornando l'identificativo della particella
    appena creato
    Tipo:   function
    input:  nessuno
    output: nessuno
    ritorno:DB_PARTICELLA.ID_PARTICELLA%TYPE
    *********************************************************************/
    FUNCTION InserimentoParticella RETURN DB_PARTICELLA.ID_PARTICELLA%TYPE IS
        recParticella DB_PARTICELLA%ROWTYPE;
    BEGIN

        SELECT SEQ_PARTICELLA.NEXTVAL
          INTO recParticella.id_particella
          FROM dual;

        recParticella.data_creazione := TRUNC(SYSDATE);
        recParticella.data_inizio_validita := TRUNC(SYSDATE);
        recParticella.flag_schedario := 'N';

        InsertTParticella (recParticella);

        RETURN recParticella.id_particella;
    END InserimentoParticella;
    /*********************************************************************
    Prepara il record d'appoggio per l'inserimento su DB_STORICO_PARTICELLA
    prelevando le informazioni dai record di appoggio ed effettua l'inserimento
    restituendo i valori inseriti in OUT nel record di appoggio
    Tipo:   procedure
    input:  pRecStoricoPart , pRecPartCert, pRecFoglio , pRecUte
    output: pRecStoricoPart
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InserimentoStoricoParticella (pRecStoricoPart IN OUT DB_STORICO_PARTICELLA%ROWTYPE,
                                            pRecPartCert    IN     DB_PARTICELLA_CERTIFICATA%ROWTYPE,
                                            pRecFoglio      IN     DB_FOGLIO%ROWTYPE,
                                            pRecUte         IN     DB_UTE%ROWTYPE) IS
    BEGIN
        SELECT SEQ_STORICO_PARTICELLA.NEXTVAL
          INTO pRecStoricoPart.id_storico_particella
          FROM dual;

        pRecStoricoPart.sezione := pRecPartCert.sezione;
        pRecStoricoPart.COMUNE := pRecPartCert.COMUNE;
        pRecStoricoPart.data_inizio_validita := TRUNC(SYSDATE);
        pRecStoricoPart.foglio := pRecPartCert.foglio;
        pRecStoricoPart.particella := pRecPartCert.particella;
        pRecStoricoPart.sup_catastale := pRecPartCert.sup_catastale;
        pRecStoricoPart.subalterno := pRecPartCert.subalterno;
        pRecStoricoPart.id_area_a := pRecFoglio.id_area_a;
        pRecStoricoPart.id_zona_altimetrica := pRecPartCert.id_zona_altimetrica;
        pRecStoricoPart.flag_irrigabile := 'N';
        pRecStoricoPart.id_area_b := pRecFoglio.id_area_b;
        pRecStoricoPart.id_caso_particolare := 99;
        pRecStoricoPart.id_area_c := pRecFoglio.id_area_c;
        pRecStoricoPart.id_area_d := pRecFoglio.id_area_d;
        pRecStoricoPart.id_area_g := pRecFoglio.id_area_g; 
        pRecStoricoPart.id_area_i := pRecFoglio.id_area_i; 
        pRecStoricoPart.id_area_l := pRecFoglio.id_area_l; 
        pRecStoricoPart.superficie_grafica := pRecPartCert.sup_grafica; 
        pRecStoricoPart.id_potenzialita_irrigua :=3; 
        pRecStoricoPart.id_terrazzamento := 1; 
        pRecStoricoPart.id_rotazione_colturale := 4; 
        pRecStoricoPart.data_aggiornamento := SYSDATE;
        pRecStoricoPart.id_utente_aggiornamento := pRecUte.id_utente_aggiornamento;
        pRecStoricoPart.flag_captazione_pozzi := 'N';

        InsertTStoricoParticella (pRecStoricoPart);

    END InserimentoStoricoParticella;

    /*********************************************************************
    Dato un record di tipo SMRGAA_WRK_MIGRAZIONE_H_P2%ROWTYPE
    ricerca sulla tavola SMRGAA_WRK_MIGR_H_TIPO_COLTURA per gli identificativi
    COD_INT, COD_MISURA E COD_SMIS
    Tipo:   function
    input:  pRecMisureH
    output: nessuno
    ritorno:SMRGAA_WRK_MIGR_H_TIPO_COLTURA%ROWTYPE
    *********************************************************************/
    FUNCTION SelectTTmpMigrHTipoColtura (pRecMisureH IN SMRGAA_WRK_MIGRAZIONE_H_P2%ROWTYPE)
    RETURN SMRGAA_WRK_MIGR_H_TIPO_COLTURA%ROWTYPE IS
        recTmpMigrHTpColt SMRGAA_WRK_MIGR_H_TIPO_COLTURA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTmpMigrHTpColt
          FROM SMRGAA_WRK_MIGR_H_TIPO_COLTURA
         WHERE IM_TSM_COD_INT = pRecMisureH.Cod_Int
           AND IM_TSM_COD_MIS = pRecMisureH.Cod_Misura
           AND IM_TSM_COD_SMIS = pRecMisureH.Cod_Smis
              AND    ANNO_FINE_VALIDITA IS NULL;

        RETURN recTmpMigrHTpColt;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
    END SelectTTmpMigrHTipoColtura;

    /*********************************************************************
    Valorizza ed inserisce il record su DB_CONDUZIONE_PARTICELLA prelevando i
    valori dai record di appoggio , restituisce l'id_conduzione_particella
    appena creato
    Tipo:   function
    input:  pRecAnagAzienda, pRecUteAzienda, pRecStoricoPart, pRecMisureH
    output: nessuno
    ritorno:NUMBER
    *********************************************************************/
    FUNCTION GestioneConduzioneParticella (pRecAnagAzienda IN DB_ANAGRAFICA_AZIENDA%ROWTYPE,
                                           pRecUteAzienda  IN DB_UTE%ROWTYPE,
                                           pRecStoricoPart IN DB_STORICO_PARTICELLA%ROWTYPE,
                                           pRecMisureH     IN SMRGAA_WRK_MIGRAZIONE_H_P2%ROWTYPE)
    RETURN NUMBER IS
        recTConduzionePart DB_CONDUZIONE_PARTICELLA%ROWTYPE;
    BEGIN

        SELECT SEQ_CONDUZIONE_PARTICELLA.NEXTVAL
          INTO recTConduzionePart.id_conduzione_particella
          FROM dual;

        recTConduzionePart.id_particella := pRecStoricoPart.id_particella;
        recTConduzionePart.id_titolo_possesso := NVL(TRIM(SUBSTR(pRecMisureH.Conduzione,1,1)),4);
        recTConduzionePart.id_ute := pRecUteAzienda.id_ute;
        recTConduzionePart.superficie_condotta := 0 ;
        recTConduzionePart.data_inizio_conduzione := SYSDATE;
        recTConduzionePart.note := 'IMPORTAZIONE DA PRATICHE DI MISURA H';
        recTConduzionePart.data_aggiornamento := SYSDATE;
        recTConduzionePart.id_utente_aggiornamento := pRecUteAzienda.id_utente_aggiornamento;

        InsertTConduzioneParticella (recTConduzionePart);

        RETURN recTConduzionePart.id_conduzione_particella;

    END GestioneConduzioneParticella;

   /*********************************************************************
    Valorizza ed inserisce il record su DB_UTILIZZO_PARTICELLA prelevando i
    valori dai record di appoggio.
    Tipo:   procedure
    input:  pnIdConduzPart, pRecUteAzienda, pRecMisureH
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE AggiungiUtilizzoParticella(pnIdConduzPart DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE,
                                         pRecUteAzienda DB_UTE%ROWTYPE,
                                         pRecMisureH    SMRGAA_WRK_MIGRAZIONE_H_P2%ROWTYPE) IS
        recTUtilPart            DB_UTILIZZO_PARTICELLA%ROWTYPE;
        recTmpMigrHTipoColtura  SMRGAA_WRK_MIGR_H_TIPO_COLTURA%ROWTYPE;
    BEGIN
        SELECT SEQ_UTILIZZO_PARTICELLA.NEXTVAL
          INTO recTUtilPart.id_utilizzo_particella
          FROM dual;

        recTmpMigrHTipoColtura := SelectTTmpMigrHTipoColtura(pRecMisureH);

        recTUtilPart.id_utilizzo := recTmpMigrHTipoColtura.id_utilizzo;
        recTUtilPart.id_varieta := recTmpMigrHTipoColtura.id_varieta;
        recTUtilPart.id_conduzione_particella := pnIdConduzPart;
        recTUtilPart.superficie_utilizzata := pRecMisureH.sup_amm;
        recTUtilPart.data_aggiornamento := SYSDATE;
        recTUtilPart.id_utente_aggiornamento := pRecUteAzienda.id_utente_aggiornamento;
        recTUtilPart.anno := TO_CHAR(SYSDATE,'YYYY');

        InsertTUtilizzoParticella (recTUtilPart);

    END AggiungiUtilizzoParticella;

    /*********************************************************************
    Dato un id_azienda ricerca gli ultimi dati anagrafici
    Tipo:   function
    input:  pIdAzienda
    output: nessuno
    ritorno:DB_ANAGRAFICA_AZIENDA%ROWTYPE
    *********************************************************************/
    FUNCTION SelectTAnagraficaAzienda (pIdAzienda DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE)
    RETURN DB_ANAGRAFICA_AZIENDA%ROWTYPE IS
        recAnagrAzienda DB_ANAGRAFICA_AZIENDA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recAnagrAzienda
          FROM DB_ANAGRAFICA_AZIENDA
         WHERE ID_AZIENDA = pIdAzienda
           AND TRUNC(SYSDATE) BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,TRUNC(SYSDATE));

        RETURN recAnagrAzienda;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelectTAnagraficaAzienda;

    /*********************************************************************
    Dato un cuaa ricerca gli ultimi dati anagrafici
    Tipo:   function
    input:  pCuaa
    output: nessuno
    ritorno:DB_ANAGRAFICA_AZIENDA%ROWTYPE
    *********************************************************************/
    FUNCTION SelectTAnagraficaAziendaByCuaa (pCuaa DB_ANAGRAFICA_AZIENDA.CUAA%TYPE)
    RETURN DB_ANAGRAFICA_AZIENDA%ROWTYPE IS
        recAnagrAzienda DB_ANAGRAFICA_AZIENDA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recAnagrAzienda
          FROM DB_ANAGRAFICA_AZIENDA
         WHERE CUAA = pCuaa
           AND TRUNC(SYSDATE) BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,TRUNC(SYSDATE));

        RETURN recAnagrAzienda;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelectTAnagraficaAziendaByCuaa;
    /*********************************************************************
    Dato un id_azienda ricerco la corrispettiva unità tecnico economica
    sono nel caso in cui l'azienda è appena stata creata quindi ha una sola
    UTE oppure nessuna
    Tipo:   function
    input:  pIdAzienda
    output: nessuno
    ritorno:DB_UTE%ROWTYPE
    *********************************************************************/
    FUNCTION SelectTUnitaTecnicoEconomica (pIdAzienda DB_UTE.ID_AZIENDA%TYPE)
    RETURN DB_UTE%ROWTYPE IS
        recUTE DB_UTE%ROWTYPE;
    BEGIN

        SELECT *
          INTO recUTE
          FROM DB_UTE
         WHERE ID_AZIENDA = pIdAzienda
           AND TRUNC(SYSDATE) BETWEEN DATA_INIZIO_ATTIVITA AND NVL(DATA_FINE_ATTIVITA,TRUNC(SYSDATE));

        RETURN recUTE;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelectTUnitaTecnicoEconomica;

    /*********************************************************************
    Controlla se c'è stato un cambio di chiave catastale fra il record corrente
    (pRecMisureH) e quello elaborato precedentemente (pvAppIstatComu, pvAppSezione, etc)
    Tipo:   function
    input:  pRecMisureH,pvAppIstatComu,pvAppSezione,pnAppFoglio,pnAppParticel
    output: nessuno
    ritorno:TRUE/FALSE
    *********************************************************************/
    FUNCTION CambioChiaveCatastale (pRecMisureH     SMRGAA_WRK_MIGRAZIONE_H_P2%ROWTYPE,
                                    pvAppIstatComu  SMRGAA_WRK_MIGRAZIONE_H_P2.ISTAT_COMUNE%TYPE,
                                    pvAppSezione    SMRGAA_WRK_MIGRAZIONE_H_P2.SEZIONE%TYPE,
                                    pnAppFoglio     SMRGAA_WRK_MIGRAZIONE_H_P2.FOGLIO%TYPE,
                                    pnAppParticel   SMRGAA_WRK_MIGRAZIONE_H_P2.PARTICELLA%TYPE) RETURN BOOLEAN IS

    BEGIN

        IF pRecMisureH.ISTAT_COMUNE <> pvAppIstatComu OR
           NVL(pRecMisureH.sezione,'?') <> NVL(pvAppSezione,'?') OR
           pRecMisureH.foglio <> pnAppFoglio OR
           pRecMisureH.particella  <> pnAppParticel THEN

           RETURN TRUE;
        ELSE
           RETURN FALSE;
        END IF;
    END CambioChiaveCatastale;

    /*********************************************************************
    Effettua la ricerca (per chiave catastale) della particella su DB_STORICO_PARTICELLA
    Tipo:   function
    input:  pRecMisureH
    output: nessuno
    ritorno:DB_STORICO_PARTICELLA%ROWTYPE
    *********************************************************************/
    FUNCTION RicercaStoricoParticella (pRecMisureH SMRGAA_WRK_MIGRAZIONE_H_P2%ROWTYPE)
    RETURN DB_STORICO_PARTICELLA%ROWTYPE IS
        recStorPart DB_STORICO_PARTICELLA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recStorPart
          FROM DB_STORICO_PARTICELLA
         WHERE COMUNE =  pRecMisureH.ISTAT_COMUNE
           AND FOGLIO = pRecMisureH.foglio
           AND NVL(SEZIONE,'?') = NVL(pRecMisureH.sezione,'?')
           AND PARTICELLA = pRecMisureH.particella
           AND SUBALTERNO IS NULL
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recStorPart;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
        WHEN TOO_MANY_ROWS THEN
             RETURN NULL;
    END RicercaStoricoParticella;

    /*********************************************************************
    Effettua una selezione su DB_FOGLIO per istat_comune, foglio e sezione
    Tipo:   function
    input:  pRecMisureH
    output: nessuno
    ritorno:DB_FOGLIO%ROWTYPE
    *********************************************************************/
    FUNCTION SelectTFoglio (pRecPartCert IN DB_PARTICELLA_CERTIFICATA%ROWTYPE)
    RETURN DB_FOGLIO%ROWTYPE IS
        recFoglio DB_FOGLIO%ROWTYPE;
    BEGIN

        SELECT *
          INTO recFoglio
          FROM DB_FOGLIO
         WHERE COMUNE =  pRecPartCert.COMUNE
           AND FOGLIO = pRecPartCert.foglio
           AND NVL(SEZIONE,'?') = NVL(pRecPartCert.sezione,'?');

        RETURN recFoglio;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RETURN NULL;
    END SelectTFoglio;


    /*********************************************************************
    Effettua la ricerca (per chiave catastale) della particella su DB_PARTICELLA_CERTIFICATA
    Tipo:   function
    input:  pRecMisureH
    output: nessuno
    ritorno:DB_PARTICELLA_CERTIFICATA%ROWTYPE
    *********************************************************************/
    FUNCTION RicercaParticellaCertificata (pRecMisureH SMRGAA_WRK_MIGRAZIONE_H_P2%ROWTYPE)
    RETURN DB_PARTICELLA_CERTIFICATA%ROWTYPE IS
        recPartCert DB_PARTICELLA_CERTIFICATA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recPartCert
          FROM DB_PARTICELLA_CERTIFICATA
         WHERE COMUNE =  pRecMisureH.ISTAT_COMUNE
           AND FOGLIO = pRecMisureH.foglio
           AND NVL(SEZIONE,'?') = NVL(pRecMisureH.sezione,'?')
           AND PARTICELLA = pRecMisureH.particella
           AND SUBALTERNO IS NULL
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recPartCert;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
        WHEN TOO_MANY_ROWS THEN
             RETURN NULL;
    END RicercaParticellaCertificata;

    /*********************************************************************
    Dato un CUAA di provenienza inserisco tutti gli utilizzi e le condizioni
    reperite su SMRGAA_WRK_MIGRAZIONE_H_P2 nelle tavole
    DB_CONDUZIONE_PARTICELLA e DB_UTILIZZO_PARTICELLA per l'azienda
    reperita tramite il CUAA di destinazione
    Tipo:   function
    input:  pCuaaProv, pCuaaDest, pCodErr, pMsgErr
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE MAIN (pCuaaProv  IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    pCuaaDest  IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE,
                    pCodErr       IN OUT VARCHAR2,
                     pMsgErr    IN OUT VARCHAR2) IS

        recAnagAzienda DB_ANAGRAFICA_AZIENDA%ROWTYPE;
        recUteAzienda  DB_UTE%ROWTYPE;
        recStoricoPart DB_STORICO_PARTICELLA%ROWTYPE;
        recPartCertif  DB_PARTICELLA_CERTIFICATA%ROWTYPE;
        recFoglio      DB_FOGLIO%ROWTYPE;

        vAppIstatComu  SMRGAA_WRK_MIGRAZIONE_H_P2.ISTAT_COMUNE%TYPE:= '######';
        vAppSezione    SMRGAA_WRK_MIGRAZIONE_H_P2.SEZIONE%TYPE:= '#';
        nAppFoglio     SMRGAA_WRK_MIGRAZIONE_H_P2.FOGLIO%TYPE := -9999;
        nAppParticel   SMRGAA_WRK_MIGRAZIONE_H_P2.PARTICELLA%TYPE := -99999;

        nIdConduzPart  DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
        nTotSupCond    DB_CONDUZIONE_PARTICELLA.SUPERFICIE_CONDOTTA%TYPE;

        bFoundPart     BOOLEAN:=FALSE;


        CURSOR curMisureH (pCuaa IN VARCHAR2) IS
        SELECT *
          FROM SMRGAA_WRK_MIGRAZIONE_H_P2
         WHERE CUAA = pCuaa
        ORDER BY Istat_Comune, Sezione, Foglio, Particella;

    BEGIN
        -- mi cerco l'azienda del CUAA destinatario
        recAnagAzienda := SelectTAnagraficaAziendaByCuaa(pCuaaDest);
        -- se l'ho trovo
        IF recAnagAzienda.CUAA IS NOT NULL THEN
           -- mi cerco l'ID_UTE su DB_UTE
           recUteAzienda :=  SelectTUnitaTecnicoEconomica(recAnagAzienda.id_azienda);
           -- se trovo anche questo
           IF recUteAzienda.ID_UTE IS NOT NULL THEN
               -- seleziono tutte i record su SMRGAA_WRK_MIGRAZIONE_H_P2
               -- per il CUAA provenienza ordinandole per chiave catastale
               FOR recMisureH IN curMisureH (pCuaaProv) LOOP
                   -- a rottura di chiave catastale
                   IF CambioChiaveCatastale (recMisureH,
                                             vAppIstatComu,
                                             vAppSezione,
                                             nAppFoglio,
                                             nAppParticel) THEN
                       -- se non sono appena entrato nel ciclo
                       IF vAppIstatComu <> '######' THEN
                          -- se avevo trovato la particella su DB_STORICO_PARTICELLA
                          IF bFoundPart THEN
                            -- aggiorno la superficie condotta con la somma
                            -- delle superficie utilizzate a rottura di chiave catastale
                            AggiornaConduzioneParticella (nIdConduzPart,nTotSupCond);
                          END IF;
                       END IF;
                       -- mi salvo la vecchia chiave catastale
                       vAppIstatComu := recMisureH.istat_comune;
                       vAppSezione := recMisureH.sezione;
                       nAppFoglio := recMisureH.foglio;
                       nAppParticel := recMisureH.particella;
                       -- ricerco per chiave catastale su DB_STORICO_PARTICELLA
                       recStoricoPart := RicercaStoricoParticella (recMisureH);
                       -- se ho trovato qualcosa
                       IF recStoricoPart.id_storico_particella IS NOT NULL THEN
                          -- assegno alla boolena TRUE
                          bFoundPart := TRUE;
                       ELSE
                          -- altrimenti ricerco su DB_PARTICELLA_CERTIFICATA
                          recPartCertif := RicercaParticellaCertificata (recMisureH);
                          -- se trovo una corrispondenza
                          IF recPartCertif.id_particella_certificata IS NOT NULL THEN
                             -- cerco il corrispondente record su DB_FOGLIO
                             recFoglio := SelectTFoglio (recPartCertif);
                             -- inserisco la particella su DB_PARTICELLA
                             recStoricoPart.id_particella := InserimentoParticella;
                             -- inserisco lo storico particella su DB_PARTICELLA_STORICO
                             InserimentoStoricoParticella (recStoricoPart, recPartCertif, recFoglio,recUteAzienda);
                             bFoundPart := TRUE;
                          ELSE
                             bFoundPart := FALSE;
                          END IF;
                       END IF;

                       IF bFoundPart THEN
                          -- inserisco il record su DB_CONDUZIONE_PARTICELLA con
                          -- superficie condotta a 0 e mi salvo l'id in una variabile di appoggio
                          nIdConduzPart := GestioneConduzioneParticella(recAnagAzienda,recUteAzienda,recStoricoPart,recMisureH);
                       END IF;
                       -- azzero la variabile di appoggio per la somma delle superficie utilizzate dei
                       -- singoli utilizzi
                       nTotSupCond := 0;
                   END IF;
                   -- se avevo trovato la particella su
                   -- DB_STORICO_PARTICELLA
                   IF bFoundPart THEN
                      -- sommo la superficie del singolo utilizzo
                      nTotSupCond := nTotSupCond + recMisureH.sup_amm;
                      -- inserisco il singolo utilizzo associandola alla
                      -- conduzione inserita precedentemente
                      AggiungiUtilizzoParticella(nIdConduzPart,recUteAzienda,recMisureH);
                   END IF;

               END LOOP;
               -- devo aggiornare l'ultima superficie utilizzata
               -- fuori ciclo
               IF bFoundPart THEN
                  -- aggiorno la superficie condotta con la somma
                  -- delle superficie utilizzate a rottura di chiave catastale
                  AggiornaConduzioneParticella (nIdConduzPart,nTotSupCond);
               END IF;

           END IF;

        END IF;

        COMMIT;


    EXCEPTION
        WHEN OTHERS THEN
             ROLLBACK;
             pCodErr := SQLCODE;
             pMsgErr := 'Errore nella procedure PCK_CARICA_MISURA_H_ALTRO_CUAA.MAIN : ' || SUBSTR(SQLERRM,1,250);
    END MAIN;

END Pck_Carica_Misura_H_Altro_Cuaa ;

/
--------------------------------------------------------
--  DDL for Package Body PCK_EXP_PARTICELLE_OUT_CATASTO
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_EXP_PARTICELLE_OUT_CATASTO" AS

    FUNCTION MAIN (    pPath        IN VARCHAR2,
                    pFileOut    IN VARCHAR2 )RETURN NUMBER IS


        FFILEWRITE        UTL_FILE.FILE_TYPE;

        CURSOR CUR_PART IS
        SELECT DC.ID_DICHIARAZIONE_CONSISTENZA AS ID_DOMANDA,
               AZ.CUAA,
               'FA' AS COD_SETTORE,
               DC.ANNO_CAMPAGNA AS ANNO_RIFERIMENTO,
               SP.ID_PARTICELLA, 
               SUBSTR(SP.COMUNE,1,3) AS CODI_PROV,
               SUBSTR(SP.COMUNE,4,6) AS CODI_COMU,
               SP.SEZIONE,
               SP.FOGLIO AS NUM_FOGLIO,
               NVL(SP.particella,0) AS NUM_PARTICELLA,
               SP.SUBALTERNO,
               SP.ID_STORICO_PARTICELLA AS PROG_RIGA, 
               UT.CODICE AS CODICE_PRODOTTO,
               VAR.CODICE_VARIETA AS CODICE_VARIETA1,
               MC.CODICE AS COD_UTILIZZO,
               UD.SUPERFICIE_UTILIZZATA AS SUPERFICIE_UTILIZZATA,
               SP.SUP_CATASTALE AS SUPERFICIE_CATA,
               '1' AS COD_PREMIO,
               '000' AS CODICE_INTERVENTO,
               VAR.CODICE_VARIETA AS CODICE_VARIETA2,
               TO_CHAR(NVL(DC.DATA_PROTOCOLLO,SYSDATE),'DD/MM/YYYY') AS DATA_PROTOCOLLO,
               SP.ID_CASO_PARTICOLARE AS CASO_PARTICOLARE,
               '0' AS CONTROLLO_LOCO
          FROM DB_ANAGRAFICA_AZIENDA AZ,
               DB_DICHIARAZIONE_CONSISTENZA DC,
               DB_CONDUZIONE_DICHIARATA CD,
               DB_STORICO_PARTICELLA SP,
               DB_UTILIZZO_DICHIARATO UD,
               DB_TIPO_UTILIZZO UT,
               DB_TIPO_VARIETA VAR,
               DB_TIPO_MACRO_USO_VARIETA MCV,
               DB_TIPO_MACRO_USO MC,DB_R_CATALOGO_MATRICE CM
         WHERE AZ.DATA_FINE_VALIDITA IS NULL
           AND AZ.ID_AZIENDA = DC.ID_AZIENDA
           AND DC.ID_MOTIVO_DICHIARAZIONE <> 7
           AND DC.DATA_INSERIMENTO_DICHIARAZIONE = (SELECT MAX(DATA_INSERIMENTO_DICHIARAZIONE)
                                                      FROM DB_DICHIARAZIONE_CONSISTENZA
                                                     WHERE ID_AZIENDA = DC.ID_AZIENDA
                                                       AND ID_MOTIVO_DICHIARAZIONE <> 7)
           AND CD.CODICE_FOTOGRAFIA_TERRENI = DC.CODICE_FOTOGRAFIA_TERRENI
           AND CD.ID_CONDUZIONE_DICHIARATA = UD.ID_CONDUZIONE_DICHIARATA
           AND CD.ID_STORICO_PARTICELLA = SP.ID_STORICO_PARTICELLA
           AND SP.PARTICELLA IS NOT NULL 
           AND UD.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND UT.ID_UTILIZZO = CM.ID_UTILIZZO 
           AND VAR.ID_VARIETA = CM.ID_VARIETA 
           AND CM.ID_CATALOGO_MATRICE = MCV.ID_CATALOGO_MATRICE 
           AND MCV.DATA_FINE_VALIDITA IS NULL
           AND MCV.ID_MACRO_USO = MC.ID_MACRO_USO
           AND NOT EXISTS ( SELECT CER.ID_PARTICELLA_CERTIFICATA
                              FROM DB_PARTICELLA_CERTIFICATA CER
                             WHERE CER.COMUNE = SP.COMUNE
                               AND NVL(CER.SEZIONE,-1)=NVL(SP.SEZIONE,-1)
                               AND CER.FOGLIO=SP.FOGLIO
                               AND CER.PARTICELLA=SP.PARTICELLA
                               AND NVL(CER.SUBALTERNO,'-') = NVL(SP.SUBALTERNO,'-') 
                               AND CER.DATA_FINE_VALIDITA IS NULL);

    vStringaOut    VARCHAR2(1000);
    nCountPart    NUMBER;
    nCount        NUMBER;

    BEGIN

        FFILEWRITE    := Pck_Utility_File.FileOpen (pPath, pFileOut, 'W');
        DBMS_OUTPUT.PUT_LINE('Inizio Procedura - '||TO_CHAR(SYSDATE,'DD/MM/YYYY HH24:MI:SS'));

        FOR REC_P IN  CUR_PART LOOP

            nCount := nCount + 1;

            SELECT COUNT(*)
              INTO nCountPart
              FROM DB_PARTICELLA
             WHERE ID_PARTICELLA = REC_P.PROG_RIGA
               AND FLAG_INVIO_SITI = 'N';

            IF nCountPart > 0 THEN

                IF REC_P.SUPERFICIE_UTILIZZATA > 99999 THEN
                   REC_P.SUPERFICIE_UTILIZZATA := REC_P.SUPERFICIE_UTILIZZATA / 100;
                END IF;

                IF REC_P.SUPERFICIE_CATA > 99999 THEN
                   REC_P.SUPERFICIE_CATA := REC_P.SUPERFICIE_CATA / 100;
                END IF;

                nCount := nCount + 1;
                vStringaOut := ';'  || REC_P.ID_DOMANDA ||';'||
                                       REC_P.CUAA ||';'||
                                       REC_P.COD_SETTORE ||';'||
                                       REC_P.ANNO_RIFERIMENTO ||';'||
                                       REC_P.ID_PARTICELLA ||';'||
                                       REC_P.CODI_PROV ||';'||
                                       REC_P.CODI_COMU ||';'||
                                       REC_P.SEZIONE ||';'||
                                       REC_P.NUM_FOGLIO ||';'||
                                       REC_P.NUM_PARTICELLA ||';'||
                                       REC_P.SUBALTERNO ||';'||
                                       REC_P.PROG_RIGA ||';'||
                                       REC_P.CODICE_PRODOTTO ||';'||
                                       REC_P.CODICE_VARIETA1 ||';'||
                                       REC_P.COD_UTILIZZO ||';'||
                                       REC_P.SUPERFICIE_UTILIZZATA ||';'||
                                       REC_P.SUPERFICIE_CATA ||';'||
                                       REC_P.COD_PREMIO    ||';'||
                                       REC_P.CODICE_INTERVENTO ||';'||
                                       REC_P.CODICE_VARIETA2 ||';'||
                                       REC_P.DATA_PROTOCOLLO ||';'||
                                       REC_P.CASO_PARTICOLARE ||';'||
                                       REC_P.CONTROLLO_LOCO ||';';

                Pck_Utility_File.FileWrite(FFILEWRITE,vStringaOut);

                UPDATE DB_PARTICELLA
                   SET FLAG_INVIO_SITI = 'S'
                 WHERE ID_PARTICELLA = REC_P.PROG_RIGA;

                IF nCount > 2500 THEN
                   COMMIT;
                   nCount := 0;
                END IF;

            END IF;

        END LOOP;

        IF UTL_FILE.IS_OPEN(FFILEWRITE) THEN
           Pck_Utility_File.FILECLOSE(FFILEWRITE);
        END IF;

        COMMIT;

        DBMS_OUTPUT.PUT_LINE('Fine Procedura - '||TO_CHAR(SYSDATE,'DD/MM/YYYY HH24:MI:SS'));
        RETURN(0);

    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            DBMS_OUTPUT.PUT_LINE('ERRORE ORACLE '||SUBSTR(SQLERRM,1,100)||' PROCEDURA INTERROTTA');
            IF UTL_FILE.IS_OPEN(FFILEWRITE) THEN
                Pck_Utility_File.FILECLOSE(FFILEWRITE);
            END IF;
            RETURN(1);
    END MAIN;

END Pck_Exp_Particelle_Out_Catasto;

/
--------------------------------------------------------
--  DDL for Package Body PCK_GESTIONE_ISTANZA_RIESAME
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_GESTIONE_ISTANZA_RIESAME" AS
/*****************************************************************************
Package che espone tutte le function / stored procedure propedeutiche alla gestione
delle fasi di controllo in contradditorio e sopralluogo in campo dell'istanza di riesame
******************************************************************************/

    /*********************************************************************
    Tipo: procedure
    input: pMessaggio , pIdParticella, pStringa
    output: pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE AccodaMessaggio (pMessaggio    IN OUT VARCHAR2,
                               pStringa      IN VARCHAR2
                               ) IS
        nLengthPMsg INTEGER:=0;
        nLengthStr  INTEGER:=0;

    BEGIN

        IF gnMaxLengthMessaggioErrore IS NULL THEN
           BEGIN
               SELECT DATA_LENGTH
                 INTO gnMaxLengthMessaggioErrore
                 FROM USER_TAB_COLUMNS
                WHERE TABLE_NAME = 'SMRGAA_W_ISTANZA_RIESAME'
                  AND COLUMN_NAME = 'MESSAGGIO_ERRORE';
           EXCEPTION
               WHEN OTHERS THEN
                    gnMaxLengthMessaggioErrore := 2000;
           END;
        END IF;

        -- setto la lunghezza del messaggio attuale
        nLengthPMsg := NVL(LENGTH(pMessaggio),0);
        -- setto la lunghezza della stringa da aggiungere al messaggio attuale
        nLengthStr := NVL(LENGTH(pStringa),0);
        -- se la somma della lunghezza del messagio attuale + la stringa da aggiungere
        -- + l'id_particella + i due caratteri separatore e' minore della lunghezza massima disponibile
        IF nLengthPMsg + nLengthStr + 1 <= gnMaxLengthMessaggioErrore THEN
           -- accoda la stringa nel messaggio
           pMessaggio := pMessaggio || ';' || pStringa;
        END IF;

    END AccodaMessaggio;

    /*********************************************************************
    Estrapola la data di nascita dal codice fiscale
    Tipo: function
    input: pCodFiscale
    output: nessuno
    ritorno: DATE
    *********************************************************************/
    FUNCTION DATA_DA_CF(pCodFiscale IN VARCHAR2) RETURN DATE IS
       nAnno    NUMBER(2);
       nGiorno  NUMBER(2);
       nMese    NUMBER(2);
       vAnnoFourDigit VARCHAR2(4);
    begin

         nAnno := SUBSTR(pCodFiscale,7,2);
         nGiorno := TO_NUMBER(SUBSTR(pCodFiscale,10,2),'99');

         IF nGiorno > 40 THEN
            nGiorno := nGiorno - 40;
         END IF;

         IF SUBSTR(pCodFiscale,9,1) = 'A' THEN
            nMese := 1;
         ELSIF SUBSTR(pCodFiscale,9,1) = 'B' THEN
            nMese := 2;
         ELSIF SUBSTR(pCodFiscale,9,1) = 'C' THEN
            nMese := 3;
         ELSIF SUBSTR(pCodFiscale,9,1) = 'D' THEN
            nMese := 4;
         ELSIF SUBSTR(pCodFiscale,9,1) = 'E' THEN
            nMese := 5;
         ELSIF SUBSTR(pCodFiscale,9,1) = 'H' THEN
            nMese := 6;
         ELSIF SUBSTR(pCodFiscale,9,1) = 'L' THEN
            nMese := 7;
         ELSIF SUBSTR(pCodFiscale,9,1) = 'M' THEN
            nMese := 8;
         ELSIF SUBSTR(pCodFiscale,9,1) = 'P' THEN
            nMese := 9;
         ELSIF SUBSTR(pCodFiscale,9,1) = 'R' THEN
            nMese := 10;
         ELSIF SUBSTR(pCodFiscale,9,1) = 'S' THEN
            nMese := 11;
         ELSIF SUBSTR(pCodFiscale,9,1) = 'T' THEN
            nMese := 12;
         END IF;

         IF TO_NUMBER(nAnno,'99') > TO_NUMBER(TO_CHAR(SYSDATE,'yy')) AND
            TO_NUMBER(nAnno,'99') <= 99  THEN
            vAnnoFourDigit := '19' || nAnno;
         ELSE
            vAnnoFourDigit := '20' || nAnno;
         END IF;

         RETURN TO_DATE(nGiorno || '/' || nMese || '/' || vAnnoFourDigit,'dd/mm/yyyy');

    EXCEPTION
        WHEN OTHERS THEN
             RETURN NULL;
    END DATA_DA_CF;

    /*********************************************************************
    Dato un record di DB_SOGGETTO lo inserisce nella tabella omonima
    Tipo: procedure
    input: pRecTSoggetto
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTSoggetto (pRecTSoggetto IN DB_SOGGETTO%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_SOGGETTO
            (
            ID_SOGGETTO,
            FLAG_FISICO
            )
        VALUES
            (
            pRecTSoggetto.ID_SOGGETTO,
            pRecTSoggetto.FLAG_FISICO
            );
    END InsertTSoggetto;

    /*********************************************************************
    Dato un record di DB_PERSONA_FISICA lo inserisce nella tabella omonima
    Tipo: procedure
    input: pRecTPersonaFisica
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTPersonaFisica (pRecTPersonaFisica IN DB_PERSONA_FISICA%ROWTYPE) IS
    BEGIN
        INSERT INTO DB_PERSONA_FISICA
            (
            ID_PERSONA_FISICA,
            ID_SOGGETTO,
            CODICE_FISCALE,
            COGNOME,
            NASCITA_COMUNE,
            NOME,
            SESSO,
            RES_COMUNE,
            NASCITA_DATA,
            RES_INDIRIZZO,
            RES_CAP,
            RES_TELEFONO,
            RES_FAX,
            RES_MAIL,
            DATA_AGGIORNAMENTO,
            NOTE,
            ID_UTENTE_AGGIORNAMENTO,
            DOM_INDIRIZZO,
            DOM_CAP,
            NASCITA_CITTA_ESTERO,
            RES_CITTA_ESTERO,
            MODIFICA_INTERMEDIARIO,
            ID_TITOLO_STUDIO,
            ID_INDIRIZZO_STUDIO,
            DOM_COMUNE,
            DOM_CITTA_ESTERO,
            DATA_INIZIO_RESIDENZA,
            FLAG_CF_OK,
            NUMERO_CELLULARE,
            PREFISSO_INTER_CELLULARE,
            ID_PREFISSO_CELLULARE
            )
        VALUES
            (
            pRecTPersonaFisica.ID_PERSONA_FISICA,
            pRecTPersonaFisica.ID_SOGGETTO,
            pRecTPersonaFisica.CODICE_FISCALE,
            pRecTPersonaFisica.COGNOME,
            pRecTPersonaFisica.NASCITA_COMUNE,
            pRecTPersonaFisica.NOME,
            pRecTPersonaFisica.SESSO,
            pRecTPersonaFisica.RES_COMUNE,
            pRecTPersonaFisica.NASCITA_DATA,
            pRecTPersonaFisica.RES_INDIRIZZO,
            pRecTPersonaFisica.RES_CAP,
            pRecTPersonaFisica.RES_TELEFONO,
            pRecTPersonaFisica.RES_FAX,
            pRecTPersonaFisica.RES_MAIL,
            pRecTPersonaFisica.DATA_AGGIORNAMENTO,
            pRecTPersonaFisica.NOTE,
            pRecTPersonaFisica.ID_UTENTE_AGGIORNAMENTO,
            pRecTPersonaFisica.DOM_INDIRIZZO,
            pRecTPersonaFisica.DOM_CAP,
            pRecTPersonaFisica.NASCITA_CITTA_ESTERO,
            pRecTPersonaFisica.RES_CITTA_ESTERO,
            pRecTPersonaFisica.MODIFICA_INTERMEDIARIO,
            pRecTPersonaFisica.ID_TITOLO_STUDIO,
            pRecTPersonaFisica.ID_INDIRIZZO_STUDIO,
            pRecTPersonaFisica.DOM_COMUNE,
            pRecTPersonaFisica.DOM_CITTA_ESTERO,
            pRecTPersonaFisica.DATA_INIZIO_RESIDENZA,
            pRecTPersonaFisica.FLAG_CF_OK,
            pRecTPersonaFisica.NUMERO_CELLULARE,
            pRecTPersonaFisica.PREFISSO_INTER_CELLULARE,
            pRecTPersonaFisica.ID_PREFISSO_CELLULARE
            );
    END InsertTPersonaFisica;

    /*********************************************************************
    Dato un record di DB_SOPRALLUOGO_ISTANZA lo inserisce nella tabella omonima
    Tipo: procedure
    input: pRecTSopralIstanza
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTSopralluogoIstanza (pRecTSopralIstanza IN DB_SOPRALLUOGO_ISTANZA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_SOPRALLUOGO_ISTANZA
            (
            ID_SOPRALLUOGO_ISTANZA,
            ID_ISTANZA_RIESAME_AZIENDA,
            TIPO_SOGGETTO,
            ID_SOGGETTO,
            NOME_TECNICO_SOPRALLUOGO,
            COGNOME_TECNICO_SOPRALLUOOGO,
            CF_TECNICO_SOPRALLUOGO,
            PRESENTE_SOPRALLUOGO,
            FIRMATARIO_SOPRALLUOGO,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA
            )
        VALUES
            (
            pRecTSopralIstanza.ID_SOPRALLUOGO_ISTANZA,
            pRecTSopralIstanza.ID_ISTANZA_RIESAME_AZIENDA,
            pRecTSopralIstanza.TIPO_SOGGETTO,
            pRecTSopralIstanza.ID_SOGGETTO,
            pRecTSopralIstanza.NOME_TECNICO_SOPRALLUOGO,
            pRecTSopralIstanza.COGNOME_TECNICO_SOPRALLUOOGO,
            pRecTSopralIstanza.CF_TECNICO_SOPRALLUOGO,
            pRecTSopralIstanza.PRESENTE_SOPRALLUOGO,
            pRecTSopralIstanza.FIRMATARIO_SOPRALLUOGO,
            pRecTSopralIstanza.DATA_INIZIO_VALIDITA,
            pRecTSopralIstanza.DATA_FINE_VALIDITA
            );
    END InsertTSopralluogoIstanza;

    /*********************************************************************
    Ricerca su DB_PERSONA_FISICA per codice fiscale e ne restituisce il ROWTYPE
    in caso di TOO_MANY_ROWS ritorna il massimo ID_PERSONA_FISICA
    Tipo: function
    input: pCodFiscale
    output: nessuno
    ritorno: DB_PERSONA_FISICA%ROWTYPE
    *********************************************************************/
    FUNCTION SelTPersonaFisicaByCodFiscale (pCodFiscale IN DB_PERSONA_FISICA.CODICE_FISCALE%TYPE)
    RETURN DB_PERSONA_FISICA%ROWTYPE IS
        recTPersonaFisica DB_PERSONA_FISICA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTPersonaFisica
          FROM DB_PERSONA_FISICA
         WHERE CODICE_FISCALE = pCodFiscale;

        RETURN recTPersonaFisica;
    EXCEPTION
        WHEN TOO_MANY_ROWS THEN
             SELECT *
               INTO recTPersonaFisica
               FROM DB_PERSONA_FISICA
              WHERE ID_PERSONA_FISICA =
                (SELECT MAX(ID_PERSONA_FISICA)
                   FROM DB_PERSONA_FISICA
                  WHERE CODICE_FISCALE = pCodFiscale);

             RETURN recTPersonaFisica;
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTPersonaFisicaByCodFiscale;

    /*********************************************************************
    Dato un ID_ISTANZA_RIESAME_AZIENDA ricerca se c'è un sopralluogo attivo
    e  ne restituisce il rowtype
    Tipo: function
    input: pIstRiesAzienda
    output: nessuno
    ritorno:DB_SOPRALLUOGO_ISTANZA%ROWTYPE
    *********************************************************************/
    FUNCTION SelLastTSopralIstanzaByIdIstAz (pIstRiesAzienda IN DB_SOPRALLUOGO_ISTANZA.ID_ISTANZA_RIESAME_AZIENDA%TYPE)
    RETURN DB_SOPRALLUOGO_ISTANZA%ROWTYPE IS
        recTSopralIstanza DB_SOPRALLUOGO_ISTANZA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTSopralIstanza
          FROM DB_SOPRALLUOGO_ISTANZA
         WHERE ID_ISTANZA_RIESAME_AZIENDA = pIstRiesAzienda
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recTSopralIstanza;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelLastTSopralIstanzaByIdIstAz;

    /*********************************************************************
    Dato un record di DB_ITER_RIESAME_AZIENDA lo inserisce nella tabella omonima
    Tipo: procedure
    input: pRecTIterRiesameAzienda
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTIterRiesameAzienda (pRecTIterRiesameAzienda IN DB_ITER_RIESAME_AZIENDA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_ITER_RIESAME_AZIENDA
            (
            ID_ITER_RIESAME_AZIENDA,
            ID_ISTANZA_RIESAME_AZIENDA,
            STATO_ISTANZA,
            NUMERO_PARTICELLE_SEGNALATE,
            NUMERO_PARTICELLE_RISOLTE,
            PREVISTO_PAGAMENTO,
            IMPORTO_DEBITORIO,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA
            )
        VALUES
            (
            pRecTIterRiesameAzienda.ID_ITER_RIESAME_AZIENDA,
            pRecTIterRiesameAzienda.ID_ISTANZA_RIESAME_AZIENDA,
            pRecTIterRiesameAzienda.STATO_ISTANZA,
            pRecTIterRiesameAzienda.NUMERO_PARTICELLE_SEGNALATE,
            pRecTIterRiesameAzienda.NUMERO_PARTICELLE_RISOLTE,
            pRecTIterRiesameAzienda.PREVISTO_PAGAMENTO,
            pRecTIterRiesameAzienda.IMPORTO_DEBITORIO,
            pRecTIterRiesameAzienda.DATA_INIZIO_VALIDITA,
            pRecTIterRiesameAzienda.DATA_FINE_VALIDITA
            );
    END InsertTIterRiesameAzienda;

    /*********************************************************************
    Aggiorna a SYSDATE la data fine validita del record identificato tramite
    l'ID_SOPRALLUOGO_ISTANZA dato in input
    Tipo: procedure
    input: pIdSopralIstanza
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ChiudiSopralluogoIstanza (pIdSopralIstanza IN DB_SOPRALLUOGO_ISTANZA.ID_SOPRALLUOGO_ISTANZA%TYPE) IS
    BEGIN

        UPDATE DB_SOPRALLUOGO_ISTANZA
           SET DATA_FINE_VALIDITA = SYSDATE
         WHERE ID_SOPRALLUOGO_ISTANZA = pIdSopralIstanza;

    END ChiudiSopralluogoIstanza;

    /*********************************************************************
    Aggiorna a SYSDATE la data fine validita del record identificato tramite
    l'ID_ITER_RIESAME_AZIENDA dato in input
    Tipo: procedure
    input: pIdIterRiesameAzienda
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ChiudiIterRiesAzienda (pIdIterRiesameAzienda IN DB_ITER_RIESAME_AZIENDA.ID_ITER_RIESAME_AZIENDA%TYPE) IS
    BEGIN

        UPDATE DB_ITER_RIESAME_AZIENDA
           SET DATA_FINE_VALIDITA = SYSDATE
         WHERE ID_ITER_RIESAME_AZIENDA = pIdIterRiesameAzienda;

    END ChiudiIterRiesAzienda;

    /*********************************************************************
    Dato un protocollo di istanza di riesame ricerca il corrispettivo
    record su DB_ISTANZA_RIESAME_AZIENDA
    Tipo: function
    input: pProtIstanza
    output: nessuno
    ritorno: DB_ISTANZA_RIESAME_AZIENDA%ROWTYPE
    *********************************************************************/
    FUNCTION SelTIstRiesameAziendaByProt (pProtIstanza IN DB_ISTANZA_RIESAME_AZIENDA.PROTOCOLLO_ISTANZA%TYPE)
    RETURN DB_ISTANZA_RIESAME_AZIENDA%ROWTYPE IS
        recTIstanzaRiesameAzienda DB_ISTANZA_RIESAME_AZIENDA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTIstanzaRiesameAzienda
          FROM DB_ISTANZA_RIESAME_AZIENDA
         WHERE PROTOCOLLO_ISTANZA = pProtIstanza;

        RETURN recTIstanzaRiesameAzienda;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTIstRiesameAziendaByProt;

    /*********************************************************************
    Dato un protocollo di istanza di riesame ricerca l'iter attivo
    su DB_ITER_RIESAME_AZIENDA
    Tipo: function
    input: pProtIstanza
    output: nessuno
    ritorno: DB_ITER_RIESAME_AZIENDA%ROWTYPE
    *********************************************************************/
    FUNCTION SelLastTIterRiesAziendaByProt (pProtIstanza IN DB_ISTANZA_RIESAME_AZIENDA.PROTOCOLLO_ISTANZA%TYPE)
    RETURN DB_ITER_RIESAME_AZIENDA%ROWTYPE IS
        recTIterRiesAzienda DB_ITER_RIESAME_AZIENDA%ROWTYPE;
    BEGIN

        SELECT IRA.*
          INTO recTIterRiesAzienda
          FROM DB_ITER_RIESAME_AZIENDA IRA,
               DB_ISTANZA_RIESAME_AZIENDA IRAA
         WHERE IRAA.ID_ISTANZA_RIESAME_AZIENDA = IRA.ID_ISTANZA_RIESAME_AZIENDA
           AND IRAA.PROTOCOLLO_ISTANZA = pProtIstanza
           AND IRA.DATA_FINE_VALIDITA IS NULL;


        RETURN recTIterRiesAzienda;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelLastTIterRiesAziendaByProt;

    /*********************************************************************
    Dati una fase di istanza di riesame ed un ID_ISTANZA_RIESAME ricerca
    se per la particella (dell'ID_ISTANZA_RIESAME dato in input) c'è stata un'istanza
    di riesame successiva dell'opportuna fase (data in input).
    Tipo: function
    input: pIdFaseIst, pRecTIstRiPrec
    output: nessuno
    ritorno: DB_ISTANZA_RIESAME%ROWTYPE
    *********************************************************************/
    FUNCTION SelTIstanzaRiesameByIdFaseProt (pIdFaseIst     IN DB_ISTANZA_RIESAME.ID_FASE_ISTANZA_RIESAME%TYPE,
                                             pRecTIstRiPrec IN DB_ISTANZA_RIESAME%ROWTYPE
                                             )
    RETURN DB_ISTANZA_RIESAME%ROWTYPE IS
        recTIstanzaRiesame DB_ISTANZA_RIESAME%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTIstanzaRiesame
          FROM DB_ISTANZA_RIESAME
         WHERE ID_FASE_ISTANZA_RIESAME = pIdFaseIst
           AND PROTOCOLLO_ISTANZA = pRecTIstRiPrec.PROTOCOLLO_ISTANZA
           AND ID_PARTICELLA = pRecTIstRiPrec.ID_PARTICELLA
           AND DATA_ANNULLAMENTO IS NULL;

        RETURN recTIstanzaRiesame;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTIstanzaRiesameByIdFaseProt;

    /*********************************************************************
    Dato un ID_ISTANZA_RIESAME ricerca il corrispettivo record su
    DB_ISTANZA_RIESAME
    Tipo: function
    input: pIdIstanzaRiesame
    output: nessuno
    ritorno: DB_ISTANZA_RIESAME%ROWTYPE
    *********************************************************************/
    FUNCTION SelTIstanzaRiesameById (pIdIstanzaRiesame IN DB_ISTANZA_RIESAME.ID_ISTANZA_RIESAME%TYPE)
    RETURN DB_ISTANZA_RIESAME%ROWTYPE IS
        recTIstanzaRiesame DB_ISTANZA_RIESAME%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTIstanzaRiesame
          FROM DB_ISTANZA_RIESAME
         WHERE ID_ISTANZA_RIESAME = pIdIstanzaRiesame;

        RETURN recTIstanzaRiesame;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTIstanzaRiesameById;

    /*********************************************************************
    Aggiorna le colonne EVASO e MESSAGGIO_ERRORE per l'ID_ISTA dato
    in input con i valori dati in input
    Tipo: procedure
    input: pIdIstanzaRiesame
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE AggiornaIstanzaRiesameElab (pRecWIstRiesameElab IN curIstanzaRiesameEvasa%ROWTYPE) IS
    BEGIN

        UPDATE SMRGAA_W_ISTANZA_RIESAME
           SET EVASO = pRecWIstRiesameElab.EVASO,
               MESSAGGIO_ERRORE = pRecWIstRiesameElab.MESSAGGIO_ERRORE
         WHERE ID_ISTA = pRecWIstRiesameElab.ID_ISTA;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('AggiornaIstanzaRiesameElab - ID_ISTA = ' || pRecWIstRiesameElab.ID_ISTA);
             RAISE;
    END AggiornaIstanzaRiesameElab;

    /*********************************************************************
    Dato un ID_CATEGORIA_NOTIFICA ritorna il corrispettivo record trovato
    su DB_TIPO_CATEGORIA_NOTIFICA andando per primary key
    Tipo: function
    input: pIdCatNot
    output: nessuno
    ritorno: DB_TIPO_CATEGORIA_NOTIFICA%ROWTYPE
    *********************************************************************/
    FUNCTION SelDCategoriaNotificaById (pIdCatNot IN DB_TIPO_CATEGORIA_NOTIFICA.ID_CATEGORIA_NOTIFICA%TYPE)
    RETURN DB_TIPO_CATEGORIA_NOTIFICA%ROWTYPE IS
        recDCategNotifica DB_TIPO_CATEGORIA_NOTIFICA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recDCategNotifica
          FROM DB_TIPO_CATEGORIA_NOTIFICA
         WHERE ID_CATEGORIA_NOTIFICA = pIdCatNot;

        RETURN recDCategNotifica;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('SelDCategoriaNotificaById - ID_CATEGORIA_NOTIFICA = ' || pIdCatNot);
             RAISE;
    END SelDCategoriaNotificaById;

    /*********************************************************************
    Inserisce un record di tipo DB_NOTIFICA sull'omonima tabella
    Tipo: procedure
    input: pRecTNotifica
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTNotifica (pRecTNotifica IN DB_NOTIFICA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_NOTIFICA
            (
            ID_NOTIFICA,
            ID_AZIENDA,
            ID_UTENTE_INSERIMENTO,
            ID_TIPOLOGIA_NOTIFICA,
            ID_PROCEDIMENTO_MITTENTE,
            ID_PROCEDIMENTO_DESTINATARIO,
            DATA_INSERIMENTO,
            DESCRIZIONE,
            DATA_CHIUSURA,
            NOTE_CHIUSURA,
            ID_UTENTE_CHIUSURA,
            ID_CATEGORIA_NOTIFICA,
            ID_UTENTE_AGGIORNAMENTO,
            DATA_AGGIORNAMENTO
            )
        VALUES
            (
            pRecTNotifica.ID_NOTIFICA,
            pRecTNotifica.ID_AZIENDA,
            pRecTNotifica.ID_UTENTE_INSERIMENTO,
            pRecTNotifica.ID_TIPOLOGIA_NOTIFICA,
            pRecTNotifica.ID_PROCEDIMENTO_MITTENTE,
            pRecTNotifica.ID_PROCEDIMENTO_DESTINATARIO,
            pRecTNotifica.DATA_INSERIMENTO,
            pRecTNotifica.DESCRIZIONE,
            pRecTNotifica.DATA_CHIUSURA,
            pRecTNotifica.NOTE_CHIUSURA,
            pRecTNotifica.ID_UTENTE_CHIUSURA,
            pRecTNotifica.ID_CATEGORIA_NOTIFICA,
            pRecTNotifica.ID_UTENTE_AGGIORNAMENTO,
            pRecTNotifica.DATA_AGGIORNAMENTO
            );
    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertTNotifica - ID_NOTIFICA = ' || pRecTNotifica.ID_NOTIFICA);
             RAISE;
    END InsertTNotifica;

    /*********************************************************************
    Dato un codice altro dato seleziona il corrispettivo record attivo (data fine validita a null)
    sulla tabella DB_ALTRI_DATI
    Tipo: function
    input: pCodAltroDato
    output: nessuno
    ritorno: DB_ALTRI_DATI%ROWTYPE
    *********************************************************************/
    FUNCTION SelDAltroDatoByCodice (pCodAltroDato IN DB_ALTRI_DATI.CODICE%TYPE)
    RETURN DB_ALTRI_DATI%ROWTYPE IS
        recDAltriDati DB_ALTRI_DATI%ROWTYPE;
    BEGIN

        SELECT *
          INTO recDAltriDati
          FROM DB_ALTRI_DATI
         WHERE CODICE = pCodAltroDato
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recDAltriDati;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelDAltroDatoByCodice;

    /*********************************************************************
    Dato un record di tipo DB_ISTANZA_RIESAME lo inserisce sulla tabella omonima
    Tipo: procedure
    input: pRecTIstanzaRiesame
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTIstanzaRiesame (pRecTIstanzaRiesame IN DB_ISTANZA_RIESAME%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_ISTANZA_RIESAME
            (
            ID_ISTANZA_RIESAME,
            ID_FASE_ISTANZA_RIESAME,
            ANNO,
            ID_AZIENDA,
            ID_PARTICELLA,
            DATA_RICHIESTA,
            DATA_ANNULLAMENTO,
            DATA_EVASIONE,
            DATA_AGGIORNAMENTO,
            ID_LISTA_CAMPIONE,
            DESC_LISTA_CAMPIONE,
            LAVORAZIONE_PRIORITARIA,
            NOTE,
            DATA_CHIUSURA_ISTANZA,
            DATA_SITICONVOCA,
            ID_UTENTE_RICHIEDENTE,
            DATA_SOSPENSIONE_SCADUTA,
            PROTOCOLLO_ISTANZA,
            DATA_INVIO_GIS,
            ID_STATO_SITICONVOCA
            )
        VALUES
            (
            pRecTIstanzaRiesame.ID_ISTANZA_RIESAME,
            pRecTIstanzaRiesame.ID_FASE_ISTANZA_RIESAME,
            pRecTIstanzaRiesame.ANNO,
            pRecTIstanzaRiesame.ID_AZIENDA,
            pRecTIstanzaRiesame.ID_PARTICELLA,
            pRecTIstanzaRiesame.DATA_RICHIESTA,
            pRecTIstanzaRiesame.DATA_ANNULLAMENTO,
            pRecTIstanzaRiesame.DATA_EVASIONE,
            pRecTIstanzaRiesame.DATA_AGGIORNAMENTO,
            pRecTIstanzaRiesame.ID_LISTA_CAMPIONE,
            pRecTIstanzaRiesame.DESC_LISTA_CAMPIONE,
            pRecTIstanzaRiesame.LAVORAZIONE_PRIORITARIA,
            pRecTIstanzaRiesame.NOTE,
            pRecTIstanzaRiesame.DATA_CHIUSURA_ISTANZA,
            pRecTIstanzaRiesame.DATA_SITICONVOCA,
            pRecTIstanzaRiesame.ID_UTENTE_RICHIEDENTE,
            pRecTIstanzaRiesame.DATA_SOSPENSIONE_SCADUTA,
            pRecTIstanzaRiesame.PROTOCOLLO_ISTANZA,
            pRecTIstanzaRiesame.DATA_INVIO_GIS,
            pRecTIstanzaRiesame.ID_STATO_SITICONVOCA
            );
    END InsertTIstanzaRiesame;

    FUNCTION SelDComuneByCodIStat (pCodIstat IN COMUNE.ISTAT_COMUNE%TYPE)
    RETURN COMUNE%ROWTYPE IS
        recDComune COMUNE%ROWTYPE;
    BEGIN

        SELECT *
          INTO recDComune
          FROM COMUNE
         WHERE ISTAT_COMUNE = pCodIstat
           AND FLAG_ESTINTO = 'N';

        RETURN recDComune;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             BEGIN
                SELECT *
                  INTO recDComune
                  FROM COMUNE
                 WHERE ISTAT_COMUNE = pCodIstat
                   AND FLAG_ESTINTO = 'S';

                RETURN recDComune;

             EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     RETURN NULL;
                WHEN OTHERS THEN
                     RETURN NULL;
             END;
        WHEN OTHERS THEN
             RETURN NULL;
    END SelDComuneByCodIStat;

    FUNCTION SelTPersFisicaByIdAziendaRuolo (pIdAzienda IN DB_CONTITOLARE.ID_AZIENDA%TYPE,
                                             pIdRuolo   IN DB_CONTITOLARE.ID_RUOLO%TYPE
                                             ) RETURN DB_PERSONA_FISICA%ROWTYPE IS
        recTPersonaFisica DB_PERSONA_FISICA%ROWTYPE;
    BEGIN

        SELECT PE.*
          INTO recTPersonaFisica
          FROM DB_CONTITOLARE CO,
               DB_PERSONA_FISICA PE
         WHERE CO.ID_AZIENDA = pIdAzienda
           AND CO.ID_RUOLO = pIdRuolo
           AND CO.DATA_FINE_RUOLO IS NULL
           AND CO.ID_SOGGETTO = PE.ID_SOGGETTO;

        RETURN recTPersonaFisica;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTPersFisicaByIdAziendaRuolo;

    /*********************************************************************
    Dati in input un ID_AZIENDA, un ANNO verifica se sono presenti documenti
    di istanza di riesame (qualsiasi tipo) ed in caso affermativo controlla se
    tali documenti sono posteriori all'ultima dichiarazione dell'azienda non correttiva
    se è così per tutte le particelle associate al documento e con legame valido
    verrà inserita una richiesta di riesame associata alla fase riesame
    relazionata col tipo documento (ammesso che non sia già presente su DB_ISTANZA_RIESAME)
    Tipo: procedure
    input: pIdAzienda, pAnnoDocumento
    output: pCodErr, pDesErr
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InserisciIstanza (pIdAzienda        IN DB_ISTANZA_RIESAME.ID_AZIENDA%TYPE,
                                pAnnoDocumento    IN DB_ISTANZA_RIESAME.ANNO%TYPE,
                                pCodErr       IN OUT VARCHAR2,
                                pDesErr       IN OUT VARCHAR2) IS


        vStrVetMotDichDaEscludere SMRGAA_R_PARAM_APPLICAZIONE.VALORE_VARCHAR2%TYPE;
        recTIstanzaRiesame        DB_ISTANZA_RIESAME%ROWTYPE;
        nNumPart                  INTEGER:=0;


        CURSOR curDocAttivoIstanzaRiesame (pStrVetMotDichDaEscludere IN VARCHAR2) IS
        WITH MOTIVI_CONCATENATI AS
           ( SELECT pStrVetMotDichDaEscludere AS MotiviConc,
                    LEVEL AS pos,
                    SUBSTR(pStrVetMotDichDaEscludere,ROWNUM,1) AS CH,
                    COUNT(CASE WHEN SUBSTR(pStrVetMotDichDaEscludere,ROWNUM,1) = ',' THEN '#' END)
                    OVER (ORDER BY LEVEL) AS section
               FROM dual
         CONNECT BY LEVEL <= LENGTH(pStrVetMotDichDaEscludere)),
             MOTIVI AS
           ( SELECT SUBSTR(MotiviConc,MIN(pos), 1 + MAX(pos) - MIN(pos)) AS MOTIVO
               FROM MOTIVI_CONCATENATI
              WHERE CH <> ','
           GROUP BY MotiviConc,section )
        SELECT DISTINCT
               CP.ID_PARTICELLA,
               RTD.ID_FASE_ISTANZA_RIESAME,
               D.DATA_INSERIMENTO,
               D.UTENTE_ULTIMO_AGGIORNAMENTO,
               NVL(DC.LAVORAZIONE_PRIORITARIA,'N') AS LAVORAZIONE_PRIORITARIA,
               DC.NOTE
          FROM DB_DOCUMENTO D,
               DB_DOCUMENTO_CONDUZIONE DC,
               DB_CONDUZIONE_PARTICELLA CP,
               DB_R_FASE_RIESAME_TP_DOCUMENTO RTD
         WHERE D.ID_AZIENDA = pIdAzienda
           AND TO_CHAR(D.DATA_INSERIMENTO,'YYYY') = pAnnoDocumento
           AND D.ID_STATO_DOCUMENTO IS NULL
           AND DC.ID_DOCUMENTO = D.ID_DOCUMENTO
           AND DC.DATA_FINE_VALIDITA IS NULL
           AND DC.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
           AND D.EXT_ID_DOCUMENTO = RTD.ID_DOCUMENTO
           AND RTD.DATA_FINE_VALIDITA IS NULL
           AND EXISTS (SELECT DC.ID_DICHIARAZIONE_CONSISTENZA
                         FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                              DB_TIPO_MOTIVO_DICHIARAZIONE MOT
                        WHERE DC.ID_AZIENDA = pIdAzienda
                          AND DC.NUMERO_PROTOCOLLO IS NOT NULL
                          AND DC.ANNO = pAnnoDocumento
                          AND DC.ID_MOTIVO_DICHIARAZIONE = MOT.ID_MOTIVO_DICHIARAZIONE
                          AND MOT.TIPO_DICHIARAZIONE <> kvCodTipoMotivoDichCorrettiva
                          AND DC.ID_MOTIVO_DICHIARAZIONE <> knIdTipoMotivoDichSiccita2006
                          AND DC.DATA_INSERIMENTO_DICHIARAZIONE > D.DATA_INSERIMENTO
                          AND DC.ID_MOTIVO_DICHIARAZIONE NOT IN (SELECT MOTIVO
                                                                   FROM MOTIVI))
          AND NOT EXISTS (SELECT ID_ISTANZA_RIESAME
                            FROM DB_ISTANZA_RIESAME
                           WHERE ID_AZIENDA = pIdAzienda
                             AND ANNO = pAnnoDocumento
                             AND ID_FASE_ISTANZA_RIESAME = RTD.ID_FASE_ISTANZA_RIESAME
                             AND ID_PARTICELLA = CP.ID_PARTICELLA
                             AND DATA_ANNULLAMENTO IS NULL);

    BEGIN


        BEGIN
            SELECT VALORE_VARCHAR2
              INTO vStrVetMotDichDaEscludere
              FROM SMRGAA_R_PARAM_APPLICAZIONE PA
             WHERE ID_APPLICAZIONE = knIdApplBatchIstanzaRiesame
               AND COD_PARAMETRO = 'NO_MOTIV';
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 vStrVetMotDichDaEscludere := NULL;
        END;

        FOR recDocAttivoIstanzaRiesame IN curDocAttivoIstanzaRiesame (vStrVetMotDichDaEscludere) LOOP

            SELECT SEQ_DB_ISTANZA_RIESAME.nextval
              INTO recTIstanzaRiesame.ID_ISTANZA_RIESAME
              FROM DUAL;

            recTIstanzaRiesame.ID_FASE_ISTANZA_RIESAME := recDocAttivoIstanzaRiesame.ID_FASE_ISTANZA_RIESAME;
            recTIstanzaRiesame.ANNO := pAnnoDocumento;
            recTIstanzaRiesame.ID_AZIENDA := pIdAzienda;
            recTIstanzaRiesame.ID_PARTICELLA := recDocAttivoIstanzaRiesame.ID_PARTICELLA;
            recTIstanzaRiesame.DATA_RICHIESTA := recDocAttivoIstanzaRiesame.DATA_INSERIMENTO;
            recTIstanzaRiesame.DATA_AGGIORNAMENTO := SYSDATE;
            recTIstanzaRiesame.LAVORAZIONE_PRIORITARIA := recDocAttivoIstanzaRiesame.LAVORAZIONE_PRIORITARIA;
            recTIstanzaRiesame.NOTE := recDocAttivoIstanzaRiesame.NOTE;
            recTIstanzaRiesame.ID_UTENTE_RICHIEDENTE := recDocAttivoIstanzaRiesame.UTENTE_ULTIMO_AGGIORNAMENTO; 

            InsertTIstanzaRiesame (recTIstanzaRiesame);
            nNumPart := nNumPart + 1;

        END LOOP;

        /*
        pCodErr := '0';
        pDesErr := 'Inserite : ' || TO_CHAR(nNumPart) || ' particelle in richiesta riesame';
        */

    EXCEPTION
        WHEN OTHERS THEN
             pCodErr := '1';
             pDesErr := 'InserisciIstanza , errore pl/sql : ' || SUBSTR(SQLERRM,1,200);
    END InserisciIstanza;

    /*********************************************************************
    Dati in input un ID_AZIENDA, un ANNO ed un fase di istanza di riesame
    verifica se ci sono particelle legate a documenti annullati o storicizzati
    riferiti alla fase dell'istanza di riesame passata in input
    dove il cambiamento di stato del documento si è verificato dopo l'ultima
    esecuzione terminata a buon fine dei batch RPAIEA o RPAIIS
    e procede ad annullare la richiesta di riesame per la particella in questione
    se tale richiesta non è già stata annullata (o non è già stata evesa)
    Tipo: procedure
    input: pIdAzienda, pAnnoDocumento, pIdFaseIstRiesame, pIdUtente
    output: pCodErr, pDesErr
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE AnnullaIstanza (pIdAzienda        IN DB_ISTANZA_RIESAME.ID_AZIENDA%TYPE,
                              pAnnoDocumento    IN DB_ISTANZA_RIESAME.ANNO%TYPE,
                              pIdFaseIstRiesame IN DB_ISTANZA_RIESAME.ID_FASE_ISTANZA_RIESAME%TYPE,
                              pIdUtente         IN DB_ISTANZA_RIESAME.ID_UTENTE_RICHIEDENTE%TYPE,
                              pCodErr       IN OUT VARCHAR2,
                              pDesErr       IN OUT VARCHAR2) IS

        nNumPart    INTEGER:=0;
        VetIstanze  Num_Varray := Num_Varray ();

        CURSOR curDocumentoRiesame IS
        WITH ISTANZA_DA_ANNULLARE AS (
        SELECT CP.ID_PARTICELLA
          FROM DB_DOCUMENTO D,
               DB_DOCUMENTO_CONDUZIONE DC,
               DB_CONDUZIONE_PARTICELLA CP,
               DB_R_FASE_RIESAME_TP_DOCUMENTO RTD
         WHERE D.ID_AZIENDA = pIdAzienda
           AND TO_CHAR(D.DATA_INSERIMENTO,'YYYY') = pAnnoDocumento
           AND D.ID_STATO_DOCUMENTO IN (knIdStatoDocAnnullato, knIdStatoDocStoricizzato) -- ANNULLATI E STORICIZZATI
           AND DC.ID_DOCUMENTO = D.ID_DOCUMENTO
           AND CP.ID_CONDUZIONE_PARTICELLA = DC.ID_CONDUZIONE_PARTICELLA
           AND RTD.ID_DOCUMENTO = D.EXT_ID_DOCUMENTO
           AND RTD.ID_FASE_ISTANZA_RIESAME = pIdFaseIstRiesame
           AND RTD.DATA_FINE_VALIDITA IS NULL
           AND D.DATA_VARIAZIONE_STATO > (SELECT MAX(EB.DT_INIZIO_ESECUZIONE)
                                            FROM SMRGAA_T_ESECUZIONE_BATCH EB,
                                                 SMRGAA_D_APPLICAZIONI_BATCH AB
                                           WHERE AB.ID_APPLICAZIONE = DECODE (pIdFaseIstRiesame,knIdFaseIstRiesFotoInt,knIdApplBatchEleggibilita,knIdApplBatchIstanzaRiesame)
                                             AND AB.ID_APPLICAZIONE = EB.ID_APPLICAZIONE
                                             AND EB.FLAG_ESITO = 0)
        MINUS

        SELECT CP.ID_PARTICELLA
          FROM DB_DOCUMENTO D,
               DB_DOCUMENTO_CONDUZIONE DC,
               DB_CONDUZIONE_PARTICELLA CP,
               DB_R_FASE_RIESAME_TP_DOCUMENTO RTD
         WHERE D.ID_AZIENDA = pIdAzienda
           AND TO_CHAR(D.DATA_INSERIMENTO,'YYYY') = pAnnoDocumento
           AND D.ID_STATO_DOCUMENTO IS NULL
           AND DC.ID_DOCUMENTO = D.ID_DOCUMENTO
           AND DC.DATA_FINE_VALIDITA IS NULL 
           AND CP.ID_CONDUZIONE_PARTICELLA = DC.ID_CONDUZIONE_PARTICELLA
           AND RTD.ID_DOCUMENTO = D.EXT_ID_DOCUMENTO
           AND RTD.ID_FASE_ISTANZA_RIESAME = pIdFaseIstRiesame
           AND RTD.DATA_FINE_VALIDITA IS NULL)
      SELECT IA.ID_PARTICELLA
        FROM ISTANZA_DA_ANNULLARE IA
       WHERE EXISTS (SELECT ID_ISTANZA_RIESAME
                       FROM DB_ISTANZA_RIESAME
                      WHERE ANNO = pAnnoDocumento
                        AND ID_PARTICELLA = IA.ID_PARTICELLA
                        AND ID_FASE_ISTANZA_RIESAME = pIdFaseIstRiesame
                        AND DATA_EVASIONE IS NULL
                        AND DATA_ANNULLAMENTO IS NULL); 

    BEGIN

        FOR recDocumentoRiesame IN curDocumentoRiesame LOOP

            UPDATE DB_ISTANZA_RIESAME
               SET DATA_ANNULLAMENTO = SYSDATE,
                   DATA_AGGIORNAMENTO = SYSDATE,
                   ID_UTENTE_RICHIEDENTE = pIdUtente
             WHERE ID_AZIENDA = pIdAzienda
               AND ID_FASE_ISTANZA_RIESAME = pIdFaseIstRiesame
               AND ANNO = pAnnoDocumento
               AND ID_PARTICELLA = recDocumentoRiesame.ID_PARTICELLA
               AND DATA_ANNULLAMENTO IS NULL
               AND DATA_EVASIONE IS NULL;

            nNumPart := nNumPart + 1;

        END LOOP;

        -- visto che e' stata annullata l'istanza di riesame
        -- gli eventuali record di ID_STANZA_RIESAME_POTENZIALE
        -- ad esso legati vanno staccati cessando il record
        -- ed inserendone uno nuovo non legato all'ID_ISTANZA_RIESAME cessato
        UPDATE DB_ISTANZA_RIESAME_POTENZIALE
           SET DATA_FINE_VALIDITA = SYSDATE,
               ID_UTENTE_AGGIORNAMENTO = knIdUtenteAggBatch,
               DATA_AGGIORNAMENTO = SYSDATE
         WHERE ID_ISTANZA_RIESAME IN (SELECT ID_ISTANZA_RIESAME
                                        FROM DB_ISTANZA_RIESAME
                                       WHERE TRUNC(DATA_ANNULLAMENTO) = TRUNC(SYSDATE))
           AND DATA_FINE_VALIDITA IS NULL
        RETURN ID_ISTANZA_RIESAME_POTENZIALE BULK COLLECT INTO VetIstanze;

        -- nel vettore ho gli ID_ISTANZA_RIESAME_POTENZIALE cessati
        -- dall'update mi basta selezionarli forzando nella insert
        -- DATA_INIZIO_VALIDITA a SYSDATA, DATA_FINE_VALIDITA e ID_ISTANZA_RIESAME a NULL
        INSERT INTO DB_ISTANZA_RIESAME_POTENZIALE
            (
            ID_ISTANZA_RIESAME_POTENZIALE,
            ID_AZIENDA,
            ID_PARTICELLA,
            ID_PROCEDIMENTO,
            ID_DICHIARAZIONE_CONSISTENZA,
            EXT_ID_CONTROLLO,
            ANNO_ISTANZA,
            EXT_ID_PRATICA,
            ANNO_PRATICA,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA,
            ID_ISTANZA_RIESAME,
            DATA_AGGIORNAMENTO,
            ID_UTENTE_AGGIORNAMENTO
            )
        SELECT SEQ_DB_IST_RIESAME_POTENZIALE.nextval,
               ID_AZIENDA,
               ID_PARTICELLA,
               ID_PROCEDIMENTO,
               ID_DICHIARAZIONE_CONSISTENZA,
               EXT_ID_CONTROLLO,
               ANNO_ISTANZA,
               EXT_ID_PRATICA,
               ANNO_PRATICA,
               SYSDATE,
               NULL,
               NULL,
               SYSDATE,
               ID_UTENTE_AGGIORNAMENTO
          FROM DB_ISTANZA_RIESAME_POTENZIALE
         WHERE ID_ISTANZA_RIESAME_POTENZIALE IN (SELECT *
                                                   FROM TABLE(CAST(VetIstanze AS Num_Varray)));


        /*
        pCodErr := '0';
        pDesErr := 'Annullate : ' || TO_CHAR(nNumPart) || ' particelle in richiesta riesame';
        */

    EXCEPTION
        WHEN OTHERS THEN
             pCodErr := '1';
             pDesErr := 'Annulla Istanza , errore pl/sql : ' || SUBSTR(SQLERRM,1,200);
    END AnnullaIstanza;

    /*********************************************************************
    Estrae i dati anagrafici delle aziende che hanno richiesto istanza di riesame per
    contradditorio o sopralluogo in campo e anche i dati particellari delle particelle
    interessate e li accoda in due file di testo che poi saranno parsificati
    dal secondo job residenti su SITIPIOPR (GIS)
    Tipo: function
    input: pNomeFileDatiAnagrafici, pNomeFileDatiParticellari
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION InvioDatiAziendeInRiesame (pNomeFileDatiAnagrafici   IN VARCHAR2,
                                        pNomeFileDatiParticellari IN VARCHAR2
                                        ) RETURN NUMBER IS

        -- record di appoggio per il reperimento dei dati dell'applicazione corrente
        recDApplicazione    SMRGAA_D_APPLICAZIONI_BATCH%ROWTYPE;
        -- conterrà l'id esecuzione
        nIdEsecuzione       SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE;
        -- conterrà il codice di ritorno
        nRetCode            NUMBER(1):=0;
        -- vettore di parametri di input
        vetParametri        PCK_SMRGAA_LOG.TypVetParametriApplicazione;
        -- booleana di appoggio che mi dice se i parametri sono OK
        bParamOk            BOOLEAN:=TRUE;
        -- record che conterrà i dati dell'ultima esecuzione andata a buon fine del batch
        recTLastEsecOk      SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE;
        -- parametro che conterrà gli ID_MOTIVO_DICHIARAZIONE da escludere divisi dal seperatore ","
        vStrVetIdMotDich    SMRGAA_R_PARAM_APPLICAZIONE.VALORE_VARCHAR2%TYPE;
        -- riga di appoggio per scrittura del file delle azienda
        vRigaAzienda        VARCHAR2(4000);
        -- riga di appoggio per scrittura del file delle particelle
        vRigaParticella     VARCHAR2(4000);
        -- record di appoggio per reperimento dati titolare / rappresentante legale
        recTPersonaFisica   DB_PERSONA_FISICA%ROWTYPE;
        -- record di appoggio per la ricerca dei dati del comune
        recDComune          COMUNE%ROWTYPE;
        -- contatore del numero di aziende inviate a SITICONVOCA
        nNumAziende         INTEGER:=0;
        -- contatore del numero di utilizzi particella inviati a SITICONVOCA
        nNumParticelle      INTEGER:=0;
        -- file dei dati anagrafici da inviare a SITICONVOCA
        fFileDatiAnag       UTL_FILE.FILE_TYPE;
        -- file dei dati particellari da inviare a SITICONVOCA
        fFileDatiPart       UTL_FILE.FILE_TYPE;
        -- file dei parametri
        fFileParametri      UTL_FILE.FILE_TYPE;

        -- record di appoggio per reperimento altro dato con codice GGFOTO
        recDAltroDato       DB_ALTRI_DATI%ROWTYPE;

        vVetStatiFineIstCC    SMRGAA_R_PARAM_APPLICAZIONE.VALORE_VARCHAR2%TYPE;
        vVetStatiFineIstSC    SMRGAA_R_PARAM_APPLICAZIONE.VALORE_VARCHAR2%TYPE;
        vVetStatiFineIstCCxDC SMRGAA_R_PARAM_APPLICAZIONE.VALORE_VARCHAR2%TYPE;
        -- numero di giorni di distanza minimi tra una fase di istanza riesame e la successiva
        nGGTraFasi            SMRGAA_R_PARAM_APPLICAZIONE.VALORE_NUMBER%TYPE;
        -- stringa che contiene le fasi istanza da trattare in fase di invio suddivise da ","
        vVetFasiTratInvio     SMRGAA_R_PARAM_APPLICAZIONE.VALORE_VARCHAR2%TYPE;
        -- stringa che contiene le fasi istanza da trattare in fase di acquisizione suddivise da ","
        vVetFasiTratAcq       SMRGAA_R_PARAM_APPLICAZIONE.VALORE_VARCHAR2%TYPE;

        CURSOR curAziendaInRiesame (pNGGTraFasi         IN INTEGER,
                                    pVetFasiTratInvio   IN VARCHAR2,
                                    pDataPartenza       IN DATE) IS
        WITH FASI_CONCATENATE AS
           ( SELECT pVetFasiTratInvio AS FasiConc,
                    LEVEL AS pos,
                    SUBSTR(pVetFasiTratInvio,ROWNUM,1) AS CH,
                    COUNT(CASE WHEN SUBSTR(pVetFasiTratInvio,ROWNUM,1) = ',' THEN '#' END)
                    OVER (ORDER BY LEVEL) AS section
               FROM dual
         CONNECT BY LEVEL <= LENGTH(pVetFasiTratInvio)),
             FASI AS
           ( SELECT SUBSTR(FasiConc,MIN(pos), 1 + MAX(pos) - MIN(pos)) AS FASE
               FROM FASI_CONCATENATE
              WHERE CH <> ','
           GROUP BY FasiConc,section ),
            ISTANZA_RIESAME AS
           ( SELECT DISTINCT IR.ID_AZIENDA, IR.ANNO, IR.PROTOCOLLO_ISTANZA
               FROM DB_ISTANZA_RIESAME IR
              WHERE IR.ID_FASE_ISTANZA_RIESAME IN (SELECT FASE
                                                     FROM FASI)
                AND IR.DATA_EVASIONE IS NULL
                AND IR.DATA_ANNULLAMENTO IS NULL
                AND IR.DATA_INVIO_GIS IS NULL
                AND IR.ID_STATO_SITICONVOCA = knIdStatoSitiConvocaDaInv
                AND SYSDATE > NVL(
                              (SELECT MAX(IRI.DATA_AGGIORNAMENTO) + pNGGTraFasi 
                                 FROM DB_ISTANZA_RIESAME IRI
                                WHERE IRI.ID_AZIENDA = IR.ID_AZIENDA
                                  -- AND IRI.ANNO = IR.ANNO
                                  AND IRI.ID_FASE_ISTANZA_RIESAME = knIdFaseIstRiesFotoInt
                                  AND IRI.PROTOCOLLO_ISTANZA = IR.PROTOCOLLO_ISTANZA
                                  AND IRI.DATA_EVASIONE IS NOT NULL
                                  AND IRI.DATA_ANNULLAMENTO IS NULL),
                                  (
                                  SELECT TO_DATE('01/01/1900','DD/MM/YYYY')
                                    FROM DB_ISTANZA_RIESAME_POTENZIALE IRP
                                   WHERE IRP.ID_ISTANZA_RIESAME = IR.ID_ISTANZA_RIESAME
                                     AND IRP.DATA_FINE_VALIDITA IS NULL)) 
                AND NOT EXISTS (SELECT IRI.ID_ISTANZA_RIESAME
                                  FROM DB_ISTANZA_RIESAME IRI,
                                       DB_STORICO_PARTICELLA STP,
                                       COMUNE C,
                                       PROVINCIA P
                                 WHERE IRI.ID_AZIENDA = IR.ID_AZIENDA
                                   -- AND IRI.ANNO = IR.ANNO
                                   AND IRI.ID_FASE_ISTANZA_RIESAME = knIdFaseIstRiesFotoInt
                                   AND IRI.PROTOCOLLO_ISTANZA = IR.PROTOCOLLO_ISTANZA
                                   AND IRI.ID_PARTICELLA = STP.ID_PARTICELLA
                                   AND STP.DATA_FINE_VALIDITA IS NULL
                                   AND STP.COMUNE = C.ISTAT_COMUNE
                                   AND C.ISTAT_PROVINCIA = P.ISTAT_PROVINCIA
                                   AND P.ID_REGIONE = kvIdRegionePiemonte
                                   AND IRI.DATA_EVASIONE IS NULL
                                   AND IRI.DATA_ANNULLAMENTO IS NULL) 
                AND NOT EXISTS (SELECT IRI.ID_ISTANZA_RIESAME
                                  FROM DB_ISTANZA_RIESAME IRI
                                 WHERE IRI.ID_AZIENDA = IR.ID_AZIENDA
                                   AND IRI.ANNO = IR.ANNO
                                   AND IRI.ID_FASE_ISTANZA_RIESAME IN (knIdFaseIstRiesContradditorio,knIdFaseIstRiesSopraluogo)
                                   AND IRI.PROTOCOLLO_ISTANZA <> IR.PROTOCOLLO_ISTANZA
                                   AND IRI.DATA_INVIO_GIS IS NOT NULL
                                   AND IRI.DATA_EVASIONE IS NULL)),
             VERA_DELEGA AS (SELECT MAX(CODICE_AGEA) AS CODICE_AGEA,
                                    MAX(DENOMINAZIONE) AS DENOMINAZIONE,
                                    ID_AZIENDA
                              FROM (SELECT UZI.CODICE_AGEA,
                                           UZI.DENOMINAZIONE,
                                           IR.ID_AZIENDA
                                      FROM DB_DELEGA DE,
                                           DB_UFFICIO_ZONA_INTERMEDIARIO UZI,
                                           ISTANZA_RIESAME IR
                                     WHERE DE.ID_AZIENDA = IR.ID_AZIENDA
                                       AND DE.ID_PROCEDIMENTO = knIdProcedimentoSMRGAA
                                       AND DE.DATA_FINE IS NULL
                                       AND DE.ID_INTERMEDIARIO = UZI.ID_INTERMEDIARIO

                                     UNION

                                     SELECT NULL,
                                            NULL,
                                            IR.ID_AZIENDA
                                       FROM ISTANZA_RIESAME IR)
                                GROUP BY ID_AZIENDA)
        SELECT DISTINCT
               AZ.*,
               SUBSTR(ISR.PROTOCOLLO_ISTANZA,5,4) AS ANNO,
               ISR.PROTOCOLLO_ISTANZA, 
               VD.CODICE_AGEA,
               VD.DENOMINAZIONE AS DEN_CAA
          FROM DB_ANAGRAFICA_AZIENDA AZ,
               VERA_DELEGA VD,
               ISTANZA_RIESAME ISR
         WHERE AZ.DATA_FINE_VALIDITA IS NULL
           AND AZ.DATA_CESSAZIONE IS NULL
           AND AZ.ID_AZIENDA = ISR.ID_AZIENDA
           AND VD.ID_AZIENDA = AZ.ID_AZIENDA;


        CURSOR curParticellaInRiesame (pIdAzienda                   IN DB_ISTANZA_RIESAME.ID_AZIENDA%TYPE,
                                       pProtIstanza                 IN DB_ISTANZA_RIESAME.PROTOCOLLO_ISTANZA%TYPE,
                                       pStrVetMotDichDaEscludere    IN VARCHAR2) IS
        WITH MOTIVI_CONCATENATI AS
           ( SELECT pStrVetMotDichDaEscludere AS MotiviConc,
                    LEVEL AS pos,
                    SUBSTR(pStrVetMotDichDaEscludere,ROWNUM,1) AS CH,
                    COUNT(CASE WHEN SUBSTR(pStrVetMotDichDaEscludere,ROWNUM,1) = ',' THEN '#' END)
                    OVER (ORDER BY LEVEL) AS section
               FROM dual
         CONNECT BY LEVEL <= LENGTH(pStrVetMotDichDaEscludere)),
             MOTIVI AS
           ( SELECT SUBSTR(MotiviConc,MIN(pos), 1 + MAX(pos) - MIN(pos)) AS MOTIVO
               FROM MOTIVI_CONCATENATI
              WHERE CH <> ','
           GROUP BY MotiviConc,section )
        SELECT IR.ID_ISTANZA_RIESAME,
               --IR.ANNO,
               SUBSTR(IR.PROTOCOLLO_ISTANZA,5,4) AS ANNO,
               DECODE(IR.ID_FASE_ISTANZA_RIESAME,knIdFaseIstRiesContradditorio,1,knIdFaseIstRiesSopraluogo,2) AS TIPO_RICHIESTA,
               C.CODFISC,
               SP.SEZIONE,
               SP.FOGLIO,
               SP.PARTICELLA,
               SP.SUBALTERNO,
               TU.CODICE,
               TV.CODICE_VARIETA,
               UD.SUPERFICIE_UTILIZZATA * 10000 AS SUP_UTILIZZATA,
               CD.PERCENTUALE_POSSESSO,
               CD.ID_TITOLO_POSSESSO,
               (SELECT SUM(ED.PERCENTUALE_UTILIZZO)
                  FROM DB_ELEGGIBILITA_DICHIARATA ED,
                       DB_VARIETA_ELEGGIBILITA VE
                 WHERE ED.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
                   AND ED.ID_PARTICELLA = IR.ID_PARTICELLA
                   AND ED.ID_ELEGGIBILITA_FIT = VE.ID_ELEGGIBILITA_FIT
                   AND VE.ID_CATALOGO_MATRICE = UD.ID_CATALOGO_MATRICE 
                   AND ED.PERCENTUALE_UTILIZZO IS NOT NULL
                   AND VE.DATA_FINE_VALIDITA IS NULL) AS PERCENTUALE_UTILIZZO, 
               SP.ID_CASO_PARTICOLARE,
               IR.NOTE,
               IR.DATA_INVIO_GIS
          FROM DB_ISTANZA_RIESAME IR,
               DB_CONDUZIONE_DICHIARATA CD,
               DB_UTILIZZO_DICHIARATO UD,
               DB_STORICO_PARTICELLA SP,
               COMUNE C,
               DB_TIPO_UTILIZZO TU,
               DB_TIPO_VARIETA TV,DB_R_CATALOGO_MATRICE CM
         WHERE IR.ID_AZIENDA = pIdAzienda
           AND IR.PROTOCOLLO_ISTANZA = pProtIstanza
           AND IR.DATA_EVASIONE IS NULL
           AND IR.DATA_ANNULLAMENTO IS NULL
           AND IR.DATA_INVIO_GIS IS NULL
           AND IR.ID_FASE_ISTANZA_RIESAME IN (knIdFaseIstRiesContradditorio,knIdFaseIstRiesSopraluogo)
           AND CD.CODICE_FOTOGRAFIA_TERRENI = NVL((SELECT MAX(CDD2.CODICE_FOTOGRAFIA_TERRENI) 
                                                     FROM DB_ISTANZA_RIESAME_POTENZIALE IRP,  -- i dati di quella validazione
                                                          DB_DICHIARAZIONE_CONSISTENZA DC,
                                                          DB_CONDUZIONE_DICHIARATA CDD2
                                                    WHERE IRP.ID_ISTANZA_RIESAME = IR.ID_ISTANZA_RIESAME
                                                      AND IRP.ID_DICHIARAZIONE_CONSISTENZA = DC.ID_DICHIARAZIONE_CONSISTENZA
                                                      AND DC.CODICE_FOTOGRAFIA_TERRENI = CDD2.CODICE_FOTOGRAFIA_TERRENI
                                                      AND CDD2.ID_PARTICELLA = IR.ID_PARTICELLA
                                                      AND IRP.ID_PARTICELLA = IR.ID_PARTICELLA
                                                      AND CDD2.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento),
                                                  (SELECT MAX(CDD.CODICE_FOTOGRAFIA_TERRENI)
                                                     FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                                                          DB_CONDUZIONE_DICHIARATA CDD,
                                                          DB_TIPO_MOTIVO_DICHIARAZIONE TMD
                                                    WHERE DC.ID_AZIENDA = IR.ID_AZIENDA
                                                      AND DC.ANNO <= IR.ANNO
                                                      AND DC.CODICE_FOTOGRAFIA_TERRENI = CDD.CODICE_FOTOGRAFIA_TERRENI
                                                      AND DC.NUMERO_PROTOCOLLO IS NOT NULL
                                                      AND DC.ID_MOTIVO_DICHIARAZIONE = TMD.ID_MOTIVO_DICHIARAZIONE
                                                      AND TMD.TIPO_DICHIARAZIONE <> 'C'
                                                      AND DC.ID_MOTIVO_DICHIARAZIONE NOT IN (SELECT MOTIVO
                                                                                               FROM MOTIVI)
                                                      AND CDD.ID_PARTICELLA = IR.ID_PARTICELLA
                                                      AND CD.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento))

           AND CD.ID_PARTICELLA = IR.ID_PARTICELLA
           AND CD.ID_CONDUZIONE_DICHIARATA = UD.ID_CONDUZIONE_DICHIARATA
           AND CD.ID_STORICO_PARTICELLA = SP.ID_STORICO_PARTICELLA
           AND CD.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento
           AND SP.COMUNE = C.ISTAT_COMUNE
           AND UD.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND CM.ID_UTILIZZO = TU.ID_UTILIZZO 
           AND CM.ID_VARIETA = TV.ID_VARIETA;  

    BEGIN

        nRetCode := Pck_SMRGAA_Log.VerificaAttivazioneBatch( knIdApplBatchIstanzaRiesame ,recDApplicazione);

        IF nRetCode > 0 THEN
             -- Errore, Batch non attivo
            RETURN nRetCode;
        END IF;

         -- Inserimento in tabella dell'identificativo di esecuzione
         -- nIdEsecuzione restituito in output
        Pck_SMRGAA_Log.InsertTEsecuzione ( knIdApplBatchIstanzaRiesame, nIdEsecuzione );
        COMMIT;

         -- Scrittura nel file nomefile_esecuzione del nIdEsecuzione
        Pck_SMRGAA_Log.ScriviFileEsecuzione ( recDApplicazione.nomefile_esecuzione,
                                              recDApplicazione.path_file_esecuzione,
                                              nIdEsecuzione );

        Pck_SMRGAA_Log.LeggiFileEsecuzione ( recDApplicazione.nomefile_esecuzione, recDApplicazione.path_file_esecuzione );

        Pck_SMRGAA_Log.SetLogLevel ( recDApplicazione.log_level );

        Pck_SMRGAA_Log.Init( knIdApplBatchIstanzaRiesame, 'InvioDatiAziendeInRiesame' );

        
        -- cerco l'ultima esecuzione del batch precedente a quella attuale andata a buon fine
        recTLastEsecOk := Pck_SMRGAA_Log.SelectTLastEsecuzioneOK (knIdApplBatchIstanzaRiesame);
        -- se non la trovo
        IF recTLastEsecOk.ID_ESECUZIONE IS NULL THEN
           -- utilizzerò la SYSDATE (troncata)
           recTLastEsecOk.DT_INIZIO_ESECUZIONE := TO_DATE('01/01/1900','DD/MM/YYYY');
           recTLastEsecOk.DT_FINE_ESECUZIONE := TO_DATE('01/01/1900','DD/MM/YYYY');
        END IF;

        -- carico il vettore di parametri per il batch
        vetParametri := PCK_SMRGAA_LOG.CaricaParametriApplicazione(knIdApplBatchIstanzaRiesame);
        -- dev'esserci il parametro degli ID_MOTIVO_DICHIARAZIONE da escludere dallo scarico
        IF vetParametri.COUNT = 0 THEN
           -- quindi se non c'è non mi blocco
           PCK_SMRGAA_LOG.LogInfo ('Parametro : ' || kvCodParVetMotiviDich || ' non presente');
           bParamOk := FALSE;
        ELSE
            BEGIN
                vStrVetIdMotDich := vetParametri (kvCodParVetMotiviDich).val_varchar2;
                PCK_SMRGAA_LOG.LogInfo ('Parametro : ' || kvCodParVetMotiviDich || ' presente ed uguale a : ' || vStrVetIdMotDich);
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParVetMotiviDich || ' non presente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParVetMotiviDich || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
            END;

            BEGIN
                vVetStatiFineIstCC := vetParametri (kvCodParStatiFineIstRiesCC).val_varchar2;
                PCK_SMRGAA_LOG.LogInfo ('Parametro : ' || kvCodParStatiFineIstRiesCC || ' presente ed uguale a : ' || vVetStatiFineIstCC);
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParStatiFineIstRiesCC || ' non presente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParStatiFineIstRiesCC || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
            END;

            BEGIN
                vVetStatiFineIstSC := vetParametri (kvCodParStatiFineIstRiesSC).val_varchar2;
                PCK_SMRGAA_LOG.LogInfo ('Parametro : ' || kvCodParStatiFineIstRiesSC || ' presente ed uguale a : ' || vVetStatiFineIstSC);
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParStatiFineIstRiesSC || ' non presente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParStatiFineIstRiesSC || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
            END;

            BEGIN
                vVetStatiFineIstCCxDC := vetParametri (kvCodParStatiFineDCIstRiesCC).val_varchar2;
                PCK_SMRGAA_LOG.LogInfo ('Parametro : ' || kvCodParStatiFineDCIstRiesCC || ' presente ed uguale a : ' || vVetStatiFineIstCCxDC);
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParStatiFineDCIstRiesCC || ' non presente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParStatiFineDCIstRiesCC || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
            END;

            BEGIN
                nGGTraFasi := vetParametri (kvCodParGGTraFasi).val_number;
                PCK_SMRGAA_LOG.LogInfo ('Parametro : ' || kvCodParGGTraFasi || ' presente ed uguale a : ' || nGGTraFasi);
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParGGTraFasi || ' non presente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParGGTraFasi || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
            END;

            BEGIN
                vVetFasiTratInvio := vetParametri (kvCodParFaseAnagDaInv).val_varchar2;
                PCK_SMRGAA_LOG.LogInfo ('Parametro : ' || kvCodParFaseAnagDaInv || ' presente ed uguale a : ' || vVetFasiTratInvio);
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParFaseAnagDaInv || ' non presente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParFaseAnagDaInv || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
            END;

            BEGIN
                vVetFasiTratAcq := vetParametri (kvCodParFaseSitiConvDaAcq).val_varchar2;
                PCK_SMRGAA_LOG.LogInfo ('Parametro : ' || kvCodParFaseSitiConvDaAcq || ' presente ed uguale a : ' || vVetFasiTratAcq);
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParFaseSitiConvDaAcq || ' non presente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParFaseSitiConvDaAcq || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
            END;

        END IF;

        recDAltroDato := SelDAltroDatoByCodice (kvCodAltroDatoGGFoto);

        IF recDAltroDato.ID_ALTRI_DATI IS NULL THEN
           PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodAltroDatoGGFoto || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
           bParamOk := FALSE;
        END IF;

        IF bParamOk THEN

           EXECUTE IMMEDIATE 'TRUNCATE TABLE SMRGAA_W_ISTANZA_RIESAME';
           EXECUTE IMMEDIATE 'TRUNCATE TABLE SMRGAA_W_PART_ISTANZA_RIESAME';

           fFileParametri := UTL_FILE.FOPEN (recDApplicazione.path_file_esecuzione, SUBSTR(recDApplicazione.nomefile_esecuzione,1, INSTR(recDApplicazione.nomefile_esecuzione,'_')) || 'PARAM','W',1000);
           vRigaAzienda := kvCodParStatiFineIstRiesCC || '=' || vVetStatiFineIstCC;
           UTL_FILE.PUT_LINE(fFileParametri,vRigaAzienda);
           vRigaAzienda := kvCodParStatiFineIstRiesSC || '=' || vVetStatiFineIstSC;
           UTL_FILE.PUT_LINE(fFileParametri,vRigaAzienda);
           vRigaAzienda := kvCodParStatiFineDCIstRiesCC || '=' || vVetStatiFineIstCCxDC;
           UTL_FILE.PUT_LINE(fFileParametri,vRigaAzienda);
           vRigaAzienda := 'DT_LAST_EXEC=' || TO_CHAR(recTLastEsecOk.DT_INIZIO_ESECUZIONE,'DD/MM/YYYY HH24:MI:SS');
           UTL_FILE.PUT_LINE(fFileParametri,vRigaAzienda);
           UTL_FILE.FCLOSE(fFileParametri);

           PCK_SMRGAA_LOG.LogInfo ('Inizio Elaborazione');

           fFileDatiAnag := UTL_FILE.FOPEN (recDApplicazione.path_file_esecuzione, pNomeFileDatiAnagrafici,'W',4000);
           fFileDatiPart := UTL_FILE.FOPEN (recDApplicazione.path_file_esecuzione, pNomeFileDatiParticellari,'W',4000);

           FOR recAziendaInRiesame IN curAziendaInRiesame (nGGTraFasi,
                                                           vVetFasiTratInvio,
                                                           SYSDATE) LOOP

               vRigaAzienda := '9' || SUBSTR(recAziendaInRiesame.ANNO,3,2) || '|';
               vRigaAzienda := vRigaAzienda || recAziendaInRiesame.CUAA || '|';
               vRigaAzienda := vRigaAzienda || recAziendaInRiesame.ANNO || '|';
               vRigaAzienda := vRigaAzienda || NVL(recAziendaInRiesame.CODICE_AGEA,'000000000') || '|';
               vRigaAzienda := vRigaAzienda || NVL(recAziendaInRiesame.DEN_CAA, 'Regione Piemonte') || '|';

               IF LENGTH(recAziendaInRiesame.CUAA) = knLengthCF THEN
                  vRigaAzienda := vRigaAzienda || 'S|';
               ELSE
                  vRigaAzienda := vRigaAzienda || 'N|';
               END IF;

               vRigaAzienda := vRigaAzienda || recAziendaInRiesame.DENOMINAZIONE || '|';

               recTPersonaFisica := SelTPersFisicaByIdAziendaRuolo (recAziendaInRiesame.ID_AZIENDA, knIdRuoloTitolareRapprLegale);

               IF recTPersonaFisica.ID_PERSONA_FISICA IS NOT NULL THEN
                  vRigaAzienda := vRigaAzienda || recTPersonaFisica.COGNOME || '|';
                  vRigaAzienda := vRigaAzienda || recTPersonaFisica.NOME || '|';
                  vRigaAzienda := vRigaAzienda || TO_CHAR(recTPersonaFisica.NASCITA_DATA,'DD/MM/YYYY') || '|';

                  recDComune := SelDComuneByCodIStat (recTPersonaFisica.NASCITA_COMUNE);

                  IF recDComune.ISTAT_COMUNE IS NOT NULL THEN
                     vRigaAzienda := vRigaAzienda || recDComune.CODFISC || '|';
                  ELSE
                     vRigaAzienda := vRigaAzienda || '|';
                  END IF;

                  -- metto i dati di domicilio se ci sono tutti altrimenti metto quello di residenza
                  IF recTPersonaFisica.DOM_COMUNE IS NOT NULL AND
                     recTPersonaFisica.DOM_INDIRIZZO IS NOT NULL AND
                     recTPersonaFisica.DOM_CAP IS NOT NULL THEN

                     recDComune := SelDComuneByCodIStat (recTPersonaFisica.DOM_COMUNE);

                     IF recDComune.ISTAT_COMUNE IS NOT NULL THEN
                        vRigaAzienda := vRigaAzienda || recDComune.CODFISC || '|';
                     ELSE
                        vRigaAzienda := vRigaAzienda || '|';
                     END IF;

                     vRigaAzienda := vRigaAzienda || recTPersonaFisica.DOM_INDIRIZZO || '|';
                     vRigaAzienda := vRigaAzienda || recTPersonaFisica.DOM_CAP || '|';

                  ELSE

                     recDComune := SelDComuneByCodIStat (recTPersonaFisica.RES_COMUNE);

                     IF recDComune.ISTAT_COMUNE IS NOT NULL THEN
                        vRigaAzienda := vRigaAzienda || recDComune.CODFISC || '|';
                     ELSE
                        vRigaAzienda := vRigaAzienda || '|';
                     END IF;

                     vRigaAzienda := vRigaAzienda || recTPersonaFisica.RES_INDIRIZZO || '|';
                     vRigaAzienda := vRigaAzienda || recTPersonaFisica.RES_CAP || '|';

                  END IF;

               ELSE
                  vRigaAzienda := vRigaAzienda || '|';
                  vRigaAzienda := vRigaAzienda || '|';
                  vRigaAzienda := vRigaAzienda || '|';
                  vRigaAzienda := vRigaAzienda || '|';
                  vRigaAzienda := vRigaAzienda || '|';
                  vRigaAzienda := vRigaAzienda || '|';
                  vRigaAzienda := vRigaAzienda || '|';
               END IF;

               recDComune := SelDComuneByCodIStat (recAziendaInRiesame.SEDELEG_COMUNE);

               IF recDComune.ISTAT_COMUNE IS NOT NULL THEN
                  vRigaAzienda := vRigaAzienda || recDComune.CODFISC || '|';
               ELSE
                  vRigaAzienda := vRigaAzienda || '|';
               END IF;

               vRigaAzienda := vRigaAzienda || recAziendaInRiesame.SEDELEG_INDIRIZZO || '|';
               vRigaAzienda := vRigaAzienda || recAziendaInRiesame.SEDELEG_CAP || '|';
               vRigaAzienda := vRigaAzienda || recAziendaInRiesame.MAIL || '|'; 
               vRigaAzienda := vRigaAzienda || recAziendaInRiesame.PEC || '|'; 
               vRigaAzienda := vRigaAzienda || recAziendaInRiesame.TELEFONO || '|'; 
               vRigaAzienda := vRigaAzienda || recAziendaInRiesame.PROTOCOLLO_ISTANZA ||'|'; 
               UTL_FILE.PUT_LINE(fFileDatiAnag,vRigaAzienda);

               nNumAziende := nNumAziende + 1;

               FOR recParticellaInRiesame IN curParticellaInRiesame (recAziendaInRiesame.ID_AZIENDA,
                                                                     recAziendaInRiesame.PROTOCOLLO_ISTANZA, 
                                                                     vStrVetIdMotDich) LOOP
                   vRigaParticella := recAziendaInRiesame.CUAA || '|';
                   vRigaParticella := vRigaParticella || recParticellaInRiesame.ANNO || '|';
                   vRigaParticella := vRigaParticella || recParticellaInRiesame.ID_ISTANZA_RIESAME || '|';
                   vRigaParticella := vRigaParticella || recParticellaInRiesame.TIPO_RICHIESTA || '|';
                   vRigaParticella := vRigaParticella || recParticellaInRiesame.CODFISC || '|';
                   vRigaParticella := vRigaParticella || recParticellaInRiesame.SEZIONE || '|';
                   vRigaParticella := vRigaParticella || recParticellaInRiesame.FOGLIO || '|';
                   vRigaParticella := vRigaParticella || LPAD(recParticellaInRiesame.PARTICELLA,5,'0') || '|';
                   vRigaParticella := vRigaParticella || recParticellaInRiesame.SUBALTERNO || '|';
                   vRigaParticella := vRigaParticella || recParticellaInRiesame.CODICE || '|';
                   vRigaParticella := vRigaParticella || recParticellaInRiesame.CODICE_VARIETA || '|';
                   vRigaParticella := vRigaParticella || recParticellaInRiesame.SUP_UTILIZZATA || '|';
                   vRigaParticella := vRigaParticella || recParticellaInRiesame.PERCENTUALE_POSSESSO || '|';
                   vRigaParticella := vRigaParticella || recParticellaInRiesame.ID_TITOLO_POSSESSO || '|';
                   vRigaParticella := vRigaParticella || recParticellaInRiesame.PERCENTUALE_UTILIZZO || '|';
                   vRigaParticella := vRigaParticella || recParticellaInRiesame.ID_CASO_PARTICOLARE || '|';
                   vRigaParticella := vRigaParticella || recParticellaInRiesame.NOTE || '|';
                   vRigaParticella := vRigaParticella || TO_CHAR(recParticellaInRiesame.DATA_INVIO_GIS,'DD/MM/YYYY') || '|';
                   UTL_FILE.PUT_LINE(fFileDatiPart,vRigaParticella);
                   nNumParticelle := nNumParticelle + 1;

                   UPDATE DB_ISTANZA_RIESAME
                      SET NOTE = DECODE(DATA_INVIO_GIS, NULL, NULL, 'Data di invio a SITICONVOCA precedente = ' || TO_CHAR(DATA_INVIO_GIS,'DD/MM/YYYY HH24:MI:SS')),
                          DATA_INVIO_GIS = SYSDATE,
                          ID_STATO_SITICONVOCA = knIdStatoSitiConvocaDaConv
                    WHERE ID_ISTANZA_RIESAME = recParticellaInRiesame.ID_ISTANZA_RIESAME;

               END LOOP;

           END LOOP;

           UTL_FILE.FCLOSE(fFileDatiAnag);
           UTL_FILE.FCLOSE(fFileDatiPart);

           PCK_SMRGAA_LOG.LogInfo ('Fine Elaborazione');

        END IF;

        IF nNumAziende > 0 AND nNumParticelle > 0 THEN
           nRetCode := 0;
           PCK_SMRGAA_LOG.LogInfo ('Accodate : ' || nNumAziende || ' aziende e ' || nNumParticelle || ' particelle per invio a SITICONVOCA');
        ELSE
           PCK_SMRGAA_LOG.LogAnomalia ('Nessun Azienda con particelle in fasi di istanza di riesame da inviare a SITICONVOCA');
           nRetCode := 4;
        END IF;

        COMMIT;

        RETURN nRetCode;

    EXCEPTION
        WHEN OTHERS THEN
             ROLLBACK;
             PCK_SMRGAA_LOG.LogSqlError ('InvioDatiAziendeInRiesame');
             IF UTL_FILE.IS_OPEN(fFileParametri) THEN
                UTL_FILE.FCLOSE(fFileParametri);
             END IF;
             IF UTL_FILE.IS_OPEN(fFileDatiAnag) THEN
                UTL_FILE.FCLOSE(fFileDatiAnag);
             END IF;
             IF UTL_FILE.IS_OPEN(fFileDatiPart) THEN
                UTL_FILE.FCLOSE(fFileDatiPart);
             END IF;
             RETURN 1;
    END InvioDatiAziendeInRiesame;


    PROCEDURE EvadiIstanzaRiesame (pRecTIstanzaRiesame      IN DB_ISTANZA_RIESAME%ROWTYPE,
                                   pRecIstanzaRiesameEvasa  IN curIstanzaRiesameEvasa%ROWTYPE,
                                   pRecDTipoCategNotSopr    IN DB_TIPO_CATEGORIA_NOTIFICA%ROWTYPE,
                                   pRecDTipoCategNotCtrl    IN DB_TIPO_CATEGORIA_NOTIFICA%ROWTYPE
                                   ) IS

        recTNotifica DB_NOTIFICA%ROWTYPE;
        -- vettore di parametri di input
        TYPE TypVetDoc IS TABLE OF DB_DOCUMENTO_CONDUZIONE.ID_DOCUMENTO%TYPE INDEX BY PLS_INTEGER;
        VetDoc TypVetDoc;
        -- variabile di appoggio che conterra' il documento da cessare
        nIdDocumento        DB_DOCUMENTO.ID_DOCUMENTO%TYPE;
        -- variabile di appoggio per returning update DB_ISTANZA_RIESAME_POTENZIALE
        nIdIstRiePot        DB_ISTANZA_RIESAME_POTENZIALE.ID_ISTANZA_RIESAME_POTENZIALE%TYPE;

        vEvadiAnnulla       VARCHAR2(1);
    BEGIN

       IF pRecIstanzaRiesameEvasa.STATO = 3 THEN
          vEvadiAnnulla := 'E';
       ELSIF pRecIstanzaRiesameEvasa.ID_STATO_SITICONVOCA = knIdStatoSitiConvocaRicSopr AND
             pRecTIstanzaRiesame.ID_FASE_ISTANZA_RIESAME = knIdFaseIstRiesContradditorio THEN
          vEvadiAnnulla := 'E';
       ELSIF pRecIstanzaRiesameEvasa.STATO = 4 THEN
          vEvadiAnnulla := 'A';
       ELSE
         vEvadiAnnulla := 'N';
       END IF;


       IF vEvadiAnnulla IN ('E','A') THEN

           UPDATE DB_ISTANZA_RIESAME
              SET DATA_EVASIONE = DECODE(vEvadiAnnulla,'E',pRecIstanzaRiesameEvasa.DATA_AGGIORNAMENTO,NULL),
                  DATA_ANNULLAMENTO = DECODE(vEvadiAnnulla,'A',pRecIstanzaRiesameEvasa.DATA_AGGIORNAMENTO,NULL),
                  DATA_SITICONVOCA = NVL(pRecIstanzaRiesameEvasa.DATA_SOPRALUOGO,pRecIstanzaRiesameEvasa.DATA_CONVOCAZIONE),
                  ID_STATO_SITICONVOCA = pRecIstanzaRiesameEvasa.ID_STATO_SITICONVOCA,
                  DATA_AGGIORNAMENTO = SYSDATE
            WHERE ID_ISTANZA_RIESAME = pRecTIstanzaRiesame.ID_ISTANZA_RIESAME;

           -- devo anche slegare l'ID_ISTANZA_RIESAME_POTENZIALE
           -- che può essere stato associato all'ID_ISTANZA_RIESAME
           IF vEvadiAnnulla = 'A' THEN

              nIdIstRiePot := NULL;

              UPDATE DB_ISTANZA_RIESAME_POTENZIALE
                 SET DATA_FINE_VALIDITA = SYSDATE,
                     DATA_AGGIORNAMENTO = SYSDATE,
                     ID_UTENTE_AGGIORNAMENTO = knIdUtenteAggBatch
               WHERE ID_ISTANZA_RIESAME = pRecTIstanzaRiesame.ID_ISTANZA_RIESAME
                 AND DATA_FINE_VALIDITA IS NULL
              RETURN ID_ISTANZA_RIESAME_POTENZIALE INTO nIdIstRiePot;

              -- se c'è reinserisco il record uguale
              -- ma senza data fine validita e senza ID_ISTANZA_RIESAME
              -- e con la data inizio a sysdate
              IF nIdIstRiePot IS NOT NULL THEN

                 INSERT INTO DB_ISTANZA_RIESAME_POTENZIALE
                    (
                    ID_ISTANZA_RIESAME_POTENZIALE,
                    ID_AZIENDA,
                    ID_PARTICELLA,
                    ID_PROCEDIMENTO,
                    ID_DICHIARAZIONE_CONSISTENZA,
                    EXT_ID_CONTROLLO,
                    ANNO_ISTANZA,
                    EXT_ID_PRATICA,
                    ANNO_PRATICA,
                    DATA_INIZIO_VALIDITA,
                    DATA_FINE_VALIDITA,
                    ID_ISTANZA_RIESAME,
                    DATA_AGGIORNAMENTO,
                    ID_UTENTE_AGGIORNAMENTO
                    )
                 SELECT SEQ_DB_IST_RIESAME_POTENZIALE.nextval,
                        ID_AZIENDA,
                        ID_PARTICELLA,
                        ID_PROCEDIMENTO,
                        ID_DICHIARAZIONE_CONSISTENZA,
                        EXT_ID_CONTROLLO,
                        ANNO_ISTANZA,
                        EXT_ID_PRATICA,
                        ANNO_PRATICA,
                        SYSDATE,
                        NULL,
                        NULL,
                        SYSDATE,
                        knIdUtenteAggBatch
                   FROM DB_ISTANZA_RIESAME_POTENZIALE
                  WHERE ID_ISTANZA_RIESAME_POTENZIALE = nIdIstRiePot;

              END IF;

           END IF;

           UPDATE DB_DOCUMENTO_CONDUZIONE
              SET DATA_FINE_VALIDITA = SYSDATE
            WHERE ID_DOCUMENTO_CONDUZIONE IN (SELECT DC.ID_DOCUMENTO_CONDUZIONE
                                                FROM DB_R_FASE_RIESAME_TP_DOCUMENTO RTD,
                                                     DB_DOCUMENTO D,
                                                     DB_DOCUMENTO_CONDUZIONE DC,
                                                     DB_CONDUZIONE_PARTICELLA CP
                                               WHERE D.ID_AZIENDA = pRecTIstanzaRiesame.ID_AZIENDA
                                                 AND D.ID_STATO_DOCUMENTO IS NULL
                                                 AND D.DATA_FINE_VALIDITA IS NULL
                                                 AND D.EXT_ID_DOCUMENTO = RTD.ID_DOCUMENTO
                                                 AND RTD.DATA_FINE_VALIDITA IS NULL
                                                 AND RTD.ID_FASE_ISTANZA_RIESAME = pRecTIstanzaRiesame.ID_FASE_ISTANZA_RIESAME
                                                 AND DC.ID_DOCUMENTO = D.ID_DOCUMENTO
                                                 AND DC.DATA_FINE_VALIDITA IS NULL
                                                 AND DC.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
                                                 AND CP.ID_PARTICELLA = pRecTIstanzaRiesame.ID_PARTICELLA
                                                 AND CP.DATA_FINE_CONDUZIONE IS NULL)
           RETURN ID_DOCUMENTO BULK COLLECT INTO VetDoc;

           FOR I IN 1..VetDoc.COUNT LOOP

               UPDATE DB_DOCUMENTO D
                  SET D.DATA_FINE_VALIDITA = SYSDATE
                WHERE D.ID_DOCUMENTO = VetDoc(I)
                  AND (D.DATA_FINE_VALIDITA IS NULL OR D.DATA_FINE_VALIDITA > SYSDATE)
                  AND NOT EXISTS (SELECT DC.ID_DOCUMENTO_CONDUZIONE
                                    FROM DB_DOCUMENTO_CONDUZIONE DC
                                   WHERE DC.ID_DOCUMENTO = D.ID_DOCUMENTO
                                     AND DC.DATA_FINE_VALIDITA IS NULL)
               RETURN ID_DOCUMENTO INTO nIdDocumento;

               IF nIdDocumento IS NOT NULL THEN
                  SELECT SEQ_NOTIFICA.nextval
                    INTO recTNotifica.ID_NOTIFICA
                    FROM DUAL;

                  recTNotifica.ID_AZIENDA := pRecTIstanzaRiesame.ID_AZIENDA;
                  recTNotifica.ID_UTENTE_INSERIMENTO := 9999999999;

                  IF pRecTIstanzaRiesame.ID_FASE_ISTANZA_RIESAME = knIdFaseIstRiesContradditorio THEN
                     recTNotifica.ID_TIPOLOGIA_NOTIFICA := pRecDTipoCategNotCtrl.ID_TIPOLOGIA_NOTIFICA;
                     recTNotifica.ID_CATEGORIA_NOTIFICA := pRecDTipoCategNotCtrl.ID_CATEGORIA_NOTIFICA;
                  ELSE
                     recTNotifica.ID_TIPOLOGIA_NOTIFICA := pRecDTipoCategNotSopr.ID_TIPOLOGIA_NOTIFICA;
                     recTNotifica.ID_CATEGORIA_NOTIFICA := pRecDTipoCategNotSopr.ID_CATEGORIA_NOTIFICA;
                  END IF;
                  recTNotifica.ID_PROCEDIMENTO_MITTENTE := knIdProcedimentoSMRGAA;
                  recTNotifica.ID_PROCEDIMENTO_DESTINATARIO := knIdProcedimentoSMRGAA;
                  recTNotifica.DATA_INSERIMENTO := SYSDATE;
                  recTNotifica.ID_UTENTE_AGGIORNAMENTO := 9999999999; 
                  recTNotifica.DATA_AGGIORNAMENTO := SYSDATE; 
                  IF vEvadiAnnulla = 'E' THEN
                     recTNotifica.DESCRIZIONE := 'Chiusura automatica per evasione istanza riesame gis';
                  ELSE
                     recTNotifica.DESCRIZIONE := 'Chiusura automatica per annullamento istanza riesame gis';
                  END IF;

                  InsertTNotifica (recTNotifica);

               END IF;

           END LOOP;

       ELSE
           UPDATE DB_ISTANZA_RIESAME
              SET DATA_SITICONVOCA = NVL(pRecIstanzaRiesameEvasa.DATA_SOPRALUOGO,pRecIstanzaRiesameEvasa.DATA_CONVOCAZIONE),
                  ID_STATO_SITICONVOCA = pRecIstanzaRiesameEvasa.ID_STATO_SITICONVOCA,
                  DATA_AGGIORNAMENTO = SYSDATE
            WHERE ID_ISTANZA_RIESAME = pRecTIstanzaRiesame.ID_ISTANZA_RIESAME;

       END IF;
    END EvadiIstanzaRiesame;

    /*********************************************************************
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION Elabora_Istanza_Riesame RETURN INTEGER IS

        -- record di appoggio per il reperimento dei dati dell'applicazione corrente
        recDApplicazione    SMRGAA_D_APPLICAZIONI_BATCH%ROWTYPE;
        -- conterrà l'id esecuzione
        nIdEsecuzione       SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE;
        -- conterrà il codice di ritorno
        nRetCode            NUMBER(1):=0;
        -- vettore che conterrà i parametri del batch
        vetParametri        PCK_SMRGAA_LOG.TypVetParametriApplicazione;
        -- record di appoggio per inserimento notifiche
        recTNotifica        DB_NOTIFICA%ROWTYPE;
        -- record di appoggio per reperimento istanze di riesame
        recTIstanzaRiesame  DB_ISTANZA_RIESAME%ROWTYPE;
        -- record di appoggio per reperimento istanze di riesame precedente
        recTIstanzaRiesameNew DB_ISTANZA_RIESAME%ROWTYPE;
        -- identificativo categoria notifica x evasione controllo in contradditorio
        nIdCatNotCtrInContr DB_TIPO_CATEGORIA_NOTIFICA.ID_CATEGORIA_NOTIFICA%TYPE;
        -- identificativo categoria notifica x evasione sopraluogo in campo
        nIdCatNotSoprInCampo DB_TIPO_CATEGORIA_NOTIFICA.ID_CATEGORIA_NOTIFICA%TYPE;
        -- record di appoggio per reperimento tipologia notifica
        recDTipoCategNotSopr DB_TIPO_CATEGORIA_NOTIFICA%ROWTYPE;
        -- record di appoggio per reperimento tipologia notifica
        recDTipoCategNotCtrl DB_TIPO_CATEGORIA_NOTIFICA%ROWTYPE;
        -- record di appoggio per inserimento iter riesame azienda
        recTIterRiesAzienda  DB_ITER_RIESAME_AZIENDA%ROWTYPE;
        -- record di appoggio per letture DB_ISTANZA_RIESAME_AZIENDA
        recTIstRiesAzienda   DB_ISTANZA_RIESAME_AZIENDA%ROWTYPE;
        -- record di appoggio per inserimento su DB_SOPRALLUOGO_ISTANZA
        recTSopralluogoIst   DB_SOPRALLUOGO_ISTANZA%ROWTYPE;
        -- record di appoggio per ricerca persona fisica
        recTPersFisica       DB_PERSONA_FISICA%ROWTYPE;
        -- record di appoggi per inserimento soggetto
        recTSoggetto         DB_SOGGETTO%ROWTYPE;
        nIstTrattate         INTEGER:=0;
        nIstAnomale          INTEGER:=0;

        bParamOk             BOOLEAN:=FALSE;

        nPartIstTrattate     INTEGER:=0;
        nPartIstEvase        INTEGER:=0;
        nPartIstNonTrovate   INTEGER:=0;
        nPartIstAnnullate    INTEGER:=0;
        nPartIstGiaEvase     INTEGER:=0;

    BEGIN

        nRetCode := Pck_SMRGAA_Log.VerificaAttivazioneBatch( knIdApplBatchIstanzaRiesame ,recDApplicazione);

        IF nRetCode > 0 THEN
             -- Errore, Batch non attivo
            RETURN nRetCode;
        END IF;

        Pck_SMRGAA_Log.LeggiFileEsecuzione ( recDApplicazione.nomefile_esecuzione, recDApplicazione.path_file_esecuzione );

        Pck_SMRGAA_Log.SetLogLevel ( recDApplicazione.log_level );

        Pck_SMRGAA_Log.Init( knIdApplBatchIstanzaRiesame,'Elabora_Istanza_Riesame');

        Pck_SMRGAA_Log.LogInfo ('Inizio Elaborazione');

        -- carico il vettore di parametri per il batch
        vetParametri := PCK_SMRGAA_LOG.CaricaParametriApplicazione(knIdApplBatchIstanzaRiesame);

        IF vetParametri.COUNT = 0 THEN
           PCK_SMRGAA_LOG.LogInfo ('Nessun parametro di input al batch presente, termino elaborazione !!!');
           bParamOk := FALSE;
        ELSE

            BEGIN
                nIdCatNotCtrInContr := vetParametri (kvCodParCatNotIstCtrlInContr).val_number;
                PCK_SMRGAA_LOG.LogInfo ('Parametro : ' || kvCodParCatNotIstCtrlInContr || ' presente ed uguale a : ' || nIdCatNotCtrInContr);
                recDTipoCategNotCtrl := SelDCategoriaNotificaById(nIdCatNotCtrInContr);

            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParCatNotIstCtrlInContr || ' non presente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParCatNotIstCtrlInContr || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
            END;

            BEGIN
                nIdCatNotSoprInCampo := vetParametri (kvCodParCatNotIstSoprInCampo).val_number;
                PCK_SMRGAA_LOG.LogInfo ('Parametro : ' || kvCodParCatNotIstSoprInCampo || ' presente ed uguale a : ' || nIdCatNotSoprInCampo);
                recDTipoCategNotSopr := SelDCategoriaNotificaById (nIdCatNotSoprInCampo);

            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParCatNotIstSoprInCampo || ' non presente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParCatNotIstSoprInCampo || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                     bParamOk := FALSE;
            END;

        END IF;
        -- scorro le istanze di riesame elaborate su SITICONVOCA
        FOR recIstanzaRiesameEvasa IN curIstanzaRiesameEvasa LOOP
            nIstTrattate := nIstTrattate + 1;

            -- ricerco se sono presenti su DB_ISTANZA_RIESAME_AZIENDA per protocollo
            recTIstRiesAzienda := SelTIstRiesameAziendaByProt (recIstanzaRiesameEvasa.PROTOCOLLO_ISTANZA);
            -- se l'istanza di riesame non e' presente la cosa e' molto anomale
            -- invece se e' presente
            IF recTIstRiesAzienda.ID_ISTANZA_RIESAME_AZIENDA IS NOT NULL THEN
                -- ricerco se c'è un iter attivo
                recTIterRiesAzienda := SelLastTIterRiesAziendaByProt (recIstanzaRiesameEvasa.PROTOCOLLO_ISTANZA);
                -- se c'è controllo
                IF recTIterRiesAzienda.ID_ITER_RIESAME_AZIENDA IS NOT NULL THEN
                   -- se lo stato dell'iter gia' presente in anagrafe e' diverso da quello da importare
                   IF recTIterRiesAzienda.STATO_ISTANZA <> recIstanzaRiesameEvasa.STATO_ISTANZA THEN
                      -- se si chiudo l'iter presente in anagrafe ponendo la data di fine validita
                      -- a sysdate
                      ChiudiIterRiesAzienda (recTIterRiesAzienda.ID_ITER_RIESAME_AZIENDA);

                      -- ed inserisco il nuovo inter
                       SELECT SEQ_DB_ITER_RICHIESTA_AZIENDA.nextval
                         INTO recTIterRiesAzienda.ID_ITER_RIESAME_AZIENDA
                         FROM DUAL;

                       recTIterRiesAzienda.ID_ISTANZA_RIESAME_AZIENDA := recTIstRiesAzienda.ID_ISTANZA_RIESAME_AZIENDA;
                       recTIterRiesAzienda.STATO_ISTANZA := recIstanzaRiesameEvasa.STATO_ISTANZA;
                       recTIterRiesAzienda.NUMERO_PARTICELLE_SEGNALATE := recIstanzaRiesameEvasa.NUMERO_PARTICELLE_SEGNALATE;
                       recTIterRiesAzienda.NUMERO_PARTICELLE_RISOLTE := recIstanzaRiesameEvasa.NUMERO_PARTICELLE_RISOLTE;
                       recTIterRiesAzienda.PREVISTO_PAGAMENTO := recIstanzaRiesameEvasa.PREVISTO_PAGAMENTO;
                       recTIterRiesAzienda.IMPORTO_DEBITORIO := recIstanzaRiesameEvasa.IMPORTO_RICHIESTO / 100;
                       recTIterRiesAzienda.DATA_INIZIO_VALIDITA := SYSDATE;
                       recTIterRiesAzienda.DATA_FINE_VALIDITA := NULL;
                       InsertTIterRiesameAzienda (recTIterRiesAzienda);

                   END IF;

                ELSE
                   -- se l'iter riesame azienda non e' ancora presente lo aggiungo
                   SELECT SEQ_DB_ITER_RICHIESTA_AZIENDA.nextval
                     INTO recTIterRiesAzienda.ID_ITER_RIESAME_AZIENDA
                     FROM DUAL;

                   recTIterRiesAzienda.ID_ISTANZA_RIESAME_AZIENDA := recTIstRiesAzienda.ID_ISTANZA_RIESAME_AZIENDA;
                   recTIterRiesAzienda.STATO_ISTANZA := recIstanzaRiesameEvasa.STATO_ISTANZA;
                   recTIterRiesAzienda.NUMERO_PARTICELLE_SEGNALATE := recIstanzaRiesameEvasa.NUMERO_PARTICELLE_SEGNALATE;
                   recTIterRiesAzienda.NUMERO_PARTICELLE_RISOLTE := recIstanzaRiesameEvasa.NUMERO_PARTICELLE_RISOLTE;
                   recTIterRiesAzienda.PREVISTO_PAGAMENTO := recIstanzaRiesameEvasa.PREVISTO_PAGAMENTO;
                   recTIterRiesAzienda.IMPORTO_DEBITORIO := recIstanzaRiesameEvasa.IMPORTO_RICHIESTO / 100;
                   recTIterRiesAzienda.DATA_INIZIO_VALIDITA := SYSDATE;
                   recTIterRiesAzienda.DATA_FINE_VALIDITA := NULL;
                   InsertTIterRiesameAzienda (recTIterRiesAzienda);

                END IF;
                -- controllo se per l'istanza in esame e' stato fatto il sopraluogo
                IF recIstanzaRiesameEvasa.ESISTE_SOPRALLUOGO = 'S' THEN
                   -- se si il titolare od il delegato che hanno presenziato al sopra luogo
                   -- devono avare il codice fiscale valorizzato e formalmente corretto
                   IF LENGTH(recIstanzaRiesameEvasa.CODICE_FISCALE_SOGGETTO) = 16 THEN
                      -- ricerco se la persona fisica e' presente su DB_PERSONA_FISICA per codice fiscale
                      recTPersFisica := SelTPersonaFisicaByCodFiscale (recIstanzaRiesameEvasa.CODICE_FISCALE_SOGGETTO);
                      -- se no la inserisco
                      IF recTPersFisica.ID_SOGGETTO IS NULL THEN
                         SELECT SEQ_SOGGETTO.nextval
                           INTO recTSoggetto.ID_SOGGETTO
                           FROM DUAL;
                         recTSoggetto.FLAG_FISICO := 'S';
                         InsertTSoggetto (recTSoggetto);

                         SELECT SEQ_PERSONA_FISICA.nextval
                           INTO recTPersFisica.ID_PERSONA_FISICA
                           FROM DUAL;
                         recTPersFisica.ID_SOGGETTO := recTSoggetto.ID_SOGGETTO;

                         recTPersFisica.CODICE_FISCALE := recIstanzaRiesameEvasa.CODICE_FISCALE_SOGGETTO;
                         recTPersFisica.COGNOME := recIstanzaRiesameEvasa.COGNOME_SOGGETTO;
                         recTPersFisica.NOME := recIstanzaRiesameEvasa.NOME_SOGGETTO;
                         BEGIN
                             SELECT ISTAT_COMUNE
                               INTO recTPersFisica.NASCITA_COMUNE
                               FROM COMUNE
                              WHERE CODFISC = SUBSTR(recIstanzaRiesameEvasa.CODICE_FISCALE_SOGGETTO,12,4);
                         EXCEPTION
                            WHEN OTHERS THEN
                                 recTPersFisica.NASCITA_COMUNE := NULL;
                         END;

                         IF TO_NUMBER(SUBSTR(recIstanzaRiesameEvasa.CODICE_FISCALE_SOGGETTO,10,2),'99') > 40 THEN
                            recTPersFisica.SESSO := 'F';
                         ELSE
                            recTPersFisica.SESSO := 'M';
                         END IF;

                         recTPersFisica.NASCITA_DATA := DATA_DA_CF (recIstanzaRiesameEvasa.CODICE_FISCALE_SOGGETTO);
                         recTPersFisica.DATA_AGGIORNAMENTO := SYSDATE;
                         recTPersFisica.ID_UTENTE_AGGIORNAMENTO := knIdUtenteAggBatch;
                         recTPersFisica.NOTE := 'Soggetto importato per acquisizione firmatario sopralluogo istanza di riesame con protocollo : ' || recIstanzaRiesameEvasa.PROTOCOLLO_ISTANZA;
                         InsertTPersonaFisica (recTPersFisica);

                      END IF;

                      -- ricerco se sono gia' presenti i dati del sopralluogo per l'istanza riesame aziendale
                      -- in esame
                      recTSopralluogoIst := SelLastTSopralIstanzaByIdIstAz (recTIstRiesAzienda.ID_ISTANZA_RIESAME_AZIENDA);
                      -- se non ci sono li aggiungo
                      IF recTSopralluogoIst.ID_SOPRALLUOGO_ISTANZA IS NULL THEN
                          SELECT SEQ_DB_SOPRALLUOGO_ISTANZA.nextval
                            INTO recTSopralluogoIst.ID_SOPRALLUOGO_ISTANZA
                            FROM DUAL;

                          recTSopralluogoIst.ID_ISTANZA_RIESAME_AZIENDA := recTIstRiesAzienda.ID_ISTANZA_RIESAME_AZIENDA;
                          recTSopralluogoIst.TIPO_SOGGETTO := recIstanzaRiesameEvasa.RUOLO_SOGGETTO;
                          recTSopralluogoIst.ID_SOGGETTO := recTPersFisica.ID_SOGGETTO;
                          recTSopralluogoIst.NOME_TECNICO_SOPRALLUOGO := recIstanzaRiesameEvasa.NOME_TECNICO_SOPRALLUOGO;
                          recTSopralluogoIst.COGNOME_TECNICO_SOPRALLUOOGO := recIstanzaRiesameEvasa.COGNOME_TECNICO_SOPRALLUOOGO;
                          recTSopralluogoIst.CF_TECNICO_SOPRALLUOGO := recIstanzaRiesameEvasa.CF_TECNICO_SOPRALLUOGO;
                          recTSopralluogoIst.PRESENTE_SOPRALLUOGO := recIstanzaRiesameEvasa.PRESENTE_SOPRALLUOGO;
                          recTSopralluogoIst.FIRMATARIO_SOPRALLUOGO := recIstanzaRiesameEvasa.FIRMATARIO_SOPRALLUOGO;
                          recTSopralluogoIst.DATA_INIZIO_VALIDITA := SYSDATE;
                          recTSopralluogoIst.DATA_FINE_VALIDITA := NULL;

                          InsertTSopralluogoIstanza (recTSopralluogoIst);

                      ELSE
                          -- se sono gia' presenti controllo che i soggetti corrispondano
                          -- il titolare o delegato dell'azienda ed il tecnico che ha fatto il sopralluogo
                          IF recTSopralluogoIst.ID_SOGGETTO <> recTPersFisica.ID_SOGGETTO OR
                             recTSopralluogoIst.CF_TECNICO_SOPRALLUOGO <> recIstanzaRiesameEvasa.CF_TECNICO_SOPRALLUOGO THEN
                              -- chiudo l'occorrenza precedente di sopraluogo ed inserisco la nuova
                              ChiudiSopralluogoIstanza(recTSopralluogoIst.ID_SOPRALLUOGO_ISTANZA);

                              SELECT SEQ_DB_SOPRALLUOGO_ISTANZA.nextval
                                INTO recTSopralluogoIst.ID_SOPRALLUOGO_ISTANZA
                                FROM DUAL;

                              recTSopralluogoIst.ID_ISTANZA_RIESAME_AZIENDA := recTIstRiesAzienda.ID_ISTANZA_RIESAME_AZIENDA;
                              recTSopralluogoIst.TIPO_SOGGETTO := recIstanzaRiesameEvasa.RUOLO_SOGGETTO;
                              recTSopralluogoIst.ID_SOGGETTO := recTPersFisica.ID_SOGGETTO;
                              recTSopralluogoIst.NOME_TECNICO_SOPRALLUOGO := recIstanzaRiesameEvasa.NOME_TECNICO_SOPRALLUOGO;
                              recTSopralluogoIst.COGNOME_TECNICO_SOPRALLUOOGO := recIstanzaRiesameEvasa.COGNOME_TECNICO_SOPRALLUOOGO;
                              recTSopralluogoIst.CF_TECNICO_SOPRALLUOGO := recIstanzaRiesameEvasa.CF_TECNICO_SOPRALLUOGO;
                              recTSopralluogoIst.PRESENTE_SOPRALLUOGO := recIstanzaRiesameEvasa.PRESENTE_SOPRALLUOGO;
                              recTSopralluogoIst.FIRMATARIO_SOPRALLUOGO := recIstanzaRiesameEvasa.FIRMATARIO_SOPRALLUOGO;
                              recTSopralluogoIst.DATA_INIZIO_VALIDITA := SYSDATE;
                              recTSopralluogoIst.DATA_FINE_VALIDITA := NULL;

                              InsertTSopralluogoIstanza (recTSopralluogoIst);

                          END IF;

                      END IF;
                   ELSE
                       -- segnalo l'anomalia solo se il codice fiscale del
                       -- presente al sopralluogo e' valorizzato
                       IF recIstanzaRiesameEvasa.CODICE_FISCALE_SOGGETTO IS NULL THEN
                           PCK_SMRGAA_LOG.LogDebug ('Istanza di riesame con protocollo : ' || recIstanzaRiesameEvasa.PROTOCOLLO_ISTANZA || ' codice fiscale titolare / delegato (' || recIstanzaRiesameEvasa.CODICE_FISCALE_SOGGETTO|| ') non valorizzato');
                       ELSE
                           PCK_SMRGAA_LOG.LogAnomalia ('Istanza di riesame con protocollo : ' || recIstanzaRiesameEvasa.PROTOCOLLO_ISTANZA || ' codice fiscale titolare / delegato (' || recIstanzaRiesameEvasa.CODICE_FISCALE_SOGGETTO|| ') deve essere lungo 16 caratteri');
                           AccodaMessaggio(recIstanzaRiesameEvasa.MESSAGGIO_ERRORE, 'Codice fiscale titolare / delegato (' || recIstanzaRiesameEvasa.CODICE_FISCALE_SOGGETTO|| ') deve essere lungo 16 caratteri');
                       END IF;
                   END IF;
                END IF;

                nPartIstTrattate :=0;
                nPartIstEvase :=0;
                nPartIstNonTrovate :=0;
                nPartIstAnnullate :=0;
                nPartIstGiaEvase :=0;

                PCK_SMRGAA_LOG.LogInfo ('Inizio elaborazione particelle istanza : ' || recIstanzaRiesameEvasa.PROTOCOLLO_ISTANZA);


                FOR recParticellaIstanza IN curParticellaIstanza (recIstanzaRiesameEvasa.ID_ISTA) LOOP
                    nPartIstTrattate := nPartIstTrattate + 1;

                    recTIstanzaRiesame := SelTIstanzaRiesameById (recParticellaIstanza.ID_ISTANZA_RIESAME);
                    -- se e' presente
                    IF recTIstanzaRiesame.ID_ISTANZA_RIESAME IS NOT NULL THEN
                       -- controllo se si tratta di sopralluogo
                       IF recParticellaIstanza.RICHIESTO_SOPRALLUOGO = 1 THEN
                          -- se si l'ID_ISTANZA_RIESAME passato in input e' quello della fase precedente
                          -- devo quindi cercare se per caso e' presente un istanza per stesso protocollo
                          -- e particella di fase sopralluogo
                          recTIstanzaRiesameNew := SelTIstanzaRiesameByIdFaseProt (knIdFaseIstRiesSopraluogo,
                                                                                   recTIstanzaRiesame);

                          -- se non la trovo
                          IF recTIstanzaRiesameNew.ID_ISTANZA_RIESAME IS NULL THEN
                             -- evado l'istanza precedente se non era gia' evasa
                             IF recTIstanzaRiesame.DATA_EVASIONE IS NULL AND
                                recTIstanzaRiesame.DATA_ANNULLAMENTO IS NULL THEN
                                EvadiIstanzaRiesame (recTIstanzaRiesame, recIstanzaRiesameEvasa, recDTipoCategNotCtrl, recDTipoCategNotSopr);
                             END IF;

                             recTIstanzaRiesameNew := recTIstanzaRiesame;

                             SELECT SEQ_DB_ISTANZA_RIESAME.nextval
                               INTO recTIstanzaRiesameNew.ID_ISTANZA_RIESAME
                               FROM DUAL;

                             recTIstanzaRiesameNew.ID_FASE_ISTANZA_RIESAME := knIdFaseIstRiesSopraluogo;
                             recTIstanzaRiesameNew.DATA_RICHIESTA := recIstanzaRiesameEvasa.DATA_AGGIORNAMENTO;

                             IF recIstanzaRiesameEvasa.STATO = knIdGruppoSitiConvocaEvaso THEN
                                recTIstanzaRiesameNew.DATA_ANNULLAMENTO := NULL;
                                recTIstanzaRiesameNew.DATA_EVASIONE := recIstanzaRiesameEvasa.DATA_AGGIORNAMENTO;
                             ELSIF recIstanzaRiesameEvasa.STATO = knIdGruppoSitiConvocaAnnullato THEN
                                recTIstanzaRiesameNew.DATA_ANNULLAMENTO := recIstanzaRiesameEvasa.DATA_AGGIORNAMENTO;
                                recTIstanzaRiesameNew.DATA_EVASIONE := NULL;
                             ELSE
                                recTIstanzaRiesameNew.DATA_ANNULLAMENTO := NULL;
                                recTIstanzaRiesameNew.DATA_EVASIONE := NULL;
                             END IF;

                             recTIstanzaRiesameNew.DATA_AGGIORNAMENTO := SYSDATE;
                             recTIstanzaRiesameNew.NOTE := NULL;
                             recTIstanzaRiesameNew.DATA_SITICONVOCA := NVL(recIstanzaRiesameEvasa.DATA_EFFETTIVA_SOPRALLUOGO, recIstanzaRiesameEvasa.DATA_SOPRALUOGO);
                             recTIstanzaRiesameNew.ID_UTENTE_RICHIEDENTE := NULL;
                             recTIstanzaRiesameNew.DATA_SOSPENSIONE_SCADUTA := NULL;
                             recTIstanzaRiesameNew.ID_STATO_SITICONVOCA := recIstanzaRiesameEvasa.ID_STATO_SITICONVOCA;
                             InsertTIstanzaRiesame (recTIstanzaRiesameNew);

                             nPartIstEvase := nPartIstEvase + 1;


                          ELSE

                             IF recTIstanzaRiesameNew.ID_STATO_SITICONVOCA <> recIstanzaRiesameEvasa.ID_STATO_SITICONVOCA THEN
                                EvadiIstanzaRiesame (recTIstanzaRiesameNew, recIstanzaRiesameEvasa, recDTipoCategNotCtrl, recDTipoCategNotSopr);
                             END IF;

                             nPartIstEvase := nPartIstEvase + 1;

                          END IF;

                       ELSE
                           IF recTIstanzaRiesame.ID_STATO_SITICONVOCA  <> recIstanzaRiesameEvasa.ID_STATO_SITICONVOCA THEN
                               IF recTIstanzaRiesame.DATA_EVASIONE IS NULL AND
                                  recTIstanzaRiesame.DATA_ANNULLAMENTO IS NULL THEN

                                  EvadiIstanzaRiesame (recTIstanzaRiesame, recIstanzaRiesameEvasa, recDTipoCategNotCtrl, recDTipoCategNotSopr);
                                  recIstanzaRiesameEvasa.EVASO := 'S';
                                  nPartIstEvase := nPartIstEvase + 1;
                               ELSE
                                  IF recTIstanzaRiesame.DATA_EVASIONE IS NOT NULL THEN
                                     Pck_SMRGAA_Log.LogAnomalia ('La particella con ID_ISTANZA_RIESAME : ' || recParticellaIstanza.ID_ISTANZA_RIESAME || ' risulta essere gia'' stata evasa in elaborazione precedenti');
                                     AccodaMessaggio(recIstanzaRiesameEvasa.MESSAGGIO_ERRORE, 'Istanza di riesame : ' || recParticellaIstanza.ID_ISTANZA_RIESAME || ' già evasa');
                                     nPartIstGiaEvase := nPartIstGiaEvase + 1;
                                  END IF;

                                  IF recTIstanzaRiesame.DATA_ANNULLAMENTO IS NOT NULL THEN
                                     Pck_SMRGAA_Log.LogAnomalia ('Istanza di riesame : ' || recParticellaIstanza.ID_ISTANZA_RIESAME || ' e'' stata annullata');
                                     AccodaMessaggio(recIstanzaRiesameEvasa.MESSAGGIO_ERRORE , 'Istanza di riesame : ' || recParticellaIstanza.ID_ISTANZA_RIESAME || ' e'' stata annullata');
                                     nPartIstAnnullate := nPartIstAnnullate + 1;
                                  END IF;
                               END IF;
                           ELSE
                               nPartIstEvase := nPartIstEvase + 1;
                           END IF;
                       END IF;
                    ELSE
                        Pck_SMRGAA_Log.LogAnomalia ('Istanza di riesame : ' || recParticellaIstanza.ID_ISTANZA_RIESAME || ' non trovata');
                        AccodaMessaggio(recIstanzaRiesameEvasa.MESSAGGIO_ERRORE, 'Istanza di riesame : ' || recParticellaIstanza.ID_ISTANZA_RIESAME || ' non trovata');
                        nPartIstNonTrovate := nPartIstNonTrovate + 1;
                    END IF;

                END LOOP;

                PCK_SMRGAA_LOG.LogInfo ('Fine elaborazione particelle istanza : ' || recIstanzaRiesameEvasa.PROTOCOLLO_ISTANZA);
                Pck_SMRGAA_Log.LogInfo ('Trattate : ' || nPartIstTrattate || ' particelle in istanze di riesame');
                Pck_SMRGAA_Log.LogInfo ('Di cui : ' || nPartIstEvase || ' evase correttamente');
                Pck_SMRGAA_Log.LogInfo ('Di cui : ' || nPartIstGiaEvase || ' in stato già evaso e scartate');
                Pck_SMRGAA_Log.LogInfo ('Di cui : ' || nPartIstAnnullate || ' in stato annullato e scartate');
                Pck_SMRGAA_Log.LogInfo ('Di cui : ' || nPartIstNonTrovate || ' non trovate');

            ELSE
                PCK_SMRGAA_LOG.LogAnomalia ('Istanza di riesame con protocollo : ' || recIstanzaRiesameEvasa.PROTOCOLLO_ISTANZA || ' non presente in anagrafe !!');
                AccodaMessaggio(recIstanzaRiesameEvasa.MESSAGGIO_ERRORE, 'Nessuna istanza di riesame con questo protocollo presente in anagrafe');
            END IF;

            recIstanzaRiesameEvasa.EVASO := 'S';
            AggiornaIstanzaRiesameElab (recIstanzaRiesameEvasa);

            IF recIstanzaRiesameEvasa.MESSAGGIO_ERRORE IS NOT NULL THEN
               nIstAnomale := nIstAnomale + 1;
            END IF;


        END LOOP;

        Pck_SMRGAA_Log.LogInfo ('Fine Elaborazione - Trattate : ' || nIstTrattate || ' istanze di riesame aziendali');
        Pck_SMRGAA_Log.LogInfo ('Di cui : ' || nIstAnomale || ' han generato anomalie in fase di acquisizione');
        PCK_SMRGAA_LOG.ValorizzaEsitoBatch;

        COMMIT;

        RETURN nRetCode;

    EXCEPTION
        WHEN OTHERS THEN
             ROLLBACK;
             PCK_SMRGAA_LOG.LogSqlError ('Elabora_Istanza_Riesame');
    END Elabora_Istanza_Riesame;


END Pck_Gestione_Istanza_Riesame;

/
--------------------------------------------------------
--  DDL for Package Body PCK_GESTIONE_POLIZZA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_GESTIONE_POLIZZA" AS
/*****************************************************************************
Package che espone tutte le function / stored procedure propedeutiche alla gestione
delle polizze assicurative presenti in anagrafe
******************************************************************************/

    /*********************************************************************
    Imposta ESITO_CARICAMENTO, DATA_CARICAMENTO e MOTIVO_SCARTO per
    l'ID_RIEP_PRODOTTO_ANNO passato in input con i valori passati in input
    Tipo: procedure
    input: pRecRiepProdAnno
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE EvadiRiepProdottoAnno (pRecRiepProdAnno IN SMRGAA_W_RIEP_PRODOTTO_ANNO%ROWTYPE) IS
    BEGIN

        UPDATE SMRGAA_W_RIEP_PRODOTTO_ANNO
           SET DATA_CARICAMENTO = SYSDATE,
               ESITO_CARICAMENTO = pRecRiepProdAnno.ESITO_CARICAMENTO,
               MOTIVO_SCARTO = pRecRiepProdAnno.MOTIVO_SCARTO
         WHERE ID_RIEP_PRODOTTO_ANNO = pRecRiepProdAnno.ID_RIEP_PRODOTTO_ANNO;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('EvadiRiepProdottoAnno - ID_RIEP_PRODOTTO_ANNO = ' || pRecRiepProdAnno.ID_RIEP_PRODOTTO_ANNO);
             RAISE;
    END EvadiRiepProdottoAnno;

    /*********************************************************************
    Inserisce un record di tipo DB_RIEPILOGO_ANNUALE_PRODOTTO sull'omonima tabella
    Tipo: procedure
    input: pRecRiepAnnualeProd
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTRiepAnnualeProdotto (pRecRiepAnnualeProd IN DB_RIEPILOGO_ANNUALE_PRODOTTO%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_RIEPILOGO_ANNUALE_PRODOTTO
            (
            ID_RIEPILOGO_ANNUALE_PRODOTTO,
            ID_AZIENDA,
            AZIENDA_NEOCOSTITUITA,
            ID_TIPO_PRODOTTO,
            ANNO_CAMPAGNA,
            QUANTITA_FATTURATA,
            ETTARI_ACCERTATI,
            RESA_CALCOLATA,
            DATA_AGGIORNAMENTO,
            ID_UTENTE_AGGIORNAMENTO,
            DATA_ANNULLAMENTO,
            ID_UTENTE_ANNULLAMENTO
            )
         VALUES
            (
            pRecRiepAnnualeProd.ID_RIEPILOGO_ANNUALE_PRODOTTO,
            pRecRiepAnnualeProd.ID_AZIENDA,
            pRecRiepAnnualeProd.AZIENDA_NEOCOSTITUITA,
            pRecRiepAnnualeProd.ID_TIPO_PRODOTTO,
            pRecRiepAnnualeProd.ANNO_CAMPAGNA,
            pRecRiepAnnualeProd.QUANTITA_FATTURATA,
            pRecRiepAnnualeProd.ETTARI_ACCERTATI,
            pRecRiepAnnualeProd.RESA_CALCOLATA,
            pRecRiepAnnualeProd.DATA_AGGIORNAMENTO,
            pRecRiepAnnualeProd.ID_UTENTE_AGGIORNAMENTO,
            pRecRiepAnnualeProd.DATA_ANNULLAMENTO,
            pRecRiepAnnualeProd.ID_UTENTE_ANNULLAMENTO
            );

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertTRiepAnnualeProdotto - ID_AZIENDA / ID_TIPO_PRODOTTO = ' || pRecRiepAnnualeProd.ID_AZIENDA || '/' || pRecRiepAnnualeProd.ID_TIPO_PRODOTTO);
             RAISE;
    END InsertTRiepAnnualeProdotto;

    /*********************************************************************
    Ricerca un'azienda (anche cessata) per CUAA e restituisce il ROWTYPE di
    DB_ANAGRAFICA_AZIENDA
    Tipo: procedure
    input: pCuaa
    output: nessuno
    ritorno: DB_ANAGRAFICA_AZIENDA%ROWTYPE;
    *********************************************************************/
    FUNCTION SelDAnagAziendaByCuaa (pCuaa IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE)
    RETURN DB_ANAGRAFICA_AZIENDA%ROWTYPE IS
        recDAnagAzienda DB_ANAGRAFICA_AZIENDA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recDAnagAzienda
          FROM DB_ANAGRAFICA_AZIENDA
         WHERE CUAA = pCuaa
           AND DATA_FINE_VALIDITA IS NULL
           AND DATA_CESSAZIONE IS NULL;

        RETURN recDAnagAzienda;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            BEGIN
                SELECT *
                  INTO recDAnagAzienda
                  FROM DB_ANAGRAFICA_AZIENDA
                 WHERE CUAA = pCuaa
                   AND DATA_FINE_VALIDITA IS NULL;

                RETURN recDAnagAzienda;
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     RETURN NULL;
                WHEN TOO_MANY_ROWS THEN
                     recDAnagAzienda.ID_AZIENDA := -1;
                     RETURN recDAnagAzienda;
            END;
        WHEN TOO_MANY_ROWS THEN
             recDAnagAzienda.ID_AZIENDA := -1;
             RETURN recDAnagAzienda;
    END SelDAnagAziendaByCuaa;


    /*********************************************************************
    Ricerca un tipo prodotto assicurativo per codice prodotto ed una data
    di riferimento
    Tipo: Function
    input: pCodProdotto, pDataRif
    output: nessuno
    ritorno: DB_TIPO_PRODOTTO%ROWTYPE
    *********************************************************************/
    FUNCTION SelDTipoProdAssByCodiceEAnno (pCodProdotto IN DB_TIPO_PRODOTTO.CODICE_PRODOTTO%TYPE,
                                           pDataRif     IN DB_TIPO_PRODOTTO.DATA_INIZIO_VALIDITA%TYPE
                                           ) RETURN DB_TIPO_PRODOTTO%ROWTYPE IS
        recDTipoProdotto DB_TIPO_PRODOTTO%ROWTYPE;
    BEGIN

        SELECT *
          INTO recDTipoProdotto
          FROM DB_TIPO_PRODOTTO
         WHERE CODICE_PRODOTTO = pCodProdotto
           AND pDataRif BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA,pDataRif);

        RETURN recDTipoProdotto;

    EXCEPTION
        WHEN TOO_MANY_ROWS THEN
             recDTipoProdotto.ID_TIPO_PRODOTTO := -1;
             RETURN recDTipoProdotto;
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelDTipoProdAssByCodiceEAnno;

    /*********************************************************************
    Cancella il record presente su DB_INVIO_DETTAGLIO_POLIZZA per l'ID_DETTAGLIO_POLIZZA
    ed il TIPO_OPERAZIONE dati in input se non sono ancora stati inviati con successo
    ESITO_INVIO <> 012
    Tipo: procedure
    input: pIdDettaglioPolizza, pTipoOperazione
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE CancellaTInvioDettPolizza (pIdDettaglioPolizza IN DB_INVIO_DETTAGLIO_POLIZZA.ID_DETTAGLIO_POLIZZA%TYPE,
                                         pTipoOperazione     IN DB_INVIO_DETTAGLIO_POLIZZA.TIPO_OPERAZIONE%TYPE
                                         ) IS
    BEGIN

        DELETE
          FROM DB_INVIO_DETTAGLIO_POLIZZA
         WHERE ID_DETTAGLIO_POLIZZA = pIdDettaglioPolizza
           AND TIPO_OPERAZIONE = pTipoOperazione
           AND NVL(ESITO_INVIO,'NULL') <> '012';

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('CancellaTInvioDettPolizza - ID_DETTAGLIO_POLIZZA/TIPO_OPERAZIONE= ' || pIdDettaglioPolizza || '/' || pTipoOperazione);
             RAISE;
    END CancellaTInvioDettPolizza;

    /*********************************************************************
    Effettua l'update della colonna IMPORTO_PAGATO di DB_DETTAGLIO_POLIZZA con
    il valore passato in input per l'ID_DETATGLIO_POLIZZA passato in input
    Tipo: procedure
    input: pRecTInvioDettPolizza
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE AggiornaImportoPagato (pRecTInvioDettPolizza IN DB_INVIO_DETTAGLIO_POLIZZA%ROWTYPE) IS
    BEGIN

        UPDATE DB_DETTAGLIO_POLIZZA
           SET IMPORTO_PAGATO = pRecTInvioDettPolizza.SPESA_AMMESSA_OP 
         WHERE ID_DETTAGLIO_POLIZZA = pRecTInvioDettPolizza.ID_DETTAGLIO_POLIZZA;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('AggiornaImportoPagato - ID_DETTAGLIO_POLIZZA= ' || pRecTInvioDettPolizza.ID_DETTAGLIO_POLIZZA);
             RAISE;
    END AggiornaImportoPagato;

    /*********************************************************************
    Effettua l'update della colonna IMPORTO_PROPOSTO_OP di DB_DETTAGLIO_POLIZZA con
    il valore passato in input per l'ID_DETATGLIO_POLIZZA passato in input
    Tipo: procedure
    input: pRecTInvioDettPolizza
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE AggiornaImportoPropostoOp (pRecTInvioDettPolizza IN DB_INVIO_DETTAGLIO_POLIZZA%ROWTYPE) IS
    BEGIN

        UPDATE DB_DETTAGLIO_POLIZZA
           SET IMPORTO_PROPOSTO_OP = pRecTInvioDettPolizza.IMPORTO_PROPOSTO_OP
         WHERE ID_DETTAGLIO_POLIZZA = pRecTInvioDettPolizza.ID_DETTAGLIO_POLIZZA;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('AggiornaImportoPropostoOp - ID_DETTAGLIO_POLIZZA= ' || pRecTInvioDettPolizza.ID_DETTAGLIO_POLIZZA);
             RAISE;
    END AggiornaImportoPropostoOp;

    /*********************************************************************
    Inserisce un record di tipo DB_INVIO_DETTAGLIO_POLIZZA sull'omonima tabella
    Tipo: procedure
    input: pRecTInvioDettPolizza
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTInvioDettPolizza (pRecTInvioDettPolizza IN DB_INVIO_DETTAGLIO_POLIZZA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_INVIO_DETTAGLIO_POLIZZA
            (
            ID_INVIO_DETTAGLIO_POLIZZA,
            ID_DETTAGLIO_POLIZZA,
            TIPO_OPERAZIONE,
            SUPERFICIE_UTILIZZATA,
            SUPERFICIE_UTILIZZATA_OP,
            IMPORTO_PROPOSTO,
            IMPORTO_PROPOSTO_OP,
            IMPORTO_PAGATO,
            DATA_RICHIESTA,
            DATA_INVIO,
            ESITO_INVIO,
            DESCRIZIONE_ESITO,
            SPESA_AMMESSA_OP,
            QUOTA_FEAGA,
            QUOTA_COFINANZIATA,
            QUOTA_NAZIONALE,
            ULTERIORE_QUOTA_FEAGA,
            ULTERIORE_QUOTA_COFINANZIATA,
            ID_TIPO_MOTIVO_RIDUZIONE
            )
        VALUES
            (
            pRecTInvioDettPolizza.ID_INVIO_DETTAGLIO_POLIZZA,
            pRecTInvioDettPolizza.ID_DETTAGLIO_POLIZZA,
            pRecTInvioDettPolizza.TIPO_OPERAZIONE,
            pRecTInvioDettPolizza.SUPERFICIE_UTILIZZATA,
            pRecTInvioDettPolizza.SUPERFICIE_UTILIZZATA_OP,
            pRecTInvioDettPolizza.IMPORTO_PROPOSTO,
            pRecTInvioDettPolizza.IMPORTO_PROPOSTO_OP,
            pRecTInvioDettPolizza.IMPORTO_PAGATO,
            pRecTInvioDettPolizza.DATA_RICHIESTA,
            pRecTInvioDettPolizza.DATA_INVIO,
            pRecTInvioDettPolizza.ESITO_INVIO,
            pRecTInvioDettPolizza.DESCRIZIONE_ESITO,
            pRecTInvioDettPolizza.SPESA_AMMESSA_OP,
            pRecTInvioDettPolizza.QUOTA_FEAGA,
            pRecTInvioDettPolizza.QUOTA_COFINANZIATA,
            pRecTInvioDettPolizza.QUOTA_NAZIONALE,
            pRecTInvioDettPolizza.ULTERIORE_QUOTA_FEAGA,
            pRecTInvioDettPolizza.ULTERIORE_QUOTA_COFINANZIATA,
            pRecTInvioDettPolizza.ID_TIPO_MOTIVO_RIDUZIONE
            );

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertTInvioDettPolizza - ID_INVIO_DETTAGLIO_POLIZZA= ' || pRecTInvioDettPolizza.ID_INVIO_DETTAGLIO_POLIZZA);
             RAISE;
    END InsertTInvioDettPolizza;

    /*********************************************************************
    Dato un ID_DETTAGLIO_POLIZZA ricarca il COEFFICIENTE massimo presente
    sulla tabella DB_ESITO_DETTAGLIO_POLIZZA cpn la colonna ID_MACRO_USO valorizzata
    Tipo: function
    input: pIdDettaglioPolizza
    output: nessuno
    ritorno:  DB_ESITO_DETTAGLIO_POLIZZA.COEFFICIENTE%TYPE
    *********************************************************************/
    FUNCTION SelMaxCoefEsitoPolForDettMcUso (pIdDettaglioPolizza IN DB_ESITO_DETTAGLIO_POLIZZA.ID_DETTAGLIO_POLIZZA%TYPE)
    RETURN DB_ESITO_DETTAGLIO_POLIZZA.COEFFICIENTE%TYPE IS
        nCoefMax DB_ESITO_DETTAGLIO_POLIZZA.COEFFICIENTE%TYPE;
    BEGIN

        SELECT MAX(COEFFICIENTE)
          INTO nCoefMax
          FROM DB_ESITO_DETTAGLIO_POLIZZA
         WHERE ID_DETTAGLIO_POLIZZA = pIdDettaglioPolizza
           AND ID_MACRO_USO IS NOT NULL;

        RETURN nCoefMax;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('SelMaxCoefEsitoPolForDettMcUso - pIdDettaglioPolizza= ' || pIdDettaglioPolizza);
             RAISE;
    END SelMaxCoefEsitoPolForDettMcUso;

    /*********************************************************************
    Dato un ID_DETTAGLIO_POLIZZA ricarca il COEFFICIENTE massimo presente
    sulla tabella DB_ESITO_DETTAGLIO_POLIZZA cpn la colonna ID_MACRO_USO valorizzata
    Tipo: function
    input: pIdDettaglioPolizza
    output: nessuno
    ritorno:  DB_ESITO_DETTAGLIO_POLIZZA.COEFFICIENTE%TYPE
    *********************************************************************/
    FUNCTION SelMaxCoefEsitPolForDetGcMcUso (pIdDettaglioPolizza IN DB_ESITO_DETTAGLIO_POLIZZA.ID_DETTAGLIO_POLIZZA%TYPE)
    RETURN DB_ESITO_DETTAGLIO_POLIZZA.COEFFICIENTE%TYPE IS
        nCoefMax DB_ESITO_DETTAGLIO_POLIZZA.COEFFICIENTE%TYPE;
    BEGIN

        SELECT MAX(COEFFICIENTE)
          INTO nCoefMax
          FROM DB_ESITO_DETTAGLIO_POLIZZA
         WHERE ID_DETTAGLIO_POLIZZA = pIdDettaglioPolizza
           AND ID_GRUPPO_MACRO_USO IS NOT NULL;

        RETURN nCoefMax;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('SelMaxCoefEsitPolForDetGcMcUso - pIdDettaglioPolizza= ' || pIdDettaglioPolizza);
             RAISE;
    END SelMaxCoefEsitPolForDetGcMcUso;

    /*********************************************************************
    Ricerca l'ultima dichiarazione di consistenza per l'azienda con motivo compatibile
    con il procedimento dato in input per l'anno campagna dato in input ed effettuata
    entro la dataoffset data in input
    Tipo: function
    input: pIdAzienda, pIdProcedimento, pAnnoCampagna, pDataOffset
    output: nessuno
    ritorno: nIdDichConsistenza
    *********************************************************************/
    FUNCTION SelDichConsForAzProcAnnoData (pIdAzienda      IN DB_PROCEDIMENTO_AZIENDA.ID_AZIENDA%TYPE,
                                           pIdProcedimento IN DB_PROCEDIMENTO_AZIENDA.ID_PROCEDIMENTO%TYPE,
                                           pAnnoCampagna   IN DB_PROCEDIMENTO_AZIENDA.ANNO_CAMPAGNA%TYPE,
                                           pDataOffset     IN DB_DICHIARAZIONE_CONSISTENZA.DATA%TYPE
                                            )
    RETURN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE IS
        nIdDichConsistenza DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE;
    BEGIN

        SELECT ID_DICHIARAZIONE_CONSISTENZA
          INTO nIdDichConsistenza
          FROM DB_DICHIARAZIONE_CONSISTENZA
         WHERE ID_AZIENDA = pIdAzienda
           AND ANNO = pAnnoCampagna
           AND DATA = (SELECT MAX (DATA)
                         FROM DB_DICHIARAZIONE_CONSISTENZA DC
                        WHERE ID_AZIENDA = pIdAzienda
                          AND ANNO = pAnnoCampagna
                          AND DATA_PROTOCOLLO IS NOT NULL
                          AND NUMERO_PROTOCOLLO IS NOT NULL
                          AND DATA BETWEEN TO_DATE('01/01/' || pAnnoCampagna,'DD/MM/YYYY') AND pDataOffset
                          AND ID_MOTIVO_DICHIARAZIONE NOT IN
                             (SELECT ID_MOTIVO_DICHIARAZIONE
                                FROM DB_MOTIVO_ESCLUSO_PROCEDIMENTO
                               WHERE ID_PROCEDIMENTO = pIdProcedimento));



        RETURN nIdDichConsistenza;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('SelDichConsForAzProcAnnoData - pIdAzienda/pIdProcedimento/pAnnoCampagna/pDataOffset = ' || pIdAzienda || '/' || pIdProcedimento || '/' || pAnnoCampagna || '/' || pDataOffset);
             RAISE;
    END SelDichConsForAzProcAnnoData;

    /*********************************************************************
    Ricerca la dichiarazione di consistenza di una determinata pratica di
    un procedimento se è in stato 'C = Conclusa' od 'I = In Corso' ma in
    quest'ultimo caso solamente se è in istruttoria
    Tipo: function
    input: pIdAzienda, pIdProcedimento, pAnnoCampagna
    output: nessuno
    ritorno: nIdDichConsistenza
    *********************************************************************/
    FUNCTION SelDichConsForAziendaProcAnno (pIdAzienda      IN DB_PROCEDIMENTO_AZIENDA.ID_AZIENDA%TYPE,
                                            pIdProcedimento IN DB_PROCEDIMENTO_AZIENDA.ID_PROCEDIMENTO%TYPE,
                                            pAnnoCampagna   IN DB_PROCEDIMENTO_AZIENDA.ANNO_CAMPAGNA%TYPE
                                            )
    RETURN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE IS
        nIdDichConsistenza DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE;
    BEGIN

        SELECT MAX(ID_DICHIARAZIONE_CONSISTENZA)
          INTO nIdDichConsistenza
          FROM DB_PROCEDIMENTO_AZIENDA
         WHERE ID_AZIENDA = pIdAzienda
           AND ID_PROCEDIMENTO = pIdProcedimento
           AND ANNO_CAMPAGNA = pAnnoCampagna
           AND (STATO = kvStatoPraticaConclusa OR
               (STATO = kvStatoPraticaInCorso AND
                DESCRIZIONE_STATO = 'In istruttoria'));

        RETURN nIdDichConsistenza;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('SelDichConsForAziendaProcAnno - pIdAzienda/pIdProcedimento/pAnnoCampagna = ' || pIdAzienda || '/' || pIdProcedimento || '/' || pAnnoCampagna);
             RAISE;
    END SelDichConsForAziendaProcAnno;

    /*********************************************************************
    Cancella tutti gli esisti dei dettagli polizzi di un azienda per un anno campagna
    Tipo: procedure
    input: pIdAzienda , pAnnoCP
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE CancellaEsitiAzienda (pIdAzienda IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                                    pAnnoCP    IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE) IS
    BEGIN
        DELETE
          FROM DB_ESITO_DETTAGLIO_POLIZZA
         WHERE ID_DETTAGLIO_POLIZZA IN
               (SELECT ID_DETTAGLIO_POLIZZA
                  FROM DB_DETTAGLIO_POLIZZA DP,
                       DB_POLIZZA_ASSICURATIVA PA
                 WHERE DP.ID_POLIZZA_ASSICURATIVA = PA.ID_POLIZZA_ASSICURATIVA
                   AND PA.ID_AZIENDA = pIdAzienda
                   AND PA.ANNO_CAMPAGNA = pAnnoCp);

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('CancellaEsitiPolizza - pIdAzienda / pAnnoCP = ' || pIdAzienda || '/' || pAnnoCP);
             RAISE;
    END CancellaEsitiAzienda;

    /*********************************************************************
    Cancella tutte le istruttorie effettuate sui dettagli polizza coltura
    di una certa azienda per un certo anno campagna
    Tipo: procedure
    input: pIdAzienda , pAnnoCP
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE CancellaIstruttoriaPolizza (pIdAzienda IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                                          pAnnoCP    IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE) IS
    BEGIN

        DELETE
          FROM DB_ANNO_UTILIZZATO_ISTRUTTORIA
         WHERE ID_ISTRUTTORIA_POLIZZA_COLTURA IN (  SELECT ID_ISTRUTTORIA_POLIZZA_COLTURA
                                                      FROM DB_ISTRUTTORIA_POLIZZA_COLTURA
                                                     WHERE ID_DETTAGLIO_POLIZZA_COLTURA  IN
                                                           (SELECT ID_DETTAGLIO_POLIZZA_COLTURA
                                                              FROM DB_DETTAGLIO_POLIZZA DP,
                                                                   DB_DETTAGLIO_POLIZZA_COLTURA DPC,
                                                                   DB_POLIZZA_ASSICURATIVA PA
                                                             WHERE DP.ID_POLIZZA_ASSICURATIVA = PA.ID_POLIZZA_ASSICURATIVA
                                                               AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
                                                               AND PA.ID_AZIENDA = pIdAzienda
                                                               AND PA.ANNO_CAMPAGNA = pAnnoCp));

        DELETE
          FROM DB_ISTRUTTORIA_POLIZZA_COLTURA
         WHERE ID_DETTAGLIO_POLIZZA_COLTURA  IN
               (SELECT ID_DETTAGLIO_POLIZZA_COLTURA
                  FROM DB_DETTAGLIO_POLIZZA DP,
                       DB_DETTAGLIO_POLIZZA_COLTURA DPC,
                       DB_POLIZZA_ASSICURATIVA PA
                 WHERE DP.ID_POLIZZA_ASSICURATIVA = PA.ID_POLIZZA_ASSICURATIVA
                   AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
                   AND PA.ID_AZIENDA = pIdAzienda
                   AND PA.ANNO_CAMPAGNA = pAnnoCp);

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('CancellaIstruttoriaPolizza - pIdAzienda / pAnnoCP = ' || pIdAzienda || '/' || pAnnoCP);
             RAISE;
    END CancellaIstruttoriaPolizza;

    /*********************************************************************
    Cancella tutte le anomalie di una polizza generate da una determinata fonte
    Tipo: procedure
    input: pIdPolizzaAssicurativa , pIdFonte
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE CancellaAnomalieAzienda (pIdAzienda IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                                       pAnnoCP    IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                                       pIdFonte   IN DB_ANOMALIA_POLIZZA.ID_FONTE%TYPE) IS
    BEGIN

        DELETE
          FROM DB_ANOMALIA_POLIZZA
         WHERE ID_POLIZZA_ASSICURATIVA IN
               (SELECT PA.ID_POLIZZA_ASSICURATIVA
                  FROM DB_POLIZZA_ASSICURATIVA PA
                 WHERE PA.ID_AZIENDA = pIdAzienda
                   AND PA.ANNO_CAMPAGNA = pAnnoCp)
           AND ID_FONTE = pIdFonte;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('CancellaAnomaliePolizza - pIdAzienda/pAnnoCP/pIdFonte = ' || pIdAzienda || '/' || pAnnoCP || '/' || pIdFonte);
             RAISE;
    END CancellaAnomalieAzienda;

    /*********************************************************************
    Mi dice se per l'azienda  e l'anno campagna in questione è stato inviato al SIAN
    con successo almeno un dettaglio polizza
    Tipo: function
    input: pIdPolizzaAssicurativa
    output: nessuno
    ritorno: TRUE / FALSE
    *********************************************************************/
    FUNCTION ExisPolizzaInvForAziendaAnno (pIdAzienda IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                                           pAnnoCp    IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE
                                           )
    RETURN BOOLEAN IS
        nRec INTEGER:=0;
        bRet BOOLEAN:=FALSE;
    BEGIN

        SELECT COUNT(*)
          INTO nRec
          FROM DB_POLIZZA_ASSICURATIVA PA,
               DB_DETTAGLIO_POLIZZA DP,
               DB_INVIO_DETTAGLIO_POLIZZA IDP
         WHERE PA.ID_AZIENDA = pIdAzienda
           aND PA.ANNO_CAMPAGNA = pAnnoCp
           AND DP.ID_POLIZZA_ASSICURATIVA = PA.ID_POLIZZA_ASSICURATIVA
           AND DP.ID_DETTAGLIO_POLIZZA = IDP.ID_DETTAGLIO_POLIZZA
           AND IDP.ESITO_INVIO = '012';

        IF nRec > 0 THEN
           bRet := TRUE;
        END IF;

        RETURN bRet;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('ExisPolizzaInvForAziendaAnno - pIdAzienda/pAnnoCp = ' || pIdAzienda || '/' ||pAnnoCp);
             RAISE;
    END ExisPolizzaInvForAziendaAnno;

    /*********************************************************************
    Effettua massivamente dei controlli sulle polizze assicurative per l'anno
    campagna prelevato come parametro da SMRGAA_R_PARAM_APPLICAZIONE
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION Controlla_Polizza RETURN NUMBER IS
        -- record di appoggio per il reperimento dei dati dell'applicazione corrente
        recDApplicazione    SMRGAA_D_APPLICAZIONI_BATCH%ROWTYPE;
        -- conterrà l'id esecuzione
        nIdEsecuzione       SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE;
        -- conterrà il codice di ritorno
        nRetCode            NUMBER(1):=0;
        -- vettore dei parametri
        vetParametri        Pck_SMRGAA_Log.TypVetParametriApplicazione;
        -- anno sul quale controllare le polizze
        nAnnoOffset         DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE;
        -- eventuale tipologia intervento per la quale controllare le polizze
        nTipoIntervento     DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE;
        -- tipologia di reperimento dichiarazione di consistenza per controllo ASS05
        vTipoDichiarazione  SMRGAA_R_PARAM_APPLICAZIONE.VALORE_VARCHAR2%TYPE;
        -- identificativo tipologia procedimento per controllo ASS05
        nIdTipoProcedimento DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE;

        CURSOR curAziendaDaControllare (pAnnoCampagna IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                                        pIdTipoInt    IN DB_POLIZZA_ASSICURATIVA.ID_TIPO_INTERVENTO%TYPE,
                                        pIdAzienda    IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE
                                        ) IS
        SELECT DISTINCT ID_AZIENDA, ANNO_CAMPAGNA
          FROM DB_POLIZZA_ASSICURATIVA
         WHERE ANNO_CAMPAGNA = pAnnoCampagna
           AND (ID_TIPO_INTERVENTO = pIdTipoInt OR pIdTipoInt IS NULL)
           AND (ID_AZIENDA = pIdAzienda OR pIdAzienda IS NULL);

        CURSOR curControlloPolizza IS
        SELECT TC.*
          FROM DB_TIPO_CONTROLLO  TC,
               DB_TIPO_CONTROLLO_FASE TCF
         WHERE TC.ID_GRUPPO_CONTROLLO = knIdGcAssicurazioni
           AND TC.ID_CONTROLLO = TCF.ID_CONTROLLO
           AND TCF.ID_FASE = knIdFaseControlliPolizze
           AND TC.OBBLIGATORIO = 'S'
      ORDER BY TC.ORDINAMENTO;

        vRisultato             VARCHAR2(1);
        vMessaggio             VARCHAR2(4000);
        vStrPlSql              VARCHAR2(2000);
        bParamOk               BOOLEAN:=TRUE;

        nIdAzienda             DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE;

        nNumAziende            INTEGER:=0;
        nNumAziendaPolInviate  INTEGER:=0;
        nIdDichProcedimento    DB_PROCEDIMENTO_AZIENDA.ID_DICHIARAZIONE_CONSISTENZA%TYPE;
        vDescProcedimento      DB_TIPO_PROCEDIMENTO.DESCRIZIONE%TYPE;
    BEGIN
        nRetCode := Pck_SMRGAA_Log.VerificaAttivazioneBatch( knIdApplBatchControlliPolizza ,recDApplicazione);

        IF nRetCode > 0 THEN
             -- Errore, Batch non attivo
            RETURN nRetCode;
        END IF;

         -- Inserimento in tabella dell'identificativo di esecuzione
         -- nIdEsecuzione restituito in output
        Pck_SMRGAA_Log.InsertTEsecuzione ( knIdApplBatchControlliPolizza, nIdEsecuzione );
        COMMIT;

         -- Scrittura nel file nomefile_esecuzione del nIdEsecuzione
        Pck_SMRGAA_Log.ScriviFileEsecuzione (  recDApplicazione.nomefile_esecuzione,
                                               recDApplicazione.path_file_esecuzione,
                                               nIdEsecuzione );

        Pck_SMRGAA_Log.LeggiFileEsecuzione ( recDApplicazione.nomefile_esecuzione, recDApplicazione.path_file_esecuzione );

        Pck_SMRGAA_Log.SetLogLevel ( recDApplicazione.log_level );

        Pck_SMRGAA_Log.Init( knIdApplBatchControlliPolizza, 'Controlla_Polizza' );

        vetParametri := Pck_SMRGAA_Log.CaricaParametriApplicazione(knIdApplBatchControlliPolizza);

        BEGIN
            nAnnoOffset := vetParametri(kvParAnnoCampagna).VAL_NUMBER;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 nAnnoOffset := NULL;
                 Pck_SMRGAA_Log.LogAnomalia ('Parametro : ' || kvParAnnoCampagna || ' non specificato');
                 bParamOk := FALSE;
        END;

        BEGIN
            nIdAzienda  := vetParametri(kvParIdAzienda).VAL_NUMBER;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 nIdAzienda := NULL;
        END;

        BEGIN
            nTipoIntervento  := vetParametri(kvParIdTipoIntervento).VAL_NUMBER;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 nTipoIntervento := NULL;
        END;

        BEGIN
            vTipoDichiarazione  := vetParametri(kvParTipoRepDichConsistenza).VAL_VARCHAR2;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 vTipoDichiarazione := NULL;
        END;

        BEGIN
            nIdTipoProcedimento  := vetParametri(kvParTipoProcedimento).VAL_NUMBER;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 nIdTipoProcedimento := NULL;
                 Pck_SMRGAA_Log.LogAnomalia ('Parametro : ' || kvParTipoProcedimento || ' non specificato');
                 bParamOk := FALSE;
        END;

        IF bParamOk THEN
           Pck_SMRGAA_Log.LogInfo ('Inizio Elaborazione - Parametri');
           Pck_SMRGAA_Log.LogInfo ('- ANNO_CAMPAGNA = ' || nAnnoOffset);
           Pck_SMRGAA_Log.LogInfo ('- ID_TIPO_INTERVENTO = ' || nTipoIntervento);
           Pck_SMRGAA_Log.LogInfo ('- ID_AZIENDA = ' || nIdAzienda);
           Pck_SMRGAA_Log.LogInfo ('- TIPOLOGIA_DICHIARAZIONE = ' || vTipoDichiarazione);

           SELECT DESCRIZIONE
             INTO vDescProcedimento
             FROM DB_TIPO_PROCEDIMENTO
            WHERE ID_PROCEDIMENTO = nIdTipoProcedimento;

           Pck_SMRGAA_Log.LogInfo ('- PROCEDIMENTO =  ' || vDescProcedimento);

           -- scorro le polizze da controllare
           FOR recAziendaDaControllare IN curAziendaDaControllare (nAnnoOffset,nTipoIntervento,nIdAzienda) LOOP

               -- controllo se per il procedimento dato come parametro , l'azienda e l'anno
               -- ho una dichiarazione di consistenza
               nIdDichProcedimento := SelDichConsForAziendaProcAnno (recAziendaDaControllare.ID_AZIENDA,
                                                                     nIdTipoProcedimento,
                                                                     nAnnoOffset);
               -- se non c'è l'ho
               IF nIdDichProcedimento IS NULL THEN
                  -- cancello
                  -- DB_PROCEDIMENTO_AZIENDA per l'azienda ed il procedimento
                  DELETE
                    FROM DB_PROCEDIMENTO_AZIENDA
                   WHERE ID_AZIENDA = recAziendaDaControllare.ID_AZIENDA
                     AND ID_PROCEDIMENTO = nIdTipoProcedimento;

                  BEGIN
                     EXECUTE IMMEDIATE 'Begin ' || vDescProcedimento || '.INSERISCI_PRATICHE_SU_SMRGAA(:1); end;'
                              USING IN recAziendaDaControllare.ID_AZIENDA;

                  EXCEPTION
                     WHEN OTHERS THEN
                          Pck_SMRGAA_Log.LogAnomalia (vDescProcedimento ||'.INSERISCI_PRATICHE_SU_SMRGAA - Azienda : ' || recAziendaDaControllare.ID_AZIENDA || ' ' || SUBSTR(SQLERRM,1,150));
                  END;

               END IF;

               nNumAziende := nNumAziende + 1;
               -- controllo se per la polizza è già stato effettuato un invio al SIAN
               -- se si non effettuo i controlli
               IF ExisPolizzaInvForAziendaAnno (recAziendaDaControllare.ID_AZIENDA,
                                                recAziendaDaControllare.ANNO_CAMPAGNA) THEN
                  nNumAziendaPolInviate := nNumAziendaPolInviate + 1;
                  Pck_SMRGAA_Log.LogAnomalia ('Per l''azienda : ' || recAziendaDaControllare.ID_AZIENDA || ' risultano polizze già inviate al SIAN nell''anno campagna : ' || recAziendaDaControllare.ANNO_CAMPAGNA || 'calcolo anomalie non effettuato !!');
               ELSE
                  -- altrimenti cancello le anomalie della polizza della fonte SIAP
                  CancellaAnomalieAzienda (recAziendaDaControllare.ID_AZIENDA,recAziendaDaControllare.ANNO_CAMPAGNA,knIdTipoFonteSiap);
                  -- e gli eventuali esisti
                  CancellaEsitiAzienda (recAziendaDaControllare.ID_AZIENDA, recAziendaDaControllare.ANNO_CAMPAGNA);
                  -- e le eventuali istruttorie effettute per le polizze
                  -- estratte a campione in extra resa
                  CancellaIstruttoriaPolizza (recAziendaDaControllare.ID_AZIENDA, recAziendaDaControllare.ANNO_CAMPAGNA);


                  -- devo andare anche ad annullare il coefficiente di riduzione resa e la resa media prodotto comune
                  -- che calcola il controllo ASS11 e che va ad impostare direttamente su DB_DETTAGLIO_POLIZZA_COLTURA
                  UPDATE DB_DETTAGLIO_POLIZZA_COLTURA
                     SET COEFFICIENTE_RIDUZIONE_RESA = NULL,
                         RESA_MEDIA_PRODOTTO_COMUNE =  NULL
                   WHERE ID_DETTAGLIO_POLIZZA IN (SELECT DP.ID_DETTAGLIO_POLIZZA
                                                    FROM DB_POLIZZA_ASSICURATIVA PA,
                                                         DB_DETTAGLIO_POLIZZA DP
                                                   WHERE PA.ID_AZIENDA = recAziendaDaControllare.ID_AZIENDA
                                                     AND PA.ANNO_CAMPAGNA = recAziendaDaControllare.ANNO_CAMPAGNA
                                                     AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA)
                     AND (COEFFICIENTE_RIDUZIONE_RESA IS NOT NULL OR
                          RESA_MEDIA_PRODOTTO_COMUNE IS NOT NULL);

                  -- scorro i controlli delle polizze assicurativa e li eseguo
                  FOR recControlloPolizza IN curControlloPolizza LOOP
                      -- il controllo ASS05 è diverso dagli altri perchè passa anche l'ID_PROCEDIMENTO
                      IF recControlloPolizza.CODICE_CONTROLLO IN ('ASS05','ASS06') THEN

                         vStrPlSql := 'Begin PACK_CONTROLLI.' || recControlloPolizza.CODICE_CONTROLLO ||
                                             '(:1,:2,:3,:4,:5,:6); End;';

                         EXECUTE IMMEDIATE vStrPlSql
                                  USING IN recAziendaDaControllare.ID_AZIENDA,
                                        IN recAziendaDaControllare.ANNO_CAMPAGNA,
                                        IN nIdTipoProcedimento,
                                        IN nTipoIntervento,
                                       OUT vRisultato,
                                       OUT vMessaggio;

                      ELSE
                          vStrPlSql := 'Begin PACK_CONTROLLI.' || recControlloPolizza.CODICE_CONTROLLO ||
                                       '(:1,:2,:3,:4,:5); End;';

                          EXECUTE IMMEDIATE vStrPlSql
                                      USING IN recAziendaDaControllare.ID_AZIENDA,
                                            IN recAziendaDaControllare.ANNO_CAMPAGNA,
                                            IN nTipoIntervento,
                                           OUT vRisultato,
                                           OUT vMessaggio;


                      END IF;

                      IF vRisultato = '1' THEN
                         PCK_SMRGAA_LOG.LogAnomalia ('Azienda : ' || recAziendaDaControllare.ID_AZIENDA || ' - ' || vMessaggio);
                      END IF;

                  END LOOP;
               END IF;
               COMMIT;
           END LOOP;

           Pck_SMRGAA_Log.LogInfo ('Fine Elaborazione - Trattate : ' || nNumAziende || ' aziende ' ||
                                                    ' - Di cui : ' || nNumAziendaPolInviate || ' scartate per invio importo proposto già effettuato');

        ELSE
           Pck_SMRGAA_Log.LogAnomalia ('Esistono parametri obbligatori non specificati - Termino Elaborazione');
        END IF;

        COMMIT;

        PCK_SMRGAA_LOG.ValorizzaEsitoBatch;

        RETURN nRetCode;

    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            PCK_SMRGAA_LOG.LogSqlError ('Controlla_Polizza');
            RETURN 1;
    END Controlla_Polizza;

    /*********************************************************************
    Effettua il calcolo dell'importo proposto per tutte le polizze identificate
    tramite i parametri di input (ANNO, TIPO_INTERVENTO, eventuale ID_AZIENDA)
    e l'accodamento della richiesta dell'invio al SIAN dello stesso sulla tabella
    DB_INVIO_DETTAGLIO_POLIZZA
    Tipo: procedure
    input: pAnnoOffSet, pTipoIntervento, pIdAzienda
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE CalcolaImportoProposto (pAnnoOffSet       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                                      pIdAzienda        IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE
                                      ) IS

        -- record di appoggio per inserimento su DB_INVIO_DETTAGLIO_POLIZZA
        recTInvDettPolizza  DB_INVIO_DETTAGLIO_POLIZZA%ROWTYPE;
        -- contatore dettaglio polizza elaborati
        nDettElaborati      INTEGER:=0;
        -- contatore dettaglio polizza inviati
        nDettInviati        INTEGER:=0;
        -- contatore dettaglio polizza scartati
        nDettAZero          INTEGER:=0;

        -- cursore degli esito dettaglio polizza per i quali calcolare l'importo proposto
        -- oltre a verificare se c'è un'anomalia bloccante sul
        -- singolo dettaglio polizza controllo se c'è un'anomalia bloccante
        -- a livello di polizza assicurativa
        CURSOR curPolizzaCalcoloImportoOp (pAnnoCampagna IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                                           pIdAzienda    IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE
                                           ) IS
        SELECT DP.*,
               'N' AS BLOCCATO
          FROM DB_POLIZZA_ASSICURATIVA PA,
               DB_DETTAGLIO_POLIZZA DP
         WHERE PA.ANNO_CAMPAGNA = pAnnoCampagna
           AND (PA.ID_AZIENDA = pIdAzienda OR pIdAzienda IS NULL)
           AND PA.ID_TIPO_INTERVENTO IN (SELECT VPV.VALORE_NUMBER
                                           FROM SMRGAA_R_PARAM_APPLICAZIONE PA,
                                                SMRGAA_R_VALORE_PARAM_VETTORE VPV
                                          WHERE PA.ID_APPLICAZIONE = knIdApplBatchEsitoPolizza
                                            AND PA.COD_PARAMETRO = kvParIdTipoIntervento
                                            AND PA.TIPO_PARAMETRO = 'V'
                                            AND PA.ID_PARAMETRO_APPLICAZIONE = VPV.ID_PARAMETRO_APPLICAZIONE)
           AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
           AND NOT EXISTS (SELECT ID_DETTAGLIO_POLIZZA
                             FROM DB_INVIO_DETTAGLIO_POLIZZA
                            WHERE ID_DETTAGLIO_POLIZZA = DP.ID_DETTAGLIO_POLIZZA
                              AND IMPORTO_PROPOSTO_OP IS NOT NULL
                              AND TIPO_OPERAZIONE = kvTipoOperInvImportoProposto
                              AND ESITO_INVIO = kvCodEsitoInvioOk)
           AND NOT EXISTS (SELECT AP.ID_ANOMALIA_POLIZZA
                             FROM DB_ANOMALIA_POLIZZA AP,
                                  DB_TIPO_CONTROLLO_FASE TCF
                            WHERE AP.ID_DETTAGLIO_POLIZZA = DP.ID_DETTAGLIO_POLIZZA
                              AND AP.ID_FONTE = knIdTipoFonteSiap
                              AND AP.ID_CONTROLLO = TCF.ID_CONTROLLO
                              AND TCF.BLOCCANTE = 'S')
           AND NOT EXISTS (SELECT AP.ID_ANOMALIA_POLIZZA
                             FROM DB_ANOMALIA_POLIZZA AP,
                                  DB_TIPO_CONTROLLO_FASE TCF
                            WHERE AP.ID_POLIZZA_ASSICURATIVA = PA.ID_POLIZZA_ASSICURATIVA
                              AND AP.ID_FONTE = knIdTipoFonteSiap
                              AND AP.ID_CONTROLLO = TCF.ID_CONTROLLO
                              AND TCF.BLOCCANTE = 'S')
        UNION
        SELECT DP.*,
               'S' AS BLOCCATO
          FROM DB_POLIZZA_ASSICURATIVA PA,
               DB_DETTAGLIO_POLIZZA DP
         WHERE PA.ANNO_CAMPAGNA = pAnnoCampagna
           AND (PA.ID_AZIENDA = pIdAzienda OR pIdAzienda IS NULL)
           AND PA.ID_TIPO_INTERVENTO IN (SELECT VPV.VALORE_NUMBER
                                           FROM SMRGAA_R_PARAM_APPLICAZIONE PA,
                                                SMRGAA_R_VALORE_PARAM_VETTORE VPV
                                          WHERE PA.ID_APPLICAZIONE = knIdApplBatchEsitoPolizza
                                            AND PA.COD_PARAMETRO = kvParIdTipoIntervento
                                            AND PA.TIPO_PARAMETRO = 'V'
                                            AND PA.ID_PARAMETRO_APPLICAZIONE = VPV.ID_PARAMETRO_APPLICAZIONE)
           AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
           AND NOT EXISTS (SELECT ID_DETTAGLIO_POLIZZA
                             FROM DB_INVIO_DETTAGLIO_POLIZZA
                            WHERE ID_DETTAGLIO_POLIZZA = DP.ID_DETTAGLIO_POLIZZA
                              AND IMPORTO_PROPOSTO_OP IS NOT NULL
                              AND TIPO_OPERAZIONE = kvTipoOperInvImportoProposto
                              AND ESITO_INVIO = kvCodEsitoInvioOk)
           AND (EXISTS (SELECT AP.ID_ANOMALIA_POLIZZA
                         FROM DB_ANOMALIA_POLIZZA AP,
                              DB_TIPO_CONTROLLO_FASE TCF
                        WHERE AP.ID_DETTAGLIO_POLIZZA = DP.ID_DETTAGLIO_POLIZZA
                          AND AP.ID_FONTE = knIdTipoFonteSiap
                          AND AP.ID_CONTROLLO = TCF.ID_CONTROLLO
                          AND TCF.BLOCCANTE = 'S') OR
                 EXISTS (SELECT AP.ID_ANOMALIA_POLIZZA
                           FROM DB_ANOMALIA_POLIZZA AP,
                                DB_TIPO_CONTROLLO_FASE TCF
                          WHERE AP.ID_POLIZZA_ASSICURATIVA = PA.ID_POLIZZA_ASSICURATIVA
                            AND AP.ID_FONTE = knIdTipoFonteSiap
                            AND AP.ID_CONTROLLO = TCF.ID_CONTROLLO
                            AND TCF.BLOCCANTE = 'S')); 

    BEGIN

       Pck_SMRGAA_Log.LogInfo ('Inizio calcolo importo proposto');

       FOR recPolizzaCalcoloImportoOp IN curPolizzaCalcoloImportoOp (pAnnoOffset,
                                                                     pIdAzienda) LOOP
           nDettElaborati := nDettElaborati + 1;
           -- ed inserisco la richiesta di invio al SIAN
           SELECT SEQ_DB_INVIO_DETTAGLIO_POLIZZA.nextval
             INTO recTInvDettPolizza.ID_INVIO_DETTAGLIO_POLIZZA
             FROM DUAL;

           recTInvDettPolizza.ID_DETTAGLIO_POLIZZA := recPolizzaCalcoloImportoOp.ID_DETTAGLIO_POLIZZA;
           recTInvDettPolizza.TIPO_OPERAZIONE := kvTipoOperInvImportoProposto;
           IF recPolizzaCalcoloImportoOp.BLOCCATO = 'S' THEN
              Pck_SMRGAA_Log.LogAnomalia ('Importo Proposto forzato a 0 per ID_DETTAGLIO_POLIZZA = ' || recPolizzaCalcoloImportoOp.ID_DETTAGLIO_POLIZZA || ' causa presenza anomalie bloccanti');
              recTInvDettPolizza.IMPORTO_PROPOSTO := 0;
              recTInvDettPolizza.IMPORTO_PROPOSTO_OP := 0;
              nDettAZero := nDettAZero + 1;
           ELSE
              IF recPolizzaCalcoloImportoOp.SPESA_AMMESSA IS NOT NULL THEN
                 recTInvDettPolizza.IMPORTO_PROPOSTO := recPolizzaCalcoloImportoOp.IMPORTO_PROPOSTO;
                 recTInvDettPolizza.IMPORTO_PROPOSTO_OP := recPolizzaCalcoloImportoOp.SPESA_AMMESSA;
              ELSE
                 recTInvDettPolizza.IMPORTO_PROPOSTO := 0;
                 recTInvDettPolizza.IMPORTO_PROPOSTO_OP := 0;
                 Pck_SMRGAA_Log.LogAnomalia ('SPESA_AMMESSA non valorizzata per ID_DETTAGLIO_POLIZZA = ' || recPolizzaCalcoloImportoOp.ID_DETTAGLIO_POLIZZA);
                 nDettAZero := nDettAZero + 1;
              END IF;
           END IF;
           recTInvDettPolizza.DATA_RICHIESTA := SYSDATE;
           -- cancello la richieste di invio al SIAN non ancora presa in carico se presente
           CancellaTInvioDettPolizza (recTInvDettPolizza.ID_DETTAGLIO_POLIZZA,
                                      recTInvDettPolizza.TIPO_OPERAZIONE);
           -- inserisco la richiesta di invio al SIAN dell'importo proposto OP
           InsertTInvioDettPolizza (recTInvDettPolizza);
           -- aggiorno il dettaglio polizza con l'importo proposto op appena calcolato
           AggiornaImportoPropostoOp (recTInvDettPolizza);
           nDettInviati := nDettInviati + 1;
           COMMIT;
       END LOOP;

       Pck_SMRGAA_Log.LogInfo ('Fine calcolo importo proposto - Elaborati : ' || nDettElaborati || ' dettagli polizza per invio importo proposto al SIAN');
       Pck_SMRGAA_Log.LogInfo ('Di cui con importo proposto maggiore di zero : ' || TO_CHAR(nDettInviati  - nDettAZero));
       Pck_SMRGAA_Log.LogInfo ('Di cui con importo proposto uguale zero (SPESA AMMESSA non valorizzata od anomalia bloccante : ' || nDettAZero);

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('CalcolaImportoProposto - pAnnoOffSet/pIdAzienda= ' || pAnnoOffSet || '/' || pIdAzienda);
             RAISE;
    END CalcolaImportoProposto;

    /*********************************************************************
    Effettua il calcolo dell'importo pagabile per tutte le polizze identificate
    tramite i parametri di input (ANNO, TIPO_INTERVENTO, eventuale ID_AZIENDA)
    e l'accodamento della richiesta dell'invio al SIAN dello stesso sulla tabella
    DB_INVIO_DETTAGLIO_POLIZZA (al netto dell'applicazione della percentuale di riduzione)
    Tipo: procedure
    input: pAnnoOffSet, pTipoIntervento, pIdAzienda, pPercRiduzione
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE CalcolaImportoPagabile (pAnnoOffSet       IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                                      pIdAzienda        IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE,
                                      pPercRiduzione    IN SMRGAA_R_PARAM_APPLICAZIONE.VALORE_NUMBER%TYPE
                                      ) IS

        -- record di appoggio per inserimento su DB_INVIO_DETTAGLIO_POLIZZA
        recTInvDettPolizza  DB_INVIO_DETTAGLIO_POLIZZA%ROWTYPE;
        -- contatore dettaglio polizza elaborati
        nDettElaborati      INTEGER:=0;
        -- contatore dettaglio polizza inviati
        nDettInviati        INTEGER:=0;
        -- contatore dettaglio polizza scartati
        nDettScartati       INTEGER:=0;
        -- contenitore dell'importo proposto OP cioè della spesa ammessa di DB_DETTAGLIO_POLIZZA x il coefficiente di DB_ESITO_DETTAGLIO_POLIZZA
        nImpPagato          DB_ESITO_DETTAGLIO_POLIZZA.IMPORTO_PROPOSTO_OP%TYPE;

        -- cursore degli esito dettaglio polizza per i quali calcolare l'importo pagabile
        CURSOR curPolizzaCalcoloImportoPg (pAnnoCampagna IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                                           pIdAzienda    IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE
                                           ) IS
        SELECT DP.*,
               EDP.COEFFICIENTE,
               EDP.ID_ESITO_DETTAGLIO_POLIZZA,
               DPC.COEFFICIENTE_RIDUZIONE_RESA
          FROM DB_POLIZZA_ASSICURATIVA PA,
               DB_DETTAGLIO_POLIZZA DP,
               DB_ESITO_DETTAGLIO_POLIZZA EDP,
               DB_DETTAGLIO_POLIZZA_COLTURA DPC
         WHERE PA.ANNO_CAMPAGNA = pAnnoCampagna
           AND (PA.ID_AZIENDA = pIdAzienda OR pIdAzienda IS NULL)
           AND PA.ID_TIPO_INTERVENTO IN (SELECT VPV.VALORE_NUMBER
                                           FROM SMRGAA_R_PARAM_APPLICAZIONE PA,
                                                SMRGAA_R_VALORE_PARAM_VETTORE VPV
                                          WHERE PA.ID_APPLICAZIONE = knIdApplBatchEsitoPolizza
                                            AND PA.COD_PARAMETRO = kvParIdTipoIntervento
                                            AND PA.TIPO_PARAMETRO = 'V'
                                            AND PA.ID_PARAMETRO_APPLICAZIONE = VPV.ID_PARAMETRO_APPLICAZIONE)
           AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
           AND DP.ID_DETTAGLIO_POLIZZA = EDP.ID_DETTAGLIO_POLIZZA
           AND DP.ID_DETTAGLIO_POLIZZA = DPC.ID_DETTAGLIO_POLIZZA
           AND NOT EXISTS (SELECT ID_DETTAGLIO_POLIZZA
                             FROM DB_INVIO_DETTAGLIO_POLIZZA
                            WHERE ID_DETTAGLIO_POLIZZA = DP.ID_DETTAGLIO_POLIZZA
                              AND IMPORTO_PAGATO IS NOT NULL
                              AND TIPO_OPERAZIONE = kvTipoOperInvImportoPagabile
                              AND ESITO_INVIO = kvCodEsitoInvioOk);

    -- cursore per selezionare i dettagli polizza con gli importi pagati relativi al
    -- migliore esito (massimo importo pagabile) per ID_AZIENDA ed ANNO
    CURSOR curImportoPerInvio (pAnnoCampagna IN DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE,
                               pIdAzienda    IN DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE
                               ) IS
       WITH TOT_AZIENDA_ANNO_CRITERIO AS (
       SELECT GRUPPO.ID_AZIENDA,
              GRUPPO.ANNO_CAMPAGNA,
              GRUPPO.NETTO NETTO_G,
              MACROUSO.NETTO NETTO_M,
              CASE WHEN GRUPPO.NETTO > MACROUSO.NETTO THEN 'G' ELSE 'M' END AS CRIT_MIGLIORE,
              CASE WHEN GRUPPO.NETTO > MACROUSO.NETTO THEN GRUPPO.NETTO ELSE MACROUSO.NETTO END AS IMP_MIGLIORE
         FROM (SELECT DETTAGLI.ID_AZIENDA, DETTAGLI.ANNO_CAMPAGNA, 'G' CRITERIO, SUM(DETTAGLI.IMPORTO_PAGATO) NETTO
                FROM (SELECT DPA.ID_AZIENDA,DPA.ANNO_CAMPAGNA,DDP.ID_DETTAGLIO_POLIZZA, MAX(EDP.IMPORTO_PAGATO) IMPORTO_PAGATO
                       FROM DB_POLIZZA_ASSICURATIVA DPA,
                            DB_DETTAGLIO_POLIZZA DDP,
                            DB_DETTAGLIO_POLIZZA_COLTURA DDPC,
                            DB_ESITO_DETTAGLIO_POLIZZA EDP
                      WHERE DPA.ID_POLIZZA_ASSICURATIVA = DDP.ID_POLIZZA_ASSICURATIVA
                        AND DDP.ID_DETTAGLIO_POLIZZA = DDPC.ID_DETTAGLIO_POLIZZA
                        AND EDP.ID_DETTAGLIO_POLIZZA = DDP.ID_DETTAGLIO_POLIZZA
                        AND EDP.ID_GRUPPO_MACRO_USO IS NOT NULL
                   GROUP BY DPA.ID_AZIENDA, DPA.ANNO_CAMPAGNA,DDP.ID_DETTAGLIO_POLIZZA) DETTAGLI
                GROUP BY DETTAGLI.ID_AZIENDA, DETTAGLI.ANNO_CAMPAGNA, 'G') GRUPPO,
               (SELECT DETTAGLI_MC.ID_AZIENDA, DETTAGLI_MC.ANNO_CAMPAGNA,'M' CRITERIO, SUM(DETTAGLI_MC.IMPORTO_PAGATO) NETTO
                  FROM (SELECT DPA.ID_AZIENDA,DPA.ANNO_CAMPAGNA, DDP.ID_DETTAGLIO_POLIZZA, MAX(EDP.IMPORTO_PAGATO) IMPORTO_PAGATO
                          FROM DB_POLIZZA_ASSICURATIVA DPA, DB_DETTAGLIO_POLIZZA DDP, DB_DETTAGLIO_POLIZZA_COLTURA DDPC, DB_ESITO_DETTAGLIO_POLIZZA EDP
                         WHERE DPA.ID_POLIZZA_ASSICURATIVA = DDP.ID_POLIZZA_ASSICURATIVA
                           AND DDP.ID_DETTAGLIO_POLIZZA = DDPC.ID_DETTAGLIO_POLIZZA
                           AND EDP.ID_DETTAGLIO_POLIZZA = DDP.ID_DETTAGLIO_POLIZZA
                           AND EDP.ID_MACRO_USO IS NOT NULL
                           GROUP BY DPA.ID_AZIENDA,DPA.ANNO_CAMPAGNA,DDP.ID_DETTAGLIO_POLIZZA) DETTAGLI_MC
               GROUP BY DETTAGLI_MC.ID_AZIENDA, DETTAGLI_MC.ANNO_CAMPAGNA, 'M') MACROUSO
        WHERE GRUPPO.ID_AZIENDA = MACROUSO.ID_AZIENDA
          AND GRUPPO.ANNO_CAMPAGNA = MACROUSO.ANNO_CAMPAGNA)
       SELECT EDP.ID_DETTAGLIO_POLIZZA,
              EDP.IMPORTO_PAGATO,
              'N' AS BLOCCATO
         FROM TOT_AZIENDA_ANNO_CRITERIO P,
              DB_POLIZZA_ASSICURATIVA PA,
              DB_DETTAGLIO_POLIZZA DP,
              DB_ESITO_DETTAGLIO_POLIZZA EDP
        WHERE PA.ANNO_CAMPAGNA = pAnnoCampagna
          AND (PA.ID_AZIENDA = pIdAzienda OR pIdAzienda IS NULL)
          AND PA.ANNO_CAMPAGNA = P.ANNO_CAMPAGNA
          AND PA.ID_AZIENDA = P.ID_AZIENDA
          AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
          AND DP.ID_DETTAGLIO_POLIZZA = EDP.ID_DETTAGLIO_POLIZZA
          AND ((P.CRIT_MIGLIORE = 'M' AND EDP.ID_MACRO_USO IS NOT NULL) OR
               (P.CRIT_MIGLIORE = 'G' AND EDP.ID_GRUPPO_MACRO_USO IS NOT NULL))
          AND EDP.IMPORTO_PAGATO = (SELECT MAX(IMPORTO_PAGATO)
                                      FROM DB_ESITO_DETTAGLIO_POLIZZA
                                     WHERE ID_DETTAGLIO_POLIZZA = EDP.ID_DETTAGLIO_POLIZZA
                                       AND ((P.CRIT_MIGLIORE = 'M' AND ID_MACRO_USO IS NOT NULL) OR
                                            (P.CRIT_MIGLIORE = 'G' AND ID_GRUPPO_MACRO_USO IS NOT NULL)))
          AND NOT EXISTS (SELECT ID_DETTAGLIO_POLIZZA
                            FROM DB_INVIO_DETTAGLIO_POLIZZA
                           WHERE ID_DETTAGLIO_POLIZZA = DP.ID_DETTAGLIO_POLIZZA
                             AND IMPORTO_PAGATO IS NOT NULL
                             AND TIPO_OPERAZIONE = kvTipoOperInvImportoPagabile
                             AND ESITO_INVIO = kvCodEsitoInvioOk)
          AND NOT EXISTS (SELECT AP.ID_ANOMALIA_POLIZZA
                            FROM DB_ANOMALIA_POLIZZA AP,
                                 DB_TIPO_CONTROLLO_FASE TCF
                           WHERE AP.ID_DETTAGLIO_POLIZZA = DP.ID_DETTAGLIO_POLIZZA
                             AND AP.ID_FONTE = knIdTipoFonteSiap
                             AND AP.ID_CONTROLLO = TCF.ID_CONTROLLO
                             AND TCF.BLOCCANTE = 'S')
          AND NOT EXISTS (SELECT AP.ID_ANOMALIA_POLIZZA
                            FROM DB_ANOMALIA_POLIZZA AP,
                                 DB_TIPO_CONTROLLO_FASE TCF
                           WHERE AP.ID_POLIZZA_ASSICURATIVA = PA.ID_POLIZZA_ASSICURATIVA
                             AND AP.ID_FONTE = knIdTipoFonteSiap
                             AND AP.ID_CONTROLLO = TCF.ID_CONTROLLO
                             AND TCF.BLOCCANTE = 'S')
        GROUP BY EDP.ID_DETTAGLIO_POLIZZA, EDP.IMPORTO_PAGATO
    UNION
    SELECT DP.ID_DETTAGLIO_POLIZZA,
           DP.IMPORTO_PAGATO,
           'S' AS BLOCCATO
      FROM DB_POLIZZA_ASSICURATIVA PA,
           DB_DETTAGLIO_POLIZZA DP
     WHERE PA.ANNO_CAMPAGNA = pAnnoCampagna
       AND (PA.ID_AZIENDA = pIdAzienda OR pIdAzienda IS NULL)
       AND PA.ID_TIPO_INTERVENTO IN (SELECT VPV.VALORE_NUMBER
                                       FROM SMRGAA_R_PARAM_APPLICAZIONE PA,
                                            SMRGAA_R_VALORE_PARAM_VETTORE VPV
                                      WHERE PA.ID_APPLICAZIONE = knIdApplBatchEsitoPolizza
                                        AND PA.COD_PARAMETRO = kvParIdTipoIntervento
                                        AND PA.TIPO_PARAMETRO = 'V'
                                        AND PA.ID_PARAMETRO_APPLICAZIONE = VPV.ID_PARAMETRO_APPLICAZIONE)
       AND PA.ID_POLIZZA_ASSICURATIVA = DP.ID_POLIZZA_ASSICURATIVA
       AND NOT EXISTS (SELECT ID_DETTAGLIO_POLIZZA
                         FROM DB_INVIO_DETTAGLIO_POLIZZA
                        WHERE ID_DETTAGLIO_POLIZZA = DP.ID_DETTAGLIO_POLIZZA
                          AND IMPORTO_PAGATO IS NOT NULL
                          AND TIPO_OPERAZIONE = kvTipoOperInvImportoPagabile
                          AND ESITO_INVIO = kvCodEsitoInvioOk)
       AND (EXISTS (SELECT AP.ID_ANOMALIA_POLIZZA
                      FROM DB_ANOMALIA_POLIZZA AP,
                           DB_TIPO_CONTROLLO_FASE TCF
                     WHERE AP.ID_DETTAGLIO_POLIZZA = DP.ID_DETTAGLIO_POLIZZA
                       AND AP.ID_FONTE = knIdTipoFonteSiap
                       AND AP.ID_CONTROLLO = TCF.ID_CONTROLLO
                       AND TCF.BLOCCANTE = 'S') OR
            EXISTS (SELECT AP.ID_ANOMALIA_POLIZZA
                      FROM DB_ANOMALIA_POLIZZA AP,
                           DB_TIPO_CONTROLLO_FASE TCF
                     WHERE AP.ID_POLIZZA_ASSICURATIVA = PA.ID_POLIZZA_ASSICURATIVA
                       AND AP.ID_FONTE = knIdTipoFonteSiap
                       AND AP.ID_CONTROLLO = TCF.ID_CONTROLLO
                       AND TCF.BLOCCANTE = 'S'));

    BEGIN

       Pck_SMRGAA_Log.LogInfo ('Inizio calcolo importo pagabile');

       -- scorro i dettagli polizza per i quali calcolare l'importo pagabile
       FOR recPolizzaCalcoloImportoPg IN curPolizzaCalcoloImportoPg (pAnnoOffset,
                                                                     pIdAzienda) LOOP
           nDettElaborati := nDettElaborati + 1;
           IF recPolizzaCalcoloImportoPg.COEFFICIENTE IS NOT NULL THEN
              IF recPolizzaCalcoloImportoPg.SPESA_AMMESSA IS NOT NULL THEN
                 nImpPagato := (recPolizzaCalcoloImportoPg.SPESA_AMMESSA * NVL(recPolizzaCalcoloImportoPg.COEFFICIENTE_RIDUZIONE_RESA,1)) * recPolizzaCalcoloImportoPg.COEFFICIENTE;
                 UPDATE DB_ESITO_DETTAGLIO_POLIZZA
                    SET IMPORTO_PAGATO = nImpPagato
                  WHERE ID_ESITO_DETTAGLIO_POLIZZA = recPolizzaCalcoloImportoPg.ID_ESITO_DETTAGLIO_POLIZZA;
                 nDettInviati := nDettInviati + 1;
              ELSE
                 Pck_SMRGAA_Log.LogAnomalia ('SPESA_AMMESSA non valorizzata per ID_DETTAGLIO_POLIZZA = ' || recPolizzaCalcoloImportoPg.ID_DETTAGLIO_POLIZZA);
                 nDettScartati := nDettScartati + 1;
              END IF;
           ELSE
              Pck_SMRGAA_Log.LogAnomalia ('Coefficiente non calcolato per ID_DETTAGLIO_POLIZZA = ' || recPolizzaCalcoloImportoPg.ID_DETTAGLIO_POLIZZA);
              nDettScartati := nDettScartati + 1;
           END IF;
           COMMIT;
       END LOOP;

       Pck_SMRGAA_Log.LogInfo ('Fine Calcolo importo pagabile - Trattati : ' || nDettElaborati || ' records di DB_ESITO_DETTAGLIO_POLIZZA');
       Pck_SMRGAA_Log.LogInfo ('- Di cui calcolati correttamente : ' || nDettInviati );
       Pck_SMRGAA_Log.LogInfo ('- Di cui scartati x mancanza coefficiente o spesa ammessa : ' || nDettScartati);

       Pck_SMRGAA_Log.LogInfo ('Inizio Invio migliore Importo Pagabile per dettaglio polizza');
       nDettInviati :=0;
       -- scorro i singoli esito dettaglio polizza per l'azienda , l'anno , il TIPO_CRITERIO ed per ID_MACRO_USO od ID_GRUPPO_MACRO_USO
       -- trovati per il migliore totale importo prosposto
       FOR recImportoPerInvio IN curImportoPerInvio (pAnnoOffset,
                                                     pIdAzienda) LOOP

           -- ed inserisco la richiesta di invio al SIAN
           SELECT SEQ_DB_INVIO_DETTAGLIO_POLIZZA.nextval
             INTO recTInvDettPolizza.ID_INVIO_DETTAGLIO_POLIZZA
             FROM DUAL;

           recTInvDettPolizza.ID_DETTAGLIO_POLIZZA := recImportoPerInvio.ID_DETTAGLIO_POLIZZA;
           recTInvDettPolizza.TIPO_OPERAZIONE := kvTipoOperInvImportoPagabile;
           -- non valorizzo più l'importo pagato ma la spesa ammessa OP
           IF recImportoPerInvio.BLOCCATO = 'S' THEN
              Pck_SMRGAA_Log.LogAnomalia ('Spesa ammessa OP forzata a 0 per ID_DETTAGLIO_POLIZZA = ' || recImportoPerInvio.ID_DETTAGLIO_POLIZZA || ' causa presenza anomalie bloccanti');
              recTInvDettPolizza.SPESA_AMMESSA_OP := 0;
           ELSE
              recTInvDettPolizza.SPESA_AMMESSA_OP := recImportoPerInvio.IMPORTO_PAGATO * pPercRiduzione / 100;
           END IF;
           recTInvDettPolizza.DATA_RICHIESTA := SYSDATE;
           -- cancello la richieste di invio al SIAN non ancora presa in carico se presente
           CancellaTInvioDettPolizza (recTInvDettPolizza.ID_DETTAGLIO_POLIZZA,
                                      recTInvDettPolizza.TIPO_OPERAZIONE);
           -- inserisco la richiesta di invio al SIAN dell'importo pagabile
           InsertTInvioDettPolizza (recTInvDettPolizza);
           -- aggiorno il dettaglio polizza con l'importo pagabile appena calcolato
           AggiornaImportoPagato (recTInvDettPolizza);
           nDettInviati := nDettInviati + 1;
           COMMIT;
       END LOOP;

       Pck_SMRGAA_Log.LogInfo ('Fine Invio migliore Importo Pagabile per dettaglio polizza');
       Pck_SMRGAA_Log.LogInfo ('- Inseriti su DB_INVIO_DETTAGLIO_POLIZZA : ' || nDettInviati || ' records');

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('CalcolaImportoPagabile - pAnnoOffSet/pIdAzienda/pPercRiduzione= ' || pAnnoOffSet || '/' || '/' || pIdAzienda || '/' || pPercRiduzione);
             RAISE;
    END CalcolaImportoPagabile;

    /*********************************************************************
    Effettua il calcolo dell'importo proposto (ed eventualmente dell'importo pagabile)
    per le polizze assicurative estratte tramite i parametri di input del batch
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION Calcola_Importo_Polizza RETURN NUMBER IS
        -- record di appoggio per il reperimento dei dati dell'applicazione corrente
        recDApplicazione    SMRGAA_D_APPLICAZIONI_BATCH%ROWTYPE;
        -- conterrà l'id esecuzione
        nIdEsecuzione       SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE;
        -- conterrà il codice di ritorno
        nRetCode            NUMBER(1):=0;
        -- vettore dei parametri
        vetParametri        Pck_SMRGAA_Log.TypVetParametriApplicazione;
        -- anno sul quale controllare le polizze
        nAnnoOffset         DB_POLIZZA_ASSICURATIVA.ANNO_CAMPAGNA%TYPE;
        -- eventuale id_azienda per il quale calcolare gli importi proposto e pagato delle polizze
        nIdAzienda          DB_POLIZZA_ASSICURATIVA.ID_AZIENDA%TYPE;
        -- flag che mi dice se devo calcolare l'importo pagabile oltre a quello proposto
        vCalcolaPagabile    SMRGAA_R_PARAM_APPLICAZIONE.VALORE_VARCHAR2%TYPE;
        -- eventuale percentuale di riduzione da applicare all'importo proposto per avere l'importo pagabile
        nPercRiduzione      SMRGAA_R_PARAM_APPLICAZIONE.VALORE_NUMBER%TYPE;
        -- booleana che mi dice se i parametri sono presenti e formalmente corretti
        bParamOk            BOOLEAN:=TRUE;

    BEGIN

        nRetCode := Pck_SMRGAA_Log.VerificaAttivazioneBatch(knIdApplBatchEsitoPolizza ,recDApplicazione);

        IF nRetCode > 0 THEN
             -- Errore, Batch non attivo
            RETURN nRetCode;
        END IF;

         -- Inserimento in tabella dell'identificativo di esecuzione
         -- nIdEsecuzione restituito in output
        Pck_SMRGAA_Log.InsertTEsecuzione ( knIdApplBatchEsitoPolizza, nIdEsecuzione );
        COMMIT;

         -- Scrittura nel file nomefile_esecuzione del nIdEsecuzione
        Pck_SMRGAA_Log.ScriviFileEsecuzione (  recDApplicazione.nomefile_esecuzione,
                                               recDApplicazione.path_file_esecuzione,
                                               nIdEsecuzione );

        Pck_SMRGAA_Log.LeggiFileEsecuzione ( recDApplicazione.nomefile_esecuzione, recDApplicazione.path_file_esecuzione );

        Pck_SMRGAA_Log.SetLogLevel ( recDApplicazione.log_level );

        Pck_SMRGAA_Log.Init( knIdApplBatchEsitoPolizza, 'Calcola_Importo_Polizza' );

        vetParametri := Pck_SMRGAA_Log.CaricaParametriApplicazione(knIdApplBatchEsitoPolizza);
        -- anno per il quale estrarre le polizze (obbligatorio)
        BEGIN
            nAnnoOffset := vetParametri(kvParAnnoCampagna).VAL_NUMBER;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 nAnnoOffset := NULL;
                 Pck_SMRGAA_Log.LogAnomalia ('Parametro : ' || kvParAnnoCampagna || ' non specificato');
                 bParamOk := FALSE;
        END;

        BEGIN
            IF vetParametri(kvParIdTipoIntervento).VETTORE.COUNT = 0 THEN
               Pck_SMRGAA_Log.LogAnomalia ('Parametro : ' || kvParIdTipoIntervento || ' , identificativi intervento da trattare non specificati');
               bParamOk := FALSE;
            END IF;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 Pck_SMRGAA_Log.LogAnomalia ('Parametro : ' || kvParIdTipoIntervento || ' non specificato');
                 bParamOk := FALSE;
        END;

        -- id_azienda per il quale estrarre le polizze (facoltativo)
        BEGIN
            nIdAzienda  := vetParametri(kvParIdAzienda).VAL_NUMBER;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 nIdAzienda := NULL;
        END;

        -- indicatore di effettuazione del calcolo del pagabile (facoltativo)
        BEGIN
            vCalcolaPagabile  := vetParametri(kvParCalcolaPagabile).VAL_VARCHAR2;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 vCalcolaPagabile := NULL;
        END;
        -- percentuale riduzione importo pagabile (facoltativo, ma ogglicatorio se vCalcolaPagabile = S)
        BEGIN
            nPercRiduzione  := vetParametri(kvParPercRiduzionePagabile).VAL_NUMBER;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 nPercRiduzione := NULL;
        END;
        -- se devo effettuare il calcolo di tutti gli importi o solamente quello del confermato (pagato)
        -- allora la percentuale di riduzione deve essere presente
        IF vCalcolaPagabile IN ('T','C') THEN
           IF nPercRiduzione IS NULL THEN
              Pck_SMRGAA_Log.LogAnomalia ('Parametro : ' || kvParPercRiduzionePagabile || ' deve essere specificato se il parametro ' || kvParCalcolaPagabile || ' è uguale ad ' || vCalcolaPagabile);
              bParamOk := FALSE;
           END IF;
        END IF;

        IF bParamOk THEN
           Pck_SMRGAA_Log.LogInfo ('Inizio Elaborazione - Parametri');
           Pck_SMRGAA_Log.LogInfo ('- ANNO_CAMPAGNA = ' || nAnnoOffset);
           Pck_SMRGAA_Log.LogInfo ('- ID_AZIENDA = ' || nIdAzienda);
           Pck_SMRGAA_Log.LogInfo ('- TIPOLOGIA_IMPORTI = ' || vCalcolaPagabile);
           Pck_SMRGAA_Log.LogInfo ('- PERCENTUALE_RIDUZIONE = ' || nPercRiduzione);
           Pck_SMRGAA_Log.StoricizzaParametri (knIdApplBatchEsitoPolizza);
           -- tutti , proposto
           IF vCalcolaPagabile IN ('T','P') THEN
              CalcolaImportoProposto (nAnnoOffset,nIdAzienda );
           END IF;
           -- tutti , confermato (pagato)
           IF vCalcolaPagabile IN ('T','C') THEN
              CalcolaImportoPagabile (nAnnoOffset,nIdAzienda, nPercRiduzione);
           END IF;

           Pck_SMRGAA_Log.LogInfo ('Fine Elaborazione');

        ELSE
           Pck_SMRGAA_Log.LogAnomalia ('Esistono parametri obbligatori non specificati - Termino Elaborazione');
        END IF;

        COMMIT;

        PCK_SMRGAA_LOG.ValorizzaEsitoBatch;

        RETURN nRetCode;

    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            PCK_SMRGAA_LOG.LogSqlError ('Calcola_Importo_Polizza');
            RETURN 1;
    END Calcola_Importo_Polizza;

    /*********************************************************************
    Carica i dati annuali di resa dei prodotti assicurativi di un'azienda
    estratta a campione per polizze partendo dalla tabella di appoggio
    SMRGAA_W_RIEP_PRODOTTO_ANNO sulla tabella effettiva DB_RIEPILOGO_ANNUALE_PRODOTTO
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION CaricaDatiAnnuali RETURN NUMBER IS
        -- record di appoggio per il reperimento dei dati dell'applicazione corrente
        recDApplicazione    SMRGAA_D_APPLICAZIONI_BATCH%ROWTYPE;
        -- conterrà l'id esecuzione
        nIdEsecuzione       SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE;
        -- conterrà il codice di ritorno
        nRetCode            NUMBER(1):=0;
        -- record di appoggio per il tipo prodotto
        recDTipoProdotto    DB_TIPO_PRODOTTO%ROWTYPE;
        recDAnagrAzienda    DB_ANAGRAFICA_AZIENDA%ROWTYPE;
        recTRiepAnnProd     DB_RIEPILOGO_ANNUALE_PRODOTTO%ROWTYPE;

        CONTROLLI_FORMALI   EXCEPTION;
        PRODOTTO_NON_IDENT  EXCEPTION;
        AZIENDA_NON_IDENT   EXCEPTION;

        nNumRec             INTEGER:=0;
        nNumOk              INTEGER:=0;
        nNumKoCtrl          INTEGER:=0;
        nNumKoPr            INTEGER:=0;
        nNumKoAz            INTEGER:=0;
        nNumKoAltro         INTEGER:=0;

        CURSOR curDatoAnnuale IS
        SELECT *
          FROM SMRGAA_W_RIEP_PRODOTTO_ANNO
         WHERE NVL(ESITO_CARICAMENTO,'KO') = 'KO';


    BEGIN

        nRetCode := Pck_SMRGAA_Log.VerificaAttivazioneBatch(knIdApplBatchDtAnnualiCampPol ,recDApplicazione);

        IF nRetCode > 0 THEN
             -- Errore, Batch non attivo
            RETURN nRetCode;
        END IF;

         -- Inserimento in tabella dell'identificativo di esecuzione
         -- nIdEsecuzione restituito in output
        Pck_SMRGAA_Log.InsertTEsecuzione ( knIdApplBatchDtAnnualiCampPol, nIdEsecuzione );
        COMMIT;

         -- Scrittura nel file nomefile_esecuzione del nIdEsecuzione
        Pck_SMRGAA_Log.ScriviFileEsecuzione (  recDApplicazione.nomefile_esecuzione,
                                               recDApplicazione.path_file_esecuzione,
                                               nIdEsecuzione );

        Pck_SMRGAA_Log.LeggiFileEsecuzione ( recDApplicazione.nomefile_esecuzione, recDApplicazione.path_file_esecuzione );

        Pck_SMRGAA_Log.SetLogLevel ( recDApplicazione.log_level );

        Pck_SMRGAA_Log.Init( knIdApplBatchDtAnnualiCampPol, 'CaricaDatiAnnuali' );

        Pck_SMRGAA_Log.LogInfo ('Inizio elaborazione');

        -- scorro i dati annuali non ancora elaborati o terminati non a buon fine
        FOR recDatoAnnuale IN curDatoAnnuale LOOP
            BEGIN
                -- incremento il contatore degli elaborati
                nNumRec := nNumRec + 1;
                -- guardo che il cuaa sia di 11 o 16 caratteri
                IF LENGTH(TRIM(recDatoAnnuale.CUAA)) NOT IN (11,16) THEN
                   recDatoAnnuale.ESITO_CARICAMENTO := 'KO';
                   recDatoAnnuale.MOTIVO_SCARTO := 'Il cuaa deve essere lungo 11 o 16 caratteri';
                   RAISE CONTROLLI_FORMALI;
                END IF;

                -- guardo che sia maiuscolo e senza spazi
                IF TRIM(UPPER(recDatoAnnuale.CUAA)) <> recDatoAnnuale.CUAA THEN
                   recDatoAnnuale.ESITO_CARICAMENTO := 'KO';
                   recDatoAnnuale.MOTIVO_SCARTO := 'Il cuaa deve essere solamente caratteri maiuscoli';
                   RAISE CONTROLLI_FORMALI;
                END IF;

                -- guardo che il codice prodotto sia maiuscolo e senza spazi
                IF TRIM(UPPER(recDatoAnnuale.CODICE_PRODOTTO)) <> recDatoAnnuale.CODICE_PRODOTTO THEN
                   recDatoAnnuale.ESITO_CARICAMENTO := 'KO';
                   recDatoAnnuale.MOTIVO_SCARTO := 'Il codice prodotto assicurativo deve contenere solamente caratteri maiuscoli';
                   RAISE CONTROLLI_FORMALI;
                END IF;

                -- cerco il codice prodotto su DB_TIPO_PRODOTTO attivo al 31/12 dell'anno campagna fornito
                recDTipoProdotto := SelDTipoProdAssByCodiceEAnno (recDatoAnnuale.CODICE_PRODOTTO,
                                                                  TO_DATE('31/12/' || recDatoAnnuale.ANNO_CAMPAGNA , 'DD/MM/YYYY'));

                IF recDTipoProdotto.ID_TIPO_PRODOTTO IS NULL THEN
                   recDatoAnnuale.ESITO_CARICAMENTO := 'KO';
                   recDatoAnnuale.MOTIVO_SCARTO := 'Nessun prodotto assicurativo trovato per il codice : ' || recDatoAnnuale.CODICE_PRODOTTO || ' nella campagna : ' || recDatoAnnuale.ANNO_CAMPAGNA;
                   RAISE PRODOTTO_NON_IDENT;
                END IF;

                IF recDTipoProdotto.ID_TIPO_PRODOTTO = -1 THEN
                   recDatoAnnuale.ESITO_CARICAMENTO := 'KO';
                   recDatoAnnuale.MOTIVO_SCARTO := 'Impossibile identificare univocamente un prodotto assicurativo per il codice : ' || recDatoAnnuale.CODICE_PRODOTTO || ' nella campagna : ' || recDatoAnnuale.ANNO_CAMPAGNA;
                   RAISE PRODOTTO_NON_IDENT;
                END IF;

                -- cerco l'azienda (anche cessata) per cuaa
                recDAnagrAzienda := SelDAnagAziendaByCuaa (recDatoAnnuale.CUAA);

                IF recDAnagrAzienda.ID_AZIENDA IS NULL THEN
                   recDatoAnnuale.ESITO_CARICAMENTO := 'KO';
                   recDatoAnnuale.MOTIVO_SCARTO := 'Non sono stata trovate aziende agricole con il CUAA : ' || recDatoAnnuale.CUAA;
                   RAISE AZIENDA_NON_IDENT;
                END IF;

                IF recDAnagrAzienda.ID_AZIENDA = -1 THEN
                   recDatoAnnuale.ESITO_CARICAMENTO := 'KO';
                   recDatoAnnuale.MOTIVO_SCARTO := 'Impossibile identificare univocamente l''azienda agricola con il CUAA : ' || recDatoAnnuale.CUAA;
                   RAISE AZIENDA_NON_IDENT;
                END IF;

                -- finalmente posso inserire sulla tabella effettiva
                SELECT SEQ_DB_RIEPILOGO_ANNUALE_PROD.nextval
                  INTO recTRiepAnnProd.ID_RIEPILOGO_ANNUALE_PRODOTTO
                  FROM DUAL;

                recTRiepAnnProd.ID_AZIENDA := recDAnagrAzienda.ID_AZIENDA;
                recTRiepAnnProd.ID_TIPO_PRODOTTO := recDTipoProdotto.ID_TIPO_PRODOTTO;
                recTRiepAnnProd.ANNO_CAMPAGNA := recDatoAnnuale.ANNO_CAMPAGNA;
                recTRiepAnnProd.QUANTITA_FATTURATA := recDatoAnnuale.QUANTITA_FATTURATA;
                recTRiepAnnProd.ETTARI_ACCERTATI := recDatoAnnuale.ETTARI_ACCERTATI;
                recTRiepAnnProd.RESA_CALCOLATA := recDatoAnnuale.RESA_CALCOLATA;
                recTRiepAnnProd.AZIENDA_NEOCOSTITUITA := recDatoAnnuale.AZIENDA_NEOCOSTITUITA;
                recTRiepAnnProd.DATA_AGGIORNAMENTO := SYSDATE;
                recTRiepAnnProd.ID_UTENTE_AGGIORNAMENTO := knIdUtenteAggBatch;
                -- inserisco
                InsertTRiepAnnualeProdotto (recTRiepAnnProd);

                -- evado il record sulla tabella di appoggio
                recDatoAnnuale.ESITO_CARICAMENTO := 'OK';
                EvadiRiepProdottoAnno (recDatoAnnuale);

                -- incremento il contatore degli ok
                nNumOk := nNumOk + 1;

                COMMIT;

            EXCEPTION
                WHEN CONTROLLI_FORMALI THEN
                     -- evado il record delle tabella di appoggio con KO
                     EvadiRiepProdottoAnno (recDatoAnnuale);
                     -- incremento il contatore degli ko per controlli formali
                     nNumKoCtrl := nNumKoCtrl + 1;
                     COMMIT;
                WHEN PRODOTTO_NON_IDENT THEN
                     -- evado il record delle tabella di appoggio con KO
                     EvadiRiepProdottoAnno (recDatoAnnuale);
                     -- incremento il contatore degli ko per prodotto non identificato
                     nNumKoPr := nNumKoPr + 1;
                     COMMIT;
                WHEN AZIENDA_NON_IDENT THEN
                     -- evado il record delle tabella di appoggio con KO
                     EvadiRiepProdottoAnno (recDatoAnnuale);
                     -- incremento il contatore degli ko per azienda non identificata
                     nNumKoAz := nNumKoAz + 1;
                     COMMIT;
                WHEN OTHERS THEN
                     recDatoAnnuale.ESITO_CARICAMENTO := 'KO';
                     recDatoAnnuale.MOTIVO_SCARTO := 'Errore pl/sql non gestito : ' || SUBSTR(SQLERRM,1,250);
                     -- evado il record delle tabella di appoggio con KO
                     EvadiRiepProdottoAnno (recDatoAnnuale);
                     -- incremento il contatore degli ko per altri motivi
                     nNumKoAltro := nNumKoAltro + 1;
                     COMMIT;
            END;


        END LOOP;

        -- espongo un breve riepilogo dell'elaborazione
        Pck_SMRGAA_Log.LogInfo ('Fine elaborazione - Trattati : ' || nNumRec || ' records');
        Pck_SMRGAA_Log.LogInfo ('Di cui acquisiti : ' || nNumOk || ' records');
        Pck_SMRGAA_Log.LogInfo ('Di cui scartati per controlli formali  : ' || nNumKoCtrl || ' records');
        Pck_SMRGAA_Log.LogInfo ('Di cui scartati per mancata identificazione prodotto  : ' || nNumKoPr || ' records');
        Pck_SMRGAA_Log.LogInfo ('Di cui scartati per mancata identificazione azienda  : ' || nNumKoAz || ' records');
        Pck_SMRGAA_Log.LogInfo ('Di cui scartati per altri motivi  : ' || nNumKoAltro || ' records');
        PCK_SMRGAA_LOG.ValorizzaEsitoBatch;

        COMMIT;

        RETURN nRetCode;

    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            PCK_SMRGAA_LOG.LogSqlError ('CaricaDatiAnnuali');
            RETURN 1;
    END CaricaDatiAnnuali;






END Pck_Gestione_Polizza;

/
--------------------------------------------------------
--  DDL for Package Body PCK_GESTIONE_REGISTRO_PASCOLO
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_GESTIONE_REGISTRO_PASCOLO" AS
/*****************************************************************************
Package che espone tutte le function / stored procedure propedeutiche all'aggiornamento
dei dati relaviti ai registri pascolo presenti nell'anagrafe aziende agricole
******************************************************************************/


    /*********************************************************************
    Invia a SITI la data di ultima esecuzione del batch dalla quale
    cercare se ci sono state nuove fotointerpretazione su SITI o SITICONVOCA
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION Main RETURN NUMBER IS
        -- record di appoggio per il reperimento dei dati dell'applicazione corrente
        recDApplicazione    SMRGAA_D_APPLICAZIONI_BATCH%ROWTYPE;
        -- conterrà l'id esecuzione
        nIdEsecuzione       SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE;
        -- conterrà il codice di ritorno
        nRetCode            NUMBER(1):=0;
        -- record di appoggio per reperimento ultima esecuzione andata a buon fine
        recTLastEsecOk      SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE;
        -- file dei parametri
        fFileParametri      UTL_FILE.FILE_TYPE;
        -- riga di appoggio per scrittura file
        vRigaApp            VARCHAR2(100);
    BEGIN

        nRetCode := Pck_SMRGAA_Log.VerificaAttivazioneBatch(knIdApplBatchAggRegistro, recDApplicazione);

        IF nRetCode > 0 THEN
           -- Errore, Batch non attivo
           RETURN nRetCode;
        END IF;

        -- Inserimento in tabella dell'identificativo di esecuzione
        -- nIdEsecuzione restituito in output
        Pck_SMRGAA_Log.InsertTEsecuzione ( knIdApplBatchAggRegistro, nIdEsecuzione );
        COMMIT;

        -- Scrittura nel file nomefile_esecuzione del nIdEsecuzione
        Pck_SMRGAA_Log.ScriviFileEsecuzione (  recDApplicazione.nomefile_esecuzione,
                                               recDApplicazione.path_file_esecuzione,
                                               nIdEsecuzione );

        Pck_SMRGAA_Log.LeggiFileEsecuzione ( recDApplicazione.nomefile_esecuzione, recDApplicazione.path_file_esecuzione );

        Pck_SMRGAA_Log.SetLogLevel ( recDApplicazione.log_level );

        Pck_SMRGAA_Log.Init( knIdApplBatchAggRegistro, 'Main' );

        recTLastEsecOk := Pck_SMRGAA_Log.SelectTLastEsecuzioneOK (knIdApplBatchAggRegistro);
        -- se non la trovo
        IF recTLastEsecOk.ID_ESECUZIONE IS NULL THEN
           -- utilizzerò la SYSDATE (troncata)
           recTLastEsecOk.DT_FINE_ESECUZIONE := TRUNC(SYSDATE) - 1;
           PCK_SMRGAA_LOG.LogAnomalia ('Data ultima esecuzione andata a buon fine non trovata , imposto SYSDATE - 1 !!!');
        END IF;

        Pck_SMRGAA_Log.LogInfo ('Inizio Elaborazione');

        fFileParametri := UTL_FILE.FOPEN (recDApplicazione.path_file_esecuzione, SUBSTR(recDApplicazione.nomefile_esecuzione,1, INSTR(recDApplicazione.nomefile_esecuzione,'_')) || 'PARAM','W',100);
        vRigaApp := 'DT_LAST_EXEC=' || TO_CHAR(recTLastEsecOk.DT_FINE_ESECUZIONE,'DD/MM/YYYY-HH24:MI:SS');
        UTL_FILE.PUT_LINE(fFileParametri,vRigaApp);
        UTL_FILE.FCLOSE(fFileParametri);

        EXECUTE IMMEDIATE 'TRUNCATE TABLE SMRGAA_W_PARTICELLA_REGISTRO';

        Pck_SMRGAA_Log.LogInfo ('Accodata data ultima esecuzione andata a buon fine : ' || TO_CHAR(recTLastEsecOk.DT_FINE_ESECUZIONE,'DD/MM/YYYY HH24:MI:SS'));
        Pck_SMRGAA_Log.LogInfo ('Fine Elaborazione');

        COMMIT;

        RETURN nRetCode;

    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            PCK_SMRGAA_LOG.LogSqlError ('Main');
            RETURN 1;
    END Main;

    /*********************************************************************
    Scorre e particelle della tabella di appoggio SMRGAA_W_PARTICELLA_REGISTRO e cessa
    i record di DB_ESITO_PASCOLO_MAGRO attivi
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION Cessa_Particella_Registro RETURN NUMBER IS
        -- record di appoggio per il reperimento dei dati dell'applicazione corrente
        recDApplicazione    SMRGAA_D_APPLICAZIONI_BATCH%ROWTYPE;
        -- conterrà l'id esecuzione
        nIdEsecuzione       SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE;
        -- conterrà il codice di ritorno
        nRetCode            NUMBER(1):=0;
        -- contatore
        nRecAgg             INTEGER:=0;
        --altro contatore
        nRecTot             INTEGER:=0;

        CURSOR curParticellaRegistro IS
        SELECT *
          FROM SMRGAA_W_PARTICELLA_REGISTRO
         WHERE NVL(ELABORATO,'N') = 'N';

    BEGIN

        nRetCode := Pck_SMRGAA_Log.VerificaAttivazioneBatch(knIdApplBatchAggRegistro, recDApplicazione);

        IF nRetCode > 0 THEN
           -- Errore, Batch non attivo
           RETURN nRetCode;
        END IF;

        -- Inserimento in tabella dell'identificativo di esecuzione
        -- nIdEsecuzione restituito in output
        Pck_SMRGAA_Log.InsertTEsecuzione ( knIdApplBatchAggRegistro, nIdEsecuzione );
        COMMIT;


        Pck_SMRGAA_Log.LeggiFileEsecuzione ( recDApplicazione.nomefile_esecuzione, recDApplicazione.path_file_esecuzione );

        Pck_SMRGAA_Log.SetLogLevel ( recDApplicazione.log_level );

        Pck_SMRGAA_Log.Init( knIdApplBatchAggRegistro, 'Cessa_Particella_Registro' );

        Pck_SMRGAA_Log.LogInfo ('Inizio Elaborazione');

        FOR recParticellaRegistro IN curParticellaRegistro LOOP

            UPDATE DB_ESITO_PASCOLO_MAGRO
               SET DATA_FINE_VALIDITA = recParticellaRegistro.DATA_OPERAZIONE
             WHERE DATA_FINE_VALIDITA IS NULL
               AND ID_FONTE = recParticellaRegistro.ID_FONTE
               AND ID_PARTICELLA_CERTIFICATA IN
                (SELECT ID_PARTICELLA_CERTIFICATA
                   FROM DB_PARTICELLA_CERTIFICATA
                  WHERE COMUNE = recParticellaRegistro.ISTAT_COMUNE
                    AND NVL(SEZIONE,'#') = NVL(recParticellaRegistro.SEZIONE,'#')
                    AND FOGLIO = recParticellaRegistro.FOGLIO
                    AND PARTICELLA = recParticellaRegistro.PARTICELLA
                    AND NVL(SUBALTERNO,'#') = NVL(recParticellaRegistro.SUBALTERNO,'#'));

            nRecAgg := SQL%ROWCOUNT;

            UPDATE SMRGAA_W_PARTICELLA_REGISTRO
               SET ELABORATO = 'S'
             WHERE ID_PARTICELLA_REGISTRO = recParticellaRegistro.ID_PARTICELLA_REGISTRO;

            nRecTot := nRecTot + nRecAgg;

            COMMIT;

        END LOOP;

        Pck_SMRGAA_Log.LogInfo ('Fine Elaborazione - Cessate : ' || nRecTot || ' occorrenze su DB_ESITO_PASCOLO_MAGRO');
        Pck_SMRGAA_Log.ValorizzaEsitoBatch;

        COMMIT;

        RETURN nRetCode;

    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            PCK_SMRGAA_LOG.LogSqlError ('Cessa_Particella_Registro');
            RETURN 1;
    END Cessa_Particella_Registro;

END Pck_Gestione_Registro_Pascolo;

/
--------------------------------------------------------
--  DDL for Package Body PCK_GESTIONE_SOCI
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_GESTIONE_SOCI" AS
/*****************************************************************************
Package che espone tutte le function / stored procedure propedeutiche all'aggiornamento
dei Soci presenti in SMRGAA rispetto ai flussi di soci forniti dai procedimenti
******************************************************************************/

    /*********************************************************************
    Ricerca dato un'iniziale di USER oracle il package che da grant di EXECUTE
    Tipo: function
    input: pInitUser
    output: pUser, pPackage
    ritorno: vPackageName
    *********************************************************************/
    FUNCTION TrovaPackage (pInitUser IN VARCHAR2,
                           pUser     OUT VARCHAR2,
                           pPackage  OUT VARCHAR2) RETURN VARCHAR2 IS
        vPackageName VARCHAR2(60);
    BEGIN
        SELECT UTP.OWNER || '.' || AO.OBJECT_NAME AS PACKAGE_NAME,
               UTP.OWNER,
               AO.OBJECT_NAME
          INTO vPackageName,
               pUser,
               pPackage
          FROM USER_TAB_PRIVS UTP,
               ALL_OBJECTS AO
         WHERE UTP.OWNER LIKE pUser ||'%'
           AND UTP.PRIVILEGE = 'EXECUTE'
           AND UTP.TABLE_NAME = AO.OBJECT_NAME
           AND AO.OBJECT_TYPE = 'PACKAGE';

        RETURN vPackageName;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END TrovaPackage;

    /*********************************************************************
    Ricerca dato uno USER oracle ed un PACKAGE name il nome del cursore
    specificato nello spec del package
    Tipo: function
    input: pInitUser
    output: pUser, pPackage
    ritorno: vNomeCursore
    *********************************************************************/
    FUNCTION TrovaCursore (pUser    IN VARCHAR2,
                           pPackage IN VARCHAR2
                           ) RETURN VARCHAR2 IS
        vNomeCursore VARCHAR2(30);
    BEGIN

        SELECT TRIM(SUBSTR(TEXT, INSTR(UPPER(TEXT),'CURSOR') + 7, INSTR(TEXT,' ',INSTR(UPPER(TEXT),'CURSOR') + 7) - (INSTR(UPPER(TEXT),'CURSOR') + 7))) AS NOME_CURSORE
          INTO vNomeCursore
          FROM ALL_SOURCE
         WHERE OWNER = pUser
           AND TYPE = 'PACKAGE'
           AND NAME = pPackage
           AND UPPER(TEXT) LIKE '%CURSOR%';

        RETURN vNomeCursore;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END TrovaCursore;

    /*********************************************************************
    Dato un record di tipo DB_AZIENDA_COLLEGATA lo inserisce sull'omonima tabella
    Tipo: procedure
    input: pRecTAziendaCollegata
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTAziendaCollegata (pRecTAziendaCollegata IN DB_AZIENDA_COLLEGATA%ROWTYPE) IS
    BEGIN
        INSERT INTO DB_AZIENDA_COLLEGATA
            (
            ID_AZIENDA_COLLEGATA,
            ID_AZIENDA,
            ID_AZIENDA_ASSOCIATA,
            DATA_INGRESSO,
            DATA_USCITA,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA,
            DATA_AGGIORNAMENTO,
            ID_UTENTE_AGGIORNAMENTO,
            ID_SOGGETTO_ASSOCIATO
            )
        VALUES
            (
            pRecTAziendaCollegata.ID_AZIENDA_COLLEGATA,
            pRecTAziendaCollegata.ID_AZIENDA,
            pRecTAziendaCollegata.ID_AZIENDA_ASSOCIATA,
            pRecTAziendaCollegata.DATA_INGRESSO,
            pRecTAziendaCollegata.DATA_USCITA,
            pRecTAziendaCollegata.DATA_INIZIO_VALIDITA,
            pRecTAziendaCollegata.DATA_FINE_VALIDITA,
            pRecTAziendaCollegata.DATA_AGGIORNAMENTO,
            pRecTAziendaCollegata.ID_UTENTE_AGGIORNAMENTO,
            pRecTAziendaCollegata.ID_SOGGETTO_ASSOCIATO
            );

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertTAziendaCollegata - ID_AZIENDA_COLLEGATA = ' || pRecTAziendaCollegata.ID_AZIENDA_COLLEGATA);
             RAISE;
    END InsertTAziendaCollegata;

    /*********************************************************************
    Dato un CUAA ricerca l'ultima anagrafica attiva su DB_ANAGRAFICA_AZIENDA
    e ne restituisce il ROWTYPE
    Tipo: function
    input: pCuaa
    output: nessuno
    ritorno: DB_ANAGRAFICA_AZIENDA%ROWTYPE
    *********************************************************************/
    FUNCTION SelectTAziendaByCuaa (pCuaa IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE) RETURN DB_ANAGRAFICA_AZIENDA%ROWTYPE IS
        recTAnagrAzienda DB_ANAGRAFICA_AZIENDA%ROWTYPE;
    BEGIN
        SELECT *
          INTO recTAnagrAzienda
          FROM DB_ANAGRAFICA_AZIENDA
         WHERE CUAA = pCuaa
           AND DATA_FINE_VALIDITA IS NULL
           AND DATA_CESSAZIONE IS NULL;

        RETURN recTAnagrAzienda;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             recTAnagrAzienda.ID_ANAGRAFICA_AZIENDA :=0;
             recTAnagrAzienda.CUAA := pCuaa;
             RETURN recTAnagrAzienda;
        WHEN TOO_MANY_ROWS THEN
             recTAnagrAzienda.ID_ANAGRAFICA_AZIENDA :=-1;
             recTAnagrAzienda.CUAA := pCuaa;
             RETURN recTAnagrAzienda;
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('SelectTAziendaByCuaa - pCuaa  = ' || pCuaa);
             RAISE;
    END SelectTAziendaByCuaa;

    /*********************************************************************
    Dato un ID_AZIENDA ricerca l'ultima anagrafica attiva su DB_ANAGRAFICA_AZIENDA
    e ne restituisce il ROWTYPE
    Tipo: function
    input: pIdAzienda
    output: nessuno
    ritorno: DB_ANAGRAFICA_AZIENDA%ROWTYPE
    *********************************************************************/
    FUNCTION SelectTAziendaById (pIdAzienda IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE) RETURN DB_ANAGRAFICA_AZIENDA%ROWTYPE IS
        recTAnagrAzienda DB_ANAGRAFICA_AZIENDA%ROWTYPE;
    BEGIN
        SELECT *
          INTO recTAnagrAzienda
          FROM DB_ANAGRAFICA_AZIENDA
         WHERE ID_AZIENDA = pIdAzienda
           AND DATA_FINE_VALIDITA IS NULL
           AND DATA_CESSAZIONE IS NULL;

        RETURN recTAnagrAzienda;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             recTAnagrAzienda.ID_ANAGRAFICA_AZIENDA :=0;
             recTAnagrAzienda.ID_AZIENDA := pIdAzienda;
             RETURN recTAnagrAzienda;
        WHEN TOO_MANY_ROWS THEN
             recTAnagrAzienda.ID_ANAGRAFICA_AZIENDA :=-1;
             recTAnagrAzienda.ID_AZIENDA := pIdAzienda;
             RETURN recTAnagrAzienda;
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('SelectTAziendaById - pIdAzienda  = ' || pIdAzienda);
             RAISE;
    END SelectTAziendaById;

    /*********************************************************************
    Ricerca l'associazione AZIENDA ENTE, AZIENDA SOCIA sulla tabella
    DB_AZIENDA_COLLEGATA sia valida che cessata
    Tipo: function
    input: pIdAziendaEnte, pIdAziendaSocia
    output: nessuno
    ritorno: DB_AZIENDA_COLLEGATA%ROWTYPE
    *********************************************************************/
    FUNCTION SelectTAziendaCollegataById (pIdAziendaEnte    IN DB_AZIENDA_COLLEGATA.ID_AZIENDA%TYPE,
                                          pIdAziendaSocia   IN DB_AZIENDA_COLLEGATA.ID_AZIENDA_ASSOCIATA%TYPE
                                          ) RETURN DB_AZIENDA_COLLEGATA%ROWTYPE IS
        recTAziendaCollegata DB_AZIENDA_COLLEGATA%ROWTYPE;
    BEGIN
        SELECT *
          INTO recTAziendaCollegata
          FROM DB_AZIENDA_COLLEGATA
         WHERE ID_AZIENDA = pIdAziendaEnte
           AND ID_AZIENDA_ASSOCIATA = pIdAziendaSocia
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recTAziendaCollegata;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             BEGIN

                SELECT *
                  INTO recTAziendaCollegata
                  FROM DB_AZIENDA_COLLEGATA
                 WHERE ID_AZIENDA = pIdAziendaEnte
                   AND ID_AZIENDA_ASSOCIATA = pIdAziendaSocia
                   AND DATA_INIZIO_VALIDITA = (SELECT MAX(DATA_INIZIO_VALIDITA)
                                                 FROM DB_AZIENDA_COLLEGATA
                                                WHERE ID_AZIENDA = pIdAziendaEnte
                                                  AND ID_AZIENDA_ASSOCIATA = pIdAziendaSocia);

                RETURN recTAziendaCollegata;

             EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     RETURN NULL;
                WHEN TOO_MANY_ROWS THEN
                     RETURN NULL;
             END;
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('SelectTAziendaCollegataById - pIdAziendaEnte/pIdAziendaSocia  = ' || pIdAziendaEnte || '/' ||pIdAziendaSocia);
             RAISE;
    END SelectTAziendaCollegataById;

    /*********************************************************************
    Effettua l'impostazione della DATA_FINE_VALIDITA per l'ID_AZIENDA_COLLEGATA
    dato in input
    Tipo: Procedure
    input: pIdAziendaCollegata, pDataFineVal
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ConcludiAziendaCollegata (pIdAziendaCollegata IN DB_AZIENDA_COLLEGATA.ID_AZIENDA_COLLEGATA%TYPE,
                                        pDataFineVal        IN DB_AZIENDA_COLLEGATA.DATA_FINE_VALIDITA%TYPE) IS
    BEGIN
        UPDATE DB_AZIENDA_COLLEGATA
           SET DATA_FINE_VALIDITA = pDataFineVal
         WHERE ID_AZIENDA_COLLEGATA = pIdAziendaCollegata;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('ConcludiAziendaCollegata - pIdAziendaCollegata/pDataFineVal  = ' || pIdAziendaCollegata || '/' || pDataFineVal);
             RAISE;
    END ConcludiAziendaCollegata;

    /*********************************************************************
    Inserisce od aggiorna l'associazione azienda ente / azienda socia
    su DB_AZIENDA_COLLEGATA con le data ingresso ed uscita fornite in input
    Tipo: Procedure
    input: pIdAziendaEnte, pIdAziendaSocia, pDataIngresso, pDataUscita
    output: bAggiornato
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE AggiungiOdAggiornaSocio (pIdAziendaEnte   IN DB_AZIENDA_COLLEGATA.ID_AZIENDA%TYPE,
                                       pIdAziendaSocia  IN DB_AZIENDA_COLLEGATA.ID_AZIENDA_ASSOCIATA%TYPE,
                                       pDataIngresso    IN DB_AZIENDA_COLLEGATA.DATA_INGRESSO%TYPE,
                                       pDataUscita      IN DB_AZIENDA_COLLEGATA.DATA_USCITA%TYPE,
                                       bAggiornato     OUT BOOLEAN
                                       ) IS
        recTAziendaCollegata DB_AZIENDA_COLLEGATA%ROWTYPE;

    BEGIN
        bAggiornato := FALSE;
        recTAziendaCollegata := SelectTAziendaCollegataById(pIdAziendaEnte,pIdAziendaSocia);

        IF recTAziendaCollegata.ID_AZIENDA_COLLEGATA IS NULL THEN
           bAggiornato := TRUE;
        ELSE
            IF recTAziendaCollegata.DATA_INGRESSO <> pDataIngresso OR
               NVL(recTAziendaCollegata.DATA_USCITA, TRUNC(SYSDATE)) <> NVL(pDataUscita, TRUNC(SYSDATE)) THEN
               IF recTAziendaCollegata.DATA_FINE_VALIDITA IS NULL THEN
                  ConcludiAziendaCollegata (recTAziendaCollegata.ID_AZIENDA_COLLEGATA, SYSDATE);
               END IF;
               bAggiornato := TRUE;
            END IF;
        END IF;

        IF bAggiornato THEN

           SELECT SEQ_DB_AZIENDA_COLLEGATA.nextval
             INTO recTAziendaCollegata.ID_AZIENDA_COLLEGATA
             FROM DUAL;
           recTAziendaCollegata.ID_AZIENDA := pIdAziendaEnte;
           recTAziendaCollegata.ID_AZIENDA_ASSOCIATA := pIdAziendaSocia;
           recTAziendaCollegata.DATA_INGRESSO := pDataIngresso;
           recTAziendaCollegata.DATA_USCITA := pDataUscita;
           recTAziendaCollegata.DATA_INIZIO_VALIDITA := SYSDATE;
           IF pDataUscita IS NOT NULL THEN
              recTAziendaCollegata.DATA_FINE_VALIDITA := SYSDATE;
           ELSE
              recTAziendaCollegata.DATA_FINE_VALIDITA := NULL;
           END IF;
           recTAziendaCollegata.DATA_AGGIORNAMENTO := SYSDATE;
           recTAziendaCollegata.ID_UTENTE_AGGIORNAMENTO := knIdUtenteAggBatch;
           recTAziendaCollegata.ID_SOGGETTO_ASSOCIATO := NULL;
           InsertTAziendaCollegata (recTAziendaCollegata);

        END IF;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('AggiungiOdAggiornaSocio - pIdAziendaEnte/pIdAziendaSocia  = ' || pIdAziendaEnte || '/' || pIdAziendaSocia );
             RAISE;
    END AggiungiOdAggiornaSocio;

    /*********************************************************************
    Effettua l'aggiornamento / inserimento dei soci GNPS su SMRGAA
    Tipo: Procedure
    input: pDataOffset
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE GestioneSociGNPS (pDataOffset IN DATE) IS
        -- record di appoggio che conterrà l'azienda ente
        recTAziendaEnte     DB_ANAGRAFICA_AZIENDA%ROWTYPE;
        -- record di appoggio che conterrà l'azienda socia
        recTAziendaSocio    DB_ANAGRAFICA_AZIENDA%ROWTYPE;
        -- Messaggio di anomalia
        vMessaggio          VARCHAR2(400);
        -- contatori
        nSociGNPS           INTEGER:=0;
        nSociGNPSAcquisiti  INTEGER:=0;
        nSociGNPSGiaOk      INTEGER:=0;
        nSociGNPSScartati   INTEGER:=0;
        -- boleana di appoggio che mi dice se l'associazione è stata aggiornata / inserita
        bAggiornato         BOOLEAN:=FALSE;

    BEGIN
        Pck_SMRGAA_Log.LogInfo ('Acquisizione variazioni Soci generate da GNPS dal : ' || TO_CHAR(pDataOffset,'DD/MM/YYYY HH24:MI:SS'));
        -- scorro il cursore dei soci GNPS (che è ordinato per AZIENDA ENTE, AZIENDA SOCIA e DATA_INGRESSO)
        FOR recAziendaEnte IN PACK_SRV_ENTI.CUR_ENTI_CONSULENZA (pDataOffset) LOOP
            nSociGNPS := nSociGNPS + 1;
            -- se l'azienda ENTE è diversa da quella elaborata precedentemente
            IF recAziendaEnte.CUAA <> NVL(recTAziendaEnte.CUAA,'N.V') THEN
               -- la ricerco in ANAGRAFE
               recTAziendaEnte := SelectTAziendaByCuaa (recAziendaEnte.CUAA);
            END IF;
            -- se l'azienda SOCIA è diversa da quella elaborata precedentemente
            IF recAziendaEnte.EXT_ID_AZIENDA <> NVL(recTAziendaSocio.ID_AZIENDA,0) THEN
               recTAziendaSocio := SelectTAziendaById (recAziendaEnte.EXT_ID_AZIENDA);
            END IF;
            -- se sono riuscito ad identificare entrambe le aziende su SMRGAA
            IF recTAziendaEnte.ID_ANAGRAFICA_AZIENDA > 0 AND
               recTAziendaSocio.ID_ANAGRAFICA_AZIENDA > 0 THEN
               -- allora posso provvedere ad aggiornare od ad inserire l'associazione
               AggiungiOdAggiornaSocio (recTAziendaEnte.ID_AZIENDA,
                                        recTAziendaSocio.ID_AZIENDA,
                                        recAziendaEnte.DATA_INGRESSO,
                                        recAziendaEnte.DATA_USCITA,
                                        bAggiornato);
               -- se aggiornato è = TRUE vuol dire che ho operato un insert od un update
               IF bAggiornato THEN
                  nSociGNPSAcquisiti := nSociGNPSAcquisiti + 1;
               ELSE
                  -- altrimenti che l'associazione era già uguale a quella di GNPS
                  nSociGNPSGiaOk := nSociGNPSGiaOk + 1;
               END IF;
            ELSE
               -- se non sono riuscito ad individuare l'AZIENDA ENTE o l'AZIENDA SOCIA
               -- od entrambe in anagrafe do apposita segnalazione
               nSociGNPSScartati := nSociGNPSScartati + 1;
               vMessaggio := 'Record scartato :';
               IF recTAziendaEnte.ID_ANAGRAFICA_AZIENDA = 0 THEN
                   vMessaggio := vMessaggio || ' Azienda ENTE con CUAA : ' || recAziendaEnte.CUAA || ' non presente / attiva in anagrafica';
               ELSIF recTAziendaEnte.ID_ANAGRAFICA_AZIENDA = -1 THEN
                   vMessaggio := vMessaggio || ' Azienda ENTE con CUAA : ' || recAziendaEnte.CUAA || ' non identificabile univocamente in anagrafica';
               END IF;

               IF recTAziendaSocio.ID_ANAGRAFICA_AZIENDA = 0 THEN
                  vMessaggio := vMessaggio || ' Azienda SOCIA con ID : ' || recAziendaEnte.EXT_ID_AZIENDA || ' non presente / attiva in anagrafica';
               ELSIF recTAziendaSocio.ID_ANAGRAFICA_AZIENDA = -1 THEN
                  vMessaggio := vMessaggio || ' Azienda SOCIA con ID : ' || recAziendaEnte.EXT_ID_AZIENDA || ' non identificabile univocamente in anagrafica';
               END IF;

               Pck_SMRGAA_Log.LogAnomalia (vMessaggio);

            END IF;

            COMMIT;

        END LOOP;
        -- Terminata l'elaborazione do un prospetto sull'aggiornamento dei soci GNPS
        Pck_SMRGAA_Log.LogInfo ('Fine Acquisizione Soci GNPS - Trattate : ' || nSociGNPS || ' associazioni GNPS');
        Pck_SMRGAA_Log.LogInfo ('Di cui : ' || nSociGNPSScartati || ' scartate per non presenza azienda ENTE o SOCIA in anagrafe');
        Pck_SMRGAA_Log.LogInfo ('Di cui : ' || nSociGNPSGiaOk || ' già presenti in anagrafe');
        Pck_SMRGAA_Log.LogInfo ('Di cui : ' || nSociGNPSAcquisiti || ' acquisite correttamente');

        COMMIT;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('GestioneSociGNPS - pDataOffset = ' || pDataOffset);
             RAISE;
    END GestioneSociGNPS;

    /*********************************************************************
    Effettua l'aggiornamento / inserimento dei soci GNPS su SMRGAA
    Tipo: Procedure
    input: pDataOffset
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE GestioneSociAbio (pDataOffset IN DATE) IS
        -- record di appoggio che conterrà l'azienda ente
        recTAziendaEnte     DB_ANAGRAFICA_AZIENDA%ROWTYPE;
        -- record di appoggio che conterrà l'azienda socia
        recTAziendaSocio    DB_ANAGRAFICA_AZIENDA%ROWTYPE;
        -- Messaggio di anomalia
        vMessaggio          VARCHAR2(400);
        -- contatori
        nSociABIO           INTEGER:=0;
        nSociABIOAcquisiti  INTEGER:=0;
        nSociABIOGiaOk      INTEGER:=0;
        nSociABIOScartati   INTEGER:=0;
        -- boleana di appoggio che mi dice se l'associazione è stata aggiornata / inserita
        bAggiornato         BOOLEAN:=FALSE;

    BEGIN
        Pck_SMRGAA_Log.LogInfo ('Acquisizione variazioni Soci generate da ABIO dal : ' || TO_CHAR(pDataOffset,'DD/MM/YYYY HH24:MI:SS'));
        -- scorro il cursore dei soci ABIO (che è ordinato per CUAA ODC, ID_AZIENDA SOCIA, DATA_INGRESSO e DATA_USCITA)
        FOR recSociOdc IN PCK_ELENCA_SOCI.curSociOdc (pDataOffset) LOOP
            nSociABIO := nSociABIO + 1;
            -- se l'azienda ODC è diversa da quella elaborata precedentemente
            IF recSociOdc.CUAA_ODC <> NVL(recTAziendaEnte.CUAA,'N.V') THEN
               -- la ricerco in ANAGRAFE
               recTAziendaEnte := SelectTAziendaByCuaa (recSociOdc.CUAA_ODC);
            END IF;
            -- se l'azienda SOCIA è diversa da quella elaborata precedentemente
            IF recSociOdc.EXT_ID_AZIENDA <> NVL(recTAziendaSocio.ID_AZIENDA,0) THEN
               recTAziendaSocio := SelectTAziendaById (recSociOdc.EXT_ID_AZIENDA);
            END IF;
            -- se sono riuscito ad identificare entrambe le aziende su SMRGAA
            IF recTAziendaEnte.ID_ANAGRAFICA_AZIENDA > 0 AND
               recTAziendaSocio.ID_ANAGRAFICA_AZIENDA > 0 THEN
               -- allora posso provvedere ad aggiornare od ad inserire l'associazione
               AggiungiOdAggiornaSocio (recTAziendaEnte.ID_AZIENDA,
                                        recTAziendaSocio.ID_AZIENDA,
                                        recSociOdc.DATA_INGRESSO,
                                        recSociOdc.DATA_USCITA,
                                        bAggiornato);
               -- se aggiornato è = TRUE vuol dire che ho operato un insert od un update
               IF bAggiornato THEN
                  nSociABIOAcquisiti := nSociABIOAcquisiti + 1;
               ELSE
                  -- altrimenti che l'associazione era già uguale a quella di GNPS
                  nSociABIOGiaOk := nSociABIOGiaOk + 1;
               END IF;
            ELSE
               -- se non sono riuscito ad individuare l'AZIENDA ENTE o l'AZIENDA SOCIA
               -- od entrambe in anagrafe do apposita segnalazione
               nSociABIOScartati := nSociABIOScartati + 1;
               vMessaggio := 'Record scartato :';
               IF recTAziendaEnte.ID_ANAGRAFICA_AZIENDA = 0 THEN
                  vMessaggio := vMessaggio || ' Azienda ODC con CUAA : ' || recSociOdc.CUAA_ODC || ' non presente / attiva in anagrafica';
               ELSIF recTAziendaEnte.ID_ANAGRAFICA_AZIENDA = -1 THEN
                  vMessaggio := vMessaggio || ' Azienda ODC con CUAA : ' || recSociOdc.CUAA_ODC || ' non identificabile univocamente in anagrafica';
               END IF;

               IF recTAziendaSocio.ID_ANAGRAFICA_AZIENDA = 0 THEN
                  vMessaggio := vMessaggio || ' Azienda SOCIA con ID : ' || recSociOdc.EXT_ID_AZIENDA || ' non presente / attiva in anagrafica';
               ELSIF recTAziendaSocio.ID_ANAGRAFICA_AZIENDA = -1 THEN
                  vMessaggio := vMessaggio || ' Azienda SOCIA con ID : ' || recSociOdc.EXT_ID_AZIENDA || ' non identificabile univocamente in anagrafica';
               END IF;

               Pck_SMRGAA_Log.LogAnomalia (vMessaggio);

            END IF;

            COMMIT;

        END LOOP;
        -- Terminata l'elaborazione do un prospetto sull'aggiornamento dei soci ABIO
        Pck_SMRGAA_Log.LogInfo ('Fine Acquisizione Soci ABIO - Trattate : ' || nSociABIO || ' associazioni ABIO');
        Pck_SMRGAA_Log.LogInfo ('Di cui : ' || nSociABIOScartati || ' scartate per non presenza azienda ODC o SOCIA in anagrafe');
        Pck_SMRGAA_Log.LogInfo ('Di cui : ' || nSociABIOGiaOk || ' già presenti in anagrafe');
        Pck_SMRGAA_Log.LogInfo ('Di cui : ' || nSociABIOAcquisiti || ' acquisite correttamente');

        COMMIT;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('GestioneSociAbio - pDataOffset = ' || pDataOffset);
             RAISE;
    END GestioneSociAbio;

    /*********************************************************************
    Effettua l'aggiornamento dei soci in anagrafe pescandoli dai flussi presenti
    sui procedimenti
    Tipo: function
    input: nessuno
    output: nessuno
    ritorno: NUMBER (0 = KO , 1 = KO , 2 = Non attivato, 3 = dipendenze non verificate)
    *********************************************************************/
    FUNCTION Aggiorna_Soci RETURN NUMBER IS

        -- record di appoggio per il reperimento dei dati dell'applicazione corrente
        recDApplicazione    SMRGAA_D_APPLICAZIONI_BATCH%ROWTYPE;
        -- conterrà l'id esecuzione
        nIdEsecuzione       SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE;
        -- conterrà il codice di ritorno
        nRetCode            NUMBER(1):=0;
        -- record che contiene i dati dell'ultima esecuzione del batch andata a buon fine
        recTLastEsecOk      SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE;
        -- data di appoggio per estrazione soci
        dOffset             DATE;
        -- vettore dei parametri
        vetParametri        Pck_SMRGAA_Log.TypVetParametriApplicazione;

    BEGIN

        nRetCode := Pck_SMRGAA_Log.VerificaAttivazioneBatch( knIdApplBatchAggiornaSoci ,recDApplicazione);

        IF nRetCode > 0 THEN
             -- Errore, Batch non attivo
            RETURN nRetCode;
        END IF;

         -- Inserimento in tabella dell'identificativo di esecuzione
         -- nIdEsecuzione restituito in output
        Pck_SMRGAA_Log.InsertTEsecuzione ( knIdApplBatchAggiornaSoci, nIdEsecuzione );
        COMMIT;

         -- Scrittura nel file nomefile_esecuzione del nIdEsecuzione
        Pck_SMRGAA_Log.ScriviFileEsecuzione (  recDApplicazione.nomefile_esecuzione,
                                               recDApplicazione.path_file_esecuzione,
                                               nIdEsecuzione );

        Pck_SMRGAA_Log.LeggiFileEsecuzione ( recDApplicazione.nomefile_esecuzione, recDApplicazione.path_file_esecuzione );

        Pck_SMRGAA_Log.SetLogLevel ( recDApplicazione.log_level );

        Pck_SMRGAA_Log.Init( knIdApplBatchAggiornaSoci, 'Aggiorna_Soci' );

        Pck_SMRGAA_Log.LogInfo ('Inizio Elaborazione');

        recTLastEsecOk := Pck_SMRGAA_Log.SelectTLastEsecuzioneOK (knIdApplBatchAggiornaSoci);

        vetParametri := Pck_SMRGAA_Log.CaricaParametriApplicazione(knIdApplBatchAggiornaSoci);

        /* INIZIO - ACQUISIZIONE SOCI DA GNPS */
        BEGIN
            dOffset := vetParametri(kvParDataOffsetGNPS).VAL_DATE;
            Pck_SMRGAA_Log.LogInfo ('Elaborazione soci GNPS con parametro data offset : ' || TO_CHAR(dOffset,'DD/MM/YYYY HH24:MI:SS'));
            Pck_SMRGAA_Log.EliminaParametroApplicazione(knIdApplBatchAggiornaSoci,kvParDataOffsetGNPS);
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 dOffset := recTLastEsecOk.DT_INIZIO_ESECUZIONE;
                 Pck_SMRGAA_Log.LogInfo ('Elaborazione soci GNPS dall''ultima esecuzione : ' || TO_CHAR(dOffset,'DD/MM/YYYY HH24:MI:SS'));
        END;

        GestioneSociGNPS (dOffset);
        /* FINE - ACQUISIZIONE SOCI DA GNPS */

        /* INIZIO - ACQUISIZIONE SOCI DA ABIO */
        BEGIN
            dOffset := vetParametri(kvParDataOffsetABIO).VAL_DATE;
            Pck_SMRGAA_Log.LogInfo ('Elaborazione soci ABIO con parametro data offset : ' || TO_CHAR(dOffset,'DD/MM/YYYY HH24:MI:SS'));
            Pck_SMRGAA_Log.EliminaParametroApplicazione(knIdApplBatchAggiornaSoci,kvParDataOffsetABIO);
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 dOffset := recTLastEsecOk.DT_INIZIO_ESECUZIONE;
                 Pck_SMRGAA_Log.LogInfo ('Elaborazione soci ABIO dall''ultima esecuzione : ' || TO_CHAR(dOffset,'DD/MM/YYYY HH24:MI:SS'));
        END;

        GestioneSociAbio (dOffset);
        /* FINE - ACQUISIZIONE SOCI DA ABIO */

        Pck_SMRGAA_Log.LogInfo ('Fine Elaborazione');

        PCK_SMRGAA_LOG.ValorizzaEsitoBatch;

        COMMIT;

        RETURN nRetCode;

    EXCEPTION
        WHEN OTHERS THEN
            ROLLBACK;
            PCK_SMRGAA_LOG.LogSqlError ('Aggiorna_Soci');
            RETURN 1;
    END Aggiorna_Soci;

END Pck_Gestione_Soci;

/
--------------------------------------------------------
--  DDL for Package Body PCK_SCARICA_ANAGRAFICA_AZIENDA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_SCARICA_ANAGRAFICA_AZIENDA" IS

    -- Variabili globali private
    passo_elaborazione VARCHAR2(2000);
    tipo_scarico DB_SCARICO_PARAMETRI.valore_parametro%TYPE;
    tipo_dati DB_SCARICO_PARAMETRI.valore_parametro%TYPE;
    percorso_file VARCHAR2(200);
    prefisso_nome_file VARCHAR2(50);
    numero_aziende NUMBER := 0;


    FUNCTION FileOpen (pFilePath VARCHAR2, pFileName VARCHAR2, pOpenMode VARCHAR2 := 'w', pLength BINARY_INTEGER)
        RETURN UTL_FILE.FILE_TYPE
       IS
    BEGIN
         RETURN UTL_FILE.FOPEN(pFilePath, pFileName, pOpenMode ,pLength);
    EXCEPTION
    WHEN UTL_FILE.INVALID_PATH THEN DBMS_OUTPUT.PUT_LINE('FileOpen: <<INVALID_PATH>>'); RAISE;
    WHEN UTL_FILE.INVALID_MODE THEN DBMS_OUTPUT.PUT_LINE('FileOpen: <<INVALID_MODE>>'); RAISE;
    WHEN UTL_FILE.INVALID_OPERATION THEN DBMS_OUTPUT.PUT_LINE('FileOpen: <<INVALID_OPERATION>>');
        IF UPPER(pOpenMode) = 'A' THEN RETURN UTL_FILE.FOPEN(pFilePath, pFileName, 'W');
        ELSE RAISE;
        END IF;
    END FileOpen;

    PROCEDURE FileRead (PFILE IN UTL_FILE.FILE_TYPE, pStr OUT VARCHAR2) IS
    BEGIN
        UTL_FILE.GET_LINE(PFILE, pstr);
    EXCEPTION
    WHEN UTL_FILE.INVALID_FILEHANDLE THEN DBMS_OUTPUT.PUT_LINE('FileRead: <<INVALID_FILEHANDLE>>'); RAISE;
    WHEN UTL_FILE.INVALID_OPERATION THEN DBMS_OUTPUT.PUT_LINE('FileRead: <<INVALID_OPERATION>>'); RAISE;
    WHEN UTL_FILE.READ_ERROR THEN DBMS_OUTPUT.PUT_LINE('FileRead: <<READ_ERROR>>'); RAISE;
    END FileRead;

    PROCEDURE FileClose(PFILE IN OUT UTL_FILE.FILE_TYPE) IS
    BEGIN
        UTL_FILE.FCLOSE(PFILE);
    EXCEPTION
    WHEN UTL_FILE.INVALID_FILEHANDLE THEN DBMS_OUTPUT.PUT_LINE('FileClose: <<INVALID_FILEHANDLE>>'); RAISE;
    WHEN UTL_FILE.WRITE_ERROR THEN DBMS_OUTPUT.PUT_LINE('FileClose: <<WRITE_ERROR>>'); RAISE;
    END FileClose;

    PROCEDURE FileWrite(PFILE IN OUT UTL_FILE.FILE_TYPE, pStr IN VARCHAR2) IS
    BEGIN
        UTL_FILE.PUT_LINE(PFILE, pstr);
    EXCEPTION
    WHEN UTL_FILE.INVALID_FILEHANDLE THEN DBMS_OUTPUT.PUT_LINE('FileWrite: <<INVALID_FILEHANDLE>>'); RAISE;
    WHEN UTL_FILE.INVALID_OPERATION THEN DBMS_OUTPUT.PUT_LINE('FileWrite: <<INVALID_OPERATION>>'); RAISE;
    WHEN UTL_FILE.WRITE_ERROR THEN DBMS_OUTPUT.PUT_LINE('FileWrite: <<WRITE_ERROR>>'); RAISE;
    END FileWrite;






    FUNCTION fnc_scarica_decodifica RETURN VARCHAR2 IS
        fFile UTL_FILE.FILE_TYPE;
        stringa_dati VARCHAR2(2000);
    BEGIN

        passo_elaborazione := 'FNC.SCAR.DECOD DB_TIPO_ATTIVITA_OTE';
        fFile := fileopen(percorso_file,
                          prefisso_nome_file||'TIPO_ATTIVITA_OTE-'||TO_CHAR(SYSDATE,'yyyymmddhh24miss')||'.TXT',
                          'w', 5000);
        FOR rec IN (SELECT codice, descrizione FROM DB_TIPO_ATTIVITA_OTE)
        LOOP
            stringa_dati := rec.codice||'#@#'||rec.descrizione||'#@#';
            FileWrite(fFile, stringa_dati);
        END LOOP;
        FileClose(fFile);


        passo_elaborazione := 'FNC.SCAR.DECOD DB_TIPO_CESSAZIONE';
        fFile := fileopen(percorso_file,
                          prefisso_nome_file||'TIPO_CESSAZIONE-'||TO_CHAR(SYSDATE,'yyyymmddhh24miss')||'.TXT',
                          'w', 5000);
        FOR rec IN (SELECT id_cessazione, descrizione, data_inizio_validita FROM DB_TIPO_CESSAZIONE)
        LOOP
            stringa_dati := TO_CHAR(rec.id_cessazione)||'#@#'||
                            rec.descrizione||'#@#'||
                            TO_CHAR(rec.data_inizio_validita,'dd/mm/yyyy')||'#@#';
            FileWrite(fFile, stringa_dati);
        END LOOP;
        FileClose(fFile);

        /*
        NON SCARICARE, deciso il 18/07/2008
        passo_elaborazione := 'FNC.SCAR.DECOD DB_TIPO_FORMA_CONDUZIONE';
        fFile := fileopen(percorso_file,
                          prefisso_nome_file||'TIPO_FORMA_CONDUZIONE-'||to_char(sysdate,'yyyymmddhh24miss')||'.TXT',
                          'w', 5000);
        for rec in (select codice, forma, descrizione from db_tipo_forma_conduzione)
        loop
            stringa_dati := rec.codice||'#@#'||rec.forma||'#@#'||rec.descrizione||'#@#';
            FileWrite(fFile, stringa_dati);
        end loop;
        FileClose(fFile);
        */


        passo_elaborazione := 'FNC.SCAR.DECOD DB_TIPO_FORMA_GIURIDICA';
        fFile := fileopen(percorso_file,
                          prefisso_nome_file||'TIPO_FORMA_GIURIDICA-'||TO_CHAR(SYSDATE,'yyyymmddhh24miss')||'.TXT',
                          'w', 5000);
        FOR rec IN (SELECT id_forma_giuridica, descrizione FROM DB_TIPO_FORMA_GIURIDICA)
        LOOP
            stringa_dati := TO_CHAR(rec.id_forma_giuridica)||'#@#'||rec.descrizione||'#@#';
            FileWrite(fFile, stringa_dati);
        END LOOP;
        FileClose(fFile);

        /*
        NON SCARICARE, deciso il 18/07/2008
        passo_elaborazione := 'FNC.SCAR.DECOD DB_TIPO_INDIRIZZO_STUDIO';
        fFile := fileopen(percorso_file,
                          prefisso_nome_file||'TIPO_INDIRIZZO_STUDIO-'||to_char(sysdate,'yyyymmddhh24miss')||'.TXT',
                          'w', 5000);
        for rec in (select id_indirizzo_studio, id_titolo_studio, descrizione from db_tipo_indirizzo_studio)
        loop
            stringa_dati := to_char(rec.id_indirizzo_studio)||'#@#'||rec.id_titolo_studio||'#@#'||rec.descrizione||'#@#';
            FileWrite(fFile, stringa_dati);
        end loop;
        FileClose(fFile);
        */


        passo_elaborazione := 'FNC.SCAR.DECOD DB_TIPO_MACRO_USO';
        fFile := fileopen(percorso_file,
                          prefisso_nome_file||'TIPO_MACRO_USO-'||TO_CHAR(SYSDATE,'yyyymmddhh24miss')||'.TXT',
                          'w', 5000);
        FOR rec IN (SELECT codice, descrizione FROM DB_TIPO_MACRO_USO)
        LOOP
            stringa_dati := rec.codice||'#@#'||rec.descrizione||'#@#';
            FileWrite(fFile, stringa_dati);
        END LOOP;
        FileClose(fFile);


        passo_elaborazione := 'FNC.SCAR.DECOD DB_TIPO_RUOLO';
        fFile := fileopen(percorso_file,
                          prefisso_nome_file||'TIPO_RUOLO-'||TO_CHAR(SYSDATE,'yyyymmddhh24miss')||'.TXT',
                          'w', 5000);
        FOR rec IN (SELECT id_ruolo, descrizione, carica_rl FROM DB_TIPO_RUOLO)
        LOOP
            stringa_dati := TO_CHAR(rec.id_ruolo)||'#@#'||rec.descrizione||'#@#'||rec.carica_rl||'#@#';
            FileWrite(fFile, stringa_dati);
        END LOOP;
        FileClose(fFile);


        passo_elaborazione := 'FNC.SCAR.DECOD DB_TIPO_SPECIE_ANIMALE';
        fFile := fileopen(percorso_file,
                          prefisso_nome_file||'TIPO_SPECIE_ANIMALE-'||TO_CHAR(SYSDATE,'yyyymmddhh24miss')||'.TXT',
                          'w', 5000);
        FOR rec IN (SELECT id_specie_animale, descrizione, unita_misura FROM DB_TIPO_SPECIE_ANIMALE)
        LOOP
            stringa_dati := TO_CHAR(rec.id_specie_animale)||'#@#'||rec.descrizione||'#@#'||rec.unita_misura||'#@#';
            FileWrite(fFile, stringa_dati);
        END LOOP;
        FileClose(fFile);


        passo_elaborazione := 'FNC.SCAR.DECOD DB_TIPO_TIPOLOGIA_AZIENDA';
        fFile := fileopen(percorso_file,
                          prefisso_nome_file||'TIPO_TIPOLOGIA_AZIEND-'||TO_CHAR(SYSDATE,'yyyymmddhh24miss')||'.TXT',
                          'w', 5000);
        FOR rec IN (SELECT id_tipologia_azienda, descrizione FROM DB_TIPO_TIPOLOGIA_AZIENDA)
        LOOP
            stringa_dati := TO_CHAR(rec.id_tipologia_azienda)||'#@#'||rec.descrizione||'#@#';
            FileWrite(fFile, stringa_dati);
        END LOOP;
        FileClose(fFile);

        /*
        NON SCARICARE, deciso il 18/07/2008
        passo_elaborazione := 'FNC.SCAR.DECOD DB_TIPO_TITOLO_STUDIO';
        fFile := fileopen(percorso_file,
                          prefisso_nome_file||'TIPO_TITOLO_STUDIO-'||to_char(sysdate,'yyyymmddhh24miss')||'.TXT',
                          'w', 5000);
        for rec in (select id_titolo_studio, descrizione from db_tipo_titolo_studio)
        loop
            stringa_dati := to_char(rec.id_titolo_studio)||'#@#'||rec.descrizione||'#@#';
            FileWrite(fFile, stringa_dati);
        end loop;
        FileClose(fFile);
        */

        passo_elaborazione := 'FNC.SCAR.DECOD DB_TIPO_ZONA_ALTIMETRICA';
        fFile := fileopen(percorso_file,
                          prefisso_nome_file||'TIPO_ZONA_ALTIMETRICA-'||TO_CHAR(SYSDATE,'yyyymmddhh24miss')||'.TXT',
                          'w', 5000);
        FOR rec IN (SELECT id_zona_altimetrica, descrizione FROM DB_TIPO_ZONA_ALTIMETRICA)
        LOOP
            stringa_dati := TO_CHAR(rec.id_zona_altimetrica)||'#@#'||rec.descrizione||'#@#';
            FileWrite(fFile, stringa_dati);
        END LOOP;
        FileClose(fFile);

        RETURN 'OK';

    EXCEPTION
    WHEN OTHERS THEN
        IF UTL_FILE.IS_OPEN(fFile) THEN FileClose(fFile);
        END IF;
        DBMS_OUTPUT.PUT_LINE('*** ERRORE !!!');
        DBMS_OUTPUT.PUT_LINE('*** Messaggio: '||SQLERRM);
        DBMS_OUTPUT.PUT_LINE('*** Passo elaborativo: '||passo_elaborazione);
        RETURN SQLERRM;
    END fnc_scarica_decodifica;





    FUNCTION fnc_scarica_anagrafica RETURN VARCHAR2 IS

        fAnagrAzienda UTL_FILE.FILE_TYPE;
        fAllevamento UTL_FILE.FILE_TYPE;
        fConduzione UTL_FILE.FILE_TYPE;
        fContitolare UTL_FILE.FILE_TYPE;
        fManodopera UTL_FILE.FILE_TYPE;
        fPersona UTL_FILE.FILE_TYPE;
        fUte UTL_FILE.FILE_TYPE;
        stringa_dati VARCHAR2(2000);
        v_superficie_utilizzata VARCHAR2(50);
        v_superficie_condotta VARCHAR2(50);
    BEGIN
        passo_elaborazione := 'FNC.SCAR.ANAGR.';

        -- Cursore principale di estrazione dati anagrafici.
        -- A seconda della tipologia dello scarico leggo tutti i dati anagrafici ritenuti consistenti
        FOR azienda IN (SELECT ana.ID_AZIENDA ID_AZIENDA, ana.ID_TIPOLOGIA_AZIENDA ID_TIPOLOGIA_AZIENDA, ana.CUAA CUAA,
                              ana.PARTITA_IVA PARTITA_IVA, ana.DENOMINAZIONE DENOMINAZIONE,
                              dich.data_inserimento_dichiarazione DATA_DICHIARAZ_CONSISTENZA,
                              dich.id_dichiarazione_consistenza ID_DICHIARAZIONE_CONSISTENZA,
                              dich.data_invio_aaep data_invio_aaep, dich.flag_invio_aaep flag_invio_aaep,
                              dich.CODICE_FOTOGRAFIA_TERRENI CODICE_FOTOGRAFIA_TERRENI,
                              ana.PROVINCIA_COMPETENZA PROVINCIA_COMPETENZA,
                              ana.ID_FORMA_GIURIDICA ID_FORMA_GIURIDICA, ana.CCIAA_PROVINCIA_REA CCIAA_PROVINCIA_REA,
                              ana.CCIAA_NUMERO_REA CCIAA_NUMERO_REA, ana.CCIAA_NUMERO_REGISTRO_IMPRESE CCIAA_NUMERO_REGISTRO_IMPRESE,
                              ana.CCIAA_ANNO_ISCRIZIONE CCIAA_ANNO_ISCRIZIONE, ana.SEDELEG_INDIRIZZO SEDELEG_INDIRIZZO,
                              ana.SEDELEG_CAP SEDELEG_CAP,
                              DECODE(SUBSTR(ana.SEDELEG_COMUNE,1,3),'999',NULL,ana.SEDELEG_COMUNE) SEDELEG_COMUNE,
                              ana.SEDELEG_CITTA_ESTERO SEDELEG_CITTA_ESTERO,
                              DECODE(SUBSTR(ana.SEDELEG_COMUNE,1,3),'999', com.descom, NULL) SEDELEG_STATO_ESTERO_DESCR,
                              DECODE(SUBSTR(ana.SEDELEG_COMUNE,1,3),'999', com.codfisc, NULL) SEDELEG_STATO_ESTERO_BELFIORE,
                              DECODE(SUBSTR(ana.SEDELEG_COMUNE,1,3),'999', com.sigla_estero, NULL) SEDELEG_STATO_ESTERO_SIGLA,
                              ana.MAIL MAIL, ana.SITOWEB SITOWEB,
                                        DECODE(ID_TIPO_CODIFICA_ATECO,1,
                                                                          DECODE(LENGTH(ateco.codice)
                                                                                    ,2,ateco.codice
                                                                                    ,3,SUBSTR(ateco.codice,1,2)||'.'||SUBSTR(ateco.codice,3)
                                                                                    ,4,SUBSTR(ateco.codice,1,2)||'.'||SUBSTR(ateco.codice,3)
                                                                                    ,5,SUBSTR(ateco.codice,1,2)||'.'||SUBSTR(ateco.codice,3,2)||'.'||SUBSTR(ateco.codice,5)
                                                                                    ,6,SUBSTR(ateco.codice,1,2)||'.'||SUBSTR(ateco.codice,3,2)||'.'||SUBSTR(ateco.codice,5)),NULL) COD_ATECO_2002,
                                        DECODE(ID_TIPO_CODIFICA_ATECO,2,
                                                                          DECODE(LENGTH(ateco.codice)
                                                                                    ,2,ateco.codice
                                                                                    ,3,SUBSTR(ateco.codice,1,2)||'.'||SUBSTR(ateco.codice,3)
                                                                                    ,4,SUBSTR(ateco.codice,1,2)||'.'||SUBSTR(ateco.codice,3)
                                                                                    ,5,SUBSTR(ateco.codice,1,2)||'.'||SUBSTR(ateco.codice,3,2)||'.'||SUBSTR(ateco.codice,5)
                                                                                    ,6,SUBSTR(ateco.codice,1,2)||'.'||SUBSTR(ateco.codice,3,2)||'.'||SUBSTR(ateco.codice,5)),NULL) COD_ATECO_2007,

--                              NULL COD_ATECO_2007,
                                        ote.codice COD_ATTIVITA_OTE, ana.DATA_CESSAZIONE DATA_CESSAZIONE,
                              REPLACE(REPLACE(ana.CAUSALE_CESSAZIONE,CHR(13),' '), CHR(10), ' ') CAUSALE_CESSAZIONE, ana.ID_CESSAZIONE ID_CESSAZIONE,
                              ana.data_aggiornamento DATA_ULT_AGGIORNAM_SIAP
                       FROM DB_ANAGRAFICA_AZIENDA ana, DB_AZIENDA az, DB_TIPO_ATTIVITA_ATECO ateco, DB_TIPO_ATTIVITA_OTE ote,
                            COMUNE com, DB_DICHIARAZIONE_CONSISTENZA dich
                       WHERE ana.cuaa IS NOT NULL
                         AND ana.data_fine_validita IS NULL
                         AND az.id_azienda = ana.id_azienda
                         AND NVL(az.flag_azienda_provvisoria,'N')  != 'S'
                         AND ana.id_azienda = dich.id_azienda
                         AND dich.numero_protocollo IS NOT NULL
                         AND ((ana.data_cessazione IS NULL AND (tipo_scarico = 'COMPLETO' OR (tipo_scarico = 'INCREMENTALE' AND NVL(dich.flag_invio_aaep,'N') != 'S')))
                               OR
                               (ana.data_cessazione IS NOT NULL AND
                                ana.data_aggiornamento >=
                                        (SELECT DECODE(tipo_scarico, 'COMPLETO', TO_DATE('17112006','ddmmyyyy'),
                                                                     'INCREMENTALE', NVL(MAX(dich3.data_invio_aaep), TO_DATE('17112006','ddmmyyyy')))
                                         FROM DB_DICHIARAZIONE_CONSISTENZA dich3
                                         WHERE dich3.id_azienda = ana.id_azienda)
                               )
                             )
                         AND dich.data_inserimento_dichiarazione = (SELECT MAX(dich2.data_inserimento_dichiarazione)
                                                                    FROM DB_DICHIARAZIONE_CONSISTENZA dich2
                                                                    WHERE dich2.id_azienda = dich.id_azienda
                                                                      AND dich2.data_inserimento_dichiarazione >= TO_DATE('17112006','ddmmyyyy')
                                                                      AND dich2.numero_protocollo IS NOT NULL
                                                                   )
                         AND dich.id_dichiarazione_consistenza = (SELECT MAX(dich3.id_dichiarazione_consistenza)
                                                                    FROM DB_DICHIARAZIONE_CONSISTENZA dich3
                                                                    WHERE dich3.id_azienda = dich.id_azienda
                                                                      AND dich3.data_inserimento_dichiarazione >= dich.data_inserimento_dichiarazione
                                                                      AND dich3.numero_protocollo IS NOT NULL)
                         AND ana.id_attivita_ateco = ateco.id_attivita_ateco(+)
                         AND ana.id_attivita_ote = ote.id_attivita_ote(+)
                         AND ana.sedeleg_comune = com.istat_comune(+)
                  )
        LOOP
            numero_aziende := numero_aziende + 1;

            IF NOT UTL_FILE.IS_OPEN(fAnagrAzienda) THEN
                fAnagrAzienda := FileOpen(percorso_file,
                              prefisso_nome_file||'ANAGRAFICA_AZIENDA-'||TO_CHAR(SYSDATE,'yyyymmddhh24miss')||'.TXT',
                              'w', 5000);
            END IF;

            passo_elaborazione := 'FNC.SCAR.ANAGR. DB_ANAGRAFICA_AZIENDA';

            stringa_dati := TO_CHAR(azienda.ID_AZIENDA)||'#@#'||TO_CHAR(azienda.ID_TIPOLOGIA_AZIENDA)||'#@#'||
                            azienda.CUAA||'#@#'||azienda.PARTITA_IVA||'#@#'||azienda.DENOMINAZIONE||'#@#'||
                            TO_CHAR(azienda.DATA_DICHIARAZ_CONSISTENZA,'dd/mm/yyyy hh24:mi:ss')||'#@#'||
                            azienda.PROVINCIA_COMPETENZA||'#@#'||TO_CHAR(azienda.ID_FORMA_GIURIDICA)||'#@#'||
                            azienda.CCIAA_PROVINCIA_REA||'#@#'||TO_CHAR(azienda.CCIAA_NUMERO_REA)||'#@#'||
                            azienda.CCIAA_NUMERO_REGISTRO_IMPRESE||'#@#'||azienda.CCIAA_ANNO_ISCRIZIONE||'#@#'||
                            azienda.SEDELEG_INDIRIZZO||'#@#'||azienda.SEDELEG_CAP||'#@#'||
                            azienda.SEDELEG_COMUNE||'#@#'||azienda.SEDELEG_CITTA_ESTERO||'#@#'||
                            azienda.SEDELEG_STATO_ESTERO_DESCR||'#@#'||azienda.SEDELEG_STATO_ESTERO_BELFIORE||'#@#'||
                            azienda.SEDELEG_STATO_ESTERO_SIGLA||'#@#'||azienda.MAIL||'#@#'||azienda.SITOWEB||'#@#'||
                            azienda.COD_ATECO_2002||'#@#'||azienda.COD_ATECO_2007||'#@#'||azienda.COD_ATTIVITA_OTE||'#@#'||
                            TO_CHAR(azienda.DATA_CESSAZIONE,'dd/mm/yyyy')||'#@#'||azienda.CAUSALE_CESSAZIONE||'#@#'||
                            TO_CHAR(azienda.ID_CESSAZIONE)||'#@#'||TO_CHAR(azienda.DATA_ULT_AGGIORNAM_SIAP,'dd/mm/yyyy')||'#@#';

            FileWrite(fAnagrAzienda, stringa_dati);


            -- DB_UTE E FIGLIE -----------------------------------------------
            FOR ute IN (SELECT ut.ID_UTE id_ute, ut.ID_AZIENDA id_azienda, ut.DENOMINAZIONE denominazione,
                               ut.INDIRIZZO indirizzo, ut.CAP cap,
                               DECODE(SUBSTR(ut.COMUNE,1,3), '999', NULL, ut.COMUNE) COMUNE,
                               DECODE(SUBSTR(ut.COMUNE,1,3),'999', com.descom, NULL) STATO_ESTERO_DESCR,
                               DECODE(SUBSTR(ut.COMUNE,1,3),'999', com.codfisc, NULL) STATO_ESTERO_BELFIORE,
                               DECODE(SUBSTR(ut.COMUNE,1,3),'999', com.sigla_estero, NULL) STATO_ESTERO_SIGLA,
                               ut.TELEFONO telefono, ut.FAX fax, ut.ID_ZONA_ALTIMETRICA id_zona_altimetrica,
                                        DECODE(ID_TIPO_CODIFICA_ATECO,1,
                                                                          DECODE(LENGTH(ateco.codice)
                                                                                    ,2,ateco.codice
                                                                                    ,3,SUBSTR(ateco.codice,1,2)||'.'||SUBSTR(ateco.codice,3)
                                                                                    ,4,SUBSTR(ateco.codice,1,2)||'.'||SUBSTR(ateco.codice,3)
                                                                                    ,5,SUBSTR(ateco.codice,1,2)||'.'||SUBSTR(ateco.codice,3,2)||'.'||SUBSTR(ateco.codice,5)
                                                                                    ,6,SUBSTR(ateco.codice,1,2)||'.'||SUBSTR(ateco.codice,3,2)||'.'||SUBSTR(ateco.codice,5)),NULL) COD_ATECO_2002,
                                        DECODE(ID_TIPO_CODIFICA_ATECO,2,
                                                                          DECODE(LENGTH(ateco.codice)
                                                                                    ,2,ateco.codice
                                                                                    ,3,SUBSTR(ateco.codice,1,2)||'.'||SUBSTR(ateco.codice,3)
                                                                                    ,4,SUBSTR(ateco.codice,1,2)||'.'||SUBSTR(ateco.codice,3)
                                                                                    ,5,SUBSTR(ateco.codice,1,2)||'.'||SUBSTR(ateco.codice,3,2)||'.'||SUBSTR(ateco.codice,5)
                                                                                    ,6,SUBSTR(ateco.codice,1,2)||'.'||SUBSTR(ateco.codice,3,2)||'.'||SUBSTR(ateco.codice,5)),NULL) COD_ATECO_2007,

--                              NULL COD_ATECO_2007,
                                        ote.codice COD_ATTIVITA_OTE, ut.DATA_INIZIO_ATTIVITA data_inizio_attivita,
                               ut.DATA_FINE_ATTIVITA data_fine_attivita, REPLACE(REPLACE(ut.CAUSALE_CESSAZIONE, CHR(13), ' '), CHR(10), ' ') causale_cessazione,
                               ut.data_aggiornamento DATA_ULT_AGGIORNAM_SIAP
                        FROM DB_UTE ut, DB_TIPO_ATTIVITA_ATECO ateco, DB_TIPO_ATTIVITA_OTE ote, COMUNE com
                        WHERE ut.id_azienda = azienda.id_azienda
                          AND ut.data_fine_attivita IS NULL
                          AND ateco.id_attivita_ateco(+) = ut.id_attivita_ateco
                          AND ote.id_attivita_ote(+) = ut.id_attivita_ote
                          AND com.istat_comune(+) = ut.COMUNE
                        )
            LOOP
                passo_elaborazione := 'FNC.SCAR.ANAGR. DB_UTE';

                IF NOT UTL_FILE.IS_OPEN(fUte) THEN
                    fUte := FileOpen(percorso_file,
                                     prefisso_nome_file||'UTE-'||TO_CHAR(SYSDATE,'yyyymmddhh24miss')||'.TXT',
                                     'w', 5000);
                END IF;

                stringa_dati :=  ute.ID_UTE||'#@#'||ute.ID_AZIENDA||'#@#'||ute.DENOMINAZIONE||'#@#'||ute.INDIRIZZO||'#@#'||
                            ute.CAP||'#@#'||ute.COMUNE||'#@#'||ute.STATO_ESTERO_DESCR||'#@#'||
                            ute.STATO_ESTERO_BELFIORE||'#@#'||ute.STATO_ESTERO_SIGLA||'#@#'||ute.TELEFONO||'#@#'||
                            ute.FAX||'#@#'||TO_CHAR(ute.ID_ZONA_ALTIMETRICA)||'#@#'||ute.COD_ATECO_2002||'#@#'||
                            ute.COD_ATECO_2007||'#@#'||ute.COD_ATTIVITA_OTE||'#@#'||
                            TO_CHAR(ute.DATA_INIZIO_ATTIVITA,'dd/mm/yyyy')||'#@#'||
                            TO_CHAR(ute.DATA_FINE_ATTIVITA,'dd/mm/yyyy')||'#@#'||
                            ute.CAUSALE_CESSAZIONE||'#@#'||TO_CHAR(ute.DATA_ULT_AGGIORNAM_SIAP,'dd/mm/yyyy')||'#@#';

                FileWrite(fUte, stringa_dati);


                passo_elaborazione := 'FNC.SCAR.ANAGR. DB_UTE, DB_ALLEVAMENTO';
                FOR allevamento IN (
                                    SELECT DISTINCT al.ID_UTE id_ute,
                                                    al.ID_SPECIE_ANIMALE id_specie_animale,
                                                    trim(al.CODICE_AZIENDA_ZOOTECNICA) codice_stalla, -- COLONNA AGGIUNTA il 18/07/2008
                                                    al.DATA_AGGIORNAMENTO data_aggiornamento
                                    FROM DB_ALLEVAMENTO al
                                    WHERE al.id_ute = ute.id_ute
                                      AND al.data_inizio < azienda.data_dichiaraz_consistenza
                                      AND (al.data_fine IS NULL OR al.data_fine > azienda.data_dichiaraz_consistenza)
                                      AND trim(al.codice_azienda_zootecnica) IS NOT NULL
                                      AND al.data_aggiornamento = (SELECT MAX(al2.data_aggiornamento)
                                                                   FROM DB_ALLEVAMENTO al2
                                                                   WHERE al2.id_ute = al.id_ute
                                                                     AND al2.id_specie_animale = al.id_specie_animale
                                                                     AND al2.data_inizio < azienda.data_dichiaraz_consistenza
                                                                     AND trim(al2.codice_azienda_zootecnica) IS NOT NULL
                                                                     AND (al2.data_fine IS NULL OR al2.data_fine > azienda.data_dichiaraz_consistenza)
                                                                  )
                                    )
                LOOP
                    IF NOT UTL_FILE.IS_OPEN(fAllevamento) THEN
                        fAllevamento := FileOpen(percorso_file,
                                             prefisso_nome_file||'ALLEVAMENTO-'||TO_CHAR(SYSDATE,'yyyymmddhh24miss')||'.TXT',
                                             'w', 5000);
                    END IF;

                    stringa_dati := TO_CHAR(allevamento.id_ute)||'#@#'||
                                   TO_CHAR(allevamento.id_specie_animale)||'#@#'||
                                   allevamento.codice_stalla||'#@#'|| -- COLONNA AGGIUNTA il 18/07/2008
                                   TO_CHAR(allevamento.data_aggiornamento,'dd/mm/yyyy')||'#@#';
                    FileWrite(fAllevamento, stringa_dati);

                END LOOP;


                passo_elaborazione := 'FNC.SCAR.ANAGR. DB_UTE, DB_CONDUZIONE_DICHIARATA, DB_UTILIZZO_DICHIARATO';
                FOR conduzione IN (SELECT cond.id_ute ID_UTE,
                                          macro.codice COD_MACRO_USO,
                                          SUM(cond.superficie_condotta) superficie_condotta,
                                          SUM(util.superficie_utilizzata) SUPERFICIE_UTILIZZATA,
                                          MAX(util.data_aggiornamento) DATA_ULT_AGGIORNAM_SIAP
                                   FROM DB_CONDUZIONE_DICHIARATA cond,
                                        DB_UTILIZZO_DICHIARATO util,
                                        DB_TIPO_MACRO_USO_VARIETA varieta,
                                        DB_TIPO_MACRO_USO macro,DB_R_CATALOGO_MATRICE CM
                                   WHERE cond.id_ute = ute.id_ute
                                     AND cond.codice_fotografia_terreni = azienda.codice_fotografia_terreni
                                     AND util.id_conduzione_dichiarata = cond.id_conduzione_dichiarata
                                     AND UTIL.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
                                     AND VARIETA.ID_CATALOGO_MATRICE  = CM.ID_CATALOGO_MATRICE 
                                     ---AND varieta.id_varieta = util.id_varieta
                                     --AND NVL(util.id_tipo_dettaglio_uso,-1) = NVL(varieta.id_tipo_dettaglio_uso,-1) 
                                     AND azienda.data_dichiaraz_consistenza BETWEEN varieta.data_inizio_validita    -- sia nelle validazioni pre id_tipo_dettaglio_uso che post devo fare questo giochetto
                                                                                AND NVL(varieta.data_fine_validita,azienda.data_dichiaraz_consistenza) 
                                     AND macro.id_macro_uso = varieta.id_macro_uso
                                   GROUP BY cond.id_ute, macro.codice)
                LOOP
                    IF NOT UTL_FILE.IS_OPEN(fConduzione) THEN
                        fConduzione := FileOpen(percorso_file,
                                    prefisso_nome_file||'CONDUZIONE_DICHIARATA-'||TO_CHAR(SYSDATE,'yyyymmddhh24miss')||'.TXT',
                                    'w', 5000);
                    END IF;

                    v_superficie_utilizzata := TO_CHAR(conduzione.superficie_utilizzata*10000);
                    v_superficie_condotta := TO_CHAR(conduzione.superficie_condotta*10000);

                    stringa_dati := TO_CHAR(conduzione.id_ute)||'#@#'||conduzione.cod_macro_uso||'#@#'||
                                    v_superficie_utilizzata||'#@#'||
                                    v_superficie_condotta||'#@#'||
                                    TO_CHAR(conduzione.data_ult_aggiornam_siap,'dd/mm/yyyy')||'#@#';
                    FileWrite(fConduzione, stringa_dati);
                END LOOP;


            END LOOP;


            ----   DB_CONTITOLARE   -----------------------------------------------
            -- Prendo tutte le persone legate ad una azienda. Dato che nella tabella DB_PERSONA_FISICA
            -- esistono dei duplicati, a fronte di uno stesso codice fiscale prendo il record con data_aggiornamento più recente
            FOR contitolare IN (SELECT pers.id_persona_fisica ID_PERSONA_FISICA,
                                       cont.id_ruolo ID_RUOLO,
                                       cont.id_azienda ID_AZIENDA,
                                       cont.data_inizio_ruolo DATA_INIZIO_RUOLO
                                FROM DB_CONTITOLARE cont, DB_PERSONA_FISICA pers
                                WHERE cont.id_azienda = azienda.id_azienda
                                  AND cont.data_fine_ruolo IS NULL
                                  AND pers.id_soggetto = cont.id_soggetto
                               )
            LOOP

                passo_elaborazione := 'FNC.SCAR.ANAGR. DB_CONTITOLARE';
                IF NOT UTL_FILE.IS_OPEN(fContitolare) THEN
                    fContitolare := FileOpen(percorso_file,
                                             prefisso_nome_file||'CONTITOLARE-'||TO_CHAR(SYSDATE,'yyyymmddhh24miss')||'.TXT',
                                             'w', 5000);
                 END IF;

                stringa_dati := TO_CHAR(contitolare.id_persona_fisica)||'#@#'||
                                TO_CHAR(contitolare.id_ruolo)||'#@#'||
                                TO_CHAR(contitolare.id_azienda)||'#@#'||
                                TO_CHAR(contitolare.data_inizio_ruolo,'dd/mm/yyyy')||'#@#';

                FileWrite(fContitolare, stringa_dati);


                ----   DB_PERSONA_FISICA   -----------------------------------------------
                passo_elaborazione := 'FNC.SCAR.ANAGR. DB_PERSONA_FISICA';
                FOR persona IN (SELECT pers.id_persona_fisica ID_PERSONA_FISICA, pers.codice_fiscale CODICE_FISCALE,
                                       pers.cognome COGNOME, pers.nome NOME, pers.sesso SESSO, pers.nascita_data NASCITA_DATA,
                                       DECODE(SUBSTR(pers.nascita_comune,1,3), '999', NULL, pers.nascita_comune) NASCITA_COMUNE,
                                       pers.nascita_citta_estero NASCITA_CITTA_ESTERO,
                                       DECODE(SUBSTR(pers.nascita_comune,1,3), '999', comnasc.descom, NULL) NASCITA_STATO_ESTERO_DESCR,
                                       DECODE(SUBSTR(pers.nascita_comune,1,3), '999', comnasc.codfisc, NULL) NASCITA_STATO_ESTERO_BELFIORE,
                                       DECODE(SUBSTR(pers.nascita_comune,1,3), '999', comnasc.sigla_estero, NULL) NASCITA_STATO_ESTERO_SIGLA,
                                       pers.data_inizio_residenza DATA_INIZIO_RESIDENZA, pers.res_indirizzo RES_INDIRIZZO,
                                       pers.res_cap RES_CAP,
                                       -- NON SCARICARE, deciso il 18/07/2008
                                       --pers.res_telefono RES_TELEFONO,
                                       --pers.res_fax RES_FAX,
                                       --pers.res_mail RES_MAIL,
                                       DECODE(SUBSTR(pers.res_comune,1,3), '999', NULL, pers.res_comune) RES_COMUNE,
                                       pers.res_citta_estero RES_CITTA_ESTERO,
                                       DECODE(SUBSTR(pers.res_comune,1,3), '999', comres.descom, NULL) RES_STATO_ESTERO_DESCR,
                                       DECODE(SUBSTR(pers.res_comune,1,3), '999', comres.codfisc, NULL) RES_STATO_ESTERO_BELFIORE,
                                       DECODE(SUBSTR(pers.res_comune,1,3), '999', comres.sigla_estero, NULL) RES_STATO_ESTERO_SIGLA,
                                       pers.dom_indirizzo DOM_INDIRIZZO, pers.dom_cap DOM_CAP,
                                       DECODE(SUBSTR(pers.dom_comune,1,3), '999', NULL, pers.dom_comune) DOM_COMUNE,
                                       pers.dom_citta_estero DOM_CITTA_ESTERO,
                                       DECODE(SUBSTR(pers.dom_comune,1,3), '999', comdom.descom, NULL) DOM_STATO_ESTERO_DESCR,
                                       DECODE(SUBSTR(pers.dom_comune,1,3), '999', comdom.codfisc, NULL) DOM_STATO_ESTERO_BELFIORE,
                                       DECODE(SUBSTR(pers.dom_comune,1,3), '999', comdom.sigla_estero, NULL) DOM_STATO_ESTERO_SIGLA,
                                       -- NON SCARICARE, deciso il 18/07/2008
                                       --pers.id_titolo_studio ID_TITOLO_STUDIO,
                                       --pers.id_indirizzo_studio ID_INDIRIZZO_STUDIO,
                                       pers.data_aggiornamento DATA_ULT_AGGIORNAM_SIAP
                                FROM DB_PERSONA_FISICA pers, COMUNE comnasc, COMUNE comres, COMUNE comdom
                                WHERE pers.id_persona_fisica = contitolare.id_persona_fisica
                                  AND comnasc.istat_comune(+) = pers.nascita_comune
                                  AND comres.istat_comune(+) = pers.res_comune
                                  AND comdom.istat_comune(+) = pers.dom_comune)
                LOOP

                    IF NOT UTL_FILE.IS_OPEN(fPersona) THEN
                        fPersona := FileOpen(percorso_file,
                                             prefisso_nome_file||'PERSONA_FISICA-'||TO_CHAR(SYSDATE,'yyyymmddhh24miss')||'.TXT',
                                             'w', 5000);
                    END IF;

                    stringa_dati := TO_CHAR(persona.ID_PERSONA_FISICA)||'#@#'||persona.CODICE_FISCALE||'#@#'||
                                    persona.COGNOME||'#@#'||persona.NOME||'#@#'||persona.SESSO||'#@#'||
                                    TO_CHAR(persona.NASCITA_DATA,'dd/mm/yyyy')||'#@#'||persona.NASCITA_COMUNE||'#@#'||
                                    persona.NASCITA_CITTA_ESTERO||'#@#'||persona.NASCITA_STATO_ESTERO_DESCR||'#@#'||
                                    persona.NASCITA_STATO_ESTERO_BELFIORE||'#@#'||persona.NASCITA_STATO_ESTERO_SIGLA||'#@#'||
                                    TO_CHAR(persona.DATA_INIZIO_RESIDENZA,'dd/mm/yyyy')||'#@#'||
                                    persona.RES_INDIRIZZO||'#@#'||persona.RES_CAP||'#@#'||
                                    -- NON SCARICARE, deciso il 18/07/2008
                                    --persona.RES_TELEFONO||'#@#'||
                                    --persona.RES_FAX||'#@#'||
                                    --persona.RES_MAIL||'#@#'||
                                    persona.RES_COMUNE||'#@#'||
                                    persona.RES_CITTA_ESTERO||'#@#'||persona.RES_STATO_ESTERO_DESCR||'#@#'||
                                    persona.RES_STATO_ESTERO_BELFIORE||'#@#'||persona.RES_STATO_ESTERO_SIGLA||'#@#'||
                                    persona.DOM_INDIRIZZO||'#@#'||persona.DOM_CAP||'#@#'||persona.DOM_COMUNE||'#@#'||
                                    persona.DOM_CITTA_ESTERO||'#@#'||persona.DOM_STATO_ESTERO_DESCR||'#@#'||
                                    persona.DOM_STATO_ESTERO_BELFIORE||'#@#'||persona.DOM_STATO_ESTERO_SIGLA||'#@#'||
                                    -- NON SCARICARE, deciso il 18/07/2008
                                    --to_char(persona.ID_TITOLO_STUDIO)||'#@#'||
                                    --to_char(persona.ID_INDIRIZZO_STUDIO)||'#@#'||
                                    TO_CHAR(persona.DATA_ULT_AGGIORNAM_SIAP,'dd/mm/yyyy')||'#@#';

                    FileWrite(fPersona, stringa_dati);
                END LOOP;

            END LOOP; -- db_contitolare


            /*
            NON SCARICARE, deciso il 18/07/2008
            ----   DB_MANODOPERA   -----------------------------------------------
            passo_elaborazione := 'FNC.SCAR.ANAGR. DB_MANODOPERA';
            for manodopera in (select mano.id_azienda ID_AZIENDA, forma.codice COD_FORMA_CONDUZIONE,
                                      mano.data_aggiornamento DATA_ULT_AGGIORNAM_SIAP,
                                      sum(dett.uomini) NUMERO_UOMINI, sum(dett.donne) NUMERO_DONNE
                               from db_manodopera mano, db_tipo_forma_conduzione forma, db_dettaglio_manodopera dett
                               where mano.id_azienda = azienda.id_azienda
                                 and mano.data_fine_validita is null
                                 and forma.id_forma_conduzione(+) = mano.id_forma_conduzione
                                 and dett.id_manodopera(+) = mano.id_manodopera
                               group by mano.id_azienda, forma.codice, mano.data_aggiornamento)
            loop
                if not utl_file.is_open(fManodopera) then
                    fManodopera := FileOpen(percorso_file,
                                            prefisso_nome_file||'MANODOPERA-'||to_char(sysdate,'yyyymmddhh24miss')||'.TXT',
                                            'w', 5000);
                end if;

                stringa_dati := to_char(manodopera.id_azienda)||'#@#'||to_char(manodopera.numero_uomini)||'#@#'||
                                to_char(manodopera.numero_donne)||'#@#'||manodopera.cod_forma_conduzione||'#@#'||
                                to_char(manodopera.data_ult_aggiornam_siap,'dd/mm/yyyy')||'#@#';
                FileWrite(fManodopera, stringa_dati);

            end loop;
            */

            -- tracciatura
            UPDATE DB_DICHIARAZIONE_CONSISTENZA
            SET flag_invio_aaep = 'S', data_invio_aaep = SYSDATE
            WHERE id_dichiarazione_consistenza = azienda.id_dichiarazione_consistenza;

        END LOOP;

        -- Chiususra dei file se sono stati aperti
        IF UTL_FILE.IS_OPEN(fAnagrAzienda) THEN FileClose(fAnagrAzienda); END IF;
        IF UTL_FILE.IS_OPEN(fUte) THEN FileClose(fUte); END IF;
        IF UTL_FILE.IS_OPEN(fAllevamento) THEN FileClose(fAllevamento);  END IF;
        IF UTL_FILE.IS_OPEN(fPersona) THEN FileClose(fPersona); END IF;
        IF UTL_FILE.IS_OPEN(fContitolare) THEN FileClose(fContitolare); END IF;
        -- NON SCARICARE, deciso il 18/07/2008
        --if utl_file.is_open(fManodopera) then FileClose(fManodopera); end if;
        IF UTL_FILE.IS_OPEN(fConduzione) THEN FileClose(fConduzione); END IF;


        RETURN 'OK';

    EXCEPTION
    WHEN OTHERS THEN
        IF UTL_FILE.IS_OPEN(fAnagrAzienda) THEN FileClose(fAnagrAzienda); END IF;
        IF UTL_FILE.IS_OPEN(fUte) THEN FileClose(fUte); END IF;
        IF UTL_FILE.IS_OPEN(fAllevamento) THEN FileClose(fAllevamento);  END IF;
        IF UTL_FILE.IS_OPEN(fPersona) THEN FileClose(fPersona); END IF;
        IF UTL_FILE.IS_OPEN(fContitolare) THEN FileClose(fContitolare); END IF;
        -- NON SCARICARE, deciso il 18/07/2008
        --if utl_file.is_open(fManodopera) then FileClose(fManodopera); end if;
        IF UTL_FILE.IS_OPEN(fConduzione) THEN FileClose(fConduzione); END IF;
        DBMS_OUTPUT.PUT_LINE('*** ERRORE !!!');
        DBMS_OUTPUT.PUT_LINE('*** Messaggio: '||SQLERRM);
        DBMS_OUTPUT.PUT_LINE('*** Passo elaborativo: '||passo_elaborazione);
        RETURN SQLERRM;
    END fnc_scarica_anagrafica;





    FUNCTION fnc_main (pPathFile VARCHAR2, pPrefissoNomeFile VARCHAR2)
    RETURN NUMBER IS
        return_value VARCHAR2(1000);
        nuovoIdScarico DB_SCARICO_LOG.id_scarico%TYPE;
        UscitaForzata EXCEPTION;
    BEGIN
        percorso_file := pPathFile;
        prefisso_nome_file := pPrefissoNomeFile;

        passo_elaborazione := 'LETTURA TIPO_SCARICO';
        SELECT valore_parametro INTO tipo_scarico FROM DB_SCARICO_PARAMETRI WHERE nome_parametro = 'TIPO_SCARICO';
        passo_elaborazione := 'LETTURA TIPO_DATI';
        SELECT valore_parametro INTO tipo_dati FROM DB_SCARICO_PARAMETRI WHERE nome_parametro = 'TIPO_DATI';

        -- Tracciatura esecuzione scarico dati
        INSERT INTO DB_SCARICO_LOG (id_scarico, data_inizio_scarico, data_fine_scarico, parametri_scarico, esito)
        VALUES (seq_db_scarico_log.NEXTVAL, SYSDATE, NULL, 'TIPO_SCARICO='||tipo_scarico||';TIPO_DATI='||tipo_dati, NULL)
        RETURNING id_scarico INTO nuovoIdScarico;
        COMMIT;


        ----------------------------------          LANCIO DELLO SCARICO DATI DI DECODIFICA
        IF tipo_dati IN ('DECODIFICA','TUTTI') THEN
            return_value := fnc_scarica_decodifica;
            IF return_value != 'OK' THEN RAISE UscitaForzata;
            END IF;
        END IF;
        ----------------------------------          LANCIO DELLO SCARICO DATI ANAGRAFICI
        IF tipo_dati IN ('ANAGRAFICA','TUTTI') THEN
            return_value := fnc_scarica_anagrafica;
            IF return_value != 'OK' THEN RAISE UscitaForzata;
            END IF;
        END IF;



        passo_elaborazione := 'IMPOSTAZIONE PARAMETRO TIPO SCARICO ';

        IF tipo_scarico != 'INCREMENTALE' THEN
            -- Se lo scarico appena eseguito era diverso da INCREMENTALE, reimposto a INCREMENTALE tale parametro
            UPDATE DB_SCARICO_PARAMETRI SET valore_parametro = 'INCREMENTALE'
            WHERE nome_parametro = 'TIPO_SCARICO';
        END IF;

        /* 
           In seguito a diverse anomalie riscontrate durante l'acquisizione in AAEP (violazione di chiavi esterne) si è resa necessaria
           una modifica funzionale dello scarico: diventa necessario scaricare sempre anche i dati di decodifica.
           Quindi si "elimina" la logica secondo la quale viene reimpostato il parametro di scarico TIPO_DATI, lasciandolo
           valorizzato sempre a TUTTI

        IF tipo_dati = 'ANAGRAFICA' THEN
            -- Se ho scaricato la sola ANAGRAFICA, aggiorno il parametro TIPO_DATI a TUTTI solo se
            -- sono passati più di 30 giorni dall'ultimo scarico sia dei dati anagrafici che di quelli di decodifica
            UPDATE DB_SCARICO_PARAMETRI SET valore_parametro = 'TUTTI'
            WHERE nome_parametro = 'TIPO_DATI'
              AND NOT EXISTS (SELECT *
                              FROM DB_SCARICO_LOG
                              WHERE parametri_scarico LIKE '%TIPO_DATI=TUTTI%'
                                AND TRUNC(data_inizio_scarico) >= TRUNC(SYSDATE)-30
                                AND esito = 'PL/SQL procedure successfully completed.');
        ELSE
            -- se tipo_dati diverso da ANAGRAFICA di default reimposto ad ANAGRAFICA tale parametro
            UPDATE DB_SCARICO_PARAMETRI SET valore_parametro = 'ANAGRAFICA'
            WHERE nome_parametro = 'TIPO_DATI';
        END IF;
        */

        -- Aggiornamento Log scarico
        UPDATE DB_SCARICO_LOG
        SET esito = 'PL/SQL procedure successfully completed.',
            data_fine_scarico = SYSDATE,
            num_aziende_scaricate = numero_aziende
        WHERE id_scarico = nuovoIdScarico;

        COMMIT;

        RETURN 0;

    EXCEPTION
    WHEN UscitaForzata THEN
        -- Aggiornamento Log scarico
        UPDATE DB_SCARICO_LOG
        SET esito = return_value,
            data_fine_scarico = SYSDATE
        WHERE id_scarico = nuovoIdScarico;
        COMMIT;
        RETURN 1;
    WHEN OTHERS THEN
        -- Aggiornamento Log scarico
        return_value := SQLERRM;
        UPDATE DB_SCARICO_LOG SET esito = TO_CHAR(SYSDATE, 'dd/mm/yyyy hh24:mi:ss')||' '||return_value
        WHERE id_scarico = nuovoIdScarico;
        COMMIT;
        DBMS_OUTPUT.PUT_LINE('*** ERRORE !!!');
        DBMS_OUTPUT.PUT_LINE('*** Messaggio: '||SQLERRM);
        DBMS_OUTPUT.PUT_LINE('*** Passo elaborativo: '||passo_elaborazione);
        RETURN 1;
    END fnc_main;

END Pck_Scarica_Anagrafica_Azienda;

/
--------------------------------------------------------
--  DDL for Package Body PCK_SCARICA_SCHEDE_AGRONOMICHE
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_SCARICA_SCHEDE_AGRONOMICHE" AS
/*****************************************************************************
Package che conterra' tutte le function / procedure propedeutiche alla
generazione dei file di testo contenenti i dati delle schede agranomiche delle
unità vitate e della frutta a guscio che verranno poi elaborati dal GIS
******************************************************************************/

    /*********************************************************************
    Dato un record di tipo SMRGAA_W_UNAR_FAG_INVIATA lo inserisce
    sull'omonima tabella
    Tipo:   procedure
    input:  pRecTUnarFagInviata
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InsertTUnarFagInviata (pRecTUnarFagInviata IN SMRGAA_W_UNAR_FAG_INVIATA%ROWTYPE) IS
    BEGIN

        INSERT INTO SMRGAA_W_UNAR_FAG_INVIATA
            (
            ID_UNAR_FAG_INVIATA,
            ID_AZIENDA,
            ID_PARTICELLA,
            AREA,
            SESTO_SU_FILA,
            SESTO_TRA_FILE,
            NUM_CEPPI,
            ANNO_IMPIANTO,
            TIPO_COLTIVAZIONE_UNAR,
            COD_VARIETA_FG,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA,
            DATA_INVIO
            )
        VALUES
            (
            pRecTUnarFagInviata.ID_UNAR_FAG_INVIATA,
            pRecTUnarFagInviata.ID_AZIENDA,
            pRecTUnarFagInviata.ID_PARTICELLA,
            pRecTUnarFagInviata.AREA,
            pRecTUnarFagInviata.SESTO_SU_FILA,
            pRecTUnarFagInviata.SESTO_TRA_FILE,
            pRecTUnarFagInviata.NUM_CEPPI,
            pRecTUnarFagInviata.ANNO_IMPIANTO,
            pRecTUnarFagInviata.TIPO_COLTIVAZIONE_UNAR,
            pRecTUnarFagInviata.COD_VARIETA_FG,
            pRecTUnarFagInviata.DATA_INIZIO_VALIDITA,
            pRecTUnarFagInviata.DATA_FINE_VALIDITA,
            pRecTUnarFagInviata.DATA_INVIO
            );
    END InsertTUnarFagInviata;

    /*********************************************************************
    Formatta una stringa in base alla lunghezza desiderata per l'output su file
    Tipo:    funzione interna
    Input:    pData = stringa da formattare, pLen = lunghezza desiderata
    Output:    nessuno
    Return:    stringa formattata per l'output su file
    *********************************************************************/
    FUNCTION PAD( pData VARCHAR2, pLen NUMBER ) RETURN VARCHAR2 IS
    BEGIN
        RETURN RPAD( NVL(pData,' '), pLen, ' ' );
    END PAD;

    /*********************************************************************
    Formatta un numero in base alla lunghezza desiderata per l'output su file
    Tipo:    funzione interna
    Input:    pData = numerico da formattare, pLen = lunghezza desiderata
    Output:    nessuno
    Return:    stringa formattata per l'output su file
    *********************************************************************/
    FUNCTION PAD( pData NUMBER, pLen NUMBER ) RETURN VARCHAR2 IS
    BEGIN
        RETURN LPAD( NVL(pData,0), pLen, '0' );
    END PAD;

    /*********************************************************************
    Formatta una data in base al formato passato per l'output su file
    Tipo:    funzione interna
    Input:    pData = data da formattare, pFormat = formato desiderato (DD-MM-YYYY)
    Output:    nessuno
    Return:    stringa formattata per l'output su file
    *********************************************************************/
    FUNCTION PAD( pData DATE, pFormat VARCHAR2 ) RETURN VARCHAR2 IS
    BEGIN
        IF pData IS NULL THEN
            RETURN PAD( ' ', LENGTH(pFormat) );
        ELSE
            RETURN TO_CHAR( pData, pFormat );
        END IF;
    END PAD;

   /*********************************************************************
   Dato un record di tipo SMRGAA_W_AZIENDE_SCHEDE lo inserisce
   sull'omonima tabella
   Tipo:   procedure
   input:  pRecTAziendaScheda
   output: nessuno
   ritorno:nessuno
   *********************************************************************/
    PROCEDURE InsertTAziendaScheda (pRecTAziendaScheda IN SMRGAA_W_AZIENDE_SCHEDE%ROWTYPE) IS
    BEGIN
        INSERT INTO SMRGAA_W_AZIENDE_SCHEDE
            (
            ID_INVIO_SCHEDA,
            ID_AZIENDA
            )
        VALUES
            (
            pRecTAziendaScheda.ID_INVIO_SCHEDA,
            pRecTAziendaScheda.ID_AZIENDA
            );
    EXCEPTION
        WHEN DUP_VAL_ON_INDEX THEN
             PCK_SMRGAA_LOG.LogAnomalia ('ID_AZIENDA : ' || pRecTAziendaScheda.ID_AZIENDA || ' gia'' accodato per ID_INVIO_SCHEDA : ' || pRecTAziendaScheda.ID_INVIO_SCHEDA); 
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertTAziendaScheda - ID_AZIENDA = ' || pRecTAziendaScheda.ID_AZIENDA);
             RAISE;
    END InsertTAziendaScheda;

   /*********************************************************************
   Aggiorna andando per chiave primaria il record presente sulla tabella
   SMRGAA_W_INVIO_SCHEDE_AGR
   Tipo:   procedure
   input: pRecTInvioScheda
   output: nessuno
   ritorno:nessuno
   *********************************************************************/
    PROCEDURE UpdateTInvioScheda (pRecTInvioScheda IN SMRGAA_W_INVIO_SCHEDE_AGR%ROWTYPE) IS
    BEGIN
        UPDATE SMRGAA_W_INVIO_SCHEDE_AGR
           SET DATA_INVIO = pRecTInvioScheda.DATA_INVIO,
               NUMERO_PARTICELLE = pRecTInvioScheda.NUMERO_PARTICELLE,
               NUMERO_SCHEDE = pRecTInvioScheda.NUMERO_SCHEDE,
               NUMERO_ESTIRPI = pRecTInvioScheda.NUMERO_ESTIRPI
         WHERE ID_INVIO_SCHEDA = pRecTInvioScheda.ID_INVIO_SCHEDA;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('UpdateTInvioScheda - ID_INVIO_SCHEDA = ' || pRecTInvioScheda.ID_INVIO_SCHEDA);
             RAISE;
    END UpdateTInvioScheda;

   /*********************************************************************
   Inserisce un record di tipo  SMRGAA_W_INVIO_SCHEDE_AGR sulla tabella
   omonima
   Tipo:   procedure
   input: pRecTInvioScheda
   output: nessuno
   ritorno:nessuno
   *********************************************************************/
    PROCEDURE InsertTInvioScheda (pRecTInvioScheda IN SMRGAA_W_INVIO_SCHEDE_AGR%ROWTYPE) IS
    BEGIN

        INSERT INTO SMRGAA_W_INVIO_SCHEDE_AGR
            (
            ID_INVIO_SCHEDA,
            DATA_INVIO,
            NUMERO_PARTICELLE,
            NUMERO_SCHEDE,
            NUMERO_ESTIRPI
            )
        VALUES
            (
            pRecTInvioScheda.ID_INVIO_SCHEDA,
            pRecTInvioScheda.DATA_INVIO,
            pRecTInvioScheda.NUMERO_PARTICELLE,
            pRecTInvioScheda.NUMERO_SCHEDE,
            pRecTInvioScheda.NUMERO_ESTIRPI
            );
    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('InsertTInvioScheda - ID_INVIO_SCHEDA = ' || pRecTInvioScheda.ID_INVIO_SCHEDA);
             RAISE;
    END InsertTInvioScheda;

    /*********************************************************************
    Inserisce  sulla tabella di appoggio SMRGAA_W_PARTICELLE_SCHEDE
    tutte le particelle che saranno inviate nello scarico di schede agronimiche
    in esecuzione
    Tipo:   procedure
    input: pIdInvioScheda
    output: nessuno
    ritorno:nNumParticelleTrattate
    *********************************************************************/
    FUNCTION ImpostaParticelleTrattate (pIdInvioScheda IN SMRGAA_W_PARTICELLE_SCHEDE.ID_INVIO_SCHEDA%TYPE,
                                        pDtLastEsecOk  IN DATE
    )
    RETURN INTEGER IS
        nNumParticelleTrattate INTEGER:=0;
    BEGIN

        INSERT INTO SMRGAA_W_PARTICELLE_SCHEDE
            (ID_INVIO_SCHEDA,
             ID_PARTICELLA
            )
        SELECT pIdInvioScheda, CP.ID_PARTICELLA
          FROM DB_UTE U,
               DB_CONDUZIONE_PARTICELLA CP,
               DB_UTILIZZO_PARTICELLA UP,
               DB_ANAGRAFICA_AZIENDA AZ,
               DB_R_UTILIZZO_SITIUNAR_DECO USD,
               DB_STORICO_PARTICELLA SP,
               COMUNE C,
               PROVINCIA P,DB_R_CATALOGO_MATRICE CM
         WHERE AZ.DATA_CESSAZIONE IS NULL
           AND AZ.DATA_FINE_VALIDITA IS NULL
           AND AZ.ID_AZIENDA = U.ID_AZIENDA
           AND U.DATA_FINE_ATTIVITA IS NULL
           AND U.ID_UTE = CP.ID_UTE
           AND CP.DATA_FINE_CONDUZIONE IS NULL
           AND CP.ID_TITOLO_POSSESSO NOT IN (knIdTitPossessoAsservimento,
                                             knIdTitpossessoConferimento)
           AND UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
           AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
           AND SP.DATA_FINE_VALIDITA IS NULL
           AND SP.COMUNE = C.ISTAT_COMUNE
           AND C.ISTAT_PROVINCIA = P.ISTAT_PROVINCIA
           AND P.ID_REGIONE = kvIdRegionePiemonte 
           AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND UP.DATA_AGGIORNAMENTO > pDtLastEsecOk
           AND CM.FLAG_FRUTTA_GUSCIO = 'S' 
           AND CM.ID_UTILIZZO = USD.ID_UTILIZZO 
           AND USD.TIPO_UNAR = kvCodTipologiaUnarFag
           AND USD.NOME_CAMPO = 'COD_VARIETA'

         UNION

        SELECT pIdInvioScheda, SP.ID_PARTICELLA
          FROM DB_STORICO_UNITA_ARBOREA SUA,
               DB_STORICO_PARTICELLA SP,
               DB_ANAGRAFICA_AZIENDA  AZ,
               DB_R_UTILIZZO_SITIUNAR_DECO USD
         WHERE AZ.DATA_CESSAZIONE IS NULL
           AND AZ.DATA_FINE_VALIDITA IS NULL
           AND AZ.ID_AZIENDA = SUA.ID_AZIENDA
           AND SUA.DATA_FINE_VALIDITA IS NULL
           AND SUA.DATA_CESSAZIONE IS NULL
           AND SUA.DATA_AGGIORNAMENTO > pDtLastEsecOk
           AND SUA.ID_TIPOLOGIA_UNAR = knIdTipologiaUnarVino
           AND SUA.ID_PARTICELLA = SP.ID_PARTICELLA
           AND SP.DATA_FINE_VALIDITA IS NULL
           AND SUA.ID_UTILIZZO = USD.ID_UTILIZZO
           AND USD.TIPO_UNAR = kvCodTipologiaUnarVino
           AND USD.NOME_CAMPO = 'COD_DEST_PROD'

         UNION
        -- nuova select per gestione unar
        -- non più associate ad aziende (cessate)
        SELECT pIdInvioScheda, SP.ID_PARTICELLA
          FROM DB_STORICO_UNITA_ARBOREA SUA,
               DB_STORICO_PARTICELLA SP,
               DB_R_UTILIZZO_SITIUNAR_DECO USD
         WHERE SUA.DATA_FINE_VALIDITA IS NULL
           AND SUA.ID_AZIENDA IS NULL
           AND SUA.DATA_CESSAZIONE IS NULL
           AND SUA.DATA_AGGIORNAMENTO > pDtLastEsecOk
           AND SUA.ID_TIPOLOGIA_UNAR = knIdTipologiaUnarVino
           AND SUA.ID_PARTICELLA = SP.ID_PARTICELLA
           AND SP.DATA_FINE_VALIDITA IS NULL
           AND SUA.ID_UTILIZZO = USD.ID_UTILIZZO
           AND USD.TIPO_UNAR = kvCodTipologiaUnarVino
           AND USD.NOME_CAMPO = 'COD_DEST_PROD'

         UNION
        -- nuova select per gestione unar
        -- cessate ma legate ad una azienda
        SELECT pIdInvioScheda, SP.ID_PARTICELLA
          FROM DB_STORICO_UNITA_ARBOREA SUA,
               DB_STORICO_PARTICELLA SP,
               DB_R_UTILIZZO_SITIUNAR_DECO USD
         WHERE SUA.DATA_FINE_VALIDITA IS NOT NULL
           AND SUA.ID_AZIENDA IS NOT NULL
           AND SUA.DATA_CESSAZIONE IS NOT NULL
           AND SUA.DATA_AGGIORNAMENTO > pDtLastEsecOk
           AND SUA.ID_TIPOLOGIA_UNAR = knIdTipologiaUnarVino
           AND SUA.ID_PARTICELLA = SP.ID_PARTICELLA
           AND SP.DATA_FINE_VALIDITA IS NULL
           AND SUA.ID_UTILIZZO = USD.ID_UTILIZZO
           AND USD.TIPO_UNAR = kvCodTipologiaUnarVino
           AND USD.NOME_CAMPO = 'COD_DEST_PROD';


        nNumParticelleTrattate := SQL%ROWCOUNT;

        PCK_SMRGAA_LOG.LogInfo ('Accodate : ' || TO_CHAR(nNumParticelleTrattate) || ' particelle per l''invio scheda con ID : ' || TO_CHAR(pIdInvioScheda));

        RETURN nNumParticelleTrattate;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('ImpostaParticelleTrattate - pIdInvioScheda = ' || pIdInvioScheda);
             RAISE;
    END ImpostaParticelleTrattate;

   /*********************************************************************
   Ricerca l'ultimo invio scheda effettuato prima di quello attuale
   Tipo:  function
   input: pIdInvioScheda
   output: nessuno
   ritorno:nessuno
   *********************************************************************/
    FUNCTION SelectTInvioSchedaPrecedente (pIdInvioScheda IN SMRGAA_W_INVIO_SCHEDE_AGR.ID_INVIO_SCHEDA%TYPE)
    RETURN SMRGAA_W_INVIO_SCHEDE_AGR%ROWTYPE IS
        recTInvioScheda SMRGAA_W_INVIO_SCHEDE_AGR%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTInvioScheda
          FROM SMRGAA_W_INVIO_SCHEDE_AGR
         WHERE ID_INVIO_SCHEDA <> pIdInvioScheda;

        RETURN recTInvioScheda;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
        WHEN TOO_MANY_ROWS THEN
             PCK_SMRGAA_LOG.LogAnomalia ('Attenzione esiste più di un invio schede agronomiche precedente a quello attuale : ' || pIdInvioScheda);
             SELECT *
               INTO recTInvioScheda
               FROM SMRGAA_W_INVIO_SCHEDE_AGR
              WHERE ID_INVIO_SCHEDA = (
                    SELECT MAX(ID_INVIO_SCHEDA)
                      FROM SMRGAA_W_INVIO_SCHEDE_AGR
                     WHERE ID_INVIO_SCHEDA <> pIdInvioScheda);
             RETURN recTInvioScheda;
    END SelectTInvioSchedaPrecedente;

    /*********************************************************************
    Genera un file di testo contenente la chiave catastale delle particelle
    estirpate rispetto all'invio precedente
    Tipo:  function
    input: pPathName, pRecInvioScheda, pNomeFileEstirpate
    output: nessuno
    ritorno: nNumParticelle
    *********************************************************************/
    PROCEDURE GenerazioneFileEstirpo (pPathName          IN VARCHAR2,
                                      pNomeFileEstirpate IN VARCHAR2,
                                      pDataEstirpiDa     IN DATE) IS


        -- cursore delle particelle estirpate totalmente
        -- sia per eliminazione delle unità vitate che
        -- per frazionamento / accorpamento della particella
        CURSOR curParticelleEstirpate (pDataApp IN DATE) IS
        SELECT SP.*
          FROM DB_STORICO_PARTICELLA SP
         WHERE SP.DATA_FINE_VALIDITA IS NULL
           AND SP.ID_PARTICELLA IN (
        WITH UV_CAMBIO_PARTICELLA AS (
        SELECT A.ID_UNITA_ARBOREA,
               MAX(ID_STORICO_UNITA_ARBOREA) AS MAX_ID,
               COUNT(DISTINCT ID_PARTICELLA)
          FROM DB_STORICO_UNITA_ARBOREA A
         WHERE (A.DATA_AGGIORNAMENTO > pDataApp OR a.DATA_FINE_VALIDITA > pDataApp)
           AND A.ID_TIPOLOGIA_UNAR = knIdTipologiaUnarVino
      GROUP BY A.ID_UNITA_ARBOREA
  HAVING COUNT(DISTINCT A.ID_PARTICELLA) > 1)
      SELECT U.ID_PARTICELLA
        FROM DB_STORICO_UNITA_ARBOREA U,
             UV_CAMBIO_PARTICELLA A
       WHERE A.ID_UNITA_ARBOREA = U.ID_UNITA_ARBOREA
         AND (U.DATA_AGGIORNAMENTO > pDataApp OR U.DATA_FINE_VALIDITA > pDataApp)
         AND U.ID_PARTICELLA <> (SELECT B.ID_PARTICELLA
                                   FROM DB_STORICO_UNITA_ARBOREA B
                                  WHERE B.ID_STORICO_UNITA_ARBOREA = A.MAX_ID)
         AND NOT EXISTS (SELECT C.ID_PARTICELLA
                           FROM DB_STORICO_UNITA_ARBOREA C,
                                DB_CONDUZIONE_PARTICELLA CP,
                                DB_UTE U
                          WHERE C.ID_PARTICELLA = U.ID_PARTICELLA
                            AND C.ID_AZIENDA IS NOT NULL
                            AND C.DATA_FINE_VALIDITA IS NULL
                            AND C.ID_PARTICELLA = CP.ID_PARTICELLA
                            AND C.ID_TIPOLOGIA_UNAR = knIdTipologiaUnarVino
                            AND CP.DATA_FINE_CONDUZIONE IS NULL
                            AND U.ID_AZIENDA = C.ID_AZIENDA
                            AND U.DATA_FINE_ATTIVITA IS NULL
                            AND U.ID_UTE = CP.ID_UTE)

        UNION


        SELECT SUA.ID_PARTICELLA
          FROM DB_STORICO_UNITA_ARBOREA SUA
         WHERE SUA.ID_STORICO_UNITA_ARBOREA = (SELECT MAX(MAXSUA.ID_STORICO_UNITA_ARBOREA)
                                                 FROM DB_STORICO_UNITA_ARBOREA MAXSUA
                                                WHERE MAXSUA.ID_UNITA_ARBOREA = SUA.ID_UNITA_ARBOREA)
           AND (SUA.DATA_FINE_VALIDITA IS NOT NULL OR SUA.ID_AZIENDA IS NULL)
           AND SUA.DATA_AGGIORNAMENTO > pDataApp
           AND SUA.ID_TIPOLOGIA_UNAR = knIdTipologiaUnarVino
           AND NOT EXISTS (SELECT ALTRESUA.ID_PARTICELLA
                             FROM DB_STORICO_UNITA_ARBOREA ALTRESUA,
                                  DB_CONDUZIONE_PARTICELLA CP,
                                  DB_UTE U
                            WHERE ALTRESUA.ID_PARTICELLA = SUA.ID_PARTICELLA
                              AND ALTRESUA.ID_AZIENDA IS NOT NULL
                              AND ALTRESUA.DATA_FINE_VALIDITA IS NULL
                              AND ALTRESUA.ID_PARTICELLA = CP.ID_PARTICELLA
                              AND ALTRESUA.ID_TIPOLOGIA_UNAR = knIdTipologiaUnarVino
                              AND CP.DATA_FINE_CONDUZIONE IS NULL
                              AND U.ID_AZIENDA = ALTRESUA.ID_AZIENDA
                              AND U.DATA_FINE_ATTIVITA IS NULL
                              AND U.ID_UTE = CP.ID_UTE));

        vRiga               VARCHAR2(20);
        fFileEstirpo        UTL_FILE.FILE_TYPE;
        nNumParticelle      INTEGER:=0;
    BEGIN
        PCK_SMRGAA_LOG.LogInfo ('Inizio Generazione file particelle estirpate dal : ' || TO_CHAR(pDataEstirpiDa,'DD/MM/YYYY HH24:MI:SS'));
        -- apro un file
        fFileEstirpo := UTL_FILE.FOPEN( pPathName, pNomeFileEstirpate, 'W');
        -- apro un cursore che mi dice quali particelle c'erano nel vecchio
        -- invio e non ci sono più in questo
        FOR recParticelleEstirpate IN curParticelleEstirpate (pDataEstirpiDa) LOOP
            -- concateno la stringa contenente la chiave catastale opportunamente paddata
            vRiga := recParticelleEstirpate.SEZIONE || '|' ||
                     recParticelleEstirpate.COMUNE || '|' ||
                     recParticelleEstirpate.FOGLIO || '|' ||
                     recParticelleEstirpate.PARTICELLA || '|' ||
                     recParticelleEstirpate.SUBALTERNO || '|';
            -- la scrivo nel file
            UTL_FILE.PUT_LINE( fFileEstirpo, vRiga );
            -- ed incremento il contatore
            nNumParticelle := nNumParticelle + 1;
        END LOOP;
        -- chiudo il file
        UTL_FILE.FCLOSE(fFileEstirpo);
        PCK_SMRGAA_LOG.LogInfo ('Fine Generazione file particelle estirpate');
        -- se ho concatenato e quindi estirpato almeno una particella
        IF nNumParticelle > 0 THEN
           -- do apposito messaggio col numero di particelle
           PCK_SMRGAA_LOG.LogInfo ('Estirpate : ' || TO_CHAR(nNumParticelle));
        ELSE
           -- altrimenti do apposito messaggio di nessuna particella da estirpare
           PCK_SMRGAA_LOG.LogInfo ('Nessuna particella da estirpare');

        END IF;

        --RETURN nNumParticelle;

    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('GenerazioneFileEstirpo - pDataEstirpiDa = ' || TO_CHAR(pDataEstirpiDa,'DD/MM/YYYY HH24:MI:SS'));
             IF UTL_FILE.IS_OPEN( fFileEstirpo ) THEN
                UTL_FILE.FCLOSE( fFileEstirpo );
             END IF;
             RAISE;
    END GenerazioneFileEstirpo;

    /*********************************************************************
    Genera un file di testo contenente la chiave catastale delle particelle
    estirpate rispetto all'invio precedente
    Tipo:  function
    input: pPathName, pNomeFileUnar ,pNomeFileAttUnar, pDataDal, pGestioneVigne
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE GenerazioneFileNuoveSchede (pPathName          IN VARCHAR2,
                                          pNomeFileUnar      IN VARCHAR2,
                                          pNomeFileAttUnar   IN VARCHAR2,
                                          pDataDal           IN DATE,
                                          pGestioneVigne     IN VARCHAR2
                                          ) IS

        /* Cursore che mi estrae i dati relativi alle schede agronomiche di unita'
        vitate variate */
        CURSOR curUvVariataForSchedaAgr (pDataOffSet IN DATE) IS
        SELECT SUA.ID_STORICO_UNITA_ARBOREA,
               kvCodTipologiaUnarVino AS TIPO_UNAR,
               SP.COMUNE,
               SP.SEZIONE,
               SP.FOGLIO,
               SP.PARTICELLA,
               SP.SUBALTERNO,
               TT.CODICE AS CODICE_TERRAZZAMENTO,
               SUA.PROGR_UNAR,
               SUA.AREA,
               SUA.AREA_SERVIZIO,
               SUA.SESTO_SU_FILA,
               SUA.SESTO_TRA_FILE,
               SUA.NUM_CEPPI,
               SUA.DATA_IMPIANTO,
               SUA.DATA_INIZIO_VALIDITA,
               NVL(SUA.DATA_FINE_VALIDITA, TO_DATE('31/12/9999','DD/MM/YYYY')) AS DATA_FINE_VALIDITA,
               SUA.PERCENTUALE_FALLANZA,
               SUA.METRI_ALTITUDINE_MEDIA, 
               SUA.DATA_CESSAZIONE,
               SUA.DATA_AGGIORNAMENTO,
               SUA.DATA_SOVRAINNESTO,
               SUA.DATA_ISCRIZIONE_ALBO,
               NVL(TFA.CODICE_SIAN,'99') AS COD_FORMA_ALLEVAMENTO, -- se null metto 99 (altra forma) 
               NVL(TIU.CODICE,'0') AS COD_TIPO_IRRIGAZIONE, -
               --USD.CODICE AS COD_DEST_PROD,
               NVL(CM.CODICE_UV_SITI,11) COD_DEST_PROD,  -
               NVL(TCU.CODICE,'0') AS COD_COLTIVAZIONE_UNAR, -- se null metto 0 (non impostata)
               SCU.CODICE AS STATO_COLT_UNAR,
               TAU.CODICE AS CODICE_ANCORAGGIO,
               TPU.CODICE AS TIPO_PALO_TESSITURA,
               TPUT.CODICE AS TIPO_PALO_TESTATA,
               TFS.CODICE AS CODICE_FILO_SOSTEGNO,
               TTV.DENOMINAZIONE_MIPAF,
               TTV.SOTTOZONA_MIPAF,
               TTV.VARIETALE_MIPAF,
               TTV.ID_COLORE_MIPAF,
               NVL(TTV.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','DD/MM/YYYY')) AS DATA_REVOCA,
               SUA.DISTANZA_PALI,
               SUA.PERCENTUALE_PENDENZA_MEDIA, 
               TV.CODICE_VARIETA,
               DECODE(pGestioneVigne,'S',SUA.ID_VIGNA,NULL) AS ID_VIGNA,
               AZ.ID_AZIENDA,
               AZ.CUAA,
               SUA.ID_UNITA_ARBOREA,
               SUA.PERCENTUALE_VARIETA,
               NVL (
              (SELECT CODICE
                 FROM DB_TIPO_GIACITURA_UNAR
                WHERE ID_GIACITURA_UNAR = SUA.ID_GIACITURA_UNAR),
                CASE WHEN SP.ID_TERRAZZAMENTO IN (2,4) THEN
                     '4'
                ELSE
                    CASE WHEN SP.PERCENTUALE_PENDENZA_MEDIA < 1 THEN
                         '0'
                    WHEN SP.PERCENTUALE_PENDENZA_MEDIA >= 1 AND SP.PERCENTUALE_PENDENZA_MEDIA < 15 THEN
                         '1'
                    WHEN SP.PERCENTUALE_PENDENZA_MEDIA >= 15 AND SP.PERCENTUALE_PENDENZA_MEDIA < 25 THEN
                         '2'
                    WHEN SP.PERCENTUALE_PENDENZA_MEDIA >= 25 THEN
                         '3'
                    END
                END) AS TIPO_GIACITURA_UNAR
          FROM DB_STORICO_UNITA_ARBOREA SUA,
               DB_STORICO_PARTICELLA SP,
               DB_ANAGRAFICA_AZIENDA AZ,
               DB_TIPO_VARIETA TV,
               DB_TIPO_FORMA_ALLEVAMENTO TFA,
               DB_TIPO_IRRIGAZIONE_UNAR TIU,
               DB_TIPO_COLTIVAZIONE_UNAR TCU,
               DB_TIPO_TERRAZZAMENTO TT,
               DB_STATO_COLTIVAZIONE_UNAR SCU,
               DB_TIPO_ANCORAGGIO_UNAR TAU,
               DB_TIPO_PALO_UNAR TPU,
               DB_TIPO_PALO_UNAR TPUT,
               DB_TIPO_FILO_SOSTEGNO TFS,
               DB_TIPO_TIPOLOGIA_VINO TTV,
               --DB_R_UTILIZZO_SITIUNAR_DECO USD,
               COMUNE C,
               PROVINCIA P,DB_R_CATALOGO_MATRICE CM -- RC 08/03/2016
         WHERE AZ.ID_AZIENDA = SUA.ID_AZIENDA
           AND AZ.DATA_FINE_VALIDITA IS NULL
           -- AND AZ.DATA_CESSAZIONE IS NULL
           -- AND SUA.DATA_AGGIORNAMENTO > pDataOffSet
           AND SUA.ID_STORICO_UNITA_ARBOREA IN (SELECT ID_STORICO_UNITA_ARBOREA
                                                  FROM DB_STORICO_UNITA_ARBOREA
                                                 WHERE ID_UNITA_ARBOREA = SUA.ID_UNITA_ARBOREA
                                                   AND DATA_AGGIORNAMENTO > pDataDal)
           AND SUA.ID_TIPOLOGIA_UNAR = knIdTipologiaUnarVino
           -- AND SUA.DATA_FINE_VALIDITA IS NULL
           -- AND SUA.DATA_CESSAZIONE IS NULL
           AND SUA.DATA_IMPIANTO IS NOT NULL
           AND SUA.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND CM.ID_VARIETA = TV.ID_VARIETA 
           AND SUA.ID_FORMA_ALLEVAMENTO = TFA.ID_FORMA_ALLEVAMENTO (+)
           AND SUA.ID_IRRIGAZIONE_UNAR = TIU.ID_IRRIGAZIONE_UNAR (+)
           AND SUA.ID_COLTIVAZIONE_UNAR = TCU.ID_COLTIVAZIONE_UNAR (+)
           AND SP.ID_TERRAZZAMENTO = TT.ID_TERRAZZAMENTO
           AND SUA.ID_STATO_COLTIVAZIONE_UNAR = SCU.ID_STATO_COLTIVAZIONE_UNAR (+)
           AND SUA.ID_ANCORAGGIO_UNAR = TAU.ID_ANCORAGGIO_UNAR (+)
           AND SUA.ID_PALO_TESSITURA = TPU.ID_PALO_UNAR (+)
           AND SUA.ID_PALO_TESTATA = TPUT.ID_PALO_UNAR (+)
           AND SUA.ID_FILO_SOSTEGNO = TFS.ID_FILO_SOSTEGNO (+)
           AND SUA.ID_TIPOLOGIA_VINO = TTV.ID_TIPOLOGIA_VINO (+)
           AND SUA.ID_PARTICELLA = SP.ID_PARTICELLA
           AND SP.DATA_FINE_VALIDITA IS NULL
           AND SP.PARTICELLA IS NOT NULL 
           --AND CM.ID_UTILIZZO = USD.ID_UTILIZZO
           --AND USD.TIPO_UNAR = kvCodTipologiaUnarVino
           --AND USD.NOME_CAMPO = 'COD_DEST_PROD'
           AND SP.COMUNE = C.ISTAT_COMUNE
           AND C.ISTAT_PROVINCIA = P.ISTAT_PROVINCIA
           AND P.ID_REGIONE = kvIdRegionePiemonte;

        CURSOR curAltroVitignoUv (pIdStoricoUnitaArborea IN DB_STORICO_UNITA_ARBOREA.ID_STORICO_UNITA_ARBOREA%TYPE) IS
        SELECT AV.PERCENTUALE_VITIGNO,
               TV.CODICE_VARIETA
          FROM DB_ALTRO_VITIGNO AV,
               DB_TIPO_VARIETA TV
         WHERE AV.ID_STORICO_UNITA_ARBOREA = pIdStoricoUnitaArborea
           AND AV.ID_VARIETA = TV.ID_VARIETA;


        CURSOR curNuoveSchedeAgrFag (pDataOffSet IN DATE) IS
        SELECT NUNAR.ID_AZIENDA,
               AZ.CUAA,
               NUNAR.ID_PARTICELLA,
               SP.SEZIONE,
               SP.COMUNE,
               SP.FOGLIO,
               SP.PARTICELLA,
               SP.SUBALTERNO,
               NUNAR.AREA,
               NUNAR.SESTO_SU_FILE,
               NUNAR.SESTO_TRA_FILE,
               NUNAR.NUMERO_CEPPI,
               NUNAR.ANNO_IMPIANTO,
               '01/01/' || NUNAR.ANNO_IMPIANTO AS DATA_IMPIANTO,
               NUNAR.TIPO_COLTIVAZIONE_UNAR,
               NUNAR.CODICE_VARIETA,
               TT.CODICE AS CODICE_TERRAZZAMENTO,
               SP.PERCENTUALE_PENDENZA_MEDIA,
               SP.METRI_ALTITUDINE_MEDIA,
               CASE WHEN SP.ID_TERRAZZAMENTO IN (2,4) THEN
                    '4'
               ELSE
                    CASE WHEN SP.PERCENTUALE_PENDENZA_MEDIA < 1 THEN
                         '0'
                    WHEN SP.PERCENTUALE_PENDENZA_MEDIA >= 1 AND SP.PERCENTUALE_PENDENZA_MEDIA < 15 THEN
                         '1'
                    WHEN SP.PERCENTUALE_PENDENZA_MEDIA >= 15 AND SP.PERCENTUALE_PENDENZA_MEDIA < 25 THEN
                         '2'
                    WHEN SP.PERCENTUALE_PENDENZA_MEDIA >= 25 THEN
                         '3'
                    END
               END AS TIPO_GIACITURA_UNAR
          FROM (
        SELECT AZ.ID_AZIENDA,
               SP.ID_PARTICELLA,
               UP.SUPERFICIE_UTILIZZATA * 10000 AS AREA,
               UP.SESTO_SU_FILE,
               UP.SESTO_TRA_FILE,
               NVL(UP.NUMERO_PIANTE_CEPPI,0) AS NUMERO_CEPPI,
               UP.ANNO_IMPIANTO,
               CASE WHEN INSTR(UPPER(TI.DESCRIZIONE),'CONS') > 0 THEN
                    '2'
                    WHEN INSTR(UPPER(TI.DESCRIZIONE),'SPEC') > 0 THEN
                    '1'
                    ELSE
                    '0'
               END TIPO_COLTIVAZIONE_UNAR,
               USD.CODICE AS CODICE_VARIETA
          FROM DB_UTE U,
               DB_CONDUZIONE_PARTICELLA CP,
               DB_STORICO_PARTICELLA SP,
               COMUNE C,
               PROVINCIA P,
               DB_UTILIZZO_PARTICELLA UP,
               DB_TIPO_IMPIANTO TI,
               DB_R_UTILIZZO_SITIUNAR_DECO USD,
               DB_ANAGRAFICA_AZIENDA AZ,DB_R_CATALOGO_MATRICE CM
         WHERE AZ.DATA_FINE_VALIDITA IS NULL
           AND AZ.DATA_CESSAZIONE IS NULL
           AND U.ID_AZIENDA = AZ.ID_AZIENDA
           AND U.DATA_FINE_ATTIVITA IS NULL
           AND U.ID_UTE = CP.ID_UTE
           AND CP.DATA_FINE_CONDUZIONE IS NULL
           AND CP.ID_TITOLO_POSSESSO NOT IN (knIdTitPossessoAsservimento,
                                             knIdTitpossessoConferimento)
           AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
           AND SP.DATA_FINE_VALIDITA IS NULL
           AND SP.PARTICELLA IS NOT NULL
           AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
           AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND UP.ANNO_IMPIANTO IS NOT NULL
           AND UP.DATA_AGGIORNAMENTO > pDataOffSet
           AND CM.FLAG_FRUTTA_GUSCIO = 'S' 
           AND UP.ID_IMPIANTO = TI.ID_IMPIANTO (+)
           AND CM.ID_UTILIZZO = USD.ID_UTILIZZO
           AND USD.TIPO_UNAR = kvCodTipologiaUnarFag
           AND USD.NOME_CAMPO = 'COD_VARIETA'
           AND SP.COMUNE = C.ISTAT_COMUNE
           AND C.ISTAT_PROVINCIA = P.ISTAT_PROVINCIA
           AND P.ID_REGIONE = kvIdRegionePiemonte

         MINUS

        SELECT ID_AZIENDA,
               ID_PARTICELLA,
               AREA,
               SESTO_SU_FILA,
               SESTO_TRA_FILE,
               NUM_CEPPI,
               ANNO_IMPIANTO,
               TIPO_COLTIVAZIONE_UNAR,
               COD_VARIETA_FG
          FROM SMRGAA_W_UNAR_FAG_INVIATA
         WHERE DATA_FINE_VALIDITA IS NULL
           AND ANNO_IMPIANTO IS NOT NULL) NUNAR,
          DB_STORICO_PARTICELLA SP,
          DB_ANAGRAFICA_AZIENDA AZ,
          DB_TIPO_TERRAZZAMENTO TT
        WHERE NUNAR.ID_PARTICELLA = SP.ID_PARTICELLA
          AND SP.DATA_FINE_VALIDITA IS NULL
          AND AZ.ID_AZIENDA = NUNAR.ID_AZIENDA
          AND AZ.DATA_FINE_VALIDITA IS NULL
          AND SP.ID_TERRAZZAMENTO = TT.ID_TERRAZZAMENTO
     ORDER BY ID_AZIENDA;

        CURSOR curSchedeAgrFagCessate IS
        SELECT FI.ID_AZIENDA,
               AA.CUAA,
               FI.ID_PARTICELLA,
               0 AS PROGR_UNAR,
               SP.SEZIONE,
               SP.COMUNE,
               SP.FOGLIO,
               SP.PARTICELLA,
               SP.SUBALTERNO,
               FI.AREA,
               FI.SESTO_SU_FILA,
               FI.SESTO_TRA_FILE,
               FI.NUM_CEPPI,
               FI.ANNO_IMPIANTO,
               '01/01/' || FI.ANNO_IMPIANTO AS DATA_IMPIANTO,
               FI.TIPO_COLTIVAZIONE_UNAR,
               FI.COD_VARIETA_FG,
               FI.DATA_INIZIO_VALIDITA,
               TT.CODICE AS CODICE_TERRAZZAMENTO,
               SP.PERCENTUALE_PENDENZA_MEDIA,
               SP.METRI_ALTITUDINE_MEDIA
          FROM SMRGAA_W_UNAR_FAG_INVIATA FI,
               DB_STORICO_PARTICELLA SP,
               DB_ANAGRAFICA_AZIENDA AA,
               DB_TIPO_TERRAZZAMENTO TT
         WHERE FI.DATA_FINE_VALIDITA IS NULL
           AND FI.ANNO_IMPIANTO IS NOT NULL
           AND FI.ID_PARTICELLA = SP.ID_PARTICELLA
           AND SP.DATA_FINE_VALIDITA IS NULL
           AND SP.ID_TERRAZZAMENTO = TT.ID_TERRAZZAMENTO 
           AND AA.ID_AZIENDA = FI.ID_AZIENDA
           AND AA.DATA_FINE_VALIDITA IS NULL
           AND NOT EXISTS (
        SELECT UP.ID_UTILIZZO_PARTICELLA
          FROM DB_UTE U,
               DB_CONDUZIONE_PARTICELLA CP,
               DB_UTILIZZO_PARTICELLA UP,
               DB_TIPO_IMPIANTO TI,
               DB_R_UTILIZZO_SITIUNAR_DECO USD,
               DB_ANAGRAFICA_AZIENDA AZ,DB_R_CATALOGO_MATRICE CM
         WHERE AZ.DATA_FINE_VALIDITA IS NULL
           AND AZ.DATA_CESSAZIONE IS NULL
           AND U.ID_AZIENDA = AZ.ID_AZIENDA
           AND U.DATA_FINE_ATTIVITA IS NULL
           AND U.ID_UTE = CP.ID_UTE
           AND AZ.ID_AZIENDA = FI.ID_AZIENDA
           AND CP.DATA_FINE_CONDUZIONE IS NULL
           AND CP.ID_TITOLO_POSSESSO NOT IN (knIdTitPossessoAsservimento, knIdTitpossessoConferimento)
           AND CP.ID_PARTICELLA = FI.ID_PARTICELLA
           AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
           AND UP.SUPERFICIE_UTILIZZATA * 10000 = FI.AREA
           AND USD.CODICE = FI.COD_VARIETA_FG
           AND CASE
                  WHEN INSTR (UPPER (TI.DESCRIZIONE), 'CONS') > 0 THEN '2'
                  WHEN INSTR (UPPER (TI.DESCRIZIONE), 'SPEC') > 0 THEN '1'
                  ELSE '0'
               END = FI.TIPO_COLTIVAZIONE_UNAR
           AND NVL(UP.SESTO_SU_FILE,-1) = NVL(FI.SESTO_SU_FILA,-1)
           AND NVL(UP.SESTO_TRA_FILE,-1) = NVL(FI.SESTO_TRA_FILE,-1)
           AND NVL(UP.NUMERO_PIANTE_CEPPI,0) = FI.NUM_CEPPI
           AND UP.ANNO_IMPIANTO = FI.ANNO_IMPIANTO
           AND UP.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND CM.FLAG_FRUTTA_GUSCIO = 'S' 
           AND UP.ID_IMPIANTO = TI.ID_IMPIANTO (+)
           AND CM.ID_UTILIZZO = USD.ID_UTILIZZO 
           AND USD.TIPO_UNAR = kvCodTipologiaUnarFag
           AND USD.NOME_CAMPO = 'COD_VARIETA');

        -- accodo le fag nel file dopo aver
        -- popolato la tabella di appoggio e non più durante il popolamento
        CURSOR curUnarFagDaInviare (pDataOffSet IN DATE) IS
        SELECT FI.*,
               '01/01/' || FI.ANNO_IMPIANTO AS DATA_IMPIANTO,
               SP.COMUNE,
               SP.SEZIONE,
               SP.FOGLIO,
               SP.PARTICELLA,
               SP.SUBALTERNO,
               SP.PERCENTUALE_PENDENZA_MEDIA,
               SP.METRI_ALTITUDINE_MEDIA,
               CASE WHEN SP.ID_TERRAZZAMENTO IN (2,4) THEN
                    '4'
               ELSE
                    CASE WHEN SP.PERCENTUALE_PENDENZA_MEDIA < 1 THEN
                         '0'
                    WHEN SP.PERCENTUALE_PENDENZA_MEDIA >= 1 AND SP.PERCENTUALE_PENDENZA_MEDIA < 15 THEN
                         '1'
                    WHEN SP.PERCENTUALE_PENDENZA_MEDIA >= 15 AND SP.PERCENTUALE_PENDENZA_MEDIA < 25 THEN
                         '2'
                    WHEN SP.PERCENTUALE_PENDENZA_MEDIA >= 25 THEN
                         '3'
                    END
               END AS TIPO_GIACITURA_UNAR,
               TT.CODICE AS CODICE_TERRAZZAMENTO,
               AA.CUAA
          FROM SMRGAA_W_UNAR_FAG_INVIATA FI,
               DB_STORICO_PARTICELLA SP,
               DB_TIPO_TERRAZZAMENTO TT,
               DB_ANAGRAFICA_AZIENDA AA
         WHERE (FI.DATA_INVIO > pDataOffSet OR FI.DATA_FINE_VALIDITA > pDataOffSet)
           AND FI.ID_PARTICELLA = SP.ID_PARTICELLA
           AND SP.DATA_FINE_VALIDITA IS NULL
           AND SP.ID_TERRAZZAMENTO = TT.ID_TERRAZZAMENTO
           AND FI.ID_AZIENDA = AA.ID_AZIENDA
           AND AA.DATA_FINE_VALIDITA IS NULL
      ORDER BY FI.DATA_FINE_VALIDITA , FI.DATA_INVIO;



        vRiga           VARCHAR2(300);
        fFileUnar       UTL_FILE.FILE_TYPE;
        fFileAttUnarUv  UTL_FILE.FILE_TYPE;
        nNumUnarVar     INTEGER:=0;
        nNumFagVar      INTEGER:=0;
        nNumFagEst      INTEGER:=0;
        recTAzScheda    SMRGAA_W_AZIENDE_SCHEDE%ROWTYPE;
        recTUnarFagInv  SMRGAA_W_UNAR_FAG_INVIATA%ROWTYPE;
    BEGIN

        fFileUnar := UTL_FILE.FOPEN( pPathName, pNomeFileUnar, 'W');
        fFileAttUnarUv := UTL_FILE.FOPEN( pPathName, pNomeFileAttUnar, 'W');

        PCK_SMRGAA_LOG.LogInfo ('Inizio generazione file nuove schede agronomiche');
        -- scorro il cursore e preparo la riga per la scrittura nell'apposito
        -- file di testo
        FOR recUvVariataForSchedaAgr IN curUvVariataForSchedaAgr (pDataDal) LOOP
            BEGIN

                vRiga := SUBSTR(recUvVariataForSchedaAgr.COMUNE,1,3) || '|' ||
                         SUBSTR(recUvVariataForSchedaAgr.COMUNE,4,3) || '|' ||
                         recUvVariataForSchedaAgr.SEZIONE || '|' ||
                         recUvVariataForSchedaAgr.FOGLIO || '|' ||
                         recUvVariataForSchedaAgr.PARTICELLA || '|' ||
                         recUvVariataForSchedaAgr.SUBALTERNO || '|' ||
                         TO_CHAR(recUvVariataForSchedaAgr.DATA_INIZIO_VALIDITA,'DD/MM/YYYY HH24:MI:SS') || '|' ||
                         TO_CHAR(recUvVariataForSchedaAgr.DATA_FINE_VALIDITA,'DD/MM/YYYY HH24:MI:SS') || '|' ||
                         recUvVariataForSchedaAgr.TIPO_UNAR || '|' ||
                         TO_CHAR(recUvVariataForSchedaAgr.DATA_IMPIANTO,'DD/MM/YYYY') || '|' ||
                         TRIM(TO_CHAR(recUvVariataForSchedaAgr.AREA * 10000)) || '|' ||
                         TRIM(TO_CHAR(recUvVariataForSchedaAgr.AREA_SERVIZIO * 10000)) || '|' ||
                         recUvVariataForSchedaAgr.SESTO_SU_FILA || '|' ||
                         recUvVariataForSchedaAgr.SESTO_TRA_FILE || '|' ||
                         recUvVariataForSchedaAgr.NUM_CEPPI || '|' ||
                         recUvVariataForSchedaAgr.PERCENTUALE_PENDENZA_MEDIA * 100 || '|' ||
                         recUvVariataForSchedaAgr.METRI_ALTITUDINE_MEDIA || '|' ||
                         TO_CHAR(recUvVariataForSchedaAgr.DATA_CESSAZIONE,'DD/MM/YYYY HH24:MI:SS') || '|' ||
                         recUvVariataForSchedaAgr.CODICE_VARIETA || '|' ||
                         recUvVariataForSchedaAgr.COD_FORMA_ALLEVAMENTO || '|' ||
                         recUvVariataForSchedaAgr.COD_TIPO_IRRIGAZIONE || '|' ||
                         recUvVariataForSchedaAgr.COD_DEST_PROD || '|' ||
                         recUvVariataForSchedaAgr.PERCENTUALE_FALLANZA || '|' ||
                         recUvVariataForSchedaAgr.CODICE_TERRAZZAMENTO || '|' ||
                         recUvVariataForSchedaAgr.STATO_COLT_UNAR || '|' ||
                         recUvVariataForSchedaAgr.CODICE_ANCORAGGIO || '|' ||
                         recUvVariataForSchedaAgr.TIPO_PALO_TESTATA || '|' ||
                         recUvVariataForSchedaAgr.TIPO_PALO_TESSITURA || '|' ||
                         recUvVariataForSchedaAgr.DISTANZA_PALI || '|' ||
                         recUvVariataForSchedaAgr.CODICE_FILO_SOSTEGNO || '|' ||
                         TO_CHAR(recUvVariataForSchedaAgr.DATA_AGGIORNAMENTO,'DD/MM/YYYY HH24:MI:SS') || '|' ||
                         -- recUvVariataForSchedaAgr.ID_UNITA_ARBOREA || '|' ||  
                         recUvVariataForSchedaAgr.ID_STORICO_UNITA_ARBOREA || '|' ||
                         TO_CHAR(recUvVariataForSchedaAgr.DATA_SOVRAINNESTO,'DD/MM/YYYY') || '|' ||
                         recUvVariataForSchedaAgr.PROGR_UNAR || '|' ||
                         recUvVariataForSchedaAgr.ID_UNITA_ARBOREA || '|' || 
                         recUvVariataForSchedaAgr.CUAA || '|' ||
                         recUvVariataForSchedaAgr.DENOMINAZIONE_MIPAF || '|' ||
                         recUvVariataForSchedaAgr.SOTTOZONA_MIPAF || '|' ||
                         recUvVariataForSchedaAgr.VARIETALE_MIPAF || '|' ||
                         recUvVariataForSchedaAgr.ID_COLORE_MIPAF || '|' ||
                         TO_CHAR(recUvVariataForSchedaAgr.DATA_ISCRIZIONE_ALBO,'DD/MM/YYYY') || '|' ||
                         TO_CHAR(recUvVariataForSchedaAgr.DATA_REVOCA,'DD/MM/YYYY') || '|' ||
                         recUvVariataForSchedaAgr.ID_VIGNA || '|' ||
                         recUvVariataForSchedaAgr.TIPO_GIACITURA_UNAR || '|';

                UTL_FILE.PUT_LINE(fFileUnar,vRiga);


                vRiga := recUvVariataForSchedaAgr.ID_STORICO_UNITA_ARBOREA || '|' ||
                         recUvVariataForSchedaAgr.CODICE_VARIETA || '|' ||
                         'P' || '|' ||
                         recUvVariataForSchedaAgr.PERCENTUALE_VARIETA || '|'; 

                UTL_FILE.PUT_LINE(fFileAttUnarUv,vRiga);

                FOR recAltroVitignoUv IN curAltroVitignoUv (recUvVariataForSchedaAgr.ID_STORICO_UNITA_ARBOREA) LOOP
                    vRiga := recUvVariataForSchedaAgr.ID_STORICO_UNITA_ARBOREA || '|' ||
                             recAltroVitignoUv.CODICE_VARIETA || '|' ||
                             'A' || '|' ||
                             recAltroVitignoUv.PERCENTUALE_VITIGNO || '|';

                    UTL_FILE.PUT_LINE(fFileAttUnarUv,vRiga);
                END LOOP;


                UPDATE DB_STORICO_UNITA_ARBOREA
                   SET DATA_INVIO_SCHEDA = SYSDATE
                 WHERE ID_STORICO_UNITA_ARBOREA = recUvVariataForSchedaAgr.ID_STORICO_UNITA_ARBOREA;

                COMMIT;

                nNumUnarVar := nNumUnarVar + 1;

            EXCEPTION
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('GenerazioneFileNuoveSchede - Tipo Unar : ' || TO_CHAR(recUvVariataForSchedaAgr.TIPO_UNAR) || ' - Identificativo : ' || TO_CHAR(recUvVariataForSchedaAgr.ID_STORICO_UNITA_ARBOREA));
                     RAISE;
            END;
        END LOOP;

        UTL_FILE.FCLOSE( fFileAttUnarUv );

        FOR recNuoveSchedeAgrFag IN curNuoveSchedeAgrFag (pDataDal) LOOP
            BEGIN

                SELECT SEQ_SMRGAA_W_UNAR_FAG_INVIATA.nextval
                  INTO recTUnarFagInv.ID_UNAR_FAG_INVIATA
                  FROM DUAL;

                recTUnarFagInv.ID_AZIENDA := recNuoveSchedeAgrFag.ID_AZIENDA;
                recTUnarFagInv.ID_PARTICELLA := recNuoveSchedeAgrFag.ID_PARTICELLA;
                recTUnarFagInv.AREA := recNuoveSchedeAgrFag.AREA;
                recTUnarFagInv.SESTO_SU_FILA := recNuoveSchedeAgrFag.SESTO_SU_FILE;
                recTUnarFagInv.SESTO_TRA_FILE := recNuoveSchedeAgrFag.SESTO_TRA_FILE;
                recTUnarFagInv.NUM_CEPPI := recNuoveSchedeAgrFag.NUMERO_CEPPI;
                recTUnarFagInv.ANNO_IMPIANTO := recNuoveSchedeAgrFag.ANNO_IMPIANTO;
                recTUnarFagInv.TIPO_COLTIVAZIONE_UNAR := recNuoveSchedeAgrFag.TIPO_COLTIVAZIONE_UNAR;
                recTUnarFagInv.COD_VARIETA_FG := recNuoveSchedeAgrFag.CODICE_VARIETA;
                --recTUnarFagInv.TIPO_GIACITURA_UNAR := recNuoveSchedeAgrFag.TIPO_GIACITURA_UNAR;
                recTUnarFagInv.DATA_INIZIO_VALIDITA := TRUNC(SYSDATE);
                recTUnarFagInv.DATA_INVIO := SYSDATE;

                InsertTUnarFagInviata (recTUnarFagInv);

                nNumFagVar := nNumFagVar + 1;


            EXCEPTION
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('GenerazioneFileNuoveSchede - Tipo Unar : ' || TO_CHAR(kvCodTipologiaUnarFag) || ' - Identificativo Particella: ' || TO_CHAR(recNuoveSchedeAgrFag.ID_PARTICELLA));
                     RAISE;
            END;
        END LOOP;

        FOR recSchedeAgrFagCessate IN curSchedeAgrFagCessate LOOP
            BEGIN

                UPDATE SMRGAA_W_UNAR_FAG_INVIATA
                   SET DATA_FINE_VALIDITA = SYSDATE
                 WHERE ID_AZIENDA = recSchedeAgrFagCessate.ID_AZIENDA
                   AND ID_PARTICELLA = recSchedeAgrFagCessate.ID_PARTICELLA
                   AND AREA = recSchedeAgrFagCessate.AREA
                   AND TIPO_COLTIVAZIONE_UNAR = recSchedeAgrFagCessate.TIPO_COLTIVAZIONE_UNAR
                   AND COD_VARIETA_FG = recSchedeAgrFagCessate.COD_VARIETA_FG
                   AND NVL(SESTO_SU_FILA,-1) = NVL(recSchedeAgrFagCessate.SESTO_SU_FILA,-1)
                   AND NVL(SESTO_TRA_FILE,-1) = NVL(recSchedeAgrFagCessate.SESTO_TRA_FILE,-1)
                   AND NUM_CEPPI = recSchedeAgrFagCessate.NUM_CEPPI
                   AND NVL(ANNO_IMPIANTO,-1) = NVL(recSchedeAgrFagCessate.ANNO_IMPIANTO,-1)
                   AND DATA_FINE_VALIDITA IS NULL;

                nNumFagEst := nNumFagEst + 1;

            EXCEPTION
                WHEN OTHERS THEN
                     PCK_SMRGAA_LOG.LogAnomalia ('GenerazioneFileNuoveSchede - Tipo Unar : ' || TO_CHAR(kvCodTipologiaUnarFag) || ' Estirpo - Identificativo Particella: ' || TO_CHAR(recSchedeAgrFagCessate.ID_PARTICELLA));
                     RAISE;
            END;
        END LOOP;


        -- dopo aver popolato / aggiornato la tabella SMRGAA_W_UNAR_FAG_INVIATA
        -- estraggo i record con DATA_INVIO , DATA_FINE_VALIDITA aggiornati
        -- dopo l'ultima esecuzione andata a buon fine e li invio
        FOR recUnarFagDaInviare IN curUnarFagDaInviare (pDataDal) LOOP

            vRiga := SUBSTR(recUnarFagDaInviare.COMUNE,1,3) || '|' ||
                     SUBSTR(recUnarFagDaInviare.COMUNE,4,3) || '|' ||
                     recUnarFagDaInviare.SEZIONE || '|' ||
                     recUnarFagDaInviare.FOGLIO || '|' ||
                     recUnarFagDaInviare.PARTICELLA || '|' ||
                     recUnarFagDaInviare.SUBALTERNO || '|' ||
                     TO_CHAR(recUnarFagDaInviare.DATA_INIZIO_VALIDITA,'DD/MM/YYYY HH24:MI:SS') || '|' ||
                     TO_CHAR(NVL(recUnarFagDaInviare.DATA_FINE_VALIDITA,TO_DATE('31/12/9999','DD/MM/YYYY')), 'DD/MM/YYYY HH24:MI:SS') || '|' ||
                     kvCodTipologiaUnarFag || '|' ||
                     recUnarFagDaInviare.DATA_IMPIANTO || '|' ||
                     TRIM(TO_CHAR(recUnarFagDaInviare.AREA)) || '|' ||
                     NULL || '|' ||
                     recUnarFagDaInviare.SESTO_SU_FILA || '|' ||
                     recUnarFagDaInviare.SESTO_TRA_FILE || '|' ||
                     recUnarFagDaInviare.NUM_CEPPI || '|' ||
                     recUnarFagDaInviare.PERCENTUALE_PENDENZA_MEDIA * 100 || '|' ||
                     recUnarFagDaInviare.METRI_ALTITUDINE_MEDIA || '|' ||
                     NULL || '|' ||
                     recUnarFagDaInviare.COD_VARIETA_FG || '|' ||
                     '0'  || '|' || 
                     '0'  || '|' || 
                     NULL  || '|' ||
                     NULL  || '|' ||
                     recUnarFagDaInviare.CODICE_TERRAZZAMENTO  || '|' || 
                     NULL  || '|' ||
                     NULL  || '|' ||
                     NULL  || '|' ||
                     NULL  || '|' ||
                     NULL  || '|' ||
                     NULL  || '|' ||
                     TO_CHAR(SYSDATE,'DD/MM/YYYY HH24:MI:SS') || '|' ||
                     recUnarFagDaInviare.ID_UNAR_FAG_INVIATA || '|' ||
                     NULL || '|' ||
                     NULL || '|' ||
                     recUnarFagDaInviare.ID_UNAR_FAG_INVIATA || '|' ||
                     recUnarFagDaInviare.CUAA || '|' ||
                     NULL || '|' ||
                     NULL || '|' ||
                     NULL || '|' ||
                     NULL || '|' ||
                     NULL || '|' ||
                     NULL || '|' ||
                     NULL || '|' ||
                     recUnarFagDaInviare.TIPO_GIACITURA_UNAR || '|'; 

            UTL_FILE.PUT_LINE(fFileUnar,vRiga);


        END LOOP;

        UTL_FILE.FCLOSE( fFileUnar );

        PCK_SMRGAA_LOG.LogInfo ('Fine generazione file nuove schede agronomiche');

        IF nNumUnarVar + nNumFagVar + nNumFagEst > 0 THEN
            PCK_SMRGAA_LOG.LogInfo ('Variate ' || TO_CHAR(nNumUnarVar + nNumFagVar + nNumFagEst) || ' schede agronomiche');
        ELSE
            -- altrimenti do apposito messaggio di nessuna particella da estirpare
            PCK_SMRGAA_LOG.LogInfo ('Nessuna scheda agronomica variata rispetto ad invio precedente');
            -- e cancello il file vuoto
--            UTL_FILE.FREMOVE( pPathName, pNomeFileNuove );
        END IF;


    EXCEPTION
        WHEN OTHERS THEN
             PCK_SMRGAA_LOG.LogSqlError ('GenerazioneFileNuoveSchede');
             IF UTL_FILE.IS_OPEN( fFileUnar ) THEN
                UTL_FILE.FCLOSE( fFileUnar );
             END IF;
             IF UTL_FILE.IS_OPEN( fFileAttUnarUv ) THEN
                UTL_FILE.FCLOSE( fFileAttUnarUv );
             END IF;
             RAISE;
    END GenerazioneFileNuoveSchede;

    /*********************************************************************
    Genera i file di testo con i dati delle UV e delle FAG da inviare
    al GIS per la generazione delle schede agronomiche in quanto
    ci sono state delle variazioni (compresa l'eventuale cessazione)
    Tipo:  funzione
    input:  pNomeFileUnar,pNomeFileAttUnar
    output: nessuno
    ritorno: 0 = Ok , 1 = KO
    *********************************************************************/
    FUNCTION GeneraSchedeAgronomiche (pNomeFileUnar        VARCHAR2,
                                      pNomeFileAttUnar     VARCHAR2,
                                      pNomeFileUltimaElab  VARCHAR2) RETURN INTEGER IS


        -- conterrà 0 = Elaborazione Ok e presenti record o 2 = Elaborazione Ok ma nessun record
        -- record di appoggio per il reperimento dei dati dell'applicazione corrente
        recDApplicazione        SMRGAA_D_APPLICAZIONI_BATCH%ROWTYPE;
        -- conterrà l'id esecuzione
        nIdEsecuzione           SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE;
        -- conterrà il codice di ritorno
        nRetCode                NUMBER(1):=0;
        -- record di appoggio che contiene i dati l'ultima esecuzione del batch andata a buon fine
        recTLastEsecOk          SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE;
        -- data dalla quale reperire gli aggiornamenti sulle UNAR
        dDataDal                DATE;
        -- vettore di parametri di input
        vetParametri            PCK_SMRGAA_LOG.TypVetParametriApplicazione;
        -- indica se la gestione delle vigne sul GIS e' abilitata
        vGestioneVigne          VARCHAR2(1);

        fFileUltimaElab  UTL_FILE.FILE_TYPE;


    BEGIN

        nRetCode := Pck_SMRGAA_Log.VerificaAttivazioneBatch( knIdApplicazioneBatchSchede ,recDApplicazione);

        IF nRetCode > 0 THEN
             -- Errore, Batch non attivo
            RETURN nRetCode;
        END IF;

         -- Inserimento in tabella dell'identificativo di esecuzione
         -- nIdEsecuzione restituito in output
        Pck_SMRGAA_Log.InsertTEsecuzione ( knIdApplicazioneBatchSchede, nIdEsecuzione );
        COMMIT;

         -- Scrittura nel file nomefile_esecuzione del nIdEsecuzione
        Pck_SMRGAA_Log.ScriviFileEsecuzione (  recDApplicazione.nomefile_esecuzione,
                                               recDApplicazione.path_file_esecuzione,
                                               nIdEsecuzione );

        Pck_SMRGAA_Log.LeggiFileEsecuzione ( recDApplicazione.nomefile_esecuzione, recDApplicazione.path_file_esecuzione );

        Pck_SMRGAA_Log.SetLogLevel ( recDApplicazione.log_level );

        Pck_SMRGAA_Log.Init( knIdApplicazioneBatchSchede,'GeneraSchedeAgronomiche');

        Pck_SMRGAA_Log.LogInfo ('Inizio Elaborazione');
        -- cerco l'ultima esecuzione del batch precedente a quella attuale andata a buon fine
        recTLastEsecOk := Pck_SMRGAA_Log.SelectTLastEsecuzioneOK (knIdApplicazioneBatchSchede);
        -- se la trova
        IF recTLastEsecOk.ID_ESECUZIONE IS NOT NULL THEN
           -- prendo le variazioni avvenute sulle UNAR dalla data di fine esecuzione
           dDataDal := recTLastEsecOk.DT_FINE_ESECUZIONE;
           Pck_SMRGAA_Log.LogInfo ('Data ultima esecuzione andata a buon fine del batch : ' || TO_CHAR(dDataDal,'DD/MM/YYYY HH24:MI:SS'));
        ELSE
           -- altrimenti prendo le variazione del giorno precedente
           dDataDal := TRUNC(SYSDATE) - 1;
           Pck_SMRGAA_Log.LogInfo ('Non esistono esecuzioni precedenti andate a buon fine, prendo le variazione avvenute dal giorno precedente  : ' || TO_CHAR(dDataDal,'DD/MM/YYYY HH24:MI:SS'));
        END IF;

        fFileUltimaElab := UTL_FILE.FOPEN(recDApplicazione.path_file_esecuzione, pNomeFileUltimaElab, 'W');
        UTL_FILE.PUT_LINE(fFileUltimaElab,TO_CHAR(dDataDal,'YYYYMMDD'));
        UTL_FILE.FCLOSE(fFileUltimaElab);

        -- carico il vettore di parametri
        vetParametri := PCK_SMRGAA_LOG.CaricaParametriApplicazione(knIdApplicazioneBatchSchede);
        -- controllo se ce ne sono
        IF vetParametri.COUNT = 0 THEN
            -- se non ce ne sono segnalo l'informazione
            PCK_SMRGAA_LOG.LogInfo ('Parametro opzionale : ' || kvCodParametroDataDa || ' non presente');
        ELSE
            BEGIN
                -- se c'è però deve essere ok
                dDataDal := vetParametri (kvCodParametroDataDa).val_date;
                Pck_SMRGAA_Log.LogInfo ('Parametro : ' || kvCodParametroDataDa || ' presente : ' || TO_CHAR(dDataDal,'DD/MM/YYYY HH24:MI:SS'));
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    -- in ogni caso uso come data per reperire gli estirpi la data di ultima esecuzione andata a buon fine del batch
                    PCK_SMRGAA_LOG.LogInfo ('Parametro opzionale : ' || kvCodParametroDataDa || ' non presente');
                WHEN OTHERS THEN
                    -- in ogni caso uso come data per reperire gli estirpi la data di ultima esecuzione andata a buon fine del batch
                    -- ma segnalo l'anomalia
                    PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroDataDa || ' non valorizzato correttamente uso data ultima eseuzione');
            END;

            BEGIN
                -- se c'è però deve essere ok
                vGestioneVigne := vetParametri (kvCodParametroGestVigne).val_varchar2;
                Pck_SMRGAA_Log.LogInfo ('Parametro : ' || kvCodParametroGestVigne || ' presente : ' || vGestioneVigne);
            EXCEPTION
                WHEN NO_DATA_FOUND THEN
                    -- in ogni caso uso come data per reperire gli estirpi la data di ultima esecuzione andata a buon fine del batch
                    PCK_SMRGAA_LOG.LogInfo ('Parametro  opzionale : ' || kvCodParametroGestVigne || ' non presente');
                    vGestioneVigne := 'N';
                WHEN OTHERS THEN
                    -- in ogni caso uso come data per reperire gli estirpi la data di ultima esecuzione andata a buon fine del batch
                    -- ma segnalo l'anomalia
                    PCK_SMRGAA_LOG.LogAnomalia ('Parametro ' || kvCodParametroGestVigne || ' non valorizzato correttamente');
                    vGestioneVigne := 'N';
            END;

        END IF;

        -- effettua la generazione del file di testo contenente i dati delle schede agronomiche variate
        -- dall'invio precedente
        GenerazioneFileNuoveSchede (recDApplicazione.path_file_esecuzione,pNomeFileUnar, pNomeFileAttUnar, dDataDal, vGestioneVigne);

        PCK_SMRGAA_LOG.EliminaParametroApplicazione (knIdApplicazioneBatchSchede,kvCodParametroDataDa);
        PCK_SMRGAA_LOG.ValorizzaEsitoBatch;
        COMMIT;

        RETURN 0;

    EXCEPTION
        WHEN OTHERS THEN
             ROLLBACK;
             Pck_SMRGAA_Log.LogSqlError ('GeneraSchedeAgronomiche');
             RETURN 1;
    END GeneraSchedeAgronomiche;

END PCK_SCARICA_SCHEDE_AGRONOMICHE;

/
--------------------------------------------------------
--  DDL for Package Body PCK_SMRGAA_LIBRERIA
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_SMRGAA_LIBRERIA" AS
/*****************************************************************************
Package di libreria che espone function / procedure comuni utilizzate da altri packages
o tramite select o dal java
******************************************************************************/

    FUNCTION IsVarietaAblitataForFonteDt (pIdVarieta IN DB_VARIETA_FONTE.ID_VARIETA%TYPE,
                                          pIdFonte   IN DB_VARIETA_FONTE.ID_FONTE%TYPE,
                                          pDataRif   IN DB_VARIETA_FONTE.DATA_INIZIO_VALIDITA%TYPE
                                          ) RETURN BOOLEAN IS
        nRec INTEGER:=0;
        bRet BOOLEAN:=FALSE;
    BEGIN

        SELECT COUNT(ID_VARIETA_FONTE)
          INTO nRec
          FROM DB_VARIETA_FONTE
         WHERE ID_VARIETA = pIdVarieta
           AND ID_FONTE = pIdFonte
           AND pDataRif BETWEEN DATA_INIZIO_VALIDITA AND NVL(DATA_FINE_VALIDITA, TO_DATE('31/12/9999','DD/MM/YYYY'));

        IF nRec > 0 THEN
           bRet := TRUE;
        END IF;

        RETURN bRet;

    END IsVarietaAblitataForFonteDt;


    /*********************************************************************
    Controlla se tutte le varieta' passate in input sono compatibili
    con la fonte di registo (pascolo) passata in input
    Tipo: function
    input: pStrVetVarieta,pIdFonte
    output: nessuno
    ritorno: TRUE / FALSE
    *********************************************************************/
    FUNCTION AllVarietaInRegistroForFonte (pStrVetVarieta IN VARCHAR2,
                                           pIdFonte       IN DB_VARIETA_FONTE.ID_FONTE%TYPE
                                           ) RETURN BOOLEAN IS
        nCont   INTEGER:=0;
        bRet    BOOLEAN:=TRUE;
    BEGIN

        WITH VARIETA_CONCATENATE AS
           ( SELECT pStrVetVarieta AS VarConc,
                    LEVEL AS pos,
                    SUBSTR(pStrVetVarieta,ROWNUM,1) AS CH,
                    COUNT(CASE WHEN SUBSTR(pStrVetVarieta,ROWNUM,1) = ',' THEN '#' END)
                    OVER (ORDER BY LEVEL) AS section
               FROM dual
         CONNECT BY LEVEL <= LENGTH(pStrVetVarieta)),
             VARIETA AS
           ( SELECT SUBSTR(VarConc,MIN(pos), 1 + MAX(pos) - MIN(pos)) AS ID_VARIETA
               FROM VARIETA_CONCATENATE
              WHERE CH <> ','
           GROUP BY VarConc,section )
        SELECT COUNT(V.ID_VARIETA)
          INTO nCont
          FROM VARIETA V
         WHERE NOT EXISTS (SELECT VF.ID_VARIETA_FONTE
                             FROM DB_VARIETA_FONTE VF
                            WHERE V.ID_VARIETA = VF.ID_VARIETA
                              AND VF.ID_FONTE = pIdFonte
                              AND VF.DATA_FINE_VALIDITA IS NULL);

        IF nCont > 0 THEN
           bRet := FALSE;
        END IF;

        RETURN bRet;

    END AllVarietaInRegistroForFonte;

    /*********************************************************************
    Ricerca la fonte di una particella a  pascolo magro
    Tipo: function
    input: pIdPartCertificata
    output: nessuno
    ritorno: DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE
    *********************************************************************/
    FUNCTION SelTFontePartInRegPascByIdPart (pIdPartCertificata IN DB_ESITO_PASCOLO_MAGRO.ID_PARTICELLA_CERTIFICATA%TYPE)
    RETURN DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE IS
        nIdFonte DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE;
    BEGIN

       SELECT EPM.ID_FONTE
         INTO nIdFonte
         FROM DB_ESITO_PASCOLO_MAGRO EPM,
              DB_TIPO_FONTE TFM
        WHERE EPM.ID_PARTICELLA_CERTIFICATA = pIdPartCertificata
          AND EPM.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                     FROM DB_ESITO_PASCOLO_MAGRO EP,
                                          DB_TIPO_FONTE TF
                                    WHERE EP.ID_PARTICELLA_CERTIFICATA = pIdPartCertificata
                                      AND EP.ID_FONTE = TF.ID_FONTE
                                      AND TF.CALCOLA_ELEGGIBILE = 'S')
          AND EPM.DATA_FINE_VALIDITA IS NULL
          AND EPM.ID_FONTE = TFM.ID_FONTE
          AND TFM.id_fonte IN (4,5,7) 
          AND TFM.CALCOLA_ELEGGIBILE = 'S';

        RETURN nIdFonte;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTFontePartInRegPascByIdPart;

    /*********************************************************************
    Ricerca la fonte di una particella a pascolo magro in un certo anno
    Tipo: function
    input: pIdPartCertificata, pAnnoCampagna
    output: nessuno
    ritorno: DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE
    *********************************************************************/
    FUNCTION SelTFntPrtInRegPascByIdPrtYear (pIdPartCertificata IN DB_ESITO_PASCOLO_MAGRO.ID_PARTICELLA_CERTIFICATA%TYPE,
                                             pAnnoCampagna      IN DB_ESITO_PASCOLO_MAGRO.ANNO_CAMPAGNA%TYPE
                                             )
    RETURN DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE IS
        nIdFonte DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE;
    BEGIN

       SELECT EPM.ID_FONTE
         INTO nIdFonte
         FROM DB_ESITO_PASCOLO_MAGRO EPM,
              DB_TIPO_FONTE TFM
        WHERE EPM.ID_PARTICELLA_CERTIFICATA = pIdPartCertificata
          AND EPM.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                     FROM DB_ESITO_PASCOLO_MAGRO EP,
                                          DB_TIPO_FONTE TF
                                    WHERE EP.ID_PARTICELLA_CERTIFICATA = pIdPartCertificata
                                      AND EP.ANNO_CAMPAGNA <= pAnnoCampagna
                                      AND EP.ID_FONTE = TF.ID_FONTE
                                      AND TF.CALCOLA_ELEGGIBILE = 'S')
          AND EPM.DATA_FINE_VALIDITA IS NULL
          AND EPM.ID_FONTE = TFM.ID_FONTE
          AND TFM.CALCOLA_ELEGGIBILE = 'S';

        RETURN nIdFonte;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTFntPrtInRegPascByIdPrtYear;


    /*********************************************************************
    Chiude le unita' vitate dell'azienda passata in input con data
    fine validita non valorizzata impostandola a SYSDATE
    Tipo: procedure
    input: pIdAzienda, pIdUtenteAgg
    output: pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ChiudiUvAttive (pIdAzienda    IN DB_STORICO_UNITA_ARBOREA.ID_AZIENDA%TYPE,
                              pIdUtenteAgg  IN DB_STORICO_UNITA_ARBOREA.ID_UTENTE_AGGIORNAMENTO%TYPE,
                              pRisultato   OUT VARCHAR2,
                              pMessaggio   OUT VARCHAR2
                              ) IS
    BEGIN

        UPDATE DB_STORICO_UNITA_ARBOREA
           SET DATA_FINE_VALIDITA = SYSDATE,
               DATA_AGGIORNAMENTO = SYSDATE,
               ID_UTENTE_AGGIORNAMENTO = pIdUtenteAgg,
               NOTE = 'Chiusa x richiesta aggiornamento azienda'
         WHERE ID_AZIENDA = pIdAzienda
           AND DATA_FINE_VALIDITA IS NULL;

        pRisultato := '0';

    EXCEPTION
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'ChiudiUvAttive : ID_AZIENDA =  ' || pIdAzienda || ' - ' || SUBSTR(SQLERRM,1,150);
    END ChiudiUvAttive;

    /*********************************************************************
    Chiude l'anagrafica azienda con data_fine_validita a null
    impostandola a SYSDATE
    Tipo: procedure
    input: pIdAzienda, pIdUtenteAgg
    output: pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ChiudiAnagraficaAzienda (pIdAzienda   IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                                       pIdUtenteAgg IN DB_ANAGRAFICA_AZIENDA.ID_UTENTE_AGGIORNAMENTO%TYPE,
                                       pRisultato  OUT VARCHAR2,
                                       pMessaggio  OUT VARCHAR2
                                       ) IS
    BEGIN

        UPDATE DB_ANAGRAFICA_AZIENDA
           SET MOTIVO_MODIFICA = 'Chiusa per richiesta aggiornamento azienda',
               DATA_FINE_VALIDITA = SYSDATE,
               DATA_AGGIORNAMENTO = SYSDATE,
               ID_UTENTE_AGGIORNAMENTO = pIdUtenteAgg
         WHERE ID_AZIENDA = pIdAzienda
           AND DATA_FINE_VALIDITA IS NULL;

        pRisultato := '0';

    EXCEPTION
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'ChiudiAnagraficaAzienda : ID_AZIENDA =  ' || pIdAzienda || ' - ' || SUBSTR(SQLERRM,1,150);
    END ChiudiAnagraficaAzienda;

    /*********************************************************************
    Chiude la/le delega/e attiva/e per l'azienda impostando la data fine a SYSDATE
    e la data fine mandato alla data inizio validita' dell'iter richiesta attivo
    Tipo: procedure
    input: pIdAzienda, pRecTIterRichAz
    output: pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ChiudiAllDelegheForAzienda (pIdAzienda        IN DB_DELEGA.ID_AZIENDA%TYPE,
                                          pRecTIterRichAz   IN DB_ITER_RICHIESTA_AZIENDA%ROWTYPE,
                                          pRisultato       OUT VARCHAR2,
                                          pMessaggio       OUT VARCHAR2
                                          ) IS

        nNumDelegheChiuse   INTEGER:=0;
    BEGIN

        UPDATE DB_DELEGA
           SET DATA_FINE = SYSDATE,
               DATA_FINE_MANDATO = pRecTIterRichAz.DATA_INIZIO_VALIDITA,
               ID_UTENTE_FINE_DELEGA = pRecTIterRichAz.ID_UTENTE_AGGIORNAMENTO
         WHERE ID_AZIENDA = pIdAzienda
           AND DATA_FINE IS NULL
           AND DATA_FINE_MANDATO IS NULL;

        nNumDelegheChiuse := SQL%ROWCOUNT;

        -- se ho cessato almeno una delega
        IF nNumDelegheChiuse > 0 THEN
           -- tento di cessare i documenti di un determinato tipo
           UPDATE DB_DOCUMENTO
              SET DATA_FINE_VALIDITA = SYSDATE
            WHERE ID_AZIENDA = pIdAzienda
              AND DATA_FINE_VALIDITA IS NULL
              AND ID_STATO_DOCUMENTO IS NULL
              AND EXT_ID_DOCUMENTO = knIdTipoDocMandato;

        END IF;

        pRisultato := '0';

    EXCEPTION
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'ChiudiAllDelegheForAzienda : ID_AZIENDA =  ' || pIdAzienda || ' - ' || SUBSTR(SQLERRM,1,150);
    END ChiudiAllDelegheForAzienda;

    /*********************************************************************
    Chiude tutti i cc attivi dell'azienda
    Tipo: procedure
    input: pIdAzienda, pIdUtenteAgg
    output: pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ChiudiAllCCAttiviForAzienda (pIdAzienda   IN DB_CONTO_CORRENTE.ID_AZIENDA%TYPE,
                                           pIdUtenteAgg IN DB_CONTO_CORRENTE.ID_UTENTE_AGGIORNAMENTO%TYPE,
                                           pRisultato OUT VARCHAR2,
                                           pMessaggio OUT VARCHAR2
                                           ) IS
    BEGIN

        UPDATE DB_CONTO_CORRENTE
           SET DATA_FINE_VALIDITA = SYSDATE,
               DATA_AGGIORNAMENTO = SYSDATE,
               ID_UTENTE_AGGIORNAMENTO = pIdUtenteAgg
         WHERE ID_AZIENDA = pIdAzienda
           AND DATA_FINE_VALIDITA IS NULL;

        pRisultato := '0';

    EXCEPTION
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'ChiudiAllCCAttiviForAzienda : ID_AZIENDA =  ' || pIdAzienda || ' - ' || SUBSTR(SQLERRM,1,150);
    END ChiudiAllCCAttiviForAzienda;

    /*********************************************************************
    Chiude tutte le ute attive dell'azienda e le relative entita' figlie
    Tipo: procedure
    input: pIdAzienda
    output: pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ChiudiAllUteAttiveForAzienda (pIdAzienda      IN DB_UTE.ID_AZIENDA%TYPE,
                                            pIdUtenteAgg    IN DB_UTE.ID_UTENTE_AGGIORNAMENTO%TYPE,
                                            pRisultato     OUT VARCHAR2,
                                            pMessaggio     OUT VARCHAR2
                                            ) IS
        VetUte          Num_Varray := Num_Varray ();
        VetFabbricati   Num_Varray := Num_Varray ();
    BEGIN

        UPDATE DB_UTE
           SET DATA_FINE_ATTIVITA = SYSDATE,
               MOTIVO_MODIFICA = 'Chiusa x richiesta aggiornamento azienda',
               DATA_AGGIORNAMENTO = SYSDATE,
               ID_UTENTE_AGGIORNAMENTO = pIdUtenteAgg
         WHERE ID_AZIENDA = pIdAzienda
           AND DATA_FINE_ATTIVITA IS NULL
        RETURN ID_UTE BULK COLLECT INTO VetUte;

        UPDATE DB_ALLEVAMENTO
           SET DATA_FINE = SYSDATE,
               NOTE = 'Chiuso x richiesta aggiornamento azienda',
               DATA_AGGIORNAMENTO = SYSDATE,
               ID_UTENTE_AGGIORNAMENTO = pIdUtenteAgg
         WHERE DATA_FINE IS NULL
           AND ID_UTE IN (SELECT * FROM TABLE(CAST(VetUte AS Num_Varray)));

        UPDATE DB_CONDUZIONE_PARTICELLA
           SET DATA_FINE_CONDUZIONE = SYSDATE,
               NOTE = 'Chiusa x richiesta aggiornamento azienda',
               DATA_AGGIORNAMENTO = SYSDATE,
               ID_UTENTE_AGGIORNAMENTO = pIdUtenteAgg
         WHERE DATA_FINE_CONDUZIONE IS NULL
           AND ID_UTE IN (SELECT * FROM TABLE(CAST(VetUte AS Num_Varray)));

        UPDATE DB_FABBRICATO
           SET DATA_FINE_VALIDITA = SYSDATE,
               DATA_AGGIORNAMENTO = SYSDATE,
               ID_UTENTE_AGGIORNAMENTO = pIdUtenteAgg
         WHERE DATA_FINE_VALIDITA IS NULL
           AND ID_UTE IN (SELECT * FROM TABLE(CAST(VetUte AS Num_Varray)))
        RETURN ID_FABBRICATO BULK COLLECT INTO VetFabbricati;

        UPDATE DB_FABBRICATO_PARTICELLA
           SET DATA_FINE_VALIDITA = SYSDATE
         WHERE DATA_FINE_VALIDITA IS NULL
           AND ID_FABBRICATO IN (SELECT * FROM TABLE(CAST(VetFabbricati AS Num_Varray)));

        pRisultato := '0';

    EXCEPTION
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'ChiudiAllUteAttiveForAzienda : ID_AZIENDA =  ' || pIdAzienda || ' - ' || SUBSTR(SQLERRM,1,150);
    END ChiudiAllUteAttiveForAzienda;

    /*********************************************************************
    Dato una istat provincia
    Tipo: function
    input: pIstatProv
    output: nessuno
    ritorno: PROVINCIA.SIGLA_PROVINCIA%TYPE
    *********************************************************************/
    FUNCTION SelSiglaProvByIstatProv (pIstatProv IN PROVINCIA.ISTAT_PROVINCIA%TYPE)
    RETURN PROVINCIA.SIGLA_PROVINCIA%TYPE IS
        vSiglaProv PROVINCIA.SIGLA_PROVINCIA%TYPE;
    BEGIN

        SELECT SIGLA_PROVINCIA
          INTO vSiglaProv
          FROM PROVINCIA
         WHERE ISTAT_PROVINCIA = pIstatProv;

        RETURN vSiglaProv;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelSiglaProvByIstatProv;

    /*********************************************************************
    Dato un CUAA lo ricerca su DB_AZIENDA_TRIBUTARIA e ne ritorna il ROWTYPE
    Tipo: function
    input: pCuaa
    output: nessuno
    ritorno: DB_AZIENDA_TRIBUTARIA%ROWTYPE
    *********************************************************************/
    FUNCTION SelTAziendaTributariaByCuaa (pCuaa IN DB_AZIENDA_TRIBUTARIA.CUAA%TYPE)
    RETURN DB_AZIENDA_TRIBUTARIA%ROWTYPE IS
        recTAnagrTributaria DB_AZIENDA_TRIBUTARIA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTAnagrTributaria
          FROM DB_AZIENDA_TRIBUTARIA
         WHERE CUAA = pCuaa;

        RETURN recTAnagrTributaria;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTAziendaTributariaByCuaa;

    /*********************************************************************
    Dato un ID_AZIENDA lo ricerca su DB_AZIENDA e ne ritorna il ROWTYPE
    Tipo: function
    input: pIdAzienda
    output: nessuno
    ritorno: DB_AZIENDA%ROWTYPE
    *********************************************************************/
    FUNCTION SelTAziendaById (pIdAzienda DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE)
    RETURN DB_AZIENDA%ROWTYPE IS
        recTAzienda DB_AZIENDA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTAzienda
          FROM DB_AZIENDA
         WHERE ID_AZIENDA = pIdAzienda;

        RETURN recTAzienda;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTAziendaById;

    /*********************************************************************
    Dato un ID_AZIENDA lo ricerca su DB_ANAGRAFICA_AZIENDA per DATA_FINE_VALIDITA
    a NULL e ne ritorna il ROWTYPE
    Tipo: function
    input: pIdAzienda
    output: nessuno
    ritorno: DB_ANAGRAFICA_AZIENDA%ROWTYPE
    *********************************************************************/
    FUNCTION SelTAnagAziendaByIDAzienda (pIdAzienda DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE)
    RETURN DB_ANAGRAFICA_AZIENDA%ROWTYPE IS
        recTAnagrAzienda DB_ANAGRAFICA_AZIENDA%ROWTYPE;
    BEGIN
        SELECT AZ.*
          INTO recTAnagrAzienda
          FROM DB_ANAGRAFICA_AZIENDA AZ
         WHERE AZ.ID_AZIENDA = pIdAzienda
           AND AZ.DATA_FINE_VALIDITA IS NULL;

        RETURN recTAnagrAzienda;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTAnagAziendaByIDAzienda;

    /*********************************************************************
    Dato un CUAA lo ricerca su DB_ANAGRAFICA_AZIENDA per DATA_FINE_VALIDITA
    a NULL e ne ritorna il ROWTYPE, in caso non sia presente con
    DATA_FINE_VALIDITA a NULL restituisce il record di anagrafica
    con la massima DATA_FINE_VALIDITA
    Tipo: function
    input: pCUAA
    output: nessuno
    ritorno: DB_ANAGRAFICA_AZIENDA%ROWTYPE
    *********************************************************************/
    FUNCTION SelTAnagAziendaByCuaa (pCuaa IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE)
    RETURN DB_ANAGRAFICA_AZIENDA%ROWTYPE IS
        recTAnagrAzienda DB_ANAGRAFICA_AZIENDA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTAnagrAzienda
          FROM DB_ANAGRAFICA_AZIENDA
         WHERE CUAA = pCuaa
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recTAnagrAzienda;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             BEGIN
                 SELECT *
                   INTO recTAnagrAzienda
                   FROM DB_ANAGRAFICA_AZIENDA
                  WHERE CUAA = pCuaa
                    AND DATA_FINE_VALIDITA = (SELECT MAX(DATA_FINE_VALIDITA)
                                                FROM DB_ANAGRAFICA_AZIENDA
                                               WHERE CUAA = pCuaa
                                                 AND DATA_FINE_VALIDITA IS NOT NULL);
                RETURN recTAnagrAzienda;

             EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     RETURN NULL;
             END;
    END SelTAnagAziendaByCuaa;

    /*********************************************************************
    Dato un record di tipo DB_ITER_RICHIESTA_AZIENDA%ROWTYPE
    lo inserisce sulla stessa
    Tipo:   procedure
    input:  pRecTIterRichAzienda
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InsertTIterRichiestaAzienda (pRecTIterRichAzienda IN DB_ITER_RICHIESTA_AZIENDA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_ITER_RICHIESTA_AZIENDA
            (
            ID_ITER_RICHIESTA_AZIENDA,
            ID_RICHIESTA_AZIENDA,
            ID_STATO_RICHIESTA,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA,
            ID_UTENTE_AGGIORNAMENTO,
            NOTE,
            DATA_AGGIORNAMENTO
            )
        VALUES
            (
            pRecTIterRichAzienda.ID_ITER_RICHIESTA_AZIENDA,
            pRecTIterRichAzienda.ID_RICHIESTA_AZIENDA,
            pRecTIterRichAzienda.ID_STATO_RICHIESTA,
            pRecTIterRichAzienda.DATA_INIZIO_VALIDITA,
            pRecTIterRichAzienda.DATA_FINE_VALIDITA,
            pRecTIterRichAzienda.ID_UTENTE_AGGIORNAMENTO,
            pRecTIterRichAzienda.NOTE,
            pRecTIterRichAzienda.DATA_AGGIORNAMENTO
            );
    END InsertTIterRichiestaAzienda;

    /*********************************************************************
    Chiude l'iter_richiesta_azienda passato in input ovvero imposta
    la data di fine validita a SYSDATE
    Tipo:   procedure
    input:  pRecTIterRichiesta
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE ChiudiIterRichiesta (pRecTIterRichiesta IN DB_ITER_RICHIESTA_AZIENDA%ROWTYPE) IS
    BEGIN

        UPDATE DB_ITER_RICHIESTA_AZIENDA
           SET DATA_FINE_VALIDITA = SYSDATE
         WHERE ID_ITER_RICHIESTA_AZIENDA = pRecTIterRichiesta.ID_ITER_RICHIESTA_AZIENDA;

    END ChiudiIterRichiesta;

    /*********************************************************************
    Dato un record di tipo DB_DOCUMENTO%ROWTYPE
    lo inserisce sulla stessa
    Tipo:   procedure
    input:  pRecTDocumento
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InsertTDocumento (pRecTDocumento IN DB_DOCUMENTO%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_DOCUMENTO
            (
            ID_DOCUMENTO,
            EXT_ID_DOCUMENTO,
            ID_STATO_DOCUMENTO,
            ID_AZIENDA,
            CUAA,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA,
            NUMERO_PROTOCOLLO,
            DATA_PROTOCOLLO,
            NUMERO_DOCUMENTO,
            ENTE_RILASCIO_DOCUMENTO,
            ID_DOCUMENTO_PRECEDENTE,
            NOTE,
            DATA_ULTIMO_AGGIORNAMENTO,
            UTENTE_ULTIMO_AGGIORNAMENTO,
            DATA_INSERIMENTO,
            DATA_VARIAZIONE_STATO,
            ID_UTENTE_AGGIORNAMENTO_SRV,
            NUMERO_PROTOCOLLO_ESTERNO,
            CUAA_SOCCIDARIO,
            ESITO_CONTROLLO,
            DATA_ESECUZIONE,
            FLAG_CUAA_SOCCIDARIO_VALIDATO,
            ID_CONTO_CORRENTE,
            ID_CAUSALE_MODIFICA_DOCUMENTO
            )
        VALUES
            (
            pRecTDocumento.ID_DOCUMENTO,
            pRecTDocumento.EXT_ID_DOCUMENTO,
            pRecTDocumento.ID_STATO_DOCUMENTO,
            pRecTDocumento.ID_AZIENDA,
            pRecTDocumento.CUAA,
            pRecTDocumento.DATA_INIZIO_VALIDITA,
            pRecTDocumento.DATA_FINE_VALIDITA,
            pRecTDocumento.NUMERO_PROTOCOLLO,
            pRecTDocumento.DATA_PROTOCOLLO,
            pRecTDocumento.NUMERO_DOCUMENTO,
            pRecTDocumento.ENTE_RILASCIO_DOCUMENTO,
            pRecTDocumento.ID_DOCUMENTO_PRECEDENTE,
            pRecTDocumento.NOTE,
            pRecTDocumento.DATA_ULTIMO_AGGIORNAMENTO,
            pRecTDocumento.UTENTE_ULTIMO_AGGIORNAMENTO,
            pRecTDocumento.DATA_INSERIMENTO,
            pRecTDocumento.DATA_VARIAZIONE_STATO,
            pRecTDocumento.ID_UTENTE_AGGIORNAMENTO_SRV,
            pRecTDocumento.NUMERO_PROTOCOLLO_ESTERNO,
            pRecTDocumento.CUAA_SOCCIDARIO,
            pRecTDocumento.ESITO_CONTROLLO,
            pRecTDocumento.DATA_ESECUZIONE,
            pRecTDocumento.FLAG_CUAA_SOCCIDARIO_VALIDATO,
            pRecTDocumento.ID_CONTO_CORRENTE,
            pRecTDocumento.ID_CAUSALE_MODIFICA_DOCUMENTO
            );
    END InsertTDocumento;

    /*********************************************************************
    Effettua il ribaltamento di documenti e relativi allegati da
    DB_RICHIESTA_AZIENDA DOCUMENTO alle tabelle effettive DB_DOCUMENTO e
    DB_ALLEGATO_DOCUMENTO
    Tipo:   procedure
    input:  pIdRichAzienda, pIdAzienda, pCuaa
    output: pRisultato, pMessaggio
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE RibaltaDocumentiEdAllegati (pIdRichAzienda IN DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                                          pIdAzienda     IN DB_DOCUMENTO.ID_AZIENDA%TYPE,
                                          pCuaa          IN DB_DOCUMENTO.CUAA%TYPE,
                                          pRisultato    OUT VARCHAR2,
                                          pMessaggio    OUT VARCHAR2
                                          ) IS
        CURSOR curDocRichiestaAzienda IS
        SELECT *
          FROM DB_RICHIESTA_AZIENDA_DOCUMENTO
         WHERE ID_RICHIESTA_AZIENDA = pIdRichAzienda;

        recTDocumento DB_DOCUMENTO%ROWTYPE;

    BEGIN

        FOR recDocRichiestaAzienda IN curDocRichiestaAzienda LOOP

            SELECT SEQ_DOCUMENTO.nextval
              INTO recTDocumento.ID_DOCUMENTO
              FROM DUAL;

            recTDocumento.EXT_ID_DOCUMENTO := recDocRichiestaAzienda.EXT_ID_DOCUMENTO;
            recTDocumento.ID_AZIENDA := pIdAzienda;
            recTDocumento.CUAA := pCuaa;
            recTDocumento.DATA_INIZIO_VALIDITA := NVL(recDocRichiestaAzienda.DATA_INIZIO_VALIDITA,SYSDATE); 
            recTDocumento.DATA_FINE_VALIDITA := recDocRichiestaAzienda.DATA_FINE_VALIDITA; 
            recTDocumento.DATA_ULTIMO_AGGIORNAMENTO := SYSDATE;
            recTDocumento.UTENTE_ULTIMO_AGGIORNAMENTO := recDocRichiestaAzienda.ID_UTENTE_AGGIORNAMENTO;
            recTDocumento.NUMERO_DOCUMENTO := recDocRichiestaAzienda.NUMERO_DOCUMENTO;
            recTDocumento.ENTE_RILASCIO_DOCUMENTO := recDocRichiestaAzienda.ENTE_RILASCIO_DOCUMENTO;
            recTDocumento.DATA_INSERIMENTO := SYSDATE;

            InsertTDocumento (recTDocumento);

            INSERT INTO DB_ALLEGATO_DOCUMENTO
                (
                ID_ALLEGATO_DOCUMENTO,
                ID_ALLEGATO,
                ID_DOCUMENTO
                )
            SELECT SEQ_DB_ALLEGATO_DOCUMENTO.nextval,
                   ID_ALLEGATO,
                   recTDocumento.ID_DOCUMENTO
              FROM DB_ALLEGATO_RICHIESTA
             WHERE ID_RICHIESTA_AZIENDA_DOCUMENTO = recDocRichiestaAzienda.ID_RICHIESTA_AZIENDA_DOCUMENTO;

        END LOOP;

        pRisultato := '0';

    EXCEPTION
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'RibaltaDocumentiEdAllegati : ' || SUBSTR(SQLERRM,1,150);
    END RibaltaDocumentiEdAllegati;

    /*********************************************************************
    Dato un record di tipo DB_CATEGORIE_ALLEVAMENTO%ROWTYPE
    lo inserisce sulla stessa
    Tipo:   procedure
    input:  pRecTCategAllev
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InsertTCategoriaAllevamento (pRecTCategAllev IN DB_CATEGORIE_ALLEVAMENTO%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_CATEGORIE_ALLEVAMENTO
            (
            ID_CATEGORIE_ALLEVAMENTO,
            ID_CATEGORIA_ANIMALE,
            ID_ALLEVAMENTO,
            QUANTITA,
            PESO_VIVO_UNITARIO
            )
        VALUES
            (
            pRecTCategAllev.ID_CATEGORIE_ALLEVAMENTO,
            pRecTCategAllev.ID_CATEGORIA_ANIMALE,
            pRecTCategAllev.ID_ALLEVAMENTO,
            pRecTCategAllev.QUANTITA,
            pRecTCategAllev.PESO_VIVO_UNITARIO
            );
    END InsertTCategoriaAllevamento;

    /*********************************************************************
    Ricerca l'allevamento per UTE, SPECIE, CODICE ASL ed ID_ASL e
    ne ritorna il ROWTYPE
    Tipo:   procedure
    input:  pIdUte, pIdSpecie, pIdAsl, pCodiceAsl
    output: nessuno
    ritorno: DB_ALLEVAMENTO%ROWTYPE
    *********************************************************************/
    FUNCTION SelTAllevByUteSpecieIdCodAsl (pIdUte     IN DB_ALLEVAMENTO.ID_UTE%TYPE,
                                           pIdSpecie  IN DB_ALLEVAMENTO.ID_SPECIE_ANIMALE%TYPE,
                                           pIdAsl     IN DB_ALLEVAMENTO.ID_ASL%TYPE,
                                           pCodiceAsl IN DB_ALLEVAMENTO.CODICE_AZIENDA_ZOOTECNICA%TYPE
                                           ) RETURN DB_ALLEVAMENTO%ROWTYPE IS
        recTAllevamento DB_ALLEVAMENTO%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTAllevamento
          FROM DB_ALLEVAMENTO
         WHERE ID_UTE = pIdUte
           AND ID_SPECIE_ANIMALE = pIdSpecie
           AND NVL (ID_ASL, -1) = NVL (pIdAsl, -1)
           AND (CODICE_AZIENDA_ZOOTECNICA = pCodiceAsl OR (CODICE_AZIENDA_ZOOTECNICA IS NULL AND pCodiceAsl IS NULL))
           AND DATA_FINE IS NULL;

        RETURN recTAllevamento;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTAllevByUteSpecieIdCodAsl;

    /*********************************************************************
    Inserisce il conto corrente della nuova azienda  nella tabella effettiva
    recuperando lo sportello
    Tipo: procedure
    input: pIdRichAzienda, pIdAzienda, pRisultato, pMessaggio
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE RibaltaContoCorrente (pIdRichAzienda IN DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                                    pIdAzienda     IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                    pRisultato    OUT VARCHAR2,
                                    pMessaggio    OUT VARCHAR2
                                    ) IS
    BEGIN

        INSERT INTO DB_CONTO_CORRENTE
            (
            ID_CONTO_CORRENTE,
            ID_SPORTELLO,
            ID_AZIENDA,
            NUMERO_CONTO_CORRENTE,
            CIN,
            INTESTAZIONE,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA,
            DATA_ESTINZIONE,
            DATA_AGGIORNAMENTO,
            ID_UTENTE_AGGIORNAMENTO,
            BBAN,
            CIFRA_CONTROLLO,
            IBAN,
            FLAG_VALIDATO,
            ID_TIPO_CAUSA_INVALIDAZIONE_CC,
            NOTE,
            MOTIVO_RIVALIDAZIONE,
            ID_UTENTE_AGGIORNAMENTO_SIGOP,
            FLAG_CONTO_GF
            )
        SELECT SEQ_CONTO_CORRENTE.nextval,
               TS.ID_SPORTELLO,
               pIdAzienda,
               SUBSTR(CCAZN.IBAN,16,12),
               SUBSTR(CCAZN.IBAN,5,1),
               NULL,
               SYSDATE,
               NULL,
               NULL,
               SYSDATE,
               RA.ID_UTENTE_AGGIORNAMENTO,
               NULL,
               SUBSTR(CCAZN.IBAN,3,2),
               CCAZN.IBAN,
               'S',
               NULL,
               NULL,
               NULL,
               NULL,
               'N'
          FROM SMRGAA_W_CC_AZ_NUOVA CCAZN,
               DB_RICHIESTA_AZIENDA RA,
               SMRGAA_W_AZIENDA_NUOVA AN,
               DB_TIPO_BANCA TB,
               DB_TIPO_SPORTELLO TS
         WHERE RA.ID_RICHIESTA_AZIENDA = pIdRichAzienda
           AND RA.ID_AZIENDA_NUOVA = AN.ID_AZIENDA_NUOVA
           AND AN.ID_AZIENDA_NUOVA = CCAZN.ID_AZIENDA_NUOVA
           AND SUBSTR(CCAZN.IBAN,6,5) = TB.ABI
           AND TB.DATA_FINE_VALIDITA IS NULL
           AND TB.ID_BANCA = TS.ID_BANCA
           AND SUBSTR(CCAZN.IBAN,11,5) = TS.CAB
           AND TS.DATA_FINE_VALIDITA IS NULL;

        pRisultato := '0';

    EXCEPTION
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'RibaltaContoCorrente : ' || SUBSTR(SQLERRM,1,150);
    END RibaltaContoCorrente;

    /*********************************************************************
    Dato un record di tipo DB_ALLEVAMENTO%ROWTYPE lo inserisce sulla stessa
    Tipo:   procedure
    input:  pRecTAllevamento
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InsertTAllevamento (pRecTAllevamento IN DB_ALLEVAMENTO%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_ALLEVAMENTO
            (
            ID_ALLEVAMENTO,
            ID_UTE,
            ISTAT_COMUNE,
            ID_SPECIE_ANIMALE,
            DATA_INIZIO,
            DATA_AGGIORNAMENTO,
            ID_UTENTE_AGGIORNAMENTO,
            ID_ASL,
            CODICE_AZIENDA_ZOOTECNICA,
            DATA_FINE,
            NOTE,
            INDIRIZZO,
            CAP,
            TELEFONO,
            DICHIARAZIONE_RIPRISTINATA,
            ID_DICHIARAZIONE_CONSISTENZA,
            CODICE_FISCALE_PROPRIETARIO,
            DENOMINAZIONE_PROPRIETARIO,
            CODICE_FISCALE_DETENTORE,
            DENOMINAZIONE_DETENTORE,
            DATA_INIZIO_DETENZIONE,
            DATA_FINE_DETENZIONE,
            FLAG_SOCCIDA,
            ID_TIPO_PRODUZIONE,
            ID_ORIENTAMENTO_PRODUTTIVO,
            DESCRIZIONE_ALTRI_TRATTAM,
            FLAG_DEIEZIONE_AVICOLI,
            MEDIA_CAPI_LATTAZIONE,
            QUANTITA_ACQUA_LAVAGGIO,
            FLAG_ACQUE_EFFLUENTI,
            ID_MUNGITURA,
            SUPERFICIE_LETTIERA_PERMANENTE,
            ALTEZZA_LETTIERA_PERMANENTE
            )
        VALUES
            (
            pRecTAllevamento.ID_ALLEVAMENTO,
            pRecTAllevamento.ID_UTE,
            pRecTAllevamento.ISTAT_COMUNE,
            pRecTAllevamento.ID_SPECIE_ANIMALE,
            pRecTAllevamento.DATA_INIZIO,
            pRecTAllevamento.DATA_AGGIORNAMENTO,
            pRecTAllevamento.ID_UTENTE_AGGIORNAMENTO,
            pRecTAllevamento.ID_ASL,
            pRecTAllevamento.CODICE_AZIENDA_ZOOTECNICA,
            pRecTAllevamento.DATA_FINE,
            pRecTAllevamento.NOTE,
            pRecTAllevamento.INDIRIZZO,
            pRecTAllevamento.CAP,
            pRecTAllevamento.TELEFONO,
            pRecTAllevamento.DICHIARAZIONE_RIPRISTINATA,
            pRecTAllevamento.ID_DICHIARAZIONE_CONSISTENZA,
            pRecTAllevamento.CODICE_FISCALE_PROPRIETARIO,
            pRecTAllevamento.DENOMINAZIONE_PROPRIETARIO,
            pRecTAllevamento.CODICE_FISCALE_DETENTORE,
            pRecTAllevamento.DENOMINAZIONE_DETENTORE,
            pRecTAllevamento.DATA_INIZIO_DETENZIONE,
            pRecTAllevamento.DATA_FINE_DETENZIONE,
            pRecTAllevamento.FLAG_SOCCIDA,
            pRecTAllevamento.ID_TIPO_PRODUZIONE,
            pRecTAllevamento.ID_ORIENTAMENTO_PRODUTTIVO,
            pRecTAllevamento.DESCRIZIONE_ALTRI_TRATTAM,
            pRecTAllevamento.FLAG_DEIEZIONE_AVICOLI,
            pRecTAllevamento.MEDIA_CAPI_LATTAZIONE,
            pRecTAllevamento.QUANTITA_ACQUA_LAVAGGIO,
            pRecTAllevamento.FLAG_ACQUE_EFFLUENTI,
            pRecTAllevamento.ID_MUNGITURA,
            pRecTAllevamento.SUPERFICIE_LETTIERA_PERMANENTE,
            pRecTAllevamento.ALTEZZA_LETTIERA_PERMANENTE
            );
    END InsertTAllevamento;

    /*********************************************************************
    Ricerca la categoria animale per ID e ne restituisce il rowtype
    Tipo:   procedure
    input:  pIdCategoriaAnimale
    output: nessuno
    ritorno: DB_TIPO_CATEGORIA_ANIMALE%ROWTYPE
    *********************************************************************/
    FUNCTION SelDCategoriaAnimaleById (pIdCategoriaAnimale IN DB_TIPO_CATEGORIA_ANIMALE.ID_CATEGORIA_ANIMALE%TYPE)
    RETURN DB_TIPO_CATEGORIA_ANIMALE%ROWTYPE IS
        recDTipoCategAnimale DB_TIPO_CATEGORIA_ANIMALE%ROWTYPE;
    BEGIN
        SELECT *
          INTO recDTipoCategAnimale
          FROM DB_TIPO_CATEGORIA_ANIMALE
         WHERE ID_CATEGORIA_ANIMALE = pIdCategoriaAnimale;

        RETURN recDTipoCategAnimale;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelDCategoriaAnimaleById;

    /*********************************************************************
    Dato un record di tipo DB_UTILIZZO_PARTICELLA%ROWTYPE
    lo inserisce sulla stessa
    Tipo:   procedure
    input:  pRecUtilizzoPart
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InsertTUtilizzoParticella (pRecUtilizzoPart IN DB_UTILIZZO_PARTICELLA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_UTILIZZO_PARTICELLA
                    (
                    ID_UTILIZZO_PARTICELLA,
                    ID_UTILIZZO,
                    ID_CONDUZIONE_PARTICELLA,
                    SUPERFICIE_UTILIZZATA,
                    DATA_AGGIORNAMENTO,
                    ID_UTENTE_AGGIORNAMENTO,
                    ANNO,
                    NOTE,
                    ID_UTILIZZO_SECONDARIO,
                    SUP_UTILIZZATA_SECONDARIA,
                    ID_VARIETA,
                    ID_VARIETA_SECONDARIA,
                    ANNO_IMPIANTO,
                    ID_IMPIANTO,
                    SESTO_SU_FILE,
                    SESTO_TRA_FILE,
                    NUMERO_PIANTE_CEPPI,
                    ID_TIPO_DETTAGLIO_USO, ID_TIPO_DETT_USO_SECONDARIO, ID_TIPO_EFA, VALORE_ORIGINALE,
                    VALORE_DOPO_CONVERSIONE, VALORE_DOPO_PONDERAZIONE, ID_TIPO_PERIODO_SEMINA,
                    ID_TIPO_PERIODO_SEMINA_SECOND, ID_SEMINA, ID_SEMINA_SECONDARIA, ID_CATALOGO_MATRICE,
                    DATA_INIZIO_DESTINAZIONE, DATA_FINE_DESTINAZIONE, ID_FASE_ALLEVAMENTO,
                    ID_PRATICA_MANTENIMENTO, ID_CATALOGO_MATRICE_SECONDARIO, DATA_INIZIO_DESTINAZIONE_SEC,
                    DATA_FINE_DESTINAZIONE_SEC, ID_ISOLA_GRAFICA, ID_APPEZZAMENTO, ID_SHAPE, SHAPE
                    )
        VALUES (
                pRecUtilizzoPart.ID_UTILIZZO_PARTICELLA,
                pRecUtilizzoPart.ID_UTILIZZO,
                pRecUtilizzoPart.ID_CONDUZIONE_PARTICELLA,
                pRecUtilizzoPart.SUPERFICIE_UTILIZZATA,
                pRecUtilizzoPart.DATA_AGGIORNAMENTO,
                pRecUtilizzoPart.ID_UTENTE_AGGIORNAMENTO,
                pRecUtilizzoPart.ANNO,
                pRecUtilizzoPart.NOTE,
                pRecUtilizzoPart.ID_UTILIZZO_SECONDARIO,
                pRecUtilizzoPart.SUP_UTILIZZATA_SECONDARIA,
                pRecUtilizzoPart.ID_VARIETA,
                pRecUtilizzoPart.ID_VARIETA_SECONDARIA,
                pRecUtilizzoPart.ANNO_IMPIANTO,
                pRecUtilizzoPart.ID_IMPIANTO,
                pRecUtilizzoPart.SESTO_SU_FILE,
                pRecUtilizzoPart.SESTO_TRA_FILE,
                pRecUtilizzoPart.NUMERO_PIANTE_CEPPI,
                pRecUtilizzoPart.ID_TIPO_DETTAGLIO_USO,pRecUtilizzoPart.ID_TIPO_DETT_USO_SECONDARIO,
                pRecUtilizzoPart.ID_TIPO_EFA,pRecUtilizzoPart.VALORE_ORIGINALE,
                pRecUtilizzoPart.VALORE_DOPO_CONVERSIONE,pRecUtilizzoPart.VALORE_DOPO_PONDERAZIONE,
                pRecUtilizzoPart.ID_TIPO_PERIODO_SEMINA,pRecUtilizzoPart.ID_TIPO_PERIODO_SEMINA_SECOND,
                pRecUtilizzoPart.ID_SEMINA,pRecUtilizzoPart.ID_SEMINA_SECONDARIA,
                pRecUtilizzoPart.ID_CATALOGO_MATRICE,pRecUtilizzoPart.DATA_INIZIO_DESTINAZIONE,
                pRecUtilizzoPart.DATA_FINE_DESTINAZIONE,pRecUtilizzoPart.ID_FASE_ALLEVAMENTO,
                pRecUtilizzoPart.ID_PRATICA_MANTENIMENTO,pRecUtilizzoPart.ID_CATALOGO_MATRICE_SECONDARIO,
                pRecUtilizzoPart.DATA_INIZIO_DESTINAZIONE_SEC,pRecUtilizzoPart.DATA_FINE_DESTINAZIONE_SEC,
                pRecUtilizzoPart.ID_ISOLA_GRAFICA,pRecUtilizzoPart.ID_APPEZZAMENTO,
                pRecUtilizzoPart.ID_SHAPE,pRecUtilizzoPart.SHAPE
                );
    END InsertTUtilizzoParticella;

    /*********************************************************************
    Ricerca la particella su DB_CONDUZIONE_PARTICELLA per ID_UTE, ID_TITOLO_POSSESSO
    e percentuale possesso
    Tipo: function
    input: pIdUte, pIdPart, pIdTitPos, pPercPoss
    output: nessuno
    ritorno: DB_CONDUZIONE_PARTICELLA%ROWTYPE
    *********************************************************************/
    FUNCTION SelTCondPartByUtePartTitPerc (pIdUte       IN DB_CONDUZIONE_PARTICELLA.ID_UTE%TYPE,
                                           pIdPart      IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE,
                                           pIdTitPos    IN DB_CONDUZIONE_PARTICELLA.ID_TITOLO_POSSESSO%TYPE,
                                           pPercPoss    IN DB_CONDUZIONE_PARTICELLA.PERCENTUALE_POSSESSO%TYPE
                                           ) RETURN DB_CONDUZIONE_PARTICELLA%ROWTYPE IS
        recTCondParticella DB_CONDUZIONE_PARTICELLA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTCondParticella
          FROM DB_CONDUZIONE_PARTICELLA
         WHERE ID_UTE = pIdUte
           AND ID_PARTICELLA = pIdPart
           AND ID_TITOLO_POSSESSO = pIdTitPos
           AND PERCENTUALE_POSSESSO = pPercPoss
           AND DATA_FINE_CONDUZIONE IS NULL;

        RETURN recTCondParticella;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTCondPartByUtePartTitPerc;

    /*********************************************************************
    Dati un id_conduzione_particella ed una superficie condotta
    aggiorna l'omonimo campo per quell'id_conduzione
    Tipo:   procedure
    input:  pnIdCondPart , pnTotSupCond
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE AggiornaConduzioneParticella (pnIdCondPart IN DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE,
                                            pnTotSupCond IN DB_CONDUZIONE_PARTICELLA.SUPERFICIE_CONDOTTA%TYPE) IS
    BEGIN
        UPDATE DB_CONDUZIONE_PARTICELLA
           SET SUPERFICIE_CONDOTTA = pnTotSupCond
         WHERE ID_CONDUZIONE_PARTICELLA = pnIdCondPart;
    END AggiornaConduzioneParticella;

    /*********************************************************************
    Ricerca un foglio su DB_FOGLIO dati comune, sezione ed il numero del foglio
    Tipo: function
    input: pComune, pSezione, pFoglio
    output: nessuno
    ritorno: DB_FOGLIO%ROWTYPE
    *********************************************************************/
    FUNCTION SelTFoglioByComSezFoglio (pComune  IN DB_FOGLIO.COMUNE%TYPE,
                                       pSezione IN DB_FOGLIO.SEZIONE%TYPE,
                                       pFoglio  IN DB_FOGLIO.FOGLIO%TYPE
                                       ) RETURN DB_FOGLIO%ROWTYPE IS
        recTFoglio DB_FOGLIO%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTFoglio
          FROM DB_FOGLIO
         WHERE COMUNE = pComune
           AND NVL(SEZIONE,'#') = NVL(pSezione, '#')
           AND FOGLIO = pFoglio;

        RETURN recTFoglio;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTFoglioByComSezFoglio;

    /*********************************************************************
    Dato un record di tipo DB_FABBRICATO_PARTICELLA%ROWTYPE
    lo inserisce sulla stessa
    Tipo:   procedure
    input:  pRecTFabbricatoParticella
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InsertTFabbricatoParticella (pRecTFabbricatoParticella IN DB_FABBRICATO_PARTICELLA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_FABBRICATO_PARTICELLA
            (
            ID_FABBRICATO_PARTICELLA,
            ID_FABBRICATO,
            ID_PARTICELLA,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA
            )
        VALUES
            (
            pRecTFabbricatoParticella.ID_FABBRICATO_PARTICELLA,
            pRecTFabbricatoParticella.ID_FABBRICATO,
            pRecTFabbricatoParticella.ID_PARTICELLA,
            pRecTFabbricatoParticella.DATA_INIZIO_VALIDITA,
            pRecTFabbricatoParticella.DATA_FINE_VALIDITA
            );
    END InsertTFabbricatoParticella;

    /*********************************************************************
    Dato un record di tipo DB_PARTICELLA%ROWTYPE
    lo inserisce sulla stessa
    Tipo:   procedure
    input:  pRecConduzPart
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InsertTParticella (pRecPart IN DB_PARTICELLA%ROWTYPE) IS
    BEGIN
        INSERT INTO DB_PARTICELLA
                    (
                    ID_PARTICELLA,
                    DATA_CREAZIONE,
                    DATA_CESSAZIONE,
                    BIOLOGICO,
                    DATA_INIZIO_VALIDITA,
                    FLAG_SCHEDARIO,
                    FLAG_INVIO_SITI
                    )
             VALUES (
                    pRecPart.ID_PARTICELLA,
                    pRecPart.DATA_CREAZIONE,
                    pRecPart.DATA_CESSAZIONE,
                    pRecPart.BIOLOGICO,
                    pRecPart.DATA_INIZIO_VALIDITA,
                    pRecPart.FLAG_SCHEDARIO,
                    pRecPart.FLAG_INVIO_SITI
                    );
    END InsertTParticella;

    /*********************************************************************
    Dato un record di tipo DB_CONDUZIONE_PARTICELLA%ROWTYPE
    lo inserisce sulla stessa
    Tipo:   procedure
    input:  pRecConduzPart
    output: nessuno
    ritorno:nessuno
    *********************************************************************/
    PROCEDURE InsertTConduzioneParticella (pRecConduzPart IN DB_CONDUZIONE_PARTICELLA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_CONDUZIONE_PARTICELLA
                    (
                    ID_CONDUZIONE_PARTICELLA,
                    ID_PARTICELLA,
                    ID_TITOLO_POSSESSO,
                    ID_UTE,
                    SUPERFICIE_CONDOTTA,
                    FLAG_UTILIZZO_PARTE,
                    DATA_INIZIO_CONDUZIONE,
                    DATA_FINE_CONDUZIONE,
                    NOTE,
                    DATA_AGGIORNAMENTO,
                    ID_UTENTE_AGGIORNAMENTO,
                    ESITO_CONTROLLO,
                    DATA_ESECUZIONE,
                    RECORD_MODIFICATO,
                    DICHIARAZIONE_RIPRISTINATA,
                    ID_DICHIARAZIONE_CONSISTENZA,
                    SUPERFICIE_AGRONOMICA
                    )
        VALUES (
                pRecConduzPart.ID_CONDUZIONE_PARTICELLA,
                pRecConduzPart.ID_PARTICELLA,
                pRecConduzPart.ID_TITOLO_POSSESSO,
                pRecConduzPart.ID_UTE,
                pRecConduzPart.SUPERFICIE_CONDOTTA,
                pRecConduzPart.FLAG_UTILIZZO_PARTE,
                pRecConduzPart.DATA_INIZIO_CONDUZIONE,
                pRecConduzPart.DATA_FINE_CONDUZIONE,
                pRecConduzPart.NOTE,
                pRecConduzPart.DATA_AGGIORNAMENTO,
                pRecConduzPart.ID_UTENTE_AGGIORNAMENTO,
                pRecConduzPart.ESITO_CONTROLLO,
                pRecConduzPart.DATA_ESECUZIONE,
                pRecConduzPart.RECORD_MODIFICATO,
                pRecConduzPart.DICHIARAZIONE_RIPRISTINATA,
                pRecConduzPart.ID_DICHIARAZIONE_CONSISTENZA,
                pRecConduzPart.SUPERFICIE_AGRONOMICA
                );
    END InsertTConduzioneParticella;

    /*********************************************************************
    Inserisce un record di tipo DB_STORICO_PARTICELLA sulla tabella omonima
    Tipo: procedure
    input: pRecTStoricoParticella
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTStoricoParticella (pRecTStoricoParticella IN DB_STORICO_PARTICELLA%ROWTYPE) IS
    BEGIN
        INSERT INTO DB_STORICO_PARTICELLA
            (
            ID_STORICO_PARTICELLA,
            ID_PARTICELLA,
            SEZIONE,
            COMUNE,
            DATA_INIZIO_VALIDITA,
            FOGLIO,
            DATA_FINE_VALIDITA,
            PARTICELLA,
            SUP_CATASTALE,
            SUBALTERNO,
            --ID_AREA_A,
            ID_ZONA_ALTIMETRICA,
            FLAG_IRRIGABILE,
            --ID_AREA_B,
            ID_CASO_PARTICOLARE,
            --ID_AREA_C,
            --ID_AREA_D,
            DATA_AGGIORNAMENTO,
            ID_UTENTE_AGGIORNAMENTO,
            ID_CAUSALE_MOD_PARTICELLA,
            FLAG_CAPTAZIONE_POZZI,
            MOTIVO_MODIFICA,
            SUP_NON_ELEGGIBILE,
            SUP_NE_BOSCO_ACQUE_FABBRICATO,
            SUP_NE_FORAGGIERE,
            SUP_EL_FRUTTA_GUSCIO,
            SUP_EL_PRATO_PASCOLO,
            SUP_EL_COLTURE_MISTE,
            SUP_COLTIVAZ_ARBOREA_CONS,
            SUP_COLTIVAZ_ARBOREA_SPEC,
            DATA_FOTO,
            ID_FONTE,
            TIPO_FOTO,
            ID_DOCUMENTO,
            ID_IRRIGAZIONE,
            ID_DOCUMENTO_PROTOCOLLATO,
            --ID_FASCIA_FLUVIALE,
            --ID_AREA_G,
            --ID_AREA_H,
            SUPERFICIE_GRAFICA,
            ID_POTENZIALITA_IRRIGUA,
            ID_TERRAZZAMENTO,
            ID_ROTAZIONE_COLTURALE
            --ID_AREA_I,
            --ID_AREA_L,
            --ID_AREA_M 
            )
        VALUES
            (
            pRecTStoricoParticella.ID_STORICO_PARTICELLA,
            pRecTStoricoParticella.ID_PARTICELLA,
            pRecTStoricoParticella.SEZIONE,
            pRecTStoricoParticella.COMUNE,
            pRecTStoricoParticella.DATA_INIZIO_VALIDITA,
            pRecTStoricoParticella.FOGLIO,
            pRecTStoricoParticella.DATA_FINE_VALIDITA,
            pRecTStoricoParticella.PARTICELLA,
            pRecTStoricoParticella.SUP_CATASTALE,
            pRecTStoricoParticella.SUBALTERNO,
            --pRecTStoricoParticella.ID_AREA_A,
            pRecTStoricoParticella.ID_ZONA_ALTIMETRICA,
            pRecTStoricoParticella.FLAG_IRRIGABILE,
            --pRecTStoricoParticella.ID_AREA_B,
            pRecTStoricoParticella.ID_CASO_PARTICOLARE,
            --pRecTStoricoParticella.ID_AREA_C,
            --pRecTStoricoParticella.ID_AREA_D,
            pRecTStoricoParticella.DATA_AGGIORNAMENTO,
            pRecTStoricoParticella.ID_UTENTE_AGGIORNAMENTO,
            pRecTStoricoParticella.ID_CAUSALE_MOD_PARTICELLA,
            pRecTStoricoParticella.FLAG_CAPTAZIONE_POZZI,
            pRecTStoricoParticella.MOTIVO_MODIFICA,
            pRecTStoricoParticella.SUP_NON_ELEGGIBILE,
            pRecTStoricoParticella.SUP_NE_BOSCO_ACQUE_FABBRICATO,
            pRecTStoricoParticella.SUP_NE_FORAGGIERE,
            pRecTStoricoParticella.SUP_EL_FRUTTA_GUSCIO,
            pRecTStoricoParticella.SUP_EL_PRATO_PASCOLO,
            pRecTStoricoParticella.SUP_EL_COLTURE_MISTE,
            pRecTStoricoParticella.SUP_COLTIVAZ_ARBOREA_CONS,
            pRecTStoricoParticella.SUP_COLTIVAZ_ARBOREA_SPEC,
            pRecTStoricoParticella.DATA_FOTO,
            pRecTStoricoParticella.ID_FONTE,
            pRecTStoricoParticella.TIPO_FOTO,
            pRecTStoricoParticella.ID_DOCUMENTO,
            pRecTStoricoParticella.ID_IRRIGAZIONE,
            pRecTStoricoParticella.ID_DOCUMENTO_PROTOCOLLATO,
            --pRecTStoricoParticella.ID_FASCIA_FLUVIALE,
            --pRecTStoricoParticella.ID_AREA_G,
            --pRecTStoricoParticella.ID_AREA_H,
            pRecTStoricoParticella.SUPERFICIE_GRAFICA,
            pRecTStoricoParticella.ID_POTENZIALITA_IRRIGUA,
            pRecTStoricoParticella.ID_TERRAZZAMENTO,
            pRecTStoricoParticella.ID_ROTAZIONE_COLTURALE
            --pRecTStoricoParticella.ID_AREA_I,
            --pRecTStoricoParticella.ID_AREA_L,
            --pRecTStoricoParticella.ID_AREA_M
            );
    END InsertTStoricoParticella;

    /*********************************************************************
    Seleziona il record attivo (DATA_FINE_VALIDITA a null) di DB_PARTICELLA_CERTIFICATA
    accedendo per chiave catastale
    Tipo: function
    input: pIstatComune, pSezione, pFoglio, pParticella, pSubalterno
    output: nessuno
    ritorno: DB_PARTICELLA_CERTIFICATA%ROWTYPE
    *********************************************************************/
    FUNCTION SelTPartCertByChiaveCatastale (pIstatComune IN DB_PARTICELLA_CERTIFICATA.COMUNE%TYPE,
                                            pSezione     IN DB_PARTICELLA_CERTIFICATA.SEZIONE%TYPE,
                                            pFoglio      IN DB_PARTICELLA_CERTIFICATA.FOGLIO%TYPE,
                                            pParticella  IN DB_PARTICELLA_CERTIFICATA.PARTICELLA%TYPE,
                                            pSubalterno  IN DB_PARTICELLA_CERTIFICATA.SUBALTERNO%TYPE
                                            ) RETURN DB_PARTICELLA_CERTIFICATA%ROWTYPE IS
        recTPartCertificata DB_PARTICELLA_CERTIFICATA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTPartCertificata
          FROM DB_PARTICELLA_CERTIFICATA
         WHERE COMUNE = pIstatComune
           AND NVL(SEZIONE,'#') = NVL(pSezione,'#')
           AND FOGLIO = pFoglio
           AND PARTICELLA = pParticella
           AND NVL(SUBALTERNO,'#') = NVL(pSubalterno,'#')
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recTPartCertificata;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTPartCertByChiaveCatastale;

    /*********************************************************************
    Seleziona il record attivo (DATA_FINE_VALIDITA a null) di DB_STORICO_PARTICELLA accedendo
    per chiave catastale
    Tipo: function
    input: pIstatComune, pSezione, pFoglio, pParticella, pSubalterno
    output: nessuno
    ritorno: DB_STORICO_PARTICELLA%ROWTYPE
    *********************************************************************/
    FUNCTION SelTStorPartByChiaveCatastale (pIstatComune IN DB_STORICO_PARTICELLA.COMUNE%TYPE,
                                            pSezione     IN DB_STORICO_PARTICELLA.SEZIONE%TYPE,
                                            pFoglio      IN DB_STORICO_PARTICELLA.FOGLIO%TYPE,
                                            pParticella  IN DB_STORICO_PARTICELLA.PARTICELLA%TYPE,
                                            pSubalterno  IN DB_STORICO_PARTICELLA.SUBALTERNO%TYPE
                                            ) RETURN DB_STORICO_PARTICELLA%ROWTYPE IS
        recTStoricoParticella DB_STORICO_PARTICELLA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTStoricoParticella
          FROM DB_STORICO_PARTICELLA
         WHERE COMUNE = pIstatComune
           AND NVL(SEZIONE,'#') = NVL(pSezione,'#')
           AND FOGLIO = pFoglio
           AND PARTICELLA = pParticella
           AND NVL(SUBALTERNO,'#') = NVL(pSubalterno,'#')
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN recTStoricoParticella;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTStorPartByChiaveCatastale;

    /*********************************************************************
    Ricerca la particella della nuova azienda su DB_STORICO_PARTICELLA / DB_PARTICELLA_CERTIFICATA
    e se non presente sulla prima la inserisce
    Tipo: function
    input: pComune, pSezione, pFoglio, pParticella, pSubalterno, pIdTitPossesso
           pSuperficie, pIdUtilizzo, pIdVarieta, pIdUtAgg
    output: pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    FUNCTION GestioneParticella (pComune            IN DB_STORICO_PARTICELLA.COMUNE%TYPE,
                                 pSezione           IN DB_STORICO_PARTICELLA.SEZIONE%TYPE,
                                 pFoglio            IN DB_STORICO_PARTICELLA.FOGLIO%TYPE,
                                 pParticella        IN DB_STORICO_PARTICELLA.PARTICELLA%TYPE,
                                 pSubalterno        IN DB_STORICO_PARTICELLA.SUBALTERNO%TYPE,
                                 pIdTitPossesso     IN DB_CONDUZIONE_PARTICELLA.ID_TITOLO_POSSESSO%TYPE,
                                 pSuperficie        IN DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE,
                                 pIdUtilizzo        IN DB_UTILIZZO_PARTICELLA.ID_UTILIZZO%TYPE,
                                 pIdVarieta         IN DB_UTILIZZO_PARTICELLA.ID_VARIETA%TYPE,
                                 pIdUtAgg           IN DB_STORICO_PARTICELLA.ID_UTENTE_AGGIORNAMENTO%TYPE,
                                 pRisultato        OUT VARCHAR2,
                                 pMessaggio        OUT VARCHAR2
                                 ) RETURN DB_PARTICELLA.ID_PARTICELLA%TYPE IS

        recTStoricoPart DB_STORICO_PARTICELLA%ROWTYPE;
        recTPartCertif  DB_PARTICELLA_CERTIFICATA%ROWTYPE;
        recTParticella  DB_PARTICELLA%ROWTYPE;
        recTFoglio      DB_FOGLIO%ROWTYPE;
        nIdParticella   DB_PARTICELLA.ID_PARTICELLA%TYPE;

    BEGIN

        recTStoricoPart := SelTStorPartByChiaveCatastale (pComune,
                                                          pSezione,
                                                          pFoglio,
                                                          pParticella,
                                                          pSubalterno);

        IF recTStoricoPart.ID_STORICO_PARTICELLA IS NULL THEN

           recTFoglio := SelTFoglioByComSezFoglio (pComune,
                                                   pSezione,
                                                   pFoglio);

           IF recTFoglio.ID_FOGLIO IS NOT NULL THEN

               SELECT SEQ_PARTICELLA.nextval
                 INTO recTParticella.ID_PARTICELLA
                 FROM DUAL;
               recTParticella.DATA_CREAZIONE := SYSDATE;
               recTParticella.DATA_CESSAZIONE := NULL;
               recTParticella.BIOLOGICO := NULL;
               recTParticella.DATA_INIZIO_VALIDITA := SYSDATE;
               recTParticella.FLAG_SCHEDARIO := 'N';
               recTParticella.FLAG_INVIO_SITI := 'N';

               InsertTParticella (recTParticella);

               recTPartCertif := SelTPartCertByChiaveCatastale (pComune,
                                                                pSezione,
                                                                pFoglio,
                                                                pParticella,
                                                                pSubalterno);

               SELECT SEQ_STORICO_PARTICELLA.nextval
                 INTO recTStoricoPart.ID_STORICO_PARTICELLA
                 FROM DUAL;

               recTStoricoPart.ID_PARTICELLA := recTParticella.ID_PARTICELLA;
               recTStoricoPart.SEZIONE :=  pSezione;
               recTStoricoPart.COMUNE := pComune;
               recTStoricoPart.DATA_INIZIO_VALIDITA := SYSDATE;
               recTStoricoPart.FOGLIO := pFoglio;
               recTStoricoPart.PARTICELLA := pParticella;
               recTStoricoPart.SUBALTERNO := pSubalterno;
               recTStoricoPart.SUP_CATASTALE := NVL(recTPartCertif.SUP_CATASTALE,0);
               --recTStoricoPart.ID_AREA_A := recTFoglio.ID_AREA_A;
               recTStoricoPart.ID_ZONA_ALTIMETRICA := NVL(recTPartCertif.ID_ZONA_ALTIMETRICA,recTFoglio.ID_ZONA_ALTIMETRICA) ;
               recTStoricoPart.FLAG_IRRIGABILE := 'N';
               --recTStoricoPart.ID_AREA_B := recTFoglio.ID_AREA_B;
               recTStoricoPart.ID_CASO_PARTICOLARE := NULL;
               --recTStoricoPart.ID_AREA_C := recTFoglio.ID_AREA_C;
               --recTStoricoPart.ID_AREA_D := recTFoglio.ID_AREA_D;
               recTStoricoPart.DATA_AGGIORNAMENTO := SYSDATE;
               recTStoricoPart.ID_UTENTE_AGGIORNAMENTO := pIdUtAgg;
               recTStoricoPart.FLAG_CAPTAZIONE_POZZI := NVL(recTFoglio.FLAG_CAPTAZIONE_POZZI,'N');
               --recTStoricoPart.ID_AREA_G := recTFoglio.ID_AREA_G;
               --recTStoricoPart.ID_AREA_H := NULL;
               recTStoricoPart.SUPERFICIE_GRAFICA := NVL(recTPartCertif.SUP_GRAFICA,0);
               recTStoricoPart.ID_POTENZIALITA_IRRIGUA := 3;
               recTStoricoPart.ID_TERRAZZAMENTO := 1;
               recTStoricoPart.ID_ROTAZIONE_COLTURALE := 4;
               --recTStoricoPart.ID_AREA_L := recTFoglio.ID_AREA_L;
               --recTStoricoPart.ID_AREA_I := recTFoglio.ID_AREA_I;
               --recTStoricoPart.ID_AREA_M := 6;

               InsertTStoricoParticella (recTStoricoPart);

               pRisultato := '0';
           ELSE
               pRisultato := '2';
               pMessaggio := 'Foglio non trovato per chiave catastale : ' || pComune || '/' || NVL(pSezione,'N.P.') || '/' || TRIM(TO_CHAR(pFoglio));
           END IF;
        ELSE
            pRisultato := '0';
        END IF;

        nIdParticella := NVL(recTStoricoPart.ID_PARTICELLA, -1);
        RETURN nIdParticella;


    EXCEPTION
        WHEN OTHERS THEN
             nIdParticella := -1;
             pRisultato := '1';
             pMessaggio := 'GestioneParticella : ' || SUBSTR(SQLERRM,1,150);
             RETURN nIdParticella;
    END GestioneParticella;

    /*********************************************************************
    Inserisce un record di tipo DB_FABBRICATO sulla tabella omonima
    Tipo: procedure
    input: pRecTFabbricato
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTFabbricato (pRecTFabbricato IN DB_FABBRICATO%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_FABBRICATO
            (
            ID_FABBRICATO,
            ID_TIPOLOGIA_FABBRICATO,
            ID_FORMA_FABBRICATO,
            DENOMINAZIONE,
            SUPERFICIE,
            ANNO_COSTRUZIONE,
            DIMENSIONE,
            LUNGHEZZA,
            LARGHEZZA,
            DATA_AGGIORNAMENTO,
            ALTEZZA,
            UTM_X,
            UTM_Y,
            NOTE,
            ID_UTENTE_AGGIORNAMENTO,
            ID_UTE,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA,
            ID_COLTURA_SERRA,
            MESI_RISCALDAMENTO_SERRA,
            ORE_RISCALDAMENTO_SERRA,
            DICHIARAZIONE_RIPRISTINATA,
            ID_DICHIARAZIONE_CONSISTENZA,
            VOLUME_UTILE_PRESUNTO,
            SUPERFICIE_COPERTA,
            SUPERFICIE_SCOPERTA,
            SUPERFICIE_SCOPERTA_EXTRA
            )
        VALUES
            (
            pRecTFabbricato.ID_FABBRICATO,
            pRecTFabbricato.ID_TIPOLOGIA_FABBRICATO,
            pRecTFabbricato.ID_FORMA_FABBRICATO,
            pRecTFabbricato.DENOMINAZIONE,
            pRecTFabbricato.SUPERFICIE,
            pRecTFabbricato.ANNO_COSTRUZIONE,
            pRecTFabbricato.DIMENSIONE,
            pRecTFabbricato.LUNGHEZZA,
            pRecTFabbricato.LARGHEZZA,
            pRecTFabbricato.DATA_AGGIORNAMENTO,
            pRecTFabbricato.ALTEZZA,
            pRecTFabbricato.UTM_X,
            pRecTFabbricato.UTM_Y,
            pRecTFabbricato.NOTE,
            pRecTFabbricato.ID_UTENTE_AGGIORNAMENTO,
            pRecTFabbricato.ID_UTE,
            pRecTFabbricato.DATA_INIZIO_VALIDITA,
            pRecTFabbricato.DATA_FINE_VALIDITA,
            pRecTFabbricato.ID_COLTURA_SERRA,
            pRecTFabbricato.MESI_RISCALDAMENTO_SERRA,
            pRecTFabbricato.ORE_RISCALDAMENTO_SERRA,
            pRecTFabbricato.DICHIARAZIONE_RIPRISTINATA,
            pRecTFabbricato.ID_DICHIARAZIONE_CONSISTENZA,
            pRecTFabbricato.VOLUME_UTILE_PRESUNTO,
            pRecTFabbricato.SUPERFICIE_COPERTA,
            pRecTFabbricato.SUPERFICIE_SCOPERTA,
            pRecTFabbricato.SUPERFICIE_SCOPERTA_EXTRA
            );
    END InsertTFabbricato;

    /*********************************************************************
    Inserisce un record di tipo DB_UTE sulla tabella omonima
    Tipo: procedure
    input: pRecTUte
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTUte (pRecTUte IN DB_UTE%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_UTE
            (
            ID_UTE,
            ID_AZIENDA,
            DENOMINAZIONE,
            INDIRIZZO,
            COMUNE,
            CAP,
            ID_ZONA_ALTIMETRICA,
            ID_ATTIVITA_ATECO,
            TELEFONO,
            FAX,
            NOTE,
            DATA_INIZIO_ATTIVITA,
            DATA_FINE_ATTIVITA,
            CAUSALE_CESSAZIONE,
            DATA_AGGIORNAMENTO,
            ID_UTENTE_AGGIORNAMENTO,
            MOTIVO_MODIFICA,
            ID_ATTIVITA_OTE,
            TIPO_SEDE
            )
        VALUES
            (
            pRecTUte.ID_UTE,
            pRecTUte.ID_AZIENDA,
            pRecTUte.DENOMINAZIONE,
            pRecTUte.INDIRIZZO,
            pRecTUte.COMUNE,
            pRecTUte.CAP,
            pRecTUte.ID_ZONA_ALTIMETRICA,
            pRecTUte.ID_ATTIVITA_ATECO,
            pRecTUte.TELEFONO,
            pRecTUte.FAX,
            pRecTUte.NOTE,
            pRecTUte.DATA_INIZIO_ATTIVITA,
            pRecTUte.DATA_FINE_ATTIVITA,
            pRecTUte.CAUSALE_CESSAZIONE,
            pRecTUte.DATA_AGGIORNAMENTO,
            pRecTUte.ID_UTENTE_AGGIORNAMENTO,
            pRecTUte.MOTIVO_MODIFICA,
            pRecTUte.ID_ATTIVITA_OTE,
            pRecTUte.TIPO_SEDE
            );
    END InsertTUte;

    /*********************************************************************
    Effettua il ribaltamento dell'ute dell'azienda in proprio e delle
    relative figlie (conduzione, utilizzo , fabbricati , allevamenti) sulle
    tabelle core
    Tipo: function
    input: pIdRichAzienda, pIdAzienda
    output: pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE RibaltaUteEFiglie (pIdRichAzienda IN DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                                 pIdAzienda     IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                 pRisultato    OUT VARCHAR2,
                                 pMessaggio    OUT VARCHAR2
                                ) IS

        CURSOR curNuovaUte IS
        SELECT UAN.*,
               C.ZONAALT,
               RA.ID_UTENTE_AGGIORNAMENTO
          FROM DB_RICHIESTA_AZIENDA RA,
               SMRGAA_W_AZIENDA_NUOVA AN,
               SMRGAA_W_UTE_AZIENDA_NUOVA UAN,
               COMUNE C
         WHERE RA.ID_RICHIESTA_AZIENDA = pIdRichAzienda
           AND RA.ID_AZIENDA_NUOVA = AN.ID_AZIENDA_NUOVA
           AND AN.ID_AZIENDA_NUOVA = UAN.ID_AZIENDA_NUOVA
           AND UAN.COMUNE = C.ISTAT_COMUNE;

        CURSOR curNuovoFabbricatoUte (pIdUteAzNuova IN SMRGAA_W_FABBRICATO_AZ_NUOVA.ID_UTE_AZIENDA_NUOVA%TYPE) IS
        SELECT *
          FROM SMRGAA_W_FABBRICATO_AZ_NUOVA
         WHERE ID_UTE_AZIENDA_NUOVA = pIdUteAzNuova;


        CURSOR curPartNuovoFabbricatoUte (pIdFabbrAzNuova IN SMRGAA_W_PART_FABBR_AZ_NUOVA.ID_FABBRICATO_AZ_NUOVA%TYPE) IS
        SELECT *
          FROM SMRGAA_W_PART_FABBR_AZ_NUOVA
         WHERE ID_FABBRICATO_AZ_NUOVA = pIdFabbrAzNuova;


        CURSOR curNuovoUtilizzoUte (pIdUteAzNuova IN SMRGAA_W_UTILIZZO_AZ_NUOVA.ID_UTE_AZIENDA_NUOVA%TYPE) IS
        SELECT UAZ.*,
               UAZ.SUPERFICIE * UM.COEFF_CONVERSIONE AS SUP_CONVERTITA
          FROM SMRGAA_W_UTILIZZO_AZ_NUOVA UAZ,
               DB_UNITA_MISURA UM
         WHERE UAZ.ID_UTE_AZIENDA_NUOVA = pIdUteAzNuova
           AND UAZ.ID_UNITA_MISURA = UM.ID_UNITA_MISURA;

        CURSOR curNuovoAllevamentoUte (pIdUteAzNuova IN SMRGAA_W_UTILIZZO_AZ_NUOVA.ID_UTE_AZIENDA_NUOVA%TYPE) IS
        SELECT AAZN.*,
               TCA.ID_SPECIE_ANIMALE,
               P.ISTAT_PROVINCIA
          FROM SMRGAA_W_ALLEVAMENTO_AZ_NUOVA AAZN,
               DB_TIPO_CATEGORIA_ANIMALE TCA,
               PROVINCIA P
         WHERE AAZN.ID_UTE_AZIENDA_NUOVA = pIdUteAzNuova
           AND AAZN.ID_CATEGORIA_ANIMALE = TCA.ID_CATEGORIA_ANIMALE
           AND SUBSTR(AAZN.CODICE_ASL,4,2) = P.SIGLA_PROVINCIA (+); 

        recTUte             DB_UTE%ROWTYPE;
        recTFabbricato      DB_FABBRICATO%ROWTYPE;
        recTFabbrPartic     DB_FABBRICATO_PARTICELLA%ROWTYPE;
        recTCondPart        DB_CONDUZIONE_PARTICELLA%ROWTYPE;
        recTCondPartGP      DB_CONDUZIONE_PARTICELLA%ROWTYPE;
        recTUtilizzoPart    DB_UTILIZZO_PARTICELLA%ROWTYPE;
        recTAllevamento     DB_ALLEVAMENTO%ROWTYPE;
        recDCatAnimale      DB_TIPO_CATEGORIA_ANIMALE%ROWTYPE;
        recTCategAllev      DB_CATEGORIE_ALLEVAMENTO%ROWTYPE;
        NO_FOGLIO           EXCEPTION;

    BEGIN

        FOR recNuovaUte IN curNuovaUte LOOP

            SELECT SEQ_UTE.nextval
              INTO recTUte.ID_UTE
              FROM DUAL;
            recTUte.ID_AZIENDA := pIDAzienda;
            recTUte.DENOMINAZIONE := recNuovaUte.DENOMINAZIONE;
            recTUte.INDIRIZZO := recNuovaUte.INDIRIZZO;
            recTUte.COMUNE := recNuovaUte.COMUNE;
            recTUte.CAP := recNuovaUte.CAP;
            recTUte.ID_ZONA_ALTIMETRICA := recNuovaUte.ZONAALT;
            recTUte.TELEFONO := recNuovaUte.TELEFONO;
            recTUte.FAX := recNuovaUte.FAX;
            recTUte.NOTE := recNuovaUte.NOTE;
            recTUte.ID_UTENTE_AGGIORNAMENTO := recNuovaUte.ID_UTENTE_AGGIORNAMENTO;
            recTUte.DATA_INIZIO_ATTIVITA := SYSDATE;
            recTUte.DATA_AGGIORNAMENTO := SYSDATE;
            InsertTUte (recTUte);

            FOR recNuovoFabbricatoUte IN curNuovoFabbricatoUte (recNuovaUte.ID_UTE_AZIENDA_NUOVA) LOOP

                SELECT SEQ_FABBRICATO.nextval
                  INTO recTFabbricato.ID_FABBRICATO
                  FROM DUAL;

                recTFabbricato.ID_TIPOLOGIA_FABBRICATO := recNuovoFabbricatoUte.ID_TIPOLOGIA_FABBRICATO;
                recTFabbricato.SUPERFICIE := recNuovoFabbricatoUte.SUPERFICIE;
                recTFabbricato.ANNO_COSTRUZIONE := recNuovoFabbricatoUte.ANNO_COSTRUZIONE;
                recTFabbricato.DIMENSIONE := recNuovoFabbricatoUte.DIMENSIONE;
                recTFabbricato.LUNGHEZZA := recNuovoFabbricatoUte.LUNGHEZZA;
                recTFabbricato.LARGHEZZA := recNuovoFabbricatoUte.LARGHEZZA;
                recTFabbricato.DATA_AGGIORNAMENTO := SYSDATE;
                recTFabbricato.ALTEZZA := recNuovoFabbricatoUte.ALTEZZA;
                recTFabbricato.ID_UTENTE_AGGIORNAMENTO := recNuovaUte.ID_UTENTE_AGGIORNAMENTO;
                recTFabbricato.ID_UTE := recTUte.ID_UTE;
                recTFabbricato.DATA_INIZIO_VALIDITA := SYSDATE;
                recTFabbricato.SUPERFICIE_COPERTA := recNuovoFabbricatoUte.SUPERFICIE_COPERTA;
                recTFabbricato.SUPERFICIE_SCOPERTA := recNuovoFabbricatoUte.SUPERFICIE_SCOPERTA;

                InsertTFabbricato (recTFabbricato);

                FOR recPartNuovoFabbricatoUte IN curPartNuovoFabbricatoUte (recNuovoFabbricatoUte.ID_FABBRICATO_AZ_NUOVA) LOOP
                    recTFabbrPartic.ID_PARTICELLA := GestioneParticella (recPartNuovoFabbricatoUte.COMUNE,
                                                                         recPartNuovoFabbricatoUte.SEZIONE,
                                                                         recPartNuovoFabbricatoUte.FOGLIO,
                                                                         recPartNuovoFabbricatoUte.PARTICELLA,
                                                                         recPartNuovoFabbricatoUte.SUBALTERNO,
                                                                         recPartNuovoFabbricatoUte.ID_TITOLO_POSSESSO,
                                                                         recPartNuovoFabbricatoUte.SUPERFICIE,
                                                                         recPartNuovoFabbricatoUte.ID_UTILIZZO,
                                                                         recPartNuovoFabbricatoUte.ID_VARIETA,
                                                                         recNuovaUte.ID_UTENTE_AGGIORNAMENTO,
                                                                         pRisultato,
                                                                         pMessaggio
                                                                         );

                    IF pRisultato = '0' THEN

                       SELECT SEQ_PARTICELLA_FABBRICATO.nextval
                         INTO recTFabbrPartic.ID_FABBRICATO_PARTICELLA
                         FROM DUAL;
                       recTFabbrPartic.ID_FABBRICATO := recTFabbricato.ID_FABBRICATO;
                       recTFabbrPartic.DATA_INIZIO_VALIDITA := SYSDATE;
                       InsertTFabbricatoParticella (recTFabbrPartic);

                       recTCondPart.ID_UTE := recTUte.ID_UTE;
                       recTCondPart.ID_PARTICELLA := recTFabbrPartic.ID_PARTICELLA;
                       recTCondPart.ID_TITOLO_POSSESSO := recPartNuovoFabbricatoUte.ID_TITOLO_POSSESSO;
                       recTCondPart.PERCENTUALE_POSSESSO := 100;

                       recTCondPartGP := SelTCondPartByUtePartTitPerc (recTCondPart.ID_UTE,
                                                                       recTCondPart.ID_PARTICELLA,
                                                                       recTCondPart.ID_TITOLO_POSSESSO,
                                                                       recTCondPart.PERCENTUALE_POSSESSO);

                       IF recTCondPartGP.ID_CONDUZIONE_PARTICELLA IS NOT NULL THEN
                          recTCondPart := recTCondPartGP;
                       ELSE
                          SELECT SEQ_CONDUZIONE_PARTICELLA.nextval
                            INTO recTCondPart.ID_CONDUZIONE_PARTICELLA
                            FROM DUAL;

                          recTCondPart.DATA_INIZIO_CONDUZIONE := SYSDATE;
                          recTCondPart.SUPERFICIE_CONDOTTA := recPartNuovoFabbricatoUte.SUPERFICIE;
                          recTCondPart.ID_UTENTE_AGGIORNAMENTO := recNuovaUte.ID_UTENTE_AGGIORNAMENTO;
                          recTCondPart.DATA_AGGIORNAMENTO := SYSDATE;
                          InsertTConduzioneParticella (recTCondPart);

                       END IF;

                       SELECT SEQ_UTILIZZO_PARTICELLA.nextval
                         INTO recTUtilizzoPart.ID_UTILIZZO_PARTICELLA
                         FROM DUAL;

                       recTUtilizzoPart.ID_CONDUZIONE_PARTICELLA := recTCondPart.ID_CONDUZIONE_PARTICELLA;
                       recTUtilizzoPart.ID_UTILIZZO := recPartNuovoFabbricatoUte.ID_UTILIZZO;
                       recTUtilizzoPart.SUPERFICIE_UTILIZZATA := recPartNuovoFabbricatoUte.SUPERFICIE;
                       recTUtilizzoPart.DATA_AGGIORNAMENTO := SYSDATE;
                       recTUtilizzoPart.ID_UTENTE_AGGIORNAMENTO := recNuovaUte.ID_UTENTE_AGGIORNAMENTO;
                       recTUtilizzoPart.ANNO := TO_CHAR(SYSDATE,'YYYY');
                       recTUtilizzoPart.ID_VARIETA := recPartNuovoFabbricatoUte.ID_VARIETA;
                       InsertTUtilizzoParticella (recTUtilizzoPart);

                    ELSE
                       RAISE NO_FOGLIO;
                    END IF;

                END LOOP;
            END LOOP;

            FOR recNuovoUtilizzoUte IN curNuovoUtilizzoUte (recNuovaUte.ID_UTE_AZIENDA_NUOVA) LOOP

                recTCondPart.ID_UTE := recTUte.ID_UTE;
                recTCondPart.ID_TITOLO_POSSESSO := recNuovoUtilizzoUte.ID_TITOLO_POSSESSO;
                recTCondPart.PERCENTUALE_POSSESSO := recNuovoUtilizzoUte.PERCENTUALE_CONDUZIONE;
                recTCondPart.ID_PARTICELLA := GestioneParticella (recNuovoUtilizzoUte.COMUNE,
                                                                  recNuovoUtilizzoUte.SEZIONE,
                                                                  recNuovoUtilizzoUte.FOGLIO,
                                                                  recNuovoUtilizzoUte.PARTICELLA,
                                                                  recNuovoUtilizzoUte.SUBALTERNO,
                                                                  recNuovoUtilizzoUte.ID_TITOLO_POSSESSO,
                                                                  recNuovoUtilizzoUte.SUPERFICIE,
                                                                  recNuovoUtilizzoUte.ID_UTILIZZO,
                                                                  recNuovoUtilizzoUte.ID_VARIETA,
                                                                  recNuovaUte.ID_UTENTE_AGGIORNAMENTO,
                                                                  pRisultato,
                                                                  pMessaggio
                                                                  );

                IF pRisultato = '0' THEN
                   recTCondPartGP := SelTCondPartByUtePartTitPerc (recTCondPart.ID_UTE,
                                                                   recTCondPart.ID_PARTICELLA,
                                                                   recTCondPart.ID_TITOLO_POSSESSO,
                                                                   recTCondPart.PERCENTUALE_POSSESSO);

                   IF recTCondPartGP.ID_CONDUZIONE_PARTICELLA IS NOT NULL THEN
                      recTCondPart := recTCondPartGP;
                   ELSE
                      SELECT SEQ_CONDUZIONE_PARTICELLA.nextval
                        INTO recTCondPart.ID_CONDUZIONE_PARTICELLA
                        FROM DUAL;

                      recTCondPart.DATA_INIZIO_CONDUZIONE := SYSDATE;
                      recTCondPart.SUPERFICIE_CONDOTTA := recNuovoUtilizzoUte.SUP_CONVERTITA;
                      recTCondPart.ID_UTENTE_AGGIORNAMENTO := recNuovaUte.ID_UTENTE_AGGIORNAMENTO;
                      recTCondPart.DATA_AGGIORNAMENTO := SYSDATE;
                      InsertTConduzioneParticella (recTCondPart);

                   END IF;

                   SELECT SEQ_UTILIZZO_PARTICELLA.nextval
                     INTO recTUtilizzoPart.ID_UTILIZZO_PARTICELLA
                     FROM DUAL;

                   recTUtilizzoPart.ID_CONDUZIONE_PARTICELLA := recTCondPart.ID_CONDUZIONE_PARTICELLA;
                   recTUtilizzoPart.ID_UTILIZZO := recNuovoUtilizzoUte.ID_UTILIZZO;
                   recTUtilizzoPart.SUPERFICIE_UTILIZZATA := recNuovoUtilizzoUte.SUP_CONVERTITA;
                   recTUtilizzoPart.DATA_AGGIORNAMENTO := SYSDATE;
                   recTUtilizzoPart.ID_UTENTE_AGGIORNAMENTO := recNuovaUte.ID_UTENTE_AGGIORNAMENTO;
                   recTUtilizzoPart.ANNO := TO_CHAR(SYSDATE,'YYYY');
                   recTUtilizzoPart.ID_VARIETA := recNuovoUtilizzoUte.ID_VARIETA;
                   InsertTUtilizzoParticella (recTUtilizzoPart);
                ELSE
                   RAISE NO_FOGLIO;
                END IF;

            END LOOP;

            FOR recNuovoAllevamentoUte IN curNuovoAllevamentoUte (recNuovaUte.ID_UTE_AZIENDA_NUOVA) LOOP

                recTAllevamento := SelTAllevByUteSpecieIdCodAsl (recTUte.ID_UTE,
                                                                 recNuovoAllevamentoUte.ID_SPECIE_ANIMALE,
                                                                 recNuovoAllevamentoUte.ID_ASL,
                                                                 recNuovoAllevamentoUte.CODICE_ASL);

                IF recTAllevamento.ID_ALLEVAMENTO IS NULL THEN

                    SELECT SEQ_ALLEVAMENTO.nextval
                      INTO recTAllevamento.ID_ALLEVAMENTO
                      FROM DUAL;

                    recTAllevamento.ID_UTE := recTUte.ID_UTE;
                    recTAllevamento.ID_ASL := recNuovoAllevamentoUte.ID_ASL;
                    IF recNuovoAllevamentoUte.CODICE_ASL IS NOT NULL THEN
                       -- mi calcolo l'istat comune dallo stesso
                       recTAllevamento.ISTAT_COMUNE := recNuovoAllevamentoUte.ISTAT_PROVINCIA || SUBSTR(recNuovoAllevamentoUte.CODICE_ASL,1,3);
                    ELSE
                       -- altrimenti comune dell'ute
                       recTAllevamento.ISTAT_COMUNE := recTUte.COMUNE;
                    END IF;
                    recTAllevamento.ID_SPECIE_ANIMALE := recNuovoAllevamentoUte.ID_SPECIE_ANIMALE;
                    recTAllevamento.CODICE_AZIENDA_ZOOTECNICA := recNuovoAllevamentoUte.CODICE_ASL;
                    recTAllevamento.DATA_INIZIO := SYSDATE;
                    recTAllevamento.NOTE := recNuovoAllevamentoUte.NOTE;
                    recTAllevamento.DATA_AGGIORNAMENTO := SYSDATE;
                    recTAllevamento.ID_UTENTE_AGGIORNAMENTO := recNuovaUte.ID_UTENTE_AGGIORNAMENTO;

                    InsertTAllevamento (recTAllevamento);
                END IF;

                SELECT SEQ_CATEGORIE_ALLEVAMENTO.nextval
                  INTO recTCategAllev.ID_CATEGORIE_ALLEVAMENTO
                  FROM DUAL;

                recTCategAllev.ID_CATEGORIA_ANIMALE := recNuovoAllevamentoUte.ID_CATEGORIA_ANIMALE;
                recTCategAllev.ID_ALLEVAMENTO := recTAllevamento.ID_ALLEVAMENTO;
                recTCategAllev.QUANTITA := recNuovoAllevamentoUte.NUMERO_CAPI;
                InsertTCategoriaAllevamento (recTCategAllev);

                INSERT INTO DB_SOTTOCATEGORIA_ALLEVAMENTO
                    (
                    ID_SOTTOCATEGORIA_ALLEVAMENTO,
                    ID_SOTTOCATEGORIA_ANIMALE,
                    ID_CATEGORIE_ALLEVAMENTO,
                    ORE_PASCOLO_INVERNO,
                    QUANTITA,
                    PESO_VIVO,
                    GIORNI_VUOTO_SANITARIO,
                    GIORNI_PASCOLO_ESTATE,
                    ORE_PASCOLO_ESTATE,
                    GIORNI_PASCOLO_INVERNO,
                    CICLI,
                    FLAG_BIOLOGICO
                    )
                SELECT SEQ_SOTTOCATEGORIA_ALLEVAMENTO.nextval,
                       ID_SOTTOCATEGORIA_ANIMALE,
                       recTCategAllev.ID_CATEGORIE_ALLEVAMENTO,
                       NULL,
                       recTCategAllev.QUANTITA,
                       PESO_VIVO_MEDIO,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       NULL,
                       'N'
                  FROM (
                SELECT ID_SOTTOCATEGORIA_ANIMALE,
                       PESO_VIVO_MEDIO
                  FROM DB_TIPO_SOTTOCATEGORIA_ANIMALE
                 WHERE ID_CATEGORIA_ANIMALE = recTCategAllev.ID_CATEGORIA_ANIMALE
                   AND DATA_FINE_VALIDITA IS NULL
              ORDER BY DESCRIZIONE)
                 WHERE ROWNUM = 1;

            END LOOP;

            UPDATE DB_CONDUZIONE_PARTICELLA CP
               SET SUPERFICIE_CONDOTTA = (SELECT SUM(SUPERFICIE_UTILIZZATA)
                                            FROM DB_UTILIZZO_PARTICELLA
                                           WHERE ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA)
             WHERE ID_UTE = recTUte.ID_UTE;

        END LOOP;

        pRisultato := '0';

    EXCEPTION
        WHEN NO_FOGLIO THEN
             NULL;
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'RibaltaUteEFiglie : ' || SUBSTR(SQLERRM,1,150);
    END RibaltaUteEFiglie;


    /*********************************************************************
    Effettua il ribaltamento del titolare / rappresentante legale dell'azienda
    in proprio sulle tabelle core di anagrafe
    Tipo: function
    input: pIdRichAzienda, pIdAzienda
    output: pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    FUNCTION RibaltaContitolare (pIdSoggetto IN DB_CONTITOLARE.ID_SOGGETTO%TYPE,
                                 pIdAzienda  IN DB_CONTITOLARE.ID_AZIENDA%TYPE,
                                 pRisultato OUT VARCHAR2,
                                 pMessaggio OUT VARCHAR2
                                 ) RETURN DB_CONTITOLARE%ROWTYPE IS
        recTContitolare DB_CONTITOLARE%ROWTYPE;
    BEGIN

        INSERT INTO DB_CONTITOLARE
            (
            ID_CONTITOLARE,
            ID_SOGGETTO,
            ID_RUOLO,
            ID_AZIENDA,
            DATA_INIZIO_RUOLO,
            DATA_FINE_RUOLO,
            FLAG_ACCESSO_FORZATO,
            DATA_INIZIO_RUOLO_MOD,
            DATA_FINE_RUOLO_MOD
            )
        VALUES
            (
            SEQ_CONTITOLARE.nextval,
            pIdSoggetto,
            knIdRuoloTitolareRapprLeg,
            pIdAzienda,
            TRUNC(SYSDATE),
            NULL,
            NULL,
            TRUNC(SYSDATE),
            NULL
            )
        RETURNING ID_CONTITOLARE,
                  ID_SOGGETTO,
                  ID_RUOLO,
                  ID_AZIENDA,
                  DATA_INIZIO_RUOLO,
                  DATA_FINE_RUOLO,
                  FLAG_ACCESSO_FORZATO,
                  DATA_INIZIO_RUOLO_MOD,
                  DATA_FINE_RUOLO_MOD
             INTO recTContitolare.ID_CONTITOLARE,
                  recTContitolare.ID_SOGGETTO,
                  recTContitolare.ID_RUOLO,
                  recTContitolare.ID_AZIENDA,
                  recTContitolare.DATA_INIZIO_RUOLO,
                  recTContitolare.DATA_FINE_RUOLO,
                  recTContitolare.FLAG_ACCESSO_FORZATO,
                  recTContitolare.DATA_INIZIO_RUOLO_MOD,
                  recTContitolare.DATA_FINE_RUOLO_MOD;

        pRisultato := '0';

        RETURN recTContitolare;

    EXCEPTION
        WHEN OTHERS THEN
             recTContitolare.ID_CONTITOLARE := -1;
             pRisultato := '1';
             pMessaggio := 'RibaltaContitolare : ' || SUBSTR(SQLERRM,1,150);
             RETURN recTContitolare;
    END RibaltaContitolare;

    /*********************************************************************
    Dato un ID_SOGGETTO lo ricerca su DB_SOGGETTO e restituisce il ROWTYPE
    Tipo: function
    input: pIdSoggetto
    output: DB_SOGGETTO%ROWTYPE
    ritorno: nessuno
    *********************************************************************/
    FUNCTION SelTSoggettoById (pIdSoggetto IN DB_SOGGETTO.ID_SOGGETTO%TYPE)
    RETURN DB_SOGGETTO%ROWTYPE IS
        recTSoggetto DB_SOGGETTO%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTSoggetto
          FROM DB_SOGGETTO
         WHERE ID_SOGGETTO = pIdSoggetto;

        RETURN recTSoggetto;

    END SelTSoggettoById;

    /*********************************************************************
    Dato un record di DB_SOGGETTO lo inserisce nella tabella omonima
    Tipo: procedure
    input: pRecTSoggetto
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTSoggetto (pRecTSoggetto IN DB_SOGGETTO%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_SOGGETTO
            (
            ID_SOGGETTO,
            FLAG_FISICO
            )
        VALUES
            (
            pRecTSoggetto.ID_SOGGETTO,
            pRecTSoggetto.FLAG_FISICO
            );
    END InsertTSoggetto;

    /*********************************************************************
    Dato un record di DB_PERSONA_FISICA lo inserisce nella tabella omonima
    Tipo: procedure
    input: pRecTPersonaFisica
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTPersonaFisica (pRecTPersonaFisica IN DB_PERSONA_FISICA%ROWTYPE) IS
    BEGIN
        INSERT INTO DB_PERSONA_FISICA
            (
            ID_PERSONA_FISICA,
            ID_SOGGETTO,
            CODICE_FISCALE,
            COGNOME,
            NASCITA_COMUNE,
            NOME,
            SESSO,
            RES_COMUNE,
            NASCITA_DATA,
            RES_INDIRIZZO,
            RES_CAP,
            RES_TELEFONO,
            RES_FAX,
            RES_MAIL,
            DATA_AGGIORNAMENTO,
            NOTE,
            ID_UTENTE_AGGIORNAMENTO,
            DOM_INDIRIZZO,
            DOM_CAP,
            NASCITA_CITTA_ESTERO,
            RES_CITTA_ESTERO,
            MODIFICA_INTERMEDIARIO,
            ID_TITOLO_STUDIO,
            ID_INDIRIZZO_STUDIO,
            DOM_COMUNE,
            DOM_CITTA_ESTERO,
            DATA_INIZIO_RESIDENZA,
            FLAG_CF_OK,
            NUMERO_CELLULARE,
            PREFISSO_INTER_CELLULARE,
            ID_PREFISSO_CELLULARE
            )
        VALUES
            (
            pRecTPersonaFisica.ID_PERSONA_FISICA,
            pRecTPersonaFisica.ID_SOGGETTO,
            pRecTPersonaFisica.CODICE_FISCALE,
            pRecTPersonaFisica.COGNOME,
            pRecTPersonaFisica.NASCITA_COMUNE,
            pRecTPersonaFisica.NOME,
            pRecTPersonaFisica.SESSO,
            pRecTPersonaFisica.RES_COMUNE,
            pRecTPersonaFisica.NASCITA_DATA,
            pRecTPersonaFisica.RES_INDIRIZZO,
            pRecTPersonaFisica.RES_CAP,
            pRecTPersonaFisica.RES_TELEFONO,
            pRecTPersonaFisica.RES_FAX,
            pRecTPersonaFisica.RES_MAIL,
            pRecTPersonaFisica.DATA_AGGIORNAMENTO,
            pRecTPersonaFisica.NOTE,
            pRecTPersonaFisica.ID_UTENTE_AGGIORNAMENTO,
            pRecTPersonaFisica.DOM_INDIRIZZO,
            pRecTPersonaFisica.DOM_CAP,
            pRecTPersonaFisica.NASCITA_CITTA_ESTERO,
            pRecTPersonaFisica.RES_CITTA_ESTERO,
            pRecTPersonaFisica.MODIFICA_INTERMEDIARIO,
            pRecTPersonaFisica.ID_TITOLO_STUDIO,
            pRecTPersonaFisica.ID_INDIRIZZO_STUDIO,
            pRecTPersonaFisica.DOM_COMUNE,
            pRecTPersonaFisica.DOM_CITTA_ESTERO,
            pRecTPersonaFisica.DATA_INIZIO_RESIDENZA,
            pRecTPersonaFisica.FLAG_CF_OK,
            pRecTPersonaFisica.NUMERO_CELLULARE,
            pRecTPersonaFisica.PREFISSO_INTER_CELLULARE,
            pRecTPersonaFisica.ID_PREFISSO_CELLULARE
            );
    END InsertTPersonaFisica;

    /*********************************************************************
    Ricerca su DB_PERSONA_FISICA per codice fiscale e ne restituisce il ROWTYPE
    in caso di TOO_MANY_ROWS ritorna il massimo ID_PERSONA_FISICA
    Tipo: function
    input: pCodFiscale
    output: nessuno
    ritorno: DB_PERSONA_FISICA%ROWTYPE
    *********************************************************************/
    FUNCTION SelTPersonaFisicaByCodFiscale (pCodFiscale IN DB_PERSONA_FISICA.CODICE_FISCALE%TYPE)
    RETURN DB_PERSONA_FISICA%ROWTYPE IS
        recTPersonaFisica DB_PERSONA_FISICA%ROWTYPE;
    BEGIN

        SELECT *
          INTO recTPersonaFisica
          FROM DB_PERSONA_FISICA
         WHERE CODICE_FISCALE = pCodFiscale;

        RETURN recTPersonaFisica;
    EXCEPTION
        WHEN TOO_MANY_ROWS THEN
             SELECT *
               INTO recTPersonaFisica
               FROM DB_PERSONA_FISICA
              WHERE ID_PERSONA_FISICA =
                (SELECT MAX(ID_PERSONA_FISICA)
                   FROM DB_PERSONA_FISICA
                  WHERE CODICE_FISCALE = pCodFiscale);

             RETURN recTPersonaFisica;
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTPersonaFisicaByCodFiscale;

    /*********************************************************************
    Effettua il ribaltamento dei dati della persona fisica legata all'azienda in proprio
    sulle tabelle core di anagrafe
    Tipo: function
    input: pIdRichAzienda, pIdAzienda
    output: pRisultato, pMessaggio
    ritorno: DB_PERSONA_FISICA%ROWTYPE
    *********************************************************************/
    FUNCTION RibaltaPersonaFisica (pIdRichAzienda      IN DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                                   pIdAzienda          IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                   pVetSoggetto        IN NUM_VARRAY,
                                   pRisultato         OUT VARCHAR2,
                                   pMessaggio         OUT VARCHAR2
                                   ) RETURN DB_PERSONA_FISICA%ROWTYPE IS
        recTPersonaFisica           DB_PERSONA_FISICA%ROWTYPE;
        recTPersonaFisicaGiaPres    DB_PERSONA_FISICA%ROWTYPE;
        bNewPersona                 BOOLEAN:=TRUE;
        recTSoggetto                DB_SOGGETTO%ROWTYPE;

    BEGIN

        SELECT AN.CODICE_FISCALE,
               AN.COGNOME,
               AN.NOME,
               AN.DATA_NASCITA,
               AN.SESSO,
               AN.COMUNE_NASCITA,
               AN.CITTA_NASCITA_ESTERO,
               AN.RES_COMUNE,
               AN.RES_CITTA_ESTERO,
               AN.RES_INDIRIZZO,
               AN.RES_CAP,
               AN.TELEFONO_SOGGETTO,
               AN.FAX_SOGGETTO,
               AN.MAIL_SOGGETTO,
               RA.ID_UTENTE_AGGIORNAMENTO
          INTO recTPersonaFisica.CODICE_FISCALE,
               recTPersonaFisica.COGNOME,
               recTPersonaFisica.NOME,
               recTPersonaFisica.NASCITA_DATA,
               recTPersonaFisica.SESSO,
               recTPersonaFisica.NASCITA_COMUNE,
               recTPersonaFisica.NASCITA_CITTA_ESTERO,
               recTPersonaFisica.RES_COMUNE,
               recTPersonaFisica.RES_CITTA_ESTERO,
               recTPersonaFisica.RES_INDIRIZZO,
               recTPersonaFisica.RES_CAP,
               recTPersonaFisica.RES_TELEFONO,
               recTPersonaFisica.RES_FAX,
               recTPersonaFisica.RES_MAIL,
               recTPersonaFisica.ID_UTENTE_AGGIORNAMENTO
          FROM DB_RICHIESTA_AZIENDA RA,
               SMRGAA_W_AZIENDA_NUOVA AN
         WHERE RA.ID_RICHIESTA_AZIENDA = pIdRichAzienda
           AND RA.ID_AZIENDA_NUOVA = AN.ID_AZIENDA_NUOVA ;

        -- e' potenzialmente valorizzato solo x le richieste di tipo 4
        IF pVetSoggetto.COUNT = 0 THEN
           -- negli altri casi ricerco su persona fisica solo per codice fiscale
           recTPersonaFisicaGiaPres := SelTPersonaFisicaByCodFiscale (recTPersonaFisica.CODICE_FISCALE);
        ELSE
           -- in quel caso contiene gli ID_SOGGETTO che avevano un ruolo sull'azienda
           -- e posso cercare la persona fisica per ID_SOGGETTO e CF
           BEGIN
               SELECT *
                 INTO recTPersonaFisicaGiaPres
                 FROM DB_PERSONA_FISICA
                WHERE CODICE_FISCALE = recTPersonaFisica.CODICE_FISCALE
                  AND ID_SOGGETTO IN (SELECT *
                                        FROM TABLE(CAST(pVetSoggetto AS Num_Varray)));

           EXCEPTION
                WHEN NO_DATA_FOUND THEN
                     recTPersonaFisicaGiaPres := NULL;

           END;
        END IF;

        IF recTPersonaFisicaGiaPres.ID_PERSONA_FISICA IS NOT NULL THEN
           bNewPersona := FALSE;
           recTPersonaFisica := recTPersonaFisicaGiaPres;
           pMessaggio := 'Persona fisica gia'' esistente';
        END IF;

        IF bNewPersona THEN

           SELECT SEQ_SOGGETTO.nextval
             INTO recTSoggetto.ID_SOGGETTO
             FROM DUAL;

           recTSoggetto.Flag_Fisico := 'S';
           InsertTSoggetto(recTSoggetto);

           SELECT SEQ_PERSONA_FISICA.nextval
             INTO recTPersonaFisica.ID_PERSONA_FISICA
             FROM DUAL;
           recTPersonaFisica.ID_SOGGETTO := recTSoggetto.ID_SOGGETTO;
           recTPersonaFisica.DATA_AGGIORNAMENTO := SYSDATE;
           recTPersonaFisica.DATA_INIZIO_RESIDENZA := SYSDATE;
           recTPersonaFisica.FLAG_CF_OK := 'S';
           InsertTPersonaFisica (recTPersonaFisica);

        END IF;

        pRisultato := '0';

        RETURN recTPersonaFisica;

    EXCEPTION
        WHEN OTHERS THEN
             recTPersonaFisica.ID_PERSONA_FISICA := -1;
             pRisultato := '1';
             pMessaggio := 'RibaltaPersonaFisica : ' || SUBSTR(SQLERRM,1,150);
             RETURN recTPersonaFisica;
    END RibaltaPersonaFisica;

    /*********************************************************************
    Chiude i record attivi per l'azienda su DB_CONTITOLARE
    ed attiva i nuovi contitolari presenti sulla richiesta azienda
    Tipo: procedure
    input: pIdAzienda, pIdRichAzienda
    output: pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE ChiudiERiapriContitolare (pIdAzienda     IN DB_CONTITOLARE.ID_AZIENDA%TYPE,
                                        pIdRichAzienda IN DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                                        pRisultato    OUT VARCHAR2,
                                        pMessaggio    OUT VARCHAR2
                                        ) IS

        VetSoggetto         Num_Varray := Num_Varray ();

        recTPersonaFisica   DB_PERSONA_FISICA%ROWTYPE;
        recTContitolare     DB_CONTITOLARE%ROWTYPE;
    BEGIN

        UPDATE DB_CONTITOLARE
           SET DATA_FINE_RUOLO = SYSDATE
         WHERE ID_AZIENDA = pIdAzienda
           AND DATA_FINE_RUOLO IS NULL
        RETURN ID_SOGGETTO BULK COLLECT INTO VetSoggetto;

        -- poi ribalto la persona fisica (e' possibile che sia anche gia' presente)
        recTPersonaFisica := RibaltaPersonaFisica (pIdRichAzienda,
                                                   pIdAzienda,
                                                   VetSoggetto,
                                                   pRisultato ,
                                                   pMessaggio);

        IF pRisultato = '0' THEN
           -- inserisco il contitolare quello dovrebbe non essere gia' presente
           recTContitolare := RibaltaContitolare (recTPersonaFisica.ID_SOGGETTO,
                                                  pIdAzienda,
                                                  pRisultato ,
                                                  pMessaggio);
        END IF;

    EXCEPTION
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'ChiudiERiapriContitolare : ID_AZIENDA =  ' || pIdAzienda || ' - ' || SUBSTR(SQLERRM,1,150);
    END ChiudiERiapriContitolare;

    /*********************************************************************
    Dato un record di tipo DB_ANAGRAFICA_AZIENDA lo inserisce sulla tabella omonima
    Tipo: procedure
    input: pRecTAnagrAzienda
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTAnagraficaAzienda (pRecTAnagrAzienda IN DB_ANAGRAFICA_AZIENDA%ROWTYPE) IS
    BEGIN
        INSERT INTO DB_ANAGRAFICA_AZIENDA
            (
            ID_ANAGRAFICA_AZIENDA,
            ID_AZIENDA,
            ID_TIPOLOGIA_AZIENDA,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA,
            CUAA,
            PARTITA_IVA,
            DENOMINAZIONE,
            ID_FORMA_GIURIDICA,
            ID_ATTIVITA_ATECO,
            PROVINCIA_COMPETENZA,
            CCIAA_PROVINCIA_REA,
            CCIAA_NUMERO_REA,
            MAIL,
            SEDELEG_COMUNE,
            SEDELEG_INDIRIZZO,
            SITOWEB,
            SEDELEG_CITTA_ESTERO,
            SEDELEG_CAP,
            DATA_CESSAZIONE,
            CAUSALE_CESSAZIONE,
            NOTE,
            DATA_AGGIORNAMENTO,
            ID_UTENTE_AGGIORNAMENTO,
            ID_ATTIVITA_OTE,
            MOTIVO_MODIFICA,
            CCIAA_NUMERO_REGISTRO_IMPRESE,
            CCIAA_ANNO_ISCRIZIONE,
            MODIFICA_INTERMEDIARIO,
            NUMERO_AGEA,
            INTESTAZIONE_PARTITA_IVA,
            ID_CESSAZIONE,
            ID_DIMENSIONE_AZIENDA,
            ID_UDE,
            RLS,
            ULU,
            CODICE_AGRITURISMO,
            TELEFONO,
            FAX,
            PEC,
            ESONERO_PAGAMENTO_GF
            )
        VALUES
            (
            pRecTAnagrAzienda.ID_ANAGRAFICA_AZIENDA,
            pRecTAnagrAzienda.ID_AZIENDA,
            pRecTAnagrAzienda.ID_TIPOLOGIA_AZIENDA,
            pRecTAnagrAzienda.DATA_INIZIO_VALIDITA,
            pRecTAnagrAzienda.DATA_FINE_VALIDITA,
            pRecTAnagrAzienda.CUAA,
            pRecTAnagrAzienda.PARTITA_IVA,
            pRecTAnagrAzienda.DENOMINAZIONE,
            pRecTAnagrAzienda.ID_FORMA_GIURIDICA,
            pRecTAnagrAzienda.ID_ATTIVITA_ATECO,
            pRecTAnagrAzienda.PROVINCIA_COMPETENZA,
            pRecTAnagrAzienda.CCIAA_PROVINCIA_REA,
            pRecTAnagrAzienda.CCIAA_NUMERO_REA,
            pRecTAnagrAzienda.MAIL,
            pRecTAnagrAzienda.SEDELEG_COMUNE,
            pRecTAnagrAzienda.SEDELEG_INDIRIZZO,
            pRecTAnagrAzienda.SITOWEB,
            pRecTAnagrAzienda.SEDELEG_CITTA_ESTERO,
            pRecTAnagrAzienda.SEDELEG_CAP,
            pRecTAnagrAzienda.DATA_CESSAZIONE,
            pRecTAnagrAzienda.CAUSALE_CESSAZIONE,
            pRecTAnagrAzienda.NOTE,
            pRecTAnagrAzienda.DATA_AGGIORNAMENTO,
            pRecTAnagrAzienda.ID_UTENTE_AGGIORNAMENTO,
            pRecTAnagrAzienda.ID_ATTIVITA_OTE,
            pRecTAnagrAzienda.MOTIVO_MODIFICA,
            pRecTAnagrAzienda.CCIAA_NUMERO_REGISTRO_IMPRESE,
            pRecTAnagrAzienda.CCIAA_ANNO_ISCRIZIONE,
            pRecTAnagrAzienda.MODIFICA_INTERMEDIARIO,
            pRecTAnagrAzienda.NUMERO_AGEA,
            pRecTAnagrAzienda.INTESTAZIONE_PARTITA_IVA,
            pRecTAnagrAzienda.ID_CESSAZIONE,
            pRecTAnagrAzienda.ID_DIMENSIONE_AZIENDA,
            pRecTAnagrAzienda.ID_UDE,
            pRecTAnagrAzienda.RLS,
            pRecTAnagrAzienda.ULU,
            pRecTAnagrAzienda.CODICE_AGRITURISMO,
            pRecTAnagrAzienda.TELEFONO,
            pRecTAnagrAzienda.FAX,
            pRecTAnagrAzienda.PEC,
            pRecTAnagrAzienda.ESONERO_PAGAMENTO_GF
            );
    END InsertTAnagraficaAzienda;

    /*********************************************************************
    Dato un record di tipo DB_AZIENDA lo inserisce sulla tabella omonima
    Tipo: procedure
    input: pRecTAzienda
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTAzienda (pRecTAzienda IN DB_AZIENDA%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_AZIENDA
            (
            ID_AZIENDA,
            DATA_INIZIO_VALIDITA,
            FLAG_BONIFICA_DATI,
            VARIAZIONE_UTILIZZI_AMMESSA,
            FLAG_OBBLIGO_FASCICOLO,
            ID_AZIENDA_PROVENIENZA,
            FLAG_AZIENDA_PROVVISORIA,
            DATA_INSEDIAMENTO,
            FLAG_ESENTE_DELEGA,
            FLAG_COMPETENZA_ESCLUSIVA_PA,
            DATA_CONTROLLO,
            ID_OPR,
            DATA_APERTURA_FASCICOLO,
            DATA_CHIUSURA_FASCICOLO,
            DATA_AGGIORNAMENTO_OPR,
            ID_UTENTE_AGGIORNAMENTO_OPR,
            DATA_AGGIORNAMENTO_PRATICA,
            ID_TIPO_FORMA_ASSOCIATA,
            FASCICOLO_DEMATERIALIZZATO
            )
        VALUES
            (
            pRecTAzienda.ID_AZIENDA,
            pRecTAzienda.DATA_INIZIO_VALIDITA,
            pRecTAzienda.FLAG_BONIFICA_DATI,
            pRecTAzienda.VARIAZIONE_UTILIZZI_AMMESSA,
            pRecTAzienda.FLAG_OBBLIGO_FASCICOLO,
            pRecTAzienda.ID_AZIENDA_PROVENIENZA,
            pRecTAzienda.FLAG_AZIENDA_PROVVISORIA,
            pRecTAzienda.DATA_INSEDIAMENTO,
            pRecTAzienda.FLAG_ESENTE_DELEGA,
            pRecTAzienda.FLAG_COMPETENZA_ESCLUSIVA_PA,
            pRecTAzienda.DATA_CONTROLLO,
            pRecTAzienda.ID_OPR,
            pRecTAzienda.DATA_APERTURA_FASCICOLO,
            pRecTAzienda.DATA_CHIUSURA_FASCICOLO,
            pRecTAzienda.DATA_AGGIORNAMENTO_OPR,
            pRecTAzienda.ID_UTENTE_AGGIORNAMENTO_OPR,
            pRecTAzienda.DATA_AGGIORNAMENTO_PRATICA,
            pRecTAzienda.ID_TIPO_FORMA_ASSOCIATA,
            pRecTAzienda.FASCICOLO_DEMATERIALIZZATO
            );
    END InsertTAzienda;

    /*********************************************************************
    Effettua il ribaltamento dell'azienda in proprio su DB_AZIENDA
    Tipo: function
    input: pIdRichAzienda
    output: pRisultato, pMessaggio
    ritorno: DB_AZIENDA%ROWTYPE
    *********************************************************************/
    FUNCTION RibaltaTAzienda (pIdRichAzienda IN DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                              pRisultato    OUT VARCHAR2,
                              pMessaggio    OUT VARCHAR2
                              )
    RETURN DB_AZIENDA%ROWTYPE IS
        recTAzienda DB_AZIENDA%ROWTYPE;
    BEGIN
        SELECT SEQ_AZIENDA.nextval
          INTO recTAzienda.ID_AZIENDA
          FROM DUAL;

        recTAzienda.DATA_INIZIO_VALIDITA := TRUNC(SYSDATE);
        recTAzienda.FLAG_BONIFICA_DATI := NULL;
        recTAzienda.VARIAZIONE_UTILIZZI_AMMESSA := NULL;
        recTAzienda.FLAG_OBBLIGO_FASCICOLO := 'N';
        recTAzienda.ID_AZIENDA_PROVENIENZA := NULL;
        recTAzienda.FLAG_AZIENDA_PROVVISORIA := NULL;
        recTAzienda.DATA_INSEDIAMENTO := NULL;
        recTAzienda.FLAG_ESENTE_DELEGA := 'N';
        recTAzienda.FLAG_COMPETENZA_ESCLUSIVA_PA := 'N';
        recTAzienda.DATA_CONTROLLO := SYSDATE;
        recTAzienda.ID_OPR := 5;
        recTAzienda.DATA_APERTURA_FASCICOLO := SYSDATE;
        recTAzienda.DATA_CHIUSURA_FASCICOLO := NULL;
        recTAzienda.DATA_AGGIORNAMENTO_OPR := NULL;
        recTAzienda.ID_UTENTE_AGGIORNAMENTO_OPR := NULL;
        recTAzienda.DATA_AGGIORNAMENTO_PRATICA := NULL;
        recTAzienda.ID_TIPO_FORMA_ASSOCIATA := NULL;
        recTAzienda.FASCICOLO_DEMATERIALIZZATO := 'S'; 

        InsertTAzienda (recTAzienda);

        pRisultato := '0';

        RETURN recTAzienda;


    EXCEPTION
        WHEN OTHERS THEN
             recTAzienda.ID_AZIENDA := -1;
             pRisultato := '1';
             pMessaggio := 'RibaltaTAzienda : ' || SUBSTR(SQLERRM,1,150);
             RETURN recTAzienda;

    END RibaltaTAzienda;

    /*********************************************************************
    Effettua il ribaltamento dai dati anagrafici dell'azienda in proprio
    su DB_ANAGRAFICA_AZIENDA
    Tipo: function
    input: pIdRichAzienda , pIdAzienda
    output: pRisultato, pMessaggio
    ritorno: DB_ANAGRAFICA_AZIENDA%ROWTYPE
    *********************************************************************/
    FUNCTION RibaltaTAnagraficaAzienda (pIdRichAzienda      IN DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                                        pIdAzienda          IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                        pRisultato         OUT VARCHAR2,
                                        pMessaggio         OUT VARCHAR2
                                        ) RETURN DB_ANAGRAFICA_AZIENDA%ROWTYPE IS
        recTAnagrAzienda DB_ANAGRAFICA_AZIENDA%ROWTYPE;
        nIdAziendaSub    DB_AZIENDA.ID_AZIENDA_PROVENIENZA%TYPE;
        vCodEnte         SMRGAA_W_AZIENDA_NUOVA.CODICE_ENTE%TYPE;
    BEGIN

        SELECT SEQ_ANAGRAFICA_AZIENDA.nextval
          INTO recTAnagrAzienda.ID_ANAGRAFICA_AZIENDA
          FROM DUAL;
        recTAnagrAzienda.ID_AZIENDA := pIdAzienda;

        SELECT AN.ID_TIPOLOGIA_AZIENDA,
               AN.CUAA,
               AN.PARTITA_IVA,
               AN.DENOMINAZIONE,
               AN.ID_FORMA_GIURIDICA,
               AN.SEDELEG_COMUNE,
               AN.SEDELEG_INDIRIZZO,
               AN.SEDELEG_CITTA_ESTERO,
               AN.SEDELEG_CAP,
               AN.MAIL,
               AN.TELEFONO,
               AN.FAX,
               AN.PEC,
               AN.NOTE,
               RA.ID_UTENTE_AGGIORNAMENTO,
               DECODE((SELECT ID_REGIONE
                         FROM PROVINCIA
                        WHERE ISTAT_PROVINCIA = NVL(SUBSTR(AN.SEDELEG_COMUNE,1,3), SUBSTR(AN.RES_COMUNE,1,3))),
                      kvIdRegionePiemonte,
                      NVL(SUBSTR(AN.SEDELEG_COMUNE,1,3), SUBSTR(AN.RES_COMUNE,1,3)),
                      kvIstatProvTorino), 
               ID_AZIENDA_SUBENTRO, 
               AN.CODICE_ENTE 
          INTO recTAnagrAzienda.ID_TIPOLOGIA_AZIENDA,
               recTAnagrAzienda.CUAA,
               recTAnagrAzienda.PARTITA_IVA,
               recTAnagrAzienda.DENOMINAZIONE,
               recTAnagrAzienda.ID_FORMA_GIURIDICA,
               recTAnagrAzienda.SEDELEG_COMUNE,
               recTAnagrAzienda.SEDELEG_INDIRIZZO,
               recTAnagrAzienda.SEDELEG_CITTA_ESTERO,
               recTAnagrAzienda.SEDELEG_CAP,
               recTAnagrAzienda.MAIL,
               recTAnagrAzienda.TELEFONO,
               recTAnagrAzienda.FAX,
               recTAnagrAzienda.PEC,
               recTAnagrAzienda.NOTE,
               recTAnagrAzienda.ID_UTENTE_AGGIORNAMENTO,
               recTAnagrAzienda.PROVINCIA_COMPETENZA,
               nIdAziendaSub, 
               vCodEnte       
          FROM DB_RICHIESTA_AZIENDA RA,
               SMRGAA_W_AZIENDA_NUOVA AN
         WHERE RA.ID_RICHIESTA_AZIENDA = pIdRichAzienda
           AND RA.ID_AZIENDA_NUOVA = AN.ID_AZIENDA_NUOVA ;

        recTAnagrAzienda.DATA_INIZIO_VALIDITA := TRUNC(SYSDATE);
        recTAnagrAzienda.DATA_AGGIORNAMENTO := SYSDATE;
        IF vCodEnte IS NOT NULL THEN
            recTAnagrAzienda.INTESTAZIONE_PARTITA_IVA:=vCodEnte;
        END IF;

        InsertTAnagraficaAzienda (recTAnagrAzienda);
        IF nIdAziendaSub IS NOT NULL THEN
           UPDATE DB_AZIENDA
              SET ID_AZIENDA_PROVENIENZA = nIdAziendaSub
            WHERE ID_AZIENDA = pIdAzienda;
        END IF;

        pRisultato := '0';

        RETURN recTAnagrAzienda;

    EXCEPTION
        WHEN OTHERS THEN
             recTAnagrAzienda.ID_AZIENDA := -1;
             pRisultato := '1';
             pMessaggio := 'RibaltaTAnagraficaAzienda : ' || SUBSTR(SQLERRM,1,150);
             RETURN recTAnagrAzienda;
    END RibaltaTAnagraficaAzienda;

    /*********************************************************************
    Verifica se l'azienda in proprio legata alla richiesta in elaborazione
    e' gia presente su DB_ANAGRAFICA_AZIENDA
    Tipo: function
    input: pIdRichAzienda
    output: nessuno
    ritorno: TRUE / FALSE
    *********************************************************************/
    FUNCTION AziendaGiaPresente (pIdRichAzienda IN DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                                 pIdAzienda    OUT DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE
                                 )
    RETURN BOOLEAN IS
        bRet BOOLEAN:=FALSE;
        nRec INTEGER:=0;
    BEGIN

        SELECT AZ.ID_AZIENDA
          INTO pIdAzienda
          FROM DB_ANAGRAFICA_AZIENDA AZ,
               DB_RICHIESTA_AZIENDA RA,
               SMRGAA_W_AZIENDA_NUOVA AN
         WHERE RA.ID_RICHIESTA_AZIENDA = pIdRichAzienda
           AND RA.ID_AZIENDA_NUOVA = AN.ID_AZIENDA_NUOVA
           --AND AZ.ID_TIPOLOGIA_AZIENDA = AN.ID_TIPOLOGIA_AZIENDA
           --AND AZ.ID_FORMA_GIURIDICA = AN.ID_FORMA_GIURIDICA
           AND AN.CUAA = AZ.CUAA
           AND AZ.DATA_FINE_VALIDITA IS NULL;
           --AND AZ.DATA_CESSAZIONE IS NULL;

        bRet := TRUE;

        RETURN bRet;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             bRet := FALSE;
             RETURN bRet;
        WHEN TOO_MANY_ROWS THEN
             pIdAzienda := -1;
             bRet := TRUE;
             RETURN bRet;
    END AziendaGiaPresente;

    /*********************************************************************
    Seleziona il record di DB_RICHIESTA_AZIENDA presente per l'ID_RICHIESTA_AZIENDA
    passato in input ed il suo iter attivo
    Tipo: function
    input: pIdRichAzienda
    output: pRecIterRich
    ritorno: DB_RICHIESTA_AZIENDA%ROWTYPE
    *********************************************************************/
    FUNCTION SelTRichAziendaWithLastIter(pIdRichAzienda IN DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                                         pRecIterRich  OUT DB_ITER_RICHIESTA_AZIENDA%ROWTYPE
                                         ) RETURN DB_RICHIESTA_AZIENDA%ROWTYPE IS
        recTRichiestaAzienda DB_RICHIESTA_AZIENDA%ROWTYPE;
    BEGIN
        SELECT RA.*
          INTO recTRichiestaAzienda
          FROM DB_RICHIESTA_AZIENDA RA
         WHERE RA.ID_RICHIESTA_AZIENDA = pIdRichAzienda;

        BEGIN
            SELECT IRA.*
              INTO pRecIterRich
              FROM DB_ITER_RICHIESTA_AZIENDA IRA
             WHERE IRA.ID_RICHIESTA_AZIENDA = pIdRichAzienda
               AND IRA.DATA_FINE_VALIDITA IS NULL;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 pRecIterRich := NULL;
        END;

        RETURN recTRichiestaAzienda;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTRichAziendaWithLastIter;

    /*********************************************************************
    Verifica se per l'azienda o la dichiarazione fornite in input sono
    presenti le attestazioni per la deroga sull'avvicendamento per condizionalita'
    Tipo: function
    input: pIdAzienda, pIdDichCons
    output: nessuno
    ritorno: TRUE / FALSE
    *********************************************************************/
    FUNCTION EsisteDerogaPerCondizionalita (pIdAzienda  IN DB_DICHIARAZIONE_CONSISTENZA.ID_AZIENDA%TYPE,
                                            pIdDichCons IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE
                                            ) RETURN BOOLEAN IS
        bEsisteDeroga   BOOLEAN:= FALSE;
        nRec            INTEGER:=0;
    BEGIN

        IF pIdDichCons IS NULL THEN
           SELECT COUNT(AA.ID_ATTESTAZIONE)
             INTO nRec
             FROM DB_ATTESTAZIONE_AZIENDA AA,
                  DB_TIPO_CONTROLLO_PARAMETRO TCP
            WHERE TCP.ID_CONTROLLO = 714
              AND TCP.DATA_FINE_VALIDITA IS NULL
              AND AA.ID_AZIENDA = pIdAzienda
              AND AA.ID_ATTESTAZIONE = TCP.VALORE_NUMERICO;

        ELSE
           SELECT COUNT(AD.ID_ATTESTAZIONE)
             INTO nRec
             FROM DB_ATTESTAZIONE_DICHIARATA AD,
                  DB_DICHIARAZIONE_CONSISTENZA DC,
                  DB_TIPO_CONTROLLO_PARAMETRO TCP
            WHERE TCP.ID_CONTROLLO = 714
              AND TCP.DATA_FINE_VALIDITA IS NULL
              AND DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
              AND AD.CODICE_FOTOGRAFIA_TERRENI = DC.CODICE_FOTOGRAFIA_TERRENI
              AND AD.ID_ATTESTAZIONE = TCP.VALORE_NUMERICO
              AND AD.DATA_FINE_VALIDITA IS NULL;

        END IF;

        IF nRec > 0 THEN
           bEsisteDeroga := TRUE;
        END IF;

        RETURN bEsisteDeroga;

    END EsisteDerogaPerCondizionalita;

    /*********************************************************************
    Inserisce un record di tipo SMRGAA_W_AVVICENDAMENTO_COND sull'omonima tabella
    Tipo: procedure
    input: pRecWAvvicendamentoCond
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertWAvvicendamentoCond (pRecWAvvicendamentoCond IN SMRGAA_W_AVVICENDAMENTO_COND%ROWTYPE) IS
    BEGIN

        INSERT INTO SMRGAA_W_AVVICENDAMENTO_COND
            (
            ID_AVVICENDAMENTO_COND,
            ID_RICH_AVVICENDAMENTO,
            ID_AZIENDA,
            ID_PARTICELLA,
            ANNO,
            ID_UTILIZZO,
            ID_VARIETA,
            SUPERFICIE_UTILIZZATA,
            CONDUZIONE_IN_AZIENDA,
            PRESENZA_DU_PSR,
            ESITO,
            MESSAGGIO
            )
        VALUES
            (
            pRecWAvvicendamentoCond.ID_AVVICENDAMENTO_COND,
            pRecWAvvicendamentoCond.ID_RICH_AVVICENDAMENTO,
            pRecWAvvicendamentoCond.ID_AZIENDA,
            pRecWAvvicendamentoCond.ID_PARTICELLA,
            pRecWAvvicendamentoCond.ANNO,
            pRecWAvvicendamentoCond.ID_UTILIZZO,
            pRecWAvvicendamentoCond.ID_VARIETA,
            pRecWAvvicendamentoCond.SUPERFICIE_UTILIZZATA,
            pRecWAvvicendamentoCond.CONDUZIONE_IN_AZIENDA,
            pRecWAvvicendamentoCond.PRESENZA_DU_PSR,
            pRecWAvvicendamentoCond.ESITO,
            pRecWAvvicendamentoCond.MESSAGGIO
            );

    END InsertWAvvicendamentoCond;

    /*********************************************************************
    Ricerca l'ultima dichiarazione di consistenza protocollata presente per la particella
    e l'anno (a partire dall'azienda fornita in input ma cercando anche su
    eventuali altre aziende)
    Tipo: function
    input: pIdAzienda, pAnno, pIdPart
    output: nessuno
    ritorno: nIdDichCons
    *********************************************************************/
    FUNCTION SelMaxDichConsForAzPartAnno (pIdAzienda IN DB_DICHIARAZIONE_CONSISTENZA.ID_AZIENDA%TYPE,
                                          pAnno      IN DB_DICHIARAZIONE_CONSISTENZA.ANNO%TYPE,
                                          pIdPart    IN DB_CONDUZIONE_DICHIARATA.ID_PARTICELLA%TYPE
                                          )
    RETURN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE IS
        nIdDichCons DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE;
    BEGIN

        SELECT MAX(DC.ID_DICHIARAZIONE_CONSISTENZA)
          INTO nIdDichCons
          FROM DB_DICHIARAZIONE_CONSISTENZA DC,
               DB_CONDUZIONE_DICHIARATA CD,
               DB_PROCEDIMENTO_AZIENDA PA
         WHERE DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
           AND DC.ID_AZIENDA = pIdAzienda
           AND CD.ID_PARTICELLA = pIdPart
           AND DC.ANNO = pAnno
           AND DC.ID_DICHIARAZIONE_CONSISTENZA = PA.ID_DICHIARAZIONE_CONSISTENZA
           AND PA.ID_PROCEDIMENTO IN (knIdProcedimentoRPU, knIdProcedimentoPSR)
           AND CD.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento; 

        IF nIdDichCons IS NULL THEN

            SELECT MAX(DC.ID_DICHIARAZIONE_CONSISTENZA)
              INTO nIdDichCons
              FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                   DB_CONDUZIONE_DICHIARATA CD,
                   DB_PROCEDIMENTO_AZIENDA PA
             WHERE DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
               AND CD.ID_PARTICELLA = pIdPart
               AND DC.ANNO = pAnno
               AND DC.ID_DICHIARAZIONE_CONSISTENZA = PA.ID_DICHIARAZIONE_CONSISTENZA
               AND PA.ID_PROCEDIMENTO IN (knIdProcedimentoRPU, knIdProcedimentoPSR)
               AND CD.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento; 

            IF nIdDichCons IS NULL THEN

               SELECT MAX(DC.ID_DICHIARAZIONE_CONSISTENZA)
                 INTO nIdDichCons
                 FROM DB_DICHIARAZIONE_CONSISTENZA DC,
                      DB_CONDUZIONE_DICHIARATA CD
                WHERE DC.CODICE_FOTOGRAFIA_TERRENI = CD.CODICE_FOTOGRAFIA_TERRENI
                  AND CD.ID_PARTICELLA = pIdPart
                  AND DC.ANNO = pAnno
                  AND DC.NUMERO_PROTOCOLLO IS NOT NULL
                  AND CD.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento; 

            END IF;

        END IF;

        RETURN nIdDichCons;

    END SelMaxDichConsForAzPartAnno;

    /*********************************************************************
    Dati identificativo dichiarazione consistenza, identificativo particella
    controlla se per la particella in questione sono presenti parcelle non a vite
    su DB_ISOLA_PARCELLA
    Tipo: function
    input: pIdDichCons, pIdParticella
    output: nessuno
    ritorno: TRUE / FALSE
    *********************************************************************/
    FUNCTION ExistsParcellaNVForIdDCIdPart (pIdDichCons     IN DB_ISOLA_DICHIARATA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                            pIdParticella   IN DB_CONDUZIONE_DICHIARATA.ID_PARTICELLA%TYPE
                                            ) RETURN BOOLEAN IS
        nRec INTEGER:=0;
        bRet BOOLEAN:=FALSE;
    BEGIN
        SELECT COUNT(IP.ID_ISOLA_PARCELLA)
          INTO nRec
          FROM DB_ISOLA_DICHIARATA IDC,
               DB_ISOLA I,
               DB_ISOLA_PARCELLA IP,
               DB_PARCELLA_CONDUZIONE PC,
               DB_CONDUZIONE_DICHIARATA CD
         WHERE IDC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
           AND IDC.DATA_FINE_VALIDITA IS NULL
           AND IDC.ID_ISOLA_DICHIARATA = I.ID_ISOLA_DICHIARATA
           AND I.ID_ISOLA = IP.ID_ISOLA
           AND IP.ID_ELEGGIBILITA_FIT <> knIdEleggibilitaFitVit
           AND IP.ID_ISOLA_PARCELLA = PC.ID_ISOLA_PARCELLA
           AND PC.ID_CONDUZIONE_DICHIARATA = CD.ID_CONDUZIONE_DICHIARATA
           AND CD.ID_PARTICELLA = pIdParticella
           AND ROWNUM < 2; -- alla prima che trovo mi fermo

        IF nRec > 0 THEN
           bRet := TRUE;
        END IF;

        RETURN bRet;

    END ExistsParcellaNVForIdDCIdPart;

    /*********************************************************************
    Dato un ID_PARTICELLA_CERTIFICATA ed un ID_FONTE ricerca il totale della
    SUPERFICIE di DB_ESITO_PASCOLO_MAGRO per il massimo ANNO_CAMPAGNA
    Tipo: function
    input: pIdParticellaCertificata, pIdFonte
    output: nessuno
    ritorno: nTotSupEleg
    *********************************************************************/
    FUNCTION SelTotSupElegPascMagroByParFnt (pIdParticellaCertificata IN DB_ESITO_PASCOLO_MAGRO.ID_PARTICELLA_CERTIFICATA%TYPE,
                                             pIdFonte                 IN DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE)

    RETURN DB_ESITO_PASCOLO_MAGRO.SUPERFICIE%TYPE IS
        nTotSupEleg DB_ESITO_PASCOLO_MAGRO.SUPERFICIE%TYPE;
    BEGIN

        SELECT SUM(PCE.SUPERFICIE)
          INTO nTotSupEleg
          FROM DB_ESITO_PASCOLO_MAGRO PCE
         WHERE PCE.ID_PARTICELLA_CERTIFICATA = pIdParticellaCertificata
           AND PCE.ID_FONTE = pIdFonte
           AND PCE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                      FROM DB_ESITO_PASCOLO_MAGRO
                                     WHERE ID_PARTICELLA_CERTIFICATA = pIdParticellaCertificata
                                       AND ID_FONTE = pIdFonte)
           AND PCE.DATA_FINE_VALIDITA IS NULL;
        RETURN nTotSupEleg;
    END SelTotSupElegPascMagroByParFnt;

    /*********************************************************************
    Dato un ID_PARTICELLA_CERTIFICATA , un ID_FONTE ed un anno campagna
    ricerca il totale della SUPERFICIE di DB_ESITO_PASCOLO_MAGRO per il
    massimo ANNO_CAMPAGNA al massimo uguale a quello dato in input
    Tipo: function
    input: pIdParticellaCertificata, pAnnoCampagna, pIdFonte
    output: nessuno
    ritorno: nTotSupEleg
    *********************************************************************/
    FUNCTION SelTotSupElePMagroByParFntAnno (pIdParticellaCertificata IN DB_ESITO_PASCOLO_MAGRO.ID_PARTICELLA_CERTIFICATA%TYPE,
                                             pAnnoCampagna            IN DB_ESITO_PASCOLO_MAGRO.ANNO_CAMPAGNA%TYPE,
                                             pIdFonte                 IN DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE
                                             )

    RETURN DB_ESITO_PASCOLO_MAGRO.SUPERFICIE%TYPE IS
        nTotSupEleg DB_ESITO_PASCOLO_MAGRO.SUPERFICIE%TYPE;
    BEGIN

        SELECT SUM(PCE.SUPERFICIE)
          INTO nTotSupEleg
          FROM DB_ESITO_PASCOLO_MAGRO PCE
         WHERE PCE.ID_PARTICELLA_CERTIFICATA = pIdParticellaCertificata
           AND PCE.ID_FONTE = pIdFonte
           AND PCE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                      FROM DB_ESITO_PASCOLO_MAGRO
                                     WHERE ID_PARTICELLA_CERTIFICATA = pIdParticellaCertificata
                                       AND ANNO_CAMPAGNA <= pAnnoCampagna
                                       AND ID_FONTE = pIdFonte)
           AND PCE.DATA_FINE_VALIDITA IS NULL;

        RETURN nTotSupEleg;
    END SelTotSupElePMagroByParFntAnno;

    /*********************************************************************
    Dati in input un identificativo unità arborea ed un identificativo dichiarazione di consistenza
    mi ricerca su DB_UNAR_PARCELLA l'eventuale record con PARCELLA_SELEZIONA ad 'S' solamente
    se questo è associato ad un identificativo isola parcella che appartiene alla dichiarazione
    data in input e ritorna il corrispettivo record di DB_UNAR_PARCELLA
    Tipo: function
    input: pIdUnitaArborea, pIdDichCons
    output: nessuno
    ritorno: DB_UNAR_PARCELLA%ROWTYPE
    *********************************************************************/
    FUNCTION SelTUnarParcellaByUvAssIdDich (pIdUnitaArborea IN DB_UNAR_PARCELLA.ID_UNITA_ARBOREA%TYPE,
                                            pIdDichCons     IN DB_ISOLA_DICHIARATA.ID_DICHIARAZIONE_CONSISTENZA%TYPE
                                            ) RETURN DB_UNAR_PARCELLA%ROWTYPE IS
        recTUnarParcella   DB_UNAR_PARCELLA%ROWTYPE;
    BEGIN

        SELECT UP.*
          INTO recTUnarParcella
          FROM DB_UNAR_PARCELLA UP,
               DB_ISOLA_PARCELLA IP,
               DB_ISOLA I,
               DB_ISOLA_DICHIARATA IDC
         WHERE UP.ID_UNITA_ARBOREA = pIdUnitaArborea
           AND UP.PARCELLA_SELEZIONATA = 'S'
           AND UP.ID_ISOLA_PARCELLA = IP.ID_ISOLA_PARCELLA
           AND IP.ID_ISOLA = I.ID_ISOLA
           AND I.ID_ISOLA_DICHIARATA = IDC.ID_ISOLA_DICHIARATA
           AND IDC.DATA_FINE_VALIDITA IS NULL
           AND IDC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons;

        RETURN recTUnarParcella;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTUnarParcellaByUvAssIdDich;

    /*********************************************************************
    Dati in input un identificativo unità arborea ed un identificativo dichiarazione di consistenza
    mi ricerca su DB_UNAR_PARCELLA l'eventuale record con PARCELLA_SELEZIONA ad 'S' solamente
    se questo è associato ad un identificativo isola parcella che appartiene alla dichiarazione
    data in input e ritorna il corrispettivo record di DB_ISOLA_PARCELLA
    Tipo: function
    input: pIdUnitaArborea, pIdDichCons
    output: nessuno
    ritorno: DB_ISOLA_PARCELLA%ROWTYPE
    *********************************************************************/
    FUNCTION SelTParcellaByUnarAssIdDich (pIdUnitaArborea IN DB_UNAR_PARCELLA.ID_UNITA_ARBOREA%TYPE,
                                          pIdDichCons     IN DB_ISOLA_DICHIARATA.ID_DICHIARAZIONE_CONSISTENZA%TYPE
                                          ) RETURN DB_ISOLA_PARCELLA%ROWTYPE IS
        recTIsolaParcella   DB_ISOLA_PARCELLA%ROWTYPE;
    BEGIN

        SELECT IP.*
          INTO recTIsolaParcella
          FROM DB_UNAR_PARCELLA UP,
               DB_ISOLA_PARCELLA IP,
               DB_ISOLA I,
               DB_ISOLA_DICHIARATA IDC
         WHERE UP.ID_UNITA_ARBOREA = pIdUnitaArborea
           AND UP.PARCELLA_SELEZIONATA = 'S'
           AND UP.ID_ISOLA_PARCELLA = IP.ID_ISOLA_PARCELLA
           AND IP.ID_ISOLA = I.ID_ISOLA
           AND I.ID_ISOLA_DICHIARATA = IDC.ID_ISOLA_DICHIARATA
           AND IDC.DATA_FINE_VALIDITA IS NULL
           AND IDC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons;

        RETURN recTIsolaParcella;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTParcellaByUnarAssIdDich;

    /*********************************************************************
    Dati identificativo dichiarazione consistenza, identificativo particella
    controlla se per la particella in questione sono presenti più parcelle a vite
    su DB_ISOLA_PARCELLA ne ritorna il numero e gli id (nella stringa pStrParcelle)
    Tipo: function
    input: pIdDichCons, pIdParticella, pStrParcelle
    output: nessuno
    ritorno: nCont
    *********************************************************************/
    FUNCTION SelNumParcelleForDichConsPart (pIdDichCons     IN DB_ISOLA_DICHIARATA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                            pIdParticella   IN DB_CONDUZIONE_DICHIARATA.ID_PARTICELLA%TYPE,
                                            pStrParcelle   OUT VARCHAR2
                                            ) RETURN INTEGER IS

        nCont       INTEGER:=0;


        CURSOR curParcellaParticella IS
        SELECT DISTINCT IP.ID_ISOLA_PARCELLA
          FROM DB_ISOLA_DICHIARATA IDC,
               DB_ISOLA I,
               DB_ISOLA_PARCELLA IP,
               DB_PARCELLA_CONDUZIONE PC,
               DB_CONDUZIONE_DICHIARATA CD
         WHERE IDC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
           AND IDC.DATA_FINE_VALIDITA IS NULL
           AND IDC.ID_ISOLA_DICHIARATA = I.ID_ISOLA_DICHIARATA
           AND I.ID_ISOLA = IP.ID_ISOLA
           AND IP.ID_ELEGGIBILITA_FIT = knIdEleggibilitaFitVit
           AND IP.ID_ISOLA_PARCELLA = PC.ID_ISOLA_PARCELLA
           AND PC.ID_CONDUZIONE_DICHIARATA = CD.ID_CONDUZIONE_DICHIARATA
           AND CD.ID_PARTICELLA = pIdParticella;

    BEGIN

        FOR recParcellaParticella IN curParcellaParticella LOOP
            nCont := nCont + 1;
            pStrParcelle := pStrParcelle || recParcellaParticella.ID_ISOLA_PARCELLA || ',';
        END LOOP;

        IF pStrParcelle IS NOT NULL THEN
           pStrParcelle := SUBSTR (pStrParcelle,1, LENGTH(pStrParcelle) -1);
        END IF;

        RETURN nCont;

    END SelNumParcelleForDichConsPart;

    /*********************************************************************
    Dato un valore numerico con decimali inserito in un varchar2, lo
    rende numerico nel formato specificato (solo formati con seperatore dinamico
    ex : '99999D99' , NO --> '9999.99' o '9999,99')
    Tipo: function
    input:  pValore , pFormato
    output: nessuno
    ritorno: NUMBER
    *********************************************************************/
    FUNCTION MY_TO_NUMBER (pvalore IN VARCHAR2, pformato IN VARCHAR2) RETURN NUMBER IS
        vSepDecimale   VARCHAR2 (1) := NULL;
        vSepMigliaia   VARCHAR2 (1) := NULL;
    BEGIN
        SELECT SUBSTR (VALUE, 1, 1), SUBSTR (VALUE, 2, 1)
          INTO vsepdecimale, vsepmigliaia
          FROM nls_session_parameters
         WHERE parameter = 'NLS_NUMERIC_CHARACTERS';

        IF INSTR (pvalore, vsepmigliaia) > 0 THEN
           RETURN TO_NUMBER (REPLACE (pvalore, vsepmigliaia, vsepdecimale),pformato);
        ELSE
           RETURN TO_NUMBER (pvalore, pformato);
        END IF;
    END MY_TO_NUMBER;

    /*********************************************************************
    Dato un identificativo unità arborea lo ricerca sulla tabella
    DB_STORICO_UNITA_ARBOREA e controlla che la particella ad esso associata
    abbia almeno una conduzione attiva sul piano in lavorazione
    Tipo: function
    input: pIdAzienda, pIdUnitaArborea
    output: nessuno
    ritorno: DB_STORICO_UNITA_ARBOREA%ROWTYPE
    *********************************************************************/
    FUNCTION SelTUnitaVitataById (pIdAzienda      IN DB_STORICO_UNITA_ARBOREA.ID_AZIENDA%TYPE,
                                  pIdUnitaArborea IN DB_STORICO_UNITA_ARBOREA.ID_UNITA_ARBOREA%TYPE)
    RETURN DB_STORICO_UNITA_ARBOREA%ROWTYPE IS
        recTStoricoUnitaArborea DB_STORICO_UNITA_ARBOREA%ROWTYPE;
    BEGIN

        SELECT SUA.*
          INTO recTStoricoUnitaArborea
          FROM DB_STORICO_UNITA_ARBOREA SUA
         WHERE SUA.ID_AZIENDA = pIdAzienda
           AND SUA.ID_UNITA_ARBOREA = pIdUnitaArborea
           AND SUA.DATA_FINE_VALIDITA IS NULL
           AND SUA.DATA_CESSAZIONE IS NULL
           AND EXISTS (SELECT CP.ID_CONDUZIONE_PARTICELLA
                         FROM DB_UTE U,
                              DB_CONDUZIONE_PARTICELLA CP
                        WHERE U.ID_AZIENDA = SUA.ID_AZIENDA
                          AND U.DATA_FINE_ATTIVITA IS NULL
                          AND U.ID_UTE = CP.ID_UTE
                          AND CP.DATA_FINE_CONDUZIONE IS NULL
                          AND CP.ID_PARTICELLA = SUA.ID_PARTICELLA);

        RETURN recTStoricoUnitaArborea;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelTUnitaVitataById;

    /*********************************************************************
    Dati un ID_AZIENDA ed un ID_ISOLA_PARCELLA somma l'area totale di tutte
    le unità vitate non associate alla parcella
    Tipo: function
    input: pIdAzienda, pIdIsolaParcella
    output: nessuno
    ritorno: nTotArea
    *********************************************************************/
    FUNCTION SelTotAreaUvNonAssParcella (pIdAzienda       IN DB_STORICO_UNITA_ARBOREA.ID_AZIENDA%TYPE,
                                         pIdIsolaParcella IN DB_ISOLA_PARCELLA.ID_ISOLA_PARCELLA%TYPE
                                        ) RETURN DB_STORICO_UNITA_ARBOREA.AREA%TYPE IS
        nTotArea    DB_STORICO_UNITA_ARBOREA.AREA%TYPE:=0;

    BEGIN
        -- somma l'area delle u.v. presenti ed associate alla parcella data in input
        SELECT NVL(SUM(S.AREA),0)
          INTO nTotArea
          FROM DB_STORICO_UNITA_ARBOREA S,
               DB_UNAR_PARCELLA UP
         WHERE UP.ID_ISOLA_PARCELLA = pIdIsolaParcella
           AND UP.PARCELLA_SELEZIONATA = 'N'
           AND UP.ID_UNITA_ARBOREA = S.ID_UNITA_ARBOREA
           AND S.ID_AZIENDA = pIdAzienda
           AND S.DATA_FINE_VALIDITA IS NULL
           AND S.DATA_CESSAZIONE IS NULL
           AND EXISTS (SELECT CP.ID_CONDUZIONE_PARTICELLA
                         FROM DB_UTE U,
                              DB_CONDUZIONE_PARTICELLA CP
                        WHERE U.ID_AZIENDA = S.ID_AZIENDA
                          AND U.DATA_FINE_ATTIVITA IS NULL
                          AND U.ID_UTE = CP.ID_UTE
                          AND CP.DATA_FINE_CONDUZIONE IS NULL
                          AND CP.ID_PARTICELLA = S.ID_PARTICELLA);

        RETURN nTotArea;

    END SelTotAreaUvNonAssParcella;

-- eliminate le funzioni: SelTotAreaUvAssociateParcella, SelUnarParcAssByIsolaUvDich,
-- ExistsAssociazioneParcellaUv, SelCountUvAssForAzParticelle, ExistsParticellaInAltParcella,
-- SelParticelleForParcella, SelTIsolaParcellaById, SelTParcellaXIdConsIdPartIdEle,
-- SelTParcXIdConsIdPartIdEleUnar, Uv_In_Tolleranza_Gis, Parcella_In_Tolleranza_Gis,
-- Verifica_Avvicendamento

    /*********************************************************************
    Dati un ID_AZIENDA , un vettore di particelle ed un vettore di unità vitate
    effettua la somma dell'area delle UV reperite tramite ID_AZIENDA e vettore
    particelle escludendo eventualmente le unità vitate presenti nel vettore di
    UV
    Tipo: function
    input: pIdAzienda, pIdIsolaParcella, pStrVetParticelle, pStrVetUv
    output: nessuno
    ritorno: nTotArea
    *********************************************************************/
    FUNCTION SelTotAreaUvPartNoManyParc (pIdAzienda         IN DB_STORICO_UNITA_ARBOREA.ID_AZIENDA%TYPE,
                                         pIdIsolaParcella   IN DB_UNAR_PARCELLA.ID_ISOLA_PARCELLA%TYPE,
                                         pStrVetParticelle  IN VARCHAR2,
                                         pStrVetUv          IN VARCHAR2
                                         ) RETURN DB_STORICO_UNITA_ARBOREA.AREA%TYPE IS
        vStrSql  VARCHAR2(4000);
        nTotArea DB_STORICO_UNITA_ARBOREA.AREA%TYPE;
    BEGIN
        -- aggiunta esclusione unita arborea non selezionate
        -- sull'isola parcella interessata
        vStrSql := 'SELECT NVL(SUM(S.AREA),0)
                      FROM DB_STORICO_UNITA_ARBOREA S
                     WHERE S.ID_PARTICELLA IN (' || NVL(pStrVetParticelle,0) || ')
                       AND S.ID_UNITA_ARBOREA NOT IN (' || NVL(pStrVetUv,0) || ')
                       AND S.ID_AZIENDA = :pIdAzienda
                       AND S.DATA_FINE_VALIDITA IS NULL
                       AND S.DATA_CESSAZIONE IS NULL
                       AND EXISTS (SELECT CP.ID_CONDUZIONE_PARTICELLA
                                     FROM DB_UTE U,
                                          DB_CONDUZIONE_PARTICELLA CP
                                    WHERE U.ID_AZIENDA = S.ID_AZIENDA
                                      AND U.DATA_FINE_ATTIVITA IS NULL
                                      AND U.ID_UTE = CP.ID_UTE
                                      AND CP.DATA_FINE_CONDUZIONE IS NULL
                                      AND CP.ID_PARTICELLA = S.ID_PARTICELLA)
                       AND S.ID_UNITA_ARBOREA NOT IN (SELECT ID_UNITA_ARBOREA
                                                        FROM DB_UNAR_PARCELLA
                                                       WHERE ID_ISOLA_PARCELLA = :pIdIsolaParcella
                                                         AND PARCELLA_SELEZIONATA = :pNo)';


        EXECUTE IMMEDIATE vStrSql INTO nTotArea USING IN pIdAzienda, pIdIsolaParcella , 'N';

        RETURN nTotArea;

    END SelTotAreaUvPartNoManyParc;

    /*********************************************************************
    Seleziona il numero di unità vitate presenti ed attive su DB_STORICO_UNITA_ARBOREA
    per l'azienda data in input sulle particelle date in input
    Tipo: function
    input: pIdAzienda, pStrParticelle
    output: nessuno
    ritorno: nCont
    *********************************************************************/
    FUNCTION SelCountUvForAzParticelle (pIdAzienda        IN DB_STORICO_UNITA_ARBOREA.ID_AZIENDA%TYPE,
                                        pStrParticelle    IN VARCHAR2)
    RETURN INTEGER IS
        vStrSql     VARCHAR2(4000);
        nCont       INTEGER:=0;
    BEGIN
        vStrSql := 'SELECT COUNT(SUA.ID_STORICO_UNITA_ARBOREA)
                      FROM DB_STORICO_UNITA_ARBOREA SUA
                     WHERE SUA.ID_AZIENDA = :pIdAzienda
                       AND SUA.DATA_FINE_VALIDITA IS NULL
                       AND SUA.DATA_CESSAZIONE IS NULL
                       AND SUA.ID_PARTICELLA IN (' || NVL(pStrParticelle,0) || ')
                       AND EXISTS (SELECT CP.ID_CONDUZIONE_PARTICELLA
                                     FROM DB_UTE U,
                                          DB_CONDUZIONE_PARTICELLA CP
                                    WHERE U.ID_AZIENDA = SUA.ID_AZIENDA
                                      AND U.DATA_FINE_ATTIVITA IS NULL
                                      AND U.ID_UTE = CP.ID_UTE
                                      AND CP.DATA_FINE_CONDUZIONE IS NULL
                                      AND CP.ID_PARTICELLA = SUA.ID_PARTICELLA)';

        EXECUTE IMMEDIATE vStrSql
                     INTO nCont
                 USING IN pIdAzienda;

        RETURN nCont;

    END SelCountUvForAzParticelle;

    /*********************************************************************
    Seleziona la somma dell'area delle u.v. presenti su DB_STORICO_UNITA_ARBOREA ed attive
    per l'azienda data in input sulle particelle date in input
    Tipo: function
    input: pIdAzienda, pStrParticelle
    output: nessuno
    ritorno: nTotArea
    *********************************************************************/
    FUNCTION SelTotAreaForUvAzParticelle (pIdAzienda        IN DB_STORICO_UNITA_ARBOREA.ID_AZIENDA%TYPE,
                                          pStrParticelle    IN VARCHAR2)
    RETURN DB_STORICO_UNITA_ARBOREA.AREA%TYPE IS
        vStrSql     VARCHAR2(4000);
        nTotArea    DB_STORICO_UNITA_ARBOREA.AREA%TYPE;
    BEGIN
        vStrSql := 'SELECT NVL(SUM(SUA.AREA),0)
                      FROM DB_STORICO_UNITA_ARBOREA SUA
                     WHERE SUA.ID_AZIENDA = :pIdAzienda
                       AND SUA.DATA_FINE_VALIDITA IS NULL
                       AND SUA.DATA_CESSAZIONE IS NULL
                       AND SUA.ID_PARTICELLA IN (' || NVL(pStrParticelle,0) || ')
                       AND EXISTS (SELECT CP.ID_CONDUZIONE_PARTICELLA
                                     FROM DB_UTE U,
                                          DB_CONDUZIONE_PARTICELLA CP
                                    WHERE U.ID_AZIENDA = SUA.ID_AZIENDA
                                      AND U.DATA_FINE_ATTIVITA IS NULL
                                      AND U.ID_UTE = CP.ID_UTE
                                      AND CP.DATA_FINE_CONDUZIONE IS NULL
                                      AND CP.ID_PARTICELLA = SUA.ID_PARTICELLA)';

        EXECUTE IMMEDIATE vStrSql
                     INTO nTotArea
                 USING IN pIdAzienda;

        RETURN nTotArea;

    END SelTotAreaForUvAzParticelle;

    /*********************************************************************
    Ritorna la somma dell'area di tutte le unità vitate associate ad una determinata
    parcella data in input
    Tipo: function
    input: pIdAzienda, pCodFoto , pIdIsolaParcella
    output: null
    ritorno: nTotAreaUv
    *********************************************************************/
    FUNCTION SelTotAreaUvForAziendaParcella (pIdAzienda       IN DB_UTE.ID_AZIENDA%TYPE,
                                             pCodFoto         IN DB_CONDUZIONE_DICHIARATA.CODICE_FOTOGRAFIA_TERRENI%TYPE,
                                             pIdIsolaParcella IN DB_PARCELLA_CONDUZIONE.ID_ISOLA_PARCELLA%TYPE
                                             ) RETURN DB_STORICO_UNITA_ARBOREA.AREA%TYPE IS
        nTotAreaUv DB_STORICO_UNITA_ARBOREA.AREA%TYPE;
    BEGIN

        SELECT NVL(SUM(SUA.AREA),0)
          INTO nTotAreaUv
          FROM DB_STORICO_UNITA_ARBOREA SUA
         WHERE SUA.ID_AZIENDA = pIdAzienda
           AND SUA.ID_TIPOLOGIA_UNAR = knIdTipologiaUnarVite  --VITE
           AND SUA.DATA_FINE_VALIDITA IS NULL
           AND SUA.ID_PARTICELLA IN
            (SELECT CD.ID_PARTICELLA
               FROM DB_PARCELLA_CONDUZIONE PC,
                    DB_CONDUZIONE_DICHIARATA CD
              WHERE CD.CODICE_FOTOGRAFIA_TERRENI = pCodFoto
                AND CD.ID_CONDUZIONE_DICHIARATA = PC.ID_CONDUZIONE_DICHIARATA
                AND PC.ID_ISOLA_PARCELLA = pIdIsolaParcella)
           AND EXISTS (SELECT CP.ID_CONDUZIONE_PARTICELLA
                         FROM DB_UTE U,
                              DB_CONDUZIONE_PARTICELLA CP
                        WHERE U.ID_AZIENDA = SUA.ID_AZIENDA
                          AND U.DATA_FINE_ATTIVITA IS NULL
                          AND U.ID_UTE = CP.ID_UTE
                          AND CP.DATA_FINE_CONDUZIONE IS NULL
                          AND CP.ID_PARTICELLA = SUA.ID_PARTICELLA);

        RETURN nTotAreaUv;
    END SelTotAreaUvForAziendaParcella;

    /*********************************************************************
    Ricerca l'ultima dichiarazione di consistenza dell'azienda nella quale
    la generazione delle isole / parcelle è andata a buon fine
    Tipo: function
    input: pIdAzienda
    output: null
    ritorno: DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE
    *********************************************************************/
    FUNCTION SelLastDichConsWithIsoleForAz (pIdAzienda IN DB_DICHIARAZIONE_CONSISTENZA.ID_AZIENDA%TYPE)
    RETURN DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE IS
        recTDichConsistenza DB_DICHIARAZIONE_CONSISTENZA%ROWTYPE;
    BEGIN
        SELECT DC.*
          INTO recTDichConsistenza
          FROM DB_DICHIARAZIONE_CONSISTENZA DC
         WHERE DC.ID_AZIENDA = pIdAzienda
           AND DC.DATA_INSERIMENTO_DICHIARAZIONE =
               (SELECT MAX(DC1.DATA_INSERIMENTO_DICHIARAZIONE)
                  FROM DB_DICHIARAZIONE_CONSISTENZA DC1,
                       DB_TIPO_MOTIVO_DICHIARAZIONE TMC
                 WHERE DC1.ID_MOTIVO_DICHIARAZIONE = TMC.ID_MOTIVO_DICHIARAZIONE
                   AND TMC.TIPO_DICHIARAZIONE <> kvCodTipoMotivoDichCorrettiva
                   AND DC1.ID_AZIENDA = DC.ID_AZIENDA
                   AND DC1.FLAG_AGGIORNAMENTO_ISOLE ='S');

        RETURN recTDichConsistenza;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelLastDichConsWithIsoleForAz;

    /*********************************************************************
    Dato un ID_PARTICELLA_CERTIFICATA mi conta il numero di distinti ID_ELEGGIBILITA_FIT
    su DB_PARTIELLA_CERT_ELEG per il massimo anno campagna
    Tipo: function
    input: pIdParticellaCertificata
    output: nessuno
    ritorno: nNumEleggibilita
    *********************************************************************/
    FUNCTION SelNumEleggibilitaForPart (pIdParticellaCertificata IN DB_PARTICELLA_CERT_ELEG.ID_PARTICELLA_CERTIFICATA%TYPE)
    RETURN INTEGER IS
        nNumEleggibilita INTEGER:=0;
    BEGIN

        SELECT COUNT(DISTINCT(PCE.ID_ELEGGIBILITA_FIT))
          INTO nNumEleggibilita
          FROM DB_PARTICELLA_CERT_ELEG PCE
         WHERE PCE.ID_PARTICELLA_CERTIFICATA = pIdParticellaCertificata
           AND PCE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                      FROM DB_PARTICELLA_CERT_ELEG
                                     WHERE ID_PARTICELLA_CERTIFICATA = pIdParticellaCertificata);

        RETURN nNumEleggibilita;

    END SelNumEleggibilitaForPart;

    /*********************************************************************
    Data una stringa contenente un vettore di varieta mi dice se tra queste
    ne è presente almeno una riconducibile ad utilizzi "pascolo magro"
    Tipo: function
    input: pStrVetVarieta
    output: nessuno
    ritorno: TRUE / FALSE
    *********************************************************************/
    FUNCTION ExistsVarietaPascoloMagro (pStrVetVarieta IN VARCHAR2) RETURN BOOLEAN IS
        vStrSql VARCHAR2(1000);
        nCont   INTEGER:=0;
        bRet    BOOLEAN:=FALSE;
    BEGIN

        vStrSql := 'SELECT COUNT(TV.ID_VARIETA)
                      FROM DB_TIPO_UTILIZZO TU,
                           DB_TIPO_VARIETA TV
                     WHERE TV.ID_UTILIZZO = TU.ID_UTILIZZO
                       AND TU.PASCOLO_MAGRO = :pYes
                       AND TV.ID_VARIETA IN  (' || NVL(pStrVetVarieta,0) || ')';

        EXECUTE IMMEDIATE vStrSql INTO nCont USING IN 'S';

        IF nCont > 0 THEN
           bRet := TRUE;
        END IF;

        RETURN bRet;

    END ExistsVarietaPascoloMagro;

    /*********************************************************************
    Tipo: function
    input: pStrVetVarieta
    output: nessuno
    ritorno: TRUE / FALSE
    *********************************************************************/
    FUNCTION ExistsVarietaInRegistro (pStrVetVarieta IN VARCHAR2) RETURN BOOLEAN IS
        vStrSql VARCHAR2(1000);
        nCont   INTEGER:=0;
        bRet    BOOLEAN:=FALSE;
    BEGIN
        vStrSql := 'SELECT COUNT(ID_VARIETA)
                      FROM DB_VARIETA_FONTE
                     WHERE DATA_FINE_VALIDITA IS NULL
                       AND ID_VARIETA IN  (' || NVL(pStrVetVarieta,0) || ')';


        EXECUTE IMMEDIATE vStrSql INTO nCont;

        IF nCont > 0 THEN
           bRet := TRUE;
        END IF;

        RETURN bRet;

    END ExistsVarietaInRegistro;

    /*********************************************************************
    Dati ID_DICHIARAZIONE_CONSISTENZA, ID_PARTICELLA, ID_PARTICELLA_CERTIFICATA, ID_VARIETA
    ed un parametro che mi dice se per quella dichiarazione di consistenza c'era
    già l'eleggibilità fittizia ritorna la somma della superficie utilizzata sulla particella
    delle varietà compatibili (lato GIS) con quella in input (concatenando
    in una stringa di appoggio le varietà interessate) lavorando però su quanto dichiarato
    nella dichiarazione di consistenza
    Tipo: function
    input: pIdDichCons,pIdParticella,pIdPartCertif,pIdVarieta,pInEsitoPascoli
    output: pStrCatMatr
    ritorno: nTotSupUtilizzata
    *********************************************************************/
    FUNCTION SelTotSupUtilVarCompatDich (pIdDichCons         DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                         pIdParticella       DB_CONDUZIONE_DICHIARATA.ID_PARTICELLA%TYPE,
                                         pIdPartCertif       DB_PARTICELLA_CERT_ELEG.ID_PARTICELLA_CERTIFICATA%TYPE,
                                         pIdCatalogoMatrice  DB_UTILIZZO_DICHIARATO.ID_CATALOGO_MATRICE%TYPE,
                                         pStrCatMatr         OUT VARCHAR2 ) RETURN DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE IS
        nTotSupUtilizzata   DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE:=0;

        -- aggiunta DB_TIPO_UTILIZZO per capire se si tratta di utilizzo VITE
        CURSOR curSupUtilVarCompatibiliFit IS
        SELECT A.ID_CATALOGO_MATRICE,
               A.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE AS SUPERFICIE_UTILIZZATA,
               TU.TIPO
          FROM DB_UTILIZZO_DICHIARATO A,
               DB_TIPO_UTILIZZO TU,
               DB_CONDUZIONE_DICHIARATA B,
               DB_DICHIARAZIONE_CONSISTENZA C,DB_R_CATALOGO_MATRICE CM 
         WHERE A.ID_CONDUZIONE_DICHIARATA = B.ID_CONDUZIONE_DICHIARATA
           AND C.CODICE_FOTOGRAFIA_TERRENI = B.CODICE_FOTOGRAFIA_TERRENI
           AND B.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento
           AND C.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
           AND B.ID_PARTICELLA = pIdParticella
           AND A.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND CM.ID_UTILIZZO = TU.ID_UTILIZZO 
           AND TU.ESCLUDI_CONTROLLO_ELEGGIBILITA = 'N'
           AND A.ID_CATALOGO_MATRICE IN ( SELECT ID_CATALOGO_MATRICE  
                                    FROM DB_VARIETA_ELEGGIBILITA
                                   WHERE ID_CATALOGO_MATRICE <> pIdCatalogoMatrice
                                     AND DATA_FINE_VALIDITA IS NULL
                                     AND (ID_ELEGGIBILITA,ID_ELEGGIBILITA_FIT) IN
                                    (
                                   SELECT VE.ID_ELEGGIBILITA,  VE.ID_ELEGGIBILITA_FIT
                                     FROM DB_VARIETA_ELEGGIBILITA VE
                                    WHERE VE.ID_CATALOGO_MATRICE = pIdCatalogoMatrice
                                      AND VE.DATA_FINE_VALIDITA IS NULL
                                      AND EXISTS (SELECT PCE.ID_PARTICELLA_CERT_ELEG
                                                    FROM DB_PARTICELLA_CERT_ELEG PCE
                                                   WHERE PCE.ID_ELEGGIBILITA = VE.ID_ELEGGIBILITA
                                                     AND PCE.ID_ELEGGIBILITA_FIT  = VE.ID_ELEGGIBILITA_FIT
                                                     AND PCE.ID_PARTICELLA_CERTIFICATA = pIdPartCertif
                                                     AND PCE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                                                                FROM DB_PARTICELLA_CERT_ELEG
                                                                               WHERE ID_PARTICELLA_CERTIFICATA = pIdPartCertif)))) 
        ORDER BY A.ID_CATALOGO_MATRICE;


        nOldIdCatalogoMatrice   DB_UTILIZZO_DICHIARATO.ID_CATALOGO_MATRICE%TYPE:=0;

    BEGIN
        FOR recSupUtilVarCompatibiliFit IN curSupUtilVarCompatibiliFit LOOP
            IF nOldIdCatalogoMatrice <> recSupUtilVarCompatibiliFit.ID_CATALOGO_MATRICE THEN
               pStrCatMatr := pStrCatMatr || recSupUtilVarCompatibiliFit.ID_CATALOGO_MATRICE || ',';
            END IF;

            nTotSupUtilizzata := nTotSupUtilizzata + recSupUtilVarCompatibiliFit.SUPERFICIE_UTILIZZATA;

        END LOOP;

        IF pStrCatMatr IS NOT NULL THEN
           pStrCatMatr := SUBSTR (pStrCatMatr,1, LENGTH(pStrCatMatr) -1);
        END IF;

        RETURN nTotSupUtilizzata;

    END SelTotSupUtilVarCompatDich;

    /*********************************************************************
    Dato un ID_PARTICELLA_CERTIFICATA mi dice se è presente sulla tabella
    DB_ESITO_PASCOLO_MAGRO e mi ritorno la Superficie Eleggibile a pascolo magro
    sia quella dei controlli in campo che quella del registro storico (in alternativa)
    Tipo: function
    input: pIdPartCertif,pIdParticella,pIdPartCertif,pIdVarieta,pInEsitoPascolo
    output: pTotSupElegPMEff, pTotSupElegPMDic
    ritorno: S / N
    *********************************************************************/
    FUNCTION IsParticellaInEsitoPascoli (pIdPartCertif      IN DB_PARTICELLA_CERT_ELEG.ID_PARTICELLA_CERTIFICATA%TYPE,
                                         pTotSupElegPMEff  OUT DB_ESITO_PASCOLO_MAGRO.SUPERFICIE%TYPE,
                                         pTotSupElegPMDic  OUT DB_ESITO_PASCOLO_MAGRO.SUPERFICIE%TYPE
                                         ) RETURN VARCHAR2 IS

        vInPascoli VARCHAR2(1):='N';
    BEGIN

        -- cerco se ho della superficie eleggibile a pascolo magro secondo la fonte controllo in campo
        pTotSupElegPMEff := SelTotSupElegPascMagroByParFnt (pIdPartCertif,knIdFontePMagroEffettivo);
        -- se non ne ho
        IF pTotSupElegPMEff IS NULL THEN
           -- cerco se ho della superficie eleggibile a pascolo magro secondo la fonte registro storico pascoli
           pTotSupElegPMDic := SelTotSupElegPascMagroByParFnt (pIdPartCertif,knIdFontePMagroDichiarativo);
           IF pTotSupElegPMDic IS NOT NULL THEN
              vInPascoli := 'S';
           END IF;
        ELSE
           vInPascoli := 'S';
        END IF;

        RETURN vInPascoli;

    END IsParticellaInEsitoPascoli;


    FUNCTION SelTotSupUtilVarCompatibili (pIdAzienda          DB_UTE.ID_AZIENDA%TYPE,
                                          pIdParticella       DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE,
                                          pIdPartCertif       DB_PARTICELLA_CERT_ELEG.ID_PARTICELLA_CERTIFICATA%TYPE,
                                          pIdCatalogoMatrice  DB_UTILIZZO_PARTICELLA.ID_CATALOGO_MATRICE%TYPE,
                                          pStrCatMatr         OUT VARCHAR2 ) RETURN DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE IS

        nTotSupUtilizzata   DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE:=0;

        -- aggiunta DB_TIPO_UTILIZZO per capire se si tratta di utilizzo VITE
        CURSOR curSupUtilizzataVarCompatibili IS
        SELECT A.ID_CATALOGO_MATRICE,
               A.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE AS SUPERFICIE_UTILIZZATA,
               TU.TIPO
          FROM DB_UTILIZZO_PARTICELLA A,
               DB_CONDUZIONE_PARTICELLA B,
               DB_TIPO_UTILIZZO TU,
               DB_UTE C,DB_R_CATALOGO_MATRICE CM
         WHERE A.ID_CONDUZIONE_PARTICELLA = B.ID_CONDUZIONE_PARTICELLA
           AND B.DATA_FINE_CONDUZIONE IS NULL
           AND C.ID_UTE = B.ID_UTE
           AND C.DATA_FINE_ATTIVITA IS NULL
           AND C.ID_AZIENDA = pIdAzienda
           AND B.ID_PARTICELLA = pIdParticella
           AND B.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento
           AND A.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND TU.ID_UTILIZZO = CM.ID_UTILIZZO 
           AND TU.ESCLUDI_CONTROLLO_ELEGGIBILITA = 'N'
           AND A.ID_CATALOGO_MATRICE IN ( SELECT ID_CATALOGO_MATRICE  
                                    FROM DB_VARIETA_ELEGGIBILITA
                                   WHERE ID_CATALOGO_MATRICE <> pIdCatalogoMatrice  
                                     AND DATA_FINE_VALIDITA IS NULL
                                     AND (ID_ELEGGIBILITA,ID_ELEGGIBILITA_FIT) IN
                                    (
                                   SELECT VE.ID_ELEGGIBILITA,  VE.ID_ELEGGIBILITA_FIT
                                     FROM DB_VARIETA_ELEGGIBILITA VE
                                    WHERE VE.ID_CATALOGO_MATRICE = pIdCatalogoMatrice 
                                      AND VE.DATA_FINE_VALIDITA IS NULL
                                      AND EXISTS (SELECT ID_PARTICELLA_CERT_ELEG
                                                    FROM DB_PARTICELLA_CERT_ELEG PCE
                                                   WHERE PCE.ID_ELEGGIBILITA = VE.ID_ELEGGIBILITA
                                                     AND PCE.ID_ELEGGIBILITA_FIT  = VE.ID_ELEGGIBILITA_FIT
                                                     AND PCE.ID_PARTICELLA_CERTIFICATA = pIdPartCertif
                                                     AND PCE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                                                                FROM DB_PARTICELLA_CERT_ELEG
                                                                               WHERE ID_PARTICELLA_CERTIFICATA = pIdPartCertif)))) 
        ORDER BY A.ID_CATALOGO_MATRICE;

        nOldIdCatalogoMatrice   DB_UTILIZZO_DICHIARATO.ID_CATALOGO_MATRICE%TYPE:=0;

    BEGIN

        FOR recSupUtilizzataVarCompatibili IN curSupUtilizzataVarCompatibili LOOP
            IF nOldIdCatalogoMatrice <> recSupUtilizzataVarCompatibili.ID_CATALOGO_MATRICE THEN
               pStrCatMatr := pStrCatMatr || recSupUtilizzataVarCompatibili.ID_CATALOGO_MATRICE || ',';
            END IF;

            nTotSupUtilizzata := nTotSupUtilizzata + recSupUtilizzataVarCompatibili.SUPERFICIE_UTILIZZATA;

        END LOOP;

        IF pStrCatMatr IS NOT NULL THEN
           pStrCatMatr := SUBSTR (pStrCatMatr,1, LENGTH(pStrCatMatr) -1);
        END IF;

        RETURN nTotSupUtilizzata;

    END SelTotSupUtilVarCompatibili;

    /*********************************************************************
    Data una particella ed una dichiarazione di consistenza ritorna il totale
    della superficie utilizzata dichiarata sulla stessa ed un vettore con
    le varietà che la compongono
    Tipo: function
    input: pIdDichCons, pIdParticella
    output: pStrCatMatr
    ritorno: nTotSupUtilizzata
    *********************************************************************/
    FUNCTION SelTotUtilForParticellaDic (pIdDichCons      IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                         pIdParticella    IN DB_CONDUZIONE_DICHIARATA.ID_PARTICELLA%TYPE,
                                         pStrCatMatr     OUT VARCHAR2) RETURN DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE IS

        nTotSupUtilizzata   DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE:=0;
        -- aggiunta DB_TIPO_UTILIZZO per capire se si tratta di utilizzo VITE
        CURSOR curSuperficiUtilizzatePart IS
        SELECT A.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE AS SUPERFICIE_UTILIZZATA, 
               A.ID_CATALOGO_MATRICE,
               TU.TIPO
          FROM DB_UTILIZZO_DICHIARATO A,
               DB_TIPO_UTILIZZO TU,
               DB_CONDUZIONE_DICHIARATA B,
               DB_DICHIARAZIONE_CONSISTENZA C,DB_R_CATALOGO_MATRICE CM 
         WHERE A.ID_CONDUZIONE_DICHIARATA= B.ID_CONDUZIONE_DICHIARATA
           AND C.CODICE_FOTOGRAFIA_TERRENI= B.CODICE_FOTOGRAFIA_TERRENI
           AND B.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento
           AND C.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
           AND B.ID_PARTICELLA = pIdParticella
           AND A.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND TU.ID_UTILIZZO = CM.ID_UTILIZZO 
           AND TU.ESCLUDI_CONTROLLO_ELEGGIBILITA = 'N'
        ORDER BY A.ID_CATALOGO_MATRICE;

        nOldIdCatalogoMatrice DB_UTILIZZO_DICHIARATO.ID_CATALOGO_MATRICE%TYPE:=0;

    BEGIN

        FOR recSuperficiUtilizzatePart IN curSuperficiUtilizzatePart LOOP
            IF nOldIdCatalogoMatrice <> recSuperficiUtilizzatePart.ID_CATALOGO_MATRICE THEN
               pStrCatMatr := pStrCatMatr || recSuperficiUtilizzatePart.ID_CATALOGO_MATRICE || ',';
            END IF;

            nTotSupUtilizzata := nTotSupUtilizzata + recSuperficiUtilizzatePart.SUPERFICIE_UTILIZZATA;

        END LOOP;

        IF pStrCatMatr IS NOT NULL THEN
           pStrCatMatr := SUBSTR (pStrCatMatr,1, LENGTH(pStrCatMatr) -1);
        END IF;

        RETURN nTotSupUtilizzata;

    END SelTotUtilForParticellaDic;

    /*********************************************************************
    Dato un identificativo dichiarazione consistenza ed un identificativo particella
    ritorna la percentuale di possesso totale
    Tipo: function
    input: pIdDichCons, pIdParticella
    output: nessuno
    ritorno: nTotPercPossesso
    *********************************************************************/
    FUNCTION SelTotPercPossessoDichPart (pIdDichCons     IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                         pIdParticella   IN DB_CONDUZIONE_DICHIARATA.ID_PARTICELLA%TYPE
                                         ) RETURN DB_CONDUZIONE_DICHIARATA.PERCENTUALE_POSSESSO%TYPE IS
        nTotPercPossesso DB_CONDUZIONE_DICHIARATA.PERCENTUALE_POSSESSO%TYPE:=0;
    BEGIN

        SELECT NVL(SUM(B.PERCENTUALE_POSSESSO),0)
          INTO nTotPercPossesso
          FROM DB_CONDUZIONE_DICHIARATA B,
               DB_DICHIARAZIONE_CONSISTENZA C
         WHERE C.CODICE_FOTOGRAFIA_TERRENI= B.CODICE_FOTOGRAFIA_TERRENI
           AND B.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento
           AND C.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
           AND B.ID_PARTICELLA = pIdParticella;
           /*
           AND EXISTS (SELECT A.ID_UTILIZZO_DICHIARATO
                         FROM DB_UTILIZZO_DICHIARATO A,
                              DB_TIPO_UTILIZZO TU
                        WHERE A.ID_CONDUZIONE_DICHIARATA= B.ID_CONDUZIONE_DICHIARATA
                          AND TU.ID_UTILIZZO = A.ID_UTILIZZO
                          AND TU.ESCLUDI_CONTROLLO_ELEGGIBILITA = 'N');
           */
        RETURN nTotPercPossesso;

    END SelTotPercPossessoDichPart;

    /*********************************************************************
    Dato un identificativo azienda, un identificativo particella, un identificativo
    eleggibilità ed un identificativo eleggibilità fit ritorna la percentuale di utilizzo
    totale
    Tipo: function
    input: pIdAzienda, pIdParticella, pIdTipoEleggibilita, pIdTipoEleggibilitaFit
    output: nessuno
    ritorno: nTotPercUtilizzo
    *********************************************************************/
    FUNCTION SelTotPercUtilByDichPartEl (pIdDichCons            IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                         pIdParticella          IN DB_ELEGGIBILITA_DICHIARATA.ID_PARTICELLA%TYPE,
                                         pIdTipoEleggibilita    IN DB_ELEGGIBILITA_DICHIARATA.ID_ELEGGIBILITA%TYPE,
                                         pIdTipoEleggibilitaFit IN DB_ELEGGIBILITA_DICHIARATA.ID_ELEGGIBILITA_FIT%TYPE
                                        ) RETURN DB_ELEGGIBILITA_DICHIARATA.PERCENTUALE_UTILIZZO%TYPE IS
        nTotPercUtilizzo DB_ELEGGIBILITA_DICHIARATA.PERCENTUALE_UTILIZZO%TYPE;
    BEGIN

        SELECT SUM(ED.PERCENTUALE_UTILIZZO)
          INTO nTotPercUtilizzo
          FROM DB_ELEGGIBILITA_DICHIARATA ED,
               DB_DICHIARAZIONE_CONSISTENZA DC
         WHERE DC.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
           AND DC.CODICE_FOTOGRAFIA_TERRENI = ED.CODICE_FOTOGRAFIA_TERRENI
           AND ED.ID_PARTICELLA = pIdParticella
           AND ED.ID_ELEGGIBILITA = pIdTipoEleggibilita
           AND ED.ID_ELEGGIBILITA_FIT = pIdTipoEleggibilitaFit;

        RETURN nTotPercUtilizzo;

    END SelTotPercUtilByDichPartEl;

    /*********************************************************************
    Dato un identificativo azienda ed un identificativo particella
    ritorna la percentuale di possesso totale
    Tipo: function
    input: pIdAzienda, pIdParticella
    output: nessuno
    ritorno: nTotPercPossesso
    *********************************************************************/
    FUNCTION SelTotPercPossessoAziendaPart (pIdAzienda      IN DB_UTE.ID_AZIENDA%TYPE,
                                            pIdParticella   IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE
                                            ) RETURN DB_CONDUZIONE_PARTICELLA.PERCENTUALE_POSSESSO%TYPE IS
        nTotPercPossesso DB_CONDUZIONE_PARTICELLA.PERCENTUALE_POSSESSO%TYPE;
    BEGIN

        SELECT NVL(SUM(B.PERCENTUALE_POSSESSO),0)
          INTO nTotPercPossesso
          FROM DB_CONDUZIONE_PARTICELLA B,
               DB_UTE C
         WHERE B.DATA_FINE_CONDUZIONE IS NULL
           AND B.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento
           AND C.ID_UTE = B.ID_UTE
           AND C.DATA_FINE_ATTIVITA IS NULL
           AND C.ID_AZIENDA = pIdAzienda
           AND B.ID_PARTICELLA = pIdParticella;
/*
           AND EXISTS (SELECT A.ID_UTILIZZO_PARTICELLA
                         FROM DB_UTILIZZO_PARTICELLA A,
                              DB_TIPO_UTILIZZO TU
                        WHERE A.ID_CONDUZIONE_PARTICELLA = B.ID_CONDUZIONE_PARTICELLA
                          AND TU.ID_UTILIZZO = A.ID_UTILIZZO
                          AND TU.ESCLUDI_CONTROLLO_ELEGGIBILITA = 'N');
*/
        RETURN nTotPercPossesso;

    END SelTotPercPossessoAziendaPart;

    /*********************************************************************
    Dato un identificativo azienda, un identificativo particella, un identificativo
    eleggibilità ed un identificativo eleggibilità fit ritorna la percentuale di utilizzo
    totale
    Tipo: function
    input: pIdAzienda, pIdParticella, pIdTipoEleggibilita, pIdTipoEleggibilitaFit
    output: nessuno
    ritorno: nTotPercUtilizzo
    *********************************************************************/
    FUNCTION SelTotPercUtilByAziendaPartEl (pIdAzienda              IN DB_CONDUZIONE_ELEGGIBILITA.ID_AZIENDA%TYPE,
                                            pIdParticella           IN DB_CONDUZIONE_ELEGGIBILITA.ID_PARTICELLA%TYPE,
                                            pIdTipoEleggibilita     IN DB_ELEGGIBILITA_DICHIARATA.ID_ELEGGIBILITA%TYPE,
                                            pIdTipoEleggibilitaFit  IN DB_CONDUZIONE_ELEGGIBILITA.ID_ELEGGIBILITA_FIT%TYPE
                                            ) RETURN DB_CONDUZIONE_ELEGGIBILITA.PERCENTUALE_UTILIZZO%TYPE IS
        nTotPercUtilizzo DB_CONDUZIONE_ELEGGIBILITA.PERCENTUALE_UTILIZZO%TYPE;
    BEGIN

        SELECT SUM(CE.PERCENTUALE_UTILIZZO)
          INTO nTotPercUtilizzo
          FROM DB_CONDUZIONE_ELEGGIBILITA CE
         WHERE CE.ID_AZIENDA = pIdAzienda
           AND CE.ID_PARTICELLA = pIdParticella
           AND CE.ID_ELEGGIBILITA_FIT = pIdTipoEleggibilitaFit
           AND CE.DATA_FINE_VALIDITA IS NULL;

        RETURN nTotPercUtilizzo;

    END SelTotPercUtilByAziendaPartEl;


    /*********************************************************************
    Data una particella ritorna il totale della superficie utilizzata (compatibile
    con eleggibilita' a vite) sulla stessa
    ed un vettore con i cataloghi matrice che la compongono
    Tipo: function
    input: pIdAzienda , pIdParticella
    output: pStrCatMatr
    ritorno: nTotSupUtilizzata
    *********************************************************************/
    FUNCTION SelTotUtilizzataForPartAVite (pIdAzienda       IN DB_UTE.ID_AZIENDA%TYPE,
                                           pIdParticella    IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE,
                                           pStrCatMatr     OUT VARCHAR2
                                           ) RETURN DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE IS

        nTotSupUtilizzata   DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE:=0;

        -- aggiunta DB_TIPO_UTILIZZO per capire se si tratta di utilizzo VITE
        CURSOR curSuperficiUtilizzatePart IS
        SELECT A.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE AS SUPERFICIE_UTILIZZATA, 
               A.ID_CATALOGO_MATRICE,
               U.TIPO
          FROM DB_UTILIZZO_PARTICELLA A,
               DB_TIPO_UTILIZZO U,
               DB_CONDUZIONE_PARTICELLA B,
               DB_UTE C,DB_R_CATALOGO_MATRICE CM
         WHERE A.ID_CONDUZIONE_PARTICELLA = B.ID_CONDUZIONE_PARTICELLA
           AND B.DATA_FINE_CONDUZIONE IS NULL
           AND C.ID_UTE = B.ID_UTE
           AND C.DATA_FINE_ATTIVITA IS NULL
           AND C.ID_AZIENDA = pIdAzienda
           AND B.ID_PARTICELLA = pIdParticella
           AND B.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento
           AND A.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND U.ID_UTILIZZO = CM.ID_UTILIZZO 
           AND U.ESCLUDI_CONTROLLO_ELEGGIBILITA = 'N'
           AND A.ID_CATALOGO_MATRICE IN (SELECT ID_CATALOGO_MATRICE  
                                          FROM DB_VARIETA_ELEGGIBILITA
                                         WHERE ID_ELEGGIBILITA_FIT = knIdEleggibilitaFitVit
                                           AND ID_ELEGGIBILITA = knIdEleggibilitaColtArbSpec
                                           AND DATA_FINE_VALIDITA IS NULL)  
      ORDER BY A.ID_CATALOGO_MATRICE;

        nOldIdCatalogoMatrice DB_UTILIZZO_PARTICELLA.ID_CATALOGO_MATRICE%TYPE:=0;

    BEGIN
        FOR recSuperficiUtilizzatePart IN curSuperficiUtilizzatePart LOOP
            IF nOldIdCatalogoMatrice <> recSuperficiUtilizzatePart.ID_CATALOGO_MATRICE THEN
               pStrCatMatr := pStrCatMatr || recSuperficiUtilizzatePart.ID_CATALOGO_MATRICE || ',';
            END IF;

            nTotSupUtilizzata := nTotSupUtilizzata + recSuperficiUtilizzatePart.SUPERFICIE_UTILIZZATA;

        END LOOP;

        IF pStrCatMatr IS NOT NULL THEN
           pStrCatMatr := SUBSTR (pStrCatMatr,1, LENGTH(pStrCatMatr) -1);
        END IF;

        RETURN nTotSupUtilizzata;

    END SelTotUtilizzataForPartAVite;

    /*********************************************************************
    Data una particella ritorna il totale della superficie utilizzata sulla stessa
    ed un vettore con le varietà che la compongono
    Tipo: function
    input: pIdAzienda , pIdParticella
    output: pStrCatMatr
    ritorno: nTotSupUtilizzata
    *********************************************************************/
    FUNCTION SelTotUtilizzataForParticella (pIdAzienda       IN DB_UTE.ID_AZIENDA%TYPE,
                                            pIdParticella    IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE,
                                            pStrCatMatr     OUT VARCHAR2
                                            ) RETURN DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE IS

        nTotSupUtilizzata   DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE:=0;

        -- aggiunta DB_TIPO_UTILIZZO per capire se si tratta di utilizzo VITE
        CURSOR curSuperficiUtilizzatePart IS
        SELECT A.SUPERFICIE_UTILIZZATA * cm.COEFFICIENTE_RIDUZIONE AS SUPERFICIE_UTILIZZATA, 
               A.ID_CATALOGO_MATRICE,
               U.TIPO
          FROM DB_UTILIZZO_PARTICELLA A,
               DB_TIPO_UTILIZZO U,
               DB_CONDUZIONE_PARTICELLA B,
               DB_UTE C,DB_R_CATALOGO_MATRICE CM
         WHERE A.ID_CONDUZIONE_PARTICELLA = B.ID_CONDUZIONE_PARTICELLA
           AND B.DATA_FINE_CONDUZIONE IS NULL
           AND C.ID_UTE = B.ID_UTE
           AND C.DATA_FINE_ATTIVITA IS NULL
           AND C.ID_AZIENDA = pIdAzienda
           AND B.ID_PARTICELLA = pIdParticella
           AND A.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND B.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento
           AND U.ID_UTILIZZO = CM.ID_UTILIZZO 
           AND U.ESCLUDI_CONTROLLO_ELEGGIBILITA = 'N'
        ORDER BY A.ID_CATALOGO_MATRICE;

        nOldIdcatalogoMatrice DB_UTILIZZO_PARTICELLA.ID_CATALOGO_MATRICE%TYPE:=0;

    BEGIN
        FOR recSuperficiUtilizzatePart IN curSuperficiUtilizzatePart LOOP
            IF nOldIdcatalogoMatrice <> recSuperficiUtilizzatePart.ID_CATALOGO_MATRICE THEN
               pStrCatMatr := pStrCatMatr || recSuperficiUtilizzatePart.ID_CATALOGO_MATRICE || ',';
            END IF;

            nTotSupUtilizzata := nTotSupUtilizzata + recSuperficiUtilizzatePart.SUPERFICIE_UTILIZZATA;

        END LOOP;

        IF pStrCatMatr IS NOT NULL THEN
           pStrCatMatr := SUBSTR (pStrCatMatr,1, LENGTH(pStrCatMatr) -1);
        END IF;

        RETURN nTotSupUtilizzata;

    END SelTotUtilizzataForParticella;

    /*********************************************************************
    Ritorna il totale di superficie eleggibile a pascolo per la particella
    certificata fornita prendendola solamente dai registri pascolo
    e non dall'eleggibilita' GIS
    Tipo: function
    input: pIdPartCertif
    output: nessuno
    ritorno: nTotSupElegRegistro
    *********************************************************************/
    FUNCTION SelTotSupElegPascoloByPart (pIdPartCertif  IN DB_PARTICELLA_CERT_ELEG.ID_PARTICELLA_CERTIFICATA%TYPE) RETURN  DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE IS
        nTotSupElegRegistro DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        nTotSupElegBosco    DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        nTotSupElegPascolo  DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        nIdFonte            DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE;

    BEGIN

        nIdFonte := SelTFontePartInRegPascByIdPart (pIdPartCertif);
        -- se la particella e' presente in un registro pascolo
        IF nIdFonte IS NOT NULL THEN
           -- cerco se ho della superficie eleggibile a pascolo magro secondo la fonte del registro
           nTotSupElegRegistro := SelTotSupElegPascMagroByParFnt (pIdPartCertif,nIdFonte);
           -- se la fonte e' registro storico pascoli dichiarativo
           IF nIdFonte = knIdFontePMagroDichiarativo THEN
              -- se ho superficie eleggibile a pascolo magro dal registro storico
              -- devo controllare se ho della superficie eleggibile a bosco sul GIS
              SELECT NVL(SUM(PCE.SUPERFICIE),0)
                INTO nTotSupElegBosco
                FROM DB_PARTICELLA_CERT_ELEG PCE,
                     DB_TIPO_ELEGGIBILITA_FIT TEF
               WHERE PCE.ID_PARTICELLA_CERTIFICATA = pIdPartCertif
                 AND PCE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                            FROM DB_PARTICELLA_CERT_ELEG
                                           WHERE ID_PARTICELLA_CERTIFICATA = pIdPartCertif)
                 AND PCE.ID_ELEGGIBILITA_FIT = TEF.ID_ELEGGIBILITA_FIT
                 AND TEF.FLAG_BOSCO = 'S';
              -- se ne ho m'invento una sega mentale
              IF nTotSupElegBosco > 0 THEN
                 -- cerco se sul gis ho della superficie eleggibile a pascolo
                 SELECT NVL(SUM(PCE.SUPERFICIE * (1 - TEF.TARA)),0)
                   INTO nTotSupElegPascolo
                   FROM DB_PARTICELLA_CERT_ELEG PCE,
                        DB_TIPO_ELEGGIBILITA_FIT TEF
                  WHERE PCE.ID_PARTICELLA_CERTIFICATA = pIdPartCertif
                    AND PCE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                               FROM DB_PARTICELLA_CERT_ELEG
                                              WHERE ID_PARTICELLA_CERTIFICATA = pIdPartCertif)
                    AND PCE.ID_ELEGGIBILITA_FIT = TEF.ID_ELEGGIBILITA_FIT
                    AND TEF.FLAG_PASCOLO = 'S';
                  -- se questa è maggiore della superficie del registro storico
                  IF nTotSupElegPascolo > nTotSupElegRegistro THEN
                     -- diventa la nuova superficie eleggibile
                     nTotSupElegRegistro := nTotSupElegPascolo;
                  ELSE
                     -- altrimenti controllo se la somma eleggibile bosco + pascolo GIS
                     -- è inferiore alla superficie del registro storico
                     IF (nTotSupElegBosco + nTotSupElegPascolo) < nTotSupElegRegistro THEN
                         -- se si diventa la nuova eleggibile
                         nTotSupElegRegistro := nTotSupElegBosco + nTotSupElegPascolo;
                     END IF;
                  END IF;
              END IF;
           END IF;
        ELSE
           nTotSupElegRegistro := 0;
        END IF;

        RETURN nTotSupElegRegistro;

    END SelTotSupElegPascoloByPart;


    /*********************************************************************
    Ritorna il totale di superficie eleggibile per la particella per le varietà
    passate in input
    Tipo: function
    input: pIdPartCertif,pStrVetVarieta, pIdFonte
    output: nessuno
    ritorno: nTotSupEleg
    *********************************************************************/
    FUNCTION SelTotSupElegByPartEVetVar (pIdPartCertif  IN DB_PARTICELLA_CERT_ELEG.ID_PARTICELLA_CERTIFICATA%TYPE,
                                         pStrVetVarieta IN VARCHAR2,
                                         pIdFonte       IN DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE DEFAULT -1
                                         ) RETURN  DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE IS

        vStrSql             VARCHAR2(2000);
        nTotSupEleg         DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        nTotSupElegBosco    DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        nTotSupElegPascolo  DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        nIdFonte            DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE;
        nTotSupElegRegistro DB_ESITO_PASCOLO_MAGRO.SUPERFICIE%TYPE;

    BEGIN
        -- se l'ID_FONTE e' a -1 vuol dire che il chiamante non la ha passata
        IF pIdFonte = -1 THEN
           nIdFonte := SelTFontePartInRegPascByIdPart (pIdPartCertif);
        ELSE
           nIdFonte := pIdFonte;
        END IF;

        -- se la particella compare in un registro particellare
        -- pascoli ec-pm , registro storico, piani pastorali , etc
        -- controllo se tutte le varieta' passate in input sono compatibili con la fonte
        IF nIdFonte IS NOT NULL AND AllVarietaInRegistroForFonte (pStrVetVarieta, nIdFonte) THEN
            -- cerco se ho della superficie eleggibile a pascolo magro secondo la fonte controllo in campo
            nTotSupElegRegistro := SelTotSupElegPascMagroByParFnt (pIdPartCertif,nIdFonte);
            -- se la fonte e' registro storico pascoli dichiarativo
            IF nIdFonte = knIdFontePMagroDichiarativo THEN
               -- se ho superficie eleggibile a pascolo magro dal registro storico
               -- devo controllare se ho della superficie eleggibile a bosco sul GIS
               SELECT NVL(SUM(PCE.SUPERFICIE),0)
                 INTO nTotSupElegBosco
                 FROM DB_PARTICELLA_CERT_ELEG PCE,
                      DB_TIPO_ELEGGIBILITA_FIT TEF
                WHERE PCE.ID_PARTICELLA_CERTIFICATA = pIdPartCertif
                  AND PCE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                             FROM DB_PARTICELLA_CERT_ELEG
                                            WHERE ID_PARTICELLA_CERTIFICATA = pIdPartCertif)
                  AND PCE.ID_ELEGGIBILITA_FIT = TEF.ID_ELEGGIBILITA_FIT
                  AND TEF.FLAG_BOSCO = 'S';

               -- se ne ho m'invento una sega mentale
               IF nTotSupElegBosco > 0 THEN
                  -- cerco se sul gis ho della superficie eleggibile a pascolo
                  SELECT NVL(SUM(PCE.SUPERFICIE * (1 - TEF.TARA)),0)
                    INTO nTotSupElegPascolo
                    FROM DB_PARTICELLA_CERT_ELEG PCE,
                         DB_TIPO_ELEGGIBILITA_FIT TEF
                   WHERE PCE.ID_PARTICELLA_CERTIFICATA = pIdPartCertif
                     AND PCE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                                FROM DB_PARTICELLA_CERT_ELEG
                                               WHERE ID_PARTICELLA_CERTIFICATA = pIdPartCertif)
                     AND PCE.ID_ELEGGIBILITA_FIT = TEF.ID_ELEGGIBILITA_FIT
                     AND TEF.FLAG_PASCOLO = 'S';
                  -- se questa è maggiore della superficie del registro storico
                  IF nTotSupElegPascolo > nTotSupElegRegistro THEN
                     -- diventa la nuova superficie eleggibile
                     nTotSupElegRegistro := nTotSupElegPascolo;
                  ELSE
                     -- altrimenti controllo se la somma eleggibile bosco + pascolo GIS
                     -- è inferiore alla superficie del registro storico
                     IF (nTotSupElegBosco + nTotSupElegPascolo) < nTotSupElegRegistro THEN
                         -- se si diventa la nuova eleggibile
                         nTotSupElegRegistro := nTotSupElegBosco + nTotSupElegPascolo;
                     END IF;
                  END IF;
               ELSE
                   -- se registro dichiarativo (storico) e non sup.eleggibile a bosco
                   -- posso prendere l'eleggibile da DB_PARTICELLA_CERT_ELEG
                   vStrSql := 'SELECT NVL(SUM(PCE.SUPERFICIE),0)
                                 FROM DB_PARTICELLA_CERT_ELEG PCE
                                WHERE PCE.ID_PARTICELLA_CERTIFICATA = :pIdPartCertif
                                  AND PCE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                                             FROM DB_PARTICELLA_CERT_ELEG
                                                            WHERE ID_PARTICELLA_CERTIFICATA = :pIdPartCertif)
                                  AND EXISTS (SELECT ID_VARIETA_ELEGGIBILITA
                                                FROM DB_VARIETA_ELEGGIBILITA VE
                                               WHERE VE.ID_ELEGGIBILITA = PCE.ID_ELEGGIBILITA
                                                 AND VE.DATA_FINE_VALIDITA IS NULL
                                                 AND VE.ID_ELEGGIBILITA_FIT = PCE.ID_ELEGGIBILITA_FIT
                                                 AND VE.ID_VARIETA IN (' || NVL(pStrVetVarieta,0) || '))';

                    EXECUTE IMMEDIATE vStrSql INTO nTotSupElegRegistro USING IN pIdPartCertif,pIdPartCertif;

               END IF;
            END IF;
            nTotSupEleg := nTotSupElegRegistro;
        ELSE
            -- prendo solo eleggibilità attive per la varieta
            -- e del massimo anno campagna per cui le abbiamo
            vStrSql := 'SELECT NVL(SUM(PCE.SUPERFICIE),0)
                          FROM DB_PARTICELLA_CERT_ELEG PCE
                         WHERE PCE.ID_PARTICELLA_CERTIFICATA = :pIdPartCertif
                           AND PCE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                                      FROM DB_PARTICELLA_CERT_ELEG
                                                     WHERE ID_PARTICELLA_CERTIFICATA = :pIdPartCertif)
                           AND EXISTS (SELECT ID_VARIETA_ELEGGIBILITA
                                         FROM DB_VARIETA_ELEGGIBILITA VE
                                        WHERE VE.ID_ELEGGIBILITA = PCE.ID_ELEGGIBILITA
                                          AND VE.DATA_FINE_VALIDITA IS NULL
                                          AND VE.ID_ELEGGIBILITA_FIT = PCE.ID_ELEGGIBILITA_FIT
                                          AND VE.ID_VARIETA IN (' || NVL(pStrVetVarieta,0) || '))';

             EXECUTE IMMEDIATE vStrSql INTO nTotSupEleg USING IN pIdPartCertif,pIdPartCertif;
        END IF;

        RETURN nTotSupEleg;

    END SelTotSupElegByPartEVetVar;


FUNCTION SelTotSupElegByPartEVetCat(pIdPartCertif       DB_PARTICELLA_CERT_ELEG.ID_PARTICELLA_CERTIFICATA%TYPE,
                                    pIdCatalogoMatrice  DB_R_CATALOGO_MATRICE.ID_CATALOGO_MATRICE%TYPE,
                                    pIdFonte            DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE DEFAULT -1) RETURN DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE IS

  vStrSql              VARCHAR2(2000);
  nTotSupEleg          DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
  nTotSupElegBosco     DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
  nTotSupElegPascolo   DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
  nIdFonte             DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE;
  nTotSupElegRegistro  DB_ESITO_PASCOLO_MAGRO.SUPERFICIE%TYPE;
  nIdVarieta           DB_R_CATALOGO_MATRICE.ID_VARIETA%TYPE;
BEGIN
  -- se l'ID_FONTE e' a -1 vuol dire che il chiamante non la ha passata
  IF pIdFonte = -1 THEN
    nIdFonte := SelTFontePartInRegPascByIdPart (pIdPartCertif);
  ELSE
    nIdFonte := pIdFonte;
  END IF;

  SELECT ID_VARIETA
  INTO   nIdVarieta
  FROM   DB_R_CATALOGO_MATRICE
  WHERE  ID_CATALOGO_MATRICE = pIdCatalogoMatrice;

  -- se la particella compare in un registro particellare
  -- pascoli ec-pm , registro storico, piani pastorali , etc
  -- controllo se la varieta' passata in input e' compatibile con la fonte
  IF nIdFonte IS NOT NULL AND AllVarietaInRegistroForFonte (nIdVarieta, nIdFonte) THEN
    -- cerco se ho della superficie eleggibile a pascolo magro secondo la fonte controllo in campo
    nTotSupElegRegistro := SelTotSupElegPascMagroByParFnt (pIdPartCertif,nIdFonte);
    -- se la fonte e' registro storico pascoli dichiarativo
    IF nIdFonte = knIdFontePMagroDichiarativo THEN
      -- se ho superficie eleggibile a pascolo magro dal registro storico
      -- devo controllare se ho della superficie eleggibile a bosco sul GIS
      SELECT NVL(SUM(PCE.SUPERFICIE),0)
      INTO   nTotSupElegBosco
      FROM   DB_PARTICELLA_CERT_ELEG PCE,DB_TIPO_ELEGGIBILITA_FIT TEF
      WHERE  PCE.ID_PARTICELLA_CERTIFICATA = pIdPartCertif
      AND    PCE.ANNO_CAMPAGNA             = (SELECT MAX(ANNO_CAMPAGNA)
                                              FROM   DB_PARTICELLA_CERT_ELEG
                                              WHERE  ID_PARTICELLA_CERTIFICATA = pIdPartCertif)
      AND    PCE.ID_ELEGGIBILITA_FIT       = TEF.ID_ELEGGIBILITA_FIT
      AND    TEF.FLAG_BOSCO                = 'S';

      -- se ne ho m'invento una sega mentale
      IF nTotSupElegBosco > 0 THEN
        -- cerco se sul gis ho della superficie eleggibile a pascolo
        SELECT NVL(SUM(PCE.SUPERFICIE * (1 - TEF.TARA)),0)
        INTO   nTotSupElegPascolo
        FROM   DB_PARTICELLA_CERT_ELEG PCE,DB_TIPO_ELEGGIBILITA_FIT TEF
        WHERE  PCE.ID_PARTICELLA_CERTIFICATA = pIdPartCertif
        AND    PCE.ANNO_CAMPAGNA             = (SELECT MAX(ANNO_CAMPAGNA)
                                                FROM   DB_PARTICELLA_CERT_ELEG
                                                WHERE  ID_PARTICELLA_CERTIFICATA = pIdPartCertif)
        AND    PCE.ID_ELEGGIBILITA_FIT       = TEF.ID_ELEGGIBILITA_FIT
        AND    TEF.FLAG_PASCOLO              = 'S';

        -- se questa è maggiore della superficie del registro storico
        IF nTotSupElegPascolo > nTotSupElegRegistro THEN
          -- diventa la nuova superficie eleggibile
          nTotSupElegRegistro := nTotSupElegPascolo;
        ELSE
          -- altrimenti controllo se la somma eleggibile bosco + pascolo GIS
          -- è inferiore alla superficie del registro storico
          IF (nTotSupElegBosco + nTotSupElegPascolo) < nTotSupElegRegistro THEN
            -- se si diventa la nuova eleggibile
            nTotSupElegRegistro := nTotSupElegBosco + nTotSupElegPascolo;
          END IF;
        END IF;
      ELSE
        -- se registro dichiarativo (storico) e non sup.eleggibile a bosco
        -- posso prendere l'eleggibile da DB_PARTICELLA_CERT_ELEG
        vStrSql := 'SELECT NVL(SUM(PCE.SUPERFICIE),0)
                    FROM   DB_PARTICELLA_CERT_ELEG PCE
                    WHERE  PCE.ID_PARTICELLA_CERTIFICATA = :pIdPartCertif
                    AND    PCE.ANNO_CAMPAGNA             = (SELECT MAX(ANNO_CAMPAGNA)
                                                            FROM   DB_PARTICELLA_CERT_ELEG
                                                            WHERE  ID_PARTICELLA_CERTIFICATA = :pIdPartCertif)
                    AND    EXISTS                          (SELECT ID_VARIETA_ELEGGIBILITA
                                                            FROM   DB_VARIETA_ELEGGIBILITA VE
                                                            WHERE  VE.ID_ELEGGIBILITA     = PCE.ID_ELEGGIBILITA
                                                            AND    VE.DATA_FINE_VALIDITA  IS NULL
                                                            AND    VE.ID_ELEGGIBILITA_FIT = PCE.ID_ELEGGIBILITA_FIT
                                                            AND    VE.ID_CATALOGO_MATRICE IN (' || NVL(pIdCatalogoMatrice,0) || '))';

        EXECUTE IMMEDIATE vStrSql INTO nTotSupElegRegistro USING IN pIdPartCertif,pIdPartCertif;

      END IF;
    END IF;
    nTotSupEleg := nTotSupElegRegistro;
  ELSE
    -- prendo solo eleggibilità attive per la varieta
    -- e del massimo anno campagna per cui le abbiamo
    vStrSql := 'SELECT NVL(SUM(PCE.SUPERFICIE),0)
                FROM   DB_PARTICELLA_CERT_ELEG PCE
                WHERE  PCE.ID_PARTICELLA_CERTIFICATA = :pIdPartCertif
                AND    PCE.ANNO_CAMPAGNA             = (SELECT MAX(ANNO_CAMPAGNA)
                                                        FROM   DB_PARTICELLA_CERT_ELEG
                                                        WHERE  ID_PARTICELLA_CERTIFICATA = :pIdPartCertif)
                AND    EXISTS                          (SELECT ID_VARIETA_ELEGGIBILITA
                                                        FROM   DB_VARIETA_ELEGGIBILITA VE
                                                        WHERE  VE.ID_ELEGGIBILITA     = PCE.ID_ELEGGIBILITA
                                                        AND    VE.DATA_FINE_VALIDITA  IS NULL
                                                        AND    VE.ID_ELEGGIBILITA_FIT = PCE.ID_ELEGGIBILITA_FIT
                                                        AND    VE.ID_CATALOGO_MATRICE IN (' || NVL(pIdCatalogoMatrice,0) || '))';

    EXECUTE IMMEDIATE vStrSql INTO nTotSupEleg USING IN pIdPartCertif,pIdPartCertif;
  END IF;

  RETURN nTotSupEleg;
END SelTotSupElegByPartEVetCat;

    /*********************************************************************
    Ricerca il codice parametro nella tavola DB_PARAMENTRO e ne
    espone il valore
    Tipo:    function
    input:  pCodParamentro
    output: nessuno
    ritorno: VARCHAR2
    *********************************************************************/
    FUNCTION SelectValoreParametro (pCodParametro IN VARCHAR2) RETURN VARCHAR2 IS
        vValParametro DB_PARAMETRO.VALORE%TYPE;
    BEGIN

        SELECT VALORE
          INTO vValParametro
          FROM DB_PARAMETRO
         WHERE ID_PARAMETRO = pCodParametro;

        RETURN vValParametro;

    END SelectValoreParametro;

    /*********************************************************************
    Ritorna il totale di superficie eleggibile al netto della tara
    per la particella certificata e le varietà passate in input
    passate in input
    Tipo: function
    input: pIdPartCertif,pStrVetVarieta, pIdFonte
    output: nessuno
    ritorno: nTotSupEleg
    *********************************************************************/
    FUNCTION SelTotSupElegByPartEVetVarNTar (pIdPartCertif  IN DB_PARTICELLA_CERT_ELEG.ID_PARTICELLA_CERTIFICATA%TYPE,
                                             pStrVetCatMatr IN VARCHAR2,
                                             pIdFonte       IN DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE DEFAULT -1
                                             ) RETURN  DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE IS
        TYPE curtype IS REF CURSOR;
        vStrSql             VARCHAR2(2000);
        nTotSupEleg         DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        nTotSupElegRegistro DB_ESITO_PASCOLO_MAGRO.SUPERFICIE%TYPE;
        nTotSupElegBosco    DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        nTotSupElegPascolo  DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        nIdFonte            DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE;
        vStrVarieta         VARCHAR2(2000) := NULL;
        nIdVarieta          DB_R_CATALOGO_MATRICE.ID_VARIETA%TYPE;
        curVar              curtype;
    BEGIN

        -- se l'ID_FONTE e' a -1 vuol dire che il chiamante non la ha passata
        IF pIdFonte = -1 THEN
           nIdFonte := SelTFontePartInRegPascByIdPart (pIdPartCertif);
        ELSE
           nIdFonte := pIdFonte;
        END IF;

        vStrSql := 'SELECT DISTINCT ID_VARIETA
                    FROM   DB_R_CATALOGO_MATRICE
                    WHERE  ID_CATALOGO_MATRICE IN ('||NVL(pStrVetCatMatr,0)||')';

        OPEN curVar FOR vStrSql;
        LOOP
          FETCH curVar INTO nIdVarieta;
          EXIT WHEN curVar%NOTFOUND;
          vStrVarieta := vStrVarieta||nIdVarieta||',';
        END LOOP;
        CLOSE curVar;

        IF vStrVarieta IS NOT NULL THEN
           vStrVarieta := SUBSTR(vStrVarieta,1, LENGTH(vStrVarieta) -1);
        END IF;

        -- se la particella compare in un registro particellare
        -- pascoli ec-pm , registro storico, piani pastorali , etc
        -- controllo se tutte le varieta' passate in input sono compatibili con la fonte
        IF nIdFonte IS NOT NULL AND AllVarietaInRegistroForFonte (vStrVarieta, nIdFonte) THEN
            -- cerco se ho della superficie eleggibile dal registro
            nTotSupElegRegistro := SelTotSupElegPascMagroByParFnt (pIdPartCertif,nIdFonte);
            -- se la fonte e' registro storico pascoli dichiarativo
            IF nIdFonte = knIdFontePMagroDichiarativo THEN
               -- se ho superficie eleggibile a pascolo magro dal registro storico
               -- devo controllare se ho della superficie eleggibile a bosco sul GIS
               SELECT NVL(SUM(PCE.SUPERFICIE),0)
                 INTO nTotSupElegBosco
                 FROM DB_PARTICELLA_CERT_ELEG PCE,
                      DB_TIPO_ELEGGIBILITA_FIT TEF
                WHERE PCE.ID_PARTICELLA_CERTIFICATA = pIdPartCertif
                  AND PCE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                             FROM DB_PARTICELLA_CERT_ELEG
                                            WHERE ID_PARTICELLA_CERTIFICATA = pIdPartCertif)
                  AND PCE.ID_ELEGGIBILITA_FIT = TEF.ID_ELEGGIBILITA_FIT
                  AND TEF.FLAG_BOSCO = 'S';

               -- se ne ho m'invento una sega mentale
               IF nTotSupElegBosco > 0 THEN
                  -- cerco se sul gis ho della superficie eleggibile a pascolo
                  SELECT NVL(SUM(PCE.SUPERFICIE * (1 - TEF.TARA)),0)
                    INTO nTotSupElegPascolo
                    FROM DB_PARTICELLA_CERT_ELEG PCE,
                         DB_TIPO_ELEGGIBILITA_FIT TEF
                   WHERE PCE.ID_PARTICELLA_CERTIFICATA = pIdPartCertif
                     AND PCE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                                FROM DB_PARTICELLA_CERT_ELEG
                                               WHERE ID_PARTICELLA_CERTIFICATA = pIdPartCertif)
                     AND PCE.ID_ELEGGIBILITA_FIT = TEF.ID_ELEGGIBILITA_FIT
                     AND TEF.FLAG_PASCOLO = 'S';
                  -- se questa è maggiore della superficie del registro storico
                  IF nTotSupElegPascolo > nTotSupElegRegistro THEN
                     -- diventa la nuova superficie eleggibile
                     nTotSupElegRegistro := nTotSupElegPascolo;
                  ELSE
                     -- altrimenti controllo se la somma eleggibile bosco + pascolo GIS
                     -- è inferiore alla superficie del registro storico
                     IF (nTotSupElegBosco + nTotSupElegPascolo) < nTotSupElegRegistro THEN
                         -- se si diventa la nuova eleggibile
                         nTotSupElegRegistro := nTotSupElegBosco + nTotSupElegPascolo;
                     END IF;
                  END IF;
               ELSE
                   -- se registro dichiarativo (storico) e non sup.eleggibile a bosco
                   -- posso prendere l'eleggibile da DB_PARTICELLA_CERT_ELEG
                  vStrSql := 'SELECT NVL(SUM(PCE.SUPERFICIE * (1 - TEF.TARA)),0)
                                FROM DB_PARTICELLA_CERT_ELEG PCE,
                                     DB_TIPO_ELEGGIBILITA_FIT TEF
                               WHERE PCE.ID_PARTICELLA_CERTIFICATA = :pIdPartCertif
                                 AND PCE.ID_ELEGGIBILITA_FIT = TEF.ID_ELEGGIBILITA_FIT
                                 AND PCE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                                            FROM DB_PARTICELLA_CERT_ELEG
                                                           WHERE ID_PARTICELLA_CERTIFICATA = :pIdPartCertif)
                                 AND EXISTS (SELECT ID_VARIETA_ELEGGIBILITA
                                               FROM DB_VARIETA_ELEGGIBILITA VE
                                              WHERE VE.ID_ELEGGIBILITA = PCE.ID_ELEGGIBILITA
                                                AND VE.DATA_FINE_VALIDITA IS NULL
                                                AND VE.ID_ELEGGIBILITA_FIT = PCE.ID_ELEGGIBILITA_FIT
                                                AND VE.ID_CATOLOGO_MATRICE IN (' || NVL(pStrVetCatMatr,0) || '))'; 

                  EXECUTE IMMEDIATE vStrSql INTO nTotSupElegRegistro USING IN pIdPartCertif,pIdPartCertif;

               END IF;
            END IF;
            nTotSupEleg := nTotSupElegRegistro;
        ELSE
            -- prendo solo eleggibilità attive per la varieta
            -- e del massimo anno campagna per cui le abbiamo
            vStrSql := 'SELECT NVL(SUM(PCE.SUPERFICIE * (1 - TEF.TARA)),0)
                          FROM DB_PARTICELLA_CERT_ELEG PCE,
                               DB_TIPO_ELEGGIBILITA_FIT TEF
                         WHERE PCE.ID_PARTICELLA_CERTIFICATA = :pIdPartCertif
                           AND PCE.ID_ELEGGIBILITA_FIT = TEF.ID_ELEGGIBILITA_FIT
                           AND PCE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                                      FROM DB_PARTICELLA_CERT_ELEG
                                                     WHERE ID_PARTICELLA_CERTIFICATA = :pIdPartCertif)
                           AND EXISTS (SELECT ID_VARIETA_ELEGGIBILITA
                                         FROM DB_VARIETA_ELEGGIBILITA VE
                                        WHERE VE.ID_ELEGGIBILITA = PCE.ID_ELEGGIBILITA
                                          AND VE.DATA_FINE_VALIDITA IS NULL
                                          AND VE.ID_ELEGGIBILITA_FIT = PCE.ID_ELEGGIBILITA_FIT
                                          AND VE.ID_CATALOGO_MATRICE IN (' || NVL(pStrVetCatMatr,0) || '))'; 
             EXECUTE IMMEDIATE vStrSql INTO nTotSupEleg USING IN pIdPartCertif,pIdPartCertif;
        END IF;

        RETURN nTotSupEleg;

    END SelTotSupElegByPartEVetVarNTar;

    /*********************************************************************
    Accoda nella variabile pMessaggio per ogni particella anomala, cioè non aggiornata
    la relativa anomalie dividendo l'id_particella dal messaggio col ";" e divendo
    una particella dell'altra con il "|"
    Tipo: procedure
    input: pMessaggio , pIdParticella, pStringa
    output: pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE AccodaMessaggio (pMessaggio    IN OUT VARCHAR2,
                               pIdParticella IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE,
                               pStringa      IN VARCHAR2
                               ) IS
        nLengthPMsg INTEGER:=0;
        nLengthStr  INTEGER:=0;
        nLengthId   INTEGER:=0;
    BEGIN

        -- setto la lunghezza del messaggio attuale
        nLengthPMsg := NVL(LENGTH(pMessaggio),0);
        -- setto la lunghezza dell'id_particella
        nLengthId := NVL(LENGTH(pIdParticella),0);
        -- setto la lunghezza della stringa da aggiungere al messaggio attuale
        nLengthStr := NVL(LENGTH(pStringa),0);
        -- se la somma della lunghezza del messagio attuale + la stringa da aggiungere
        -- + l'id_particella + i due caratteri separatore e' minore della lunghezza massima disponibile
        IF nLengthPMsg + nLengthStr + nLengthId + 2 <= knMaxLengthVarchar2 THEN
           -- accoda la stringa nel messaggio
           pMessaggio := pMessaggio || pIdParticella || ';' || pStringa || '|';
        END IF;

    END AccodaMessaggio;

    /*********************************************************************
    Aggiorna la superfcie utilizzata ed eventualmente la supercfie utilizzata secondaria
    con la superficie eleggibilita data in input per il record di utilizzo particella
    dato in input
    Tipo: procedure
    input: pIdUtilizzoParticella , pSupUtilizzataSecondaria, pSupEleg, pIdUtenteAggiornamento
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
PROCEDURE AggiornaSupUtilizzata(pIdUtilizzoParticella     DB_UTILIZZO_PARTICELLA.ID_UTILIZZO_PARTICELLA%TYPE,
                                pSupUtilizzataSecondaria  DB_UTILIZZO_PARTICELLA.SUP_UTILIZZATA_SECONDARIA%TYPE,
                                pSupEleg                  DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE,
                                pIdUtenteAggiornamento    DB_UTILIZZO_PARTICELLA.ID_UTENTE_AGGIORNAMENTO%TYPE) IS
BEGIN
  IF pSupUtilizzataSecondaria > pSupEleg THEN
    UPDATE DB_UTILIZZO_PARTICELLA UP
    SET    UP.SUPERFICIE_UTILIZZATA = pSupEleg,
           UP.SUP_UTILIZZATA_SECONDARIA = pSupEleg,
           UP.VALORE_ORIGINALE = ROUND(DECODE(UP.ID_TIPO_EFA,NULL,NULL,pSupEleg*10000/(SELECT TE.FATTORE_DI_CONVERSIONE
                                                                                       FROM   DB_TIPO_EFA TE
                                                                                       WHERE  ID_TIPO_EFA = UP.ID_TIPO_EFA))),
           UP.VALORE_DOPO_CONVERSIONE = DECODE(UP.ID_TIPO_EFA, NULL, NULL, pSupEleg),
           UP.VALORE_DOPO_PONDERAZIONE = ROUND(DECODE(UP.ID_TIPO_EFA, NULL, NULL, (SELECT TE.FATTORE_DI_PONDERAZIONE
                                                                                   FROM   DB_TIPO_EFA TE
                                                                                   WHERE  ID_TIPO_EFA = UP.ID_TIPO_EFA)) *  pSupEleg,4),
           UP.DATA_AGGIORNAMENTO = SYSDATE,
           ID_UTENTE_AGGIORNAMENTO = pIdUtenteAggiornamento
    WHERE  ID_UTILIZZO_PARTICELLA = pIdUtilizzoParticella;
  ELSE
    UPDATE DB_UTILIZZO_PARTICELLA UP
    SET    UP.SUPERFICIE_UTILIZZATA = pSupEleg,
           UP.VALORE_ORIGINALE = ROUND(DECODE(UP.ID_TIPO_EFA,NULL,NULL,pSupEleg*10000/(SELECT TE.FATTORE_DI_CONVERSIONE
                                                                                       FROM   DB_TIPO_EFA TE
                                                                                       WHERE  ID_TIPO_EFA = UP.ID_TIPO_EFA))),
           UP.VALORE_DOPO_CONVERSIONE = DECODE(UP.ID_TIPO_EFA, NULL, NULL, pSupEleg),
           UP.VALORE_DOPO_PONDERAZIONE = ROUND(DECODE(UP.ID_TIPO_EFA, NULL, NULL, (SELECT TE.FATTORE_DI_PONDERAZIONE
                                                                                   FROM   DB_TIPO_EFA TE
                                                                                   WHERE  ID_TIPO_EFA = UP.ID_TIPO_EFA)) *  pSupEleg,4),
           UP.DATA_AGGIORNAMENTO = SYSDATE,
           UP.ID_UTENTE_AGGIORNAMENTO = pIdUtenteAggiornamento
    WHERE  UP.ID_UTILIZZO_PARTICELLA = pIdUtilizzoParticella;
  END IF;
END AggiornaSupUtilizzata;


    /*********************************************************************
    Dato un ID_PARTICELLA ricerca il relativo ID_PARTICELLA_CERTIFICATA attivo su
    DB_PARTICELLA_CERTIFICATA se ne trova più di uno ritorna -1
    Tipo: procedure
    input: pIdParticella
    output: nessuno
    ritorno: DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA
    *********************************************************************/
    FUNCTION SelectIdPartCertif (pIdParticella IN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA%TYPE)
    RETURN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE IS
        nIdPartCertificata DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE;
    BEGIN

        SELECT ID_PARTICELLA_CERTIFICATA
          INTO nIdPartCertificata
          FROM DB_PARTICELLA_CERTIFICATA
         WHERE ID_PARTICELLA = pIdParticella
           AND DATA_FINE_VALIDITA IS NULL;

        RETURN nIdPartCertificata;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
        WHEN TOO_MANY_ROWS THEN
             RETURN -1;
    END SelectIdPartCertif;


    /*********************************************************************
    Dato un ID_PARTICELLA ricerca il relativo ID_PARTICELLA_CERTIFICATA attivo su
    DB_PARTICELLA_CERTIFICATA se ne trova più di uno ritorna -1
    Tipo: procedure
    input: pIdParticella
    output: nessuno
    ritorno: DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA
    *********************************************************************/
    FUNCTION SelectIdPartCertifByIdPartAnno (pIdParticella IN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA%TYPE,
                                             pAnnoCampagna IN DB_PARTICELLA_CERT_ELEG.ANNO_CAMPAGNA%TYPE)
    RETURN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE IS
        nIdPartCertificata DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE;
    BEGIN

        SELECT MAX(PC.ID_PARTICELLA_CERTIFICATA)
          INTO nIdPartCertificata
          FROM DB_PARTICELLA_CERTIFICATA PC
         WHERE PC.ID_PARTICELLA = pIdParticella
           AND EXISTS (SELECT ID_PARTICELLA_CERT_ELEG
                         FROM DB_PARTICELLA_CERT_ELEG
                        WHERE ID_PARTICELLA_CERTIFICATA = PC.ID_PARTICELLA_CERTIFICATA
                          AND ANNO_CAMPAGNA <= pAnnoCampagna);


        RETURN nIdPartCertificata;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
        WHEN TOO_MANY_ROWS THEN
             RETURN -1;
    END SelectIdPartCertifByIdPartAnno;

    /*********************************************************************
    Dato un ID_PARTICELLA ed un codice fotografia terreni
    ricerca il relativo ID_PARTICELLA_CERTIFICATA attivo su
    DB_ELEGGIBILITA_DICHIARATA
    Tipo: procedure
    input: pCodiceFoto, pIdParticella
    output: nessuno
    ritorno: nIdPartCertificata
    *********************************************************************/
    FUNCTION SelIdPartCertifByFotoEIdPart (pCodiceFoto    IN DB_ELEGGIBILITA_DICHIARATA.CODICE_FOTOGRAFIA_TERRENI%TYPE,
                                           pIdParticella  IN DB_ELEGGIBILITA_DICHIARATA.ID_PARTICELLA%TYPE
                                           )
    RETURN DB_ELEGGIBILITA_DICHIARATA.ID_PARTICELLA_CERTIFICATA%TYPE IS
        nIdPartCertificata DB_ELEGGIBILITA_DICHIARATA.ID_PARTICELLA_CERTIFICATA%TYPE;
    BEGIN

        SELECT MAX(ED.ID_PARTICELLA_CERTIFICATA)
          INTO nIdPartCertificata
          FROM DB_ELEGGIBILITA_DICHIARATA ED
         WHERE ED.CODICE_FOTOGRAFIA_TERRENI = pCodiceFoto
           AND ED.ID_PARTICELLA = pIdParticella;

        RETURN nIdPartCertificata;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
             RETURN NULL;
    END SelIdPartCertifByFotoEIdPart;

    /*********************************************************************
    Dati in input un id_storico_particella verifica se la particella
    era in P25 (USO DEL SUOLO INCOMPLETO NELLA B.I. GRAFICA (GIS)) nel periodo
    passato in input (oppure se il periodo è a null guarda se è attualmente in P25)
    Tipo: funzione
    input: pIdStoricoParticella, pDataConfronto
    output: nessuno
    ritorno: 0 = No P25, 1 = P25 , NULL = Parametri mancanti / errore oracle
    *********************************************************************/
    FUNCTION Calcola_P25 (pIdStoricoParticella IN DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE,
                          pDataConfronto       IN DB_PARTICELLA_CERTIFICATA.DATA_INIZIO_VALIDITA%TYPE) RETURN NUMBER IS
        nRec INTEGER:=0;
    BEGIN

        IF pIdStoricoParticella IS NOT NULL THEN
            -- vado solamente più per ID_PARTICELLA
            -- e non per chiave catastale da anni l'ID_PARTICELLA
            -- e' sempre valorizzato su DB_PARTICELLA_CERTIFICATA
            SELECT COUNT (PC.ID_PARTICELLA_CERTIFICATA)
              INTO nRec
              FROM DB_STORICO_PARTICELLA SP,
                   DB_PARTICELLA_CERTIFICATA PC,
                   DB_TIPO_CASO_PARTICOLARE TCP
             WHERE SP.ID_STORICO_PARTICELLA = pIdStoricoParticella
               AND NVL(SP.ID_CASO_PARTICOLARE,99) = TCP.ID_CASO_PARTICOLARE 
               AND TCP.EFFETTUA_CONTROLLI_GIS = 'S' 
               AND SP.ID_PARTICELLA = PC.ID_PARTICELLA 
               AND PC.PARTICELLA_A_GIS <> 0
               AND PC.ESITO <> 0
               AND ((pDataConfronto IS NOT NULL AND pDataConfronto BETWEEN PC.DATA_INIZIO_VALIDITA AND NVL(PC.DATA_FINE_VALIDITA,pDataConfronto)) OR
                    (pDataConfronto IS NULL AND PC.DATA_FINE_VALIDITA IS NULL));

            IF nRec > 0 THEN
               nRec := 1;
            END IF;

        ELSE
            nRec := NULL;
        END IF;

        RETURN nRec;

    END Calcola_P25;

    /*********************************************************************
    Calcola l'anomalia P26 riferendosi ai dati presenti per l'azienda
    sul piano di lavorazione attuale ed eventualmente applicando la tolleranza
    espressa in percentuale e passata in input (0-100)
    Tipo: funzione
    input: pIdAzienda, pIdParticella, pIdPartCertif, pPercTolleranza
    output: nessuno
    ritorno: 0 = No P26, 1 = P26 , NULL = Parametri mancanti / errore oracle
    *********************************************************************/
    FUNCTION Calcola_P26_Con_Tolleranza(pIdAzienda      IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                                        pIdParticella   IN DB_PARTICELLA.ID_PARTICELLA%TYPE,
                                        pIdPartCertif   IN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE,
                                        pPercTolleranza IN NUMBER) RETURN NUMBER IS

        -- aggiunta tabella DB_TIPO_UTILIZZO per capire se si tratta di VITE o meno
        -- in base alla colonna TIPO
        CURSOR curSupUtilEdElegPerVarieta IS
        SELECT A.ID_CATALOGO_MATRICE,
               CM.ID_UTILIZZO,
               TU.TIPO,
               TU.PASCOLO_MAGRO, 
               SUM(A.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE) AS SUPERFICIE_UTILIZZATA,
               CM.COEFFICIENTE_RIDUZIONE
          FROM DB_UTILIZZO_PARTICELLA A,
               DB_CONDUZIONE_PARTICELLA B,
               DB_TIPO_UTILIZZO TU,
               DB_UTE C,DB_R_CATALOGO_MATRICE CM
         WHERE A.ID_CONDUZIONE_PARTICELLA = B.ID_CONDUZIONE_PARTICELLA
           AND B.DATA_FINE_CONDUZIONE IS NULL
           AND C.ID_UTE = B.ID_UTE
           AND C.DATA_FINE_ATTIVITA IS NULL
           AND C.ID_AZIENDA = pIdAzienda
           AND B.ID_PARTICELLA = pIdParticella
           AND CM.ID_CATALOGO_MATRICE = A.ID_CATALOGO_MATRICE  
           AND B.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento
           AND TU.ID_UTILIZZO = CM.ID_UTILIZZO  
           AND TU.ESCLUDI_CONTROLLO_ELEGGIBILITA = 'N'
      GROUP BY A.ID_CATALOGO_MATRICE, CM.ID_UTILIZZO, TU.TIPO, TU.PASCOLO_MAGRO, CM.COEFFICIENTE_RIDUZIONE;

        nP26                INTEGER:=0;
        nPercP26            NUMBER:=0;
        nTotUtil            DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nTotUtilVarComp     DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nTotEleg            DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        nTotElegVarComp     DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        vStrCatMatr         VARCHAR2(4000);
        nTotPercPossesso    DB_CONDUZIONE_PARTICELLA.PERCENTUALE_POSSESSO%TYPE:=0;
        nTotPercUtilizzo    DB_CONDUZIONE_ELEGGIBILITA.PERCENTUALE_UTILIZZO%TYPE;
        nNumEleggibilita    INTEGER:=0;
        nEttariTollVite     NUMBER:=0;
        nPercTollVite       NUMBER:=0;
        nEttariTolCalc      NUMBER:=0;
        nEttariTollAltro    NUMBER:=0;
        nIdFonteReg         DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE;

    BEGIN
        -- ennesima tolleranza in ettari ma solamente
        -- per gli utilizzi non a vite
        BEGIN
            nEttariTollAltro := MY_TO_NUMBER(SelectValoreParametro (kvCodParEttariTolleranzaP26Alt),'999999D999999');
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 nEttariTollAltro := 0;
        END;

        -- reperisco la massima tolleranza possibile in ettari di scostamento
        -- tra superficie utilizzata e superficie eleggibile a vite
        BEGIN
            nEttariTollVite := MY_TO_NUMBER(SelectValoreParametro (kvCodParEttariTolleranzaP26UV),'999999D999999');
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 nEttariTollVite := 0.0001;
        END;

        -- prendo un'ennesima percentuale di tolleranza solamente per la vite
        BEGIN
            nPercTollVite := MY_TO_NUMBER(SelectValoreParametro (kvCodParPercTolleranzaP26UV),'999999D999999');
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 nPercTollVite := 0;
        END;

        -- cerco se la particella compare nel registro pascoli
        nIdFonteReg := SelTFontePartInRegPascByIdPart (pIdPartCertif);

        -- assegno alla variabile la percentuale di tolleranza data in input
        nPercP26 := pPercTolleranza;
        -- se è a null imposto tolleranza allo 0 per cento
        IF nPercP26 IS NULL THEN
           nPercP26 := 0;
        END IF;

        -- controllo se i parametri id_azienda, id_particella e id_particella certificata
        -- sono valorizzati
        IF pIdAzienda IS NOT NULL AND
           pIdParticella IS NOT NULL AND
           pIdPartCertif IS NOT NULL THEN

           -- cerco la superficie utilizzata totale per la particella
           nTotUtil := SelTotUtilizzataForParticella (pIdAzienda,
                                                      pIdParticella,
                                                      vStrCatMatr);  

           -- cerco la superficie eleggibile totale per la particella
           nTotEleg := SelTotSupElegByPartEVetVarNTar (pIdPartCertif,
                                                       vStrCatMatr, 
                                                       nIdFonteReg); 

           -- cerco la percentuale di possesso totale per la particella
           nTotPercPossesso := SelTotPercPossessoAziendaPart (pIdAzienda,
                                                              pIdParticella);

           -- cerco la percentuale di utilizzo a vite totale per la particella
           nTotPercUtilizzo := SelTotPercUtilByAziendaPartEl (pIdAzienda,
                                                              pIdParticella,
                                                              knIdEleggibilitaColtArbSpec,
                                                              knIdEleggibilitaFitVit);

           IF nTotPercUtilizzo > 100 THEN
              nTotPercUtilizzo := 100;
           END IF;

           IF nTotPercPossesso > 100 THEN
              nTotPercPossesso := 100;
           END IF;
           -- controllo se c'è la P26 a livello di totale particella
           IF nTotUtil > TRUNC(NVL(nTotEleg,0),4) + TRUNC(NVL(nTotEleg,0) * (nPercP26 / 100),4) + nEttariTollAltro THEN
              nP26 := 1;
           ELSE
              nTotUtil := 0;
              nTotEleg := 0;
              vStrCatMatr := NULL;
               -- se non c'è devo controllare se c'è per varietà
              FOR recSupUtilEdElegPerVarieta IN curSupUtilEdElegPerVarieta LOOP

               -- loop su ogni varietà estraggo la superficie eleggibile per la varietà
                   vStrCatMatr := recSupUtilEdElegPerVarieta.ID_CATALOGO_MATRICE;

                   nTotEleg := SelTotSupElegByPartEVetVarNTar(pIdPartCertif,
                                                              vStrCatMatr, 
                                                              nIdFonteReg); 

                  IF NVL(recSupUtilEdElegPerVarieta.COEFFICIENTE_RIDUZIONE,0) = 0 THEN
                     IF TRUNC(recSupUtilEdElegPerVarieta.SUPERFICIE_UTILIZZATA,4) >
                      TRUNC(NVL(nTotEleg,0),4) + TRUNC(NVL(nTotEleg,0) * (nPercP26 / 100),4)THEN
                      nP26 := 1;
                      EXIT;
                     end if;

                  elSE
                    IF TRUNC(recSupUtilEdElegPerVarieta.SUPERFICIE_UTILIZZATA,4) >
                      TRUNC(NVL(nTotEleg,0),4) + TRUNC(NVL(nTotEleg,0) * (nPercP26 / 100),4) +
                      nEttariTollAltro THEN
                     nP26 := 1;
                     EXIT;
                    END IF;
                  END IF;
                  -- altrimenti lavoro per il gruppo di varietà compatibili con quello attuale
                  -- mi calcolo la superficie utilizzata totale
                  -- delle altre varietà compatibili con quest'ultima e le accodo
                  -- in una stringa di appoggio vStrVar divese dal carattere ","
                  nTotUtilVarComp := SelTotSupUtilVarCompatibili (pIdAzienda,
                                                                  pIdParticella,
                                                                  pIdPartCertif,
                                                                  recSupUtilEdElegPerVarieta.ID_CATALOGO_MATRICE,  
                                                                  vStrCatMatr); 
                  -- vStrVar è valorizzata dalla procedure SelTotSupUtilVarCompatibili con le altre
                  -- varietà devo accodare solo quella in elaborazione
                  IF vStrCatMatr IS NOT NULL THEN
                     vStrCatMatr := vStrCatMatr || ',' || recSupUtilEdElegPerVarieta.ID_CATALOGO_MATRICE;
                  ELSE
                     vStrCatMatr := recSupUtilEdElegPerVarieta.ID_CATALOGO_MATRICE;
                  END IF;

                  -- infine mi calcolo la superficie eleggibili per tutte le varietà
                  -- compatibili a partire da quella in elaborazione
                  nTotEleg  := SelTotSupElegByPartEVetVarNTar (pIdPartCertif,
                                                               vStrCatMatr, 
                                                               nIdFonteReg); 

                  -- mi calcolo il totale utilizzato per il gruppo varietà compatibili
                  nTotUtil := nTotUtilVarComp + recSupUtilEdElegPerVarieta.SUPERFICIE_UTILIZZATA;

                  -- controllo se il totale utilizzato è maggiore del totale eleggibile + tolleranza
                  IF recSupUtilEdElegPerVarieta.TIPO = 'V' THEN
                     -- mi calcolo gli ettari di tolleranza per la vite
                     -- rispetto alla superficie eleggibile applicando la percentuale
                     nEttariTolCalc := NVL(nTotEleg,0) * nPercTollVite;
                     -- applico la percentuale di possesso alla superficie eleggibile
                     nTotEleg := ROUND(nTotEleg * NVL(nTotPercUtilizzo,nTotPercPossesso) / 100,4);
                     --IF TRUNC(nTotUtil,4) <> TRUNC(NVL(nTotEleg,0),4) THEN
                     IF ROUND(nTotUtil,4) <> ROUND(NVL(nTotEleg,0),4) THEN
                        IF nTotPercPossesso = 100 THEN
                           nP26 := 1;
                           EXIT;
                        ELSE
                           IF nEttariTolCalc < nEttariTollVite THEN
                              -- se la tolleranza così calcolata è inferiore a quella specificata nell'apposito
                              -- prametro uso quella da parametro
                              nEttariTolCalc := nEttariTollVite;
                           END IF;

                           -- altrimenti controllo se tra le due superfici c'è uno scostamento
                           -- maggiore del numero di ettari calcolati
                           IF ABS (ROUND(nTotUtil,4) - ROUND(NVL(nTotEleg,0),4)) > nEttariTolCalc  THEN
                              nP26 := 1;
                              EXIT;
                           END IF;
                        END IF;
                     END IF;
                  ELSE
                      -- per il non vite è molto più semplice basta che il totale dell'utilizzata
                      -- non supereri il totale dell'eleggibile
                      IF NVL(recSupUtilEdElegPerVarieta.COEFFICIENTE_RIDUZIONE,0) = 0 THEN
                        IF TRUNC(nTotUtil,4) > TRUNC(NVL(nTotEleg,0),4) +
                                             TRUNC(NVL(nTotEleg,0) * (nPercP26 / 100),4) THEN --
                         nP26 := 1;
                         EXIT;
                        END IF;

                      elSE
                        IF TRUNC(nTotUtil,4) > TRUNC(NVL(nTotEleg,0),4) +
                                             TRUNC(NVL(nTotEleg,0) * (nPercP26 / 100),4) +
                                             nEttariTollAltro THEN 
                         nP26 := 1;
                         EXIT;
                        END IF;
                      END IF;
                  END IF;
              END LOOP;
            END IF;
        ELSE
            nP26 := NULL;
        END IF;

        RETURN nP26;

    EXCEPTION
        WHEN OTHERS THEN
        raise;
             --RETURN NULL;
    END Calcola_P26_Con_Tolleranza;

    /*********************************************************************
    Calcola l'anomalia P26 solamente sulla parte di particella compatibile
    con l'eleggibilita' a vite
    Tipo: funzione
    input: pIdAzienda, pIdParticella, pIdPartCertif, pPercTolleranza
    output: nessuno
    ritorno: 0 = No P26, 1 = P26 , NULL = Parametri mancanti / errore oracle
    *********************************************************************/
    FUNCTION Calcola_P26_UV_Con_Tolleranza(pIdAzienda      IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                                           pIdParticella   IN DB_PARTICELLA.ID_PARTICELLA%TYPE,
                                           pIdPartCertif   IN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE,
                                           pPercTolleranza IN NUMBER) RETURN NUMBER IS

        -- aggiunta tabella DB_TIPO_UTILIZZO per capire se si tratta di VITE o meno
        -- in base alla colonna TIPO
        CURSOR curSupUtilEdElegPerVarieta IS
        SELECT A.ID_CATALOGO_MATRICE,
               CM.ID_UTILIZZO,
               TU.TIPO,
               TU.PASCOLO_MAGRO, 
               SUM(A.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE) AS SUPERFICIE_UTILIZZATA,
               CM.COEFFICIENTE_RIDUZIONE
          FROM DB_UTILIZZO_PARTICELLA A,
               DB_CONDUZIONE_PARTICELLA B,
               DB_TIPO_UTILIZZO TU,
               DB_UTE C,DB_R_CATALOGO_MATRICE CM 
         WHERE A.ID_CONDUZIONE_PARTICELLA = B.ID_CONDUZIONE_PARTICELLA
           AND B.DATA_FINE_CONDUZIONE IS NULL
           AND C.ID_UTE = B.ID_UTE
           AND C.DATA_FINE_ATTIVITA IS NULL
           AND C.ID_AZIENDA = pIdAzienda
           AND B.ID_PARTICELLA = pIdParticella
           AND B.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento
           AND A.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND TU.ID_UTILIZZO = CM.ID_UTILIZZO 
           AND TU.ESCLUDI_CONTROLLO_ELEGGIBILITA = 'N'
           AND A.ID_CATALOGO_MATRICE IN (SELECT ID_CATALOGO_MATRICE  
                                  FROM DB_VARIETA_ELEGGIBILITA
                                 WHERE ID_ELEGGIBILITA_FIT = knIdEleggibilitaFitVit
                                   AND ID_ELEGGIBILITA = knIdEleggibilitaColtArbSpec
                                   AND DATA_FINE_VALIDITA IS NULL) 
      GROUP BY A.ID_CATALOGO_MATRICE, CM.ID_UTILIZZO, TU.TIPO, TU.PASCOLO_MAGRO,CM.COEFFICIENTE_RIDUZIONE;

        nP26                INTEGER:=0;
        nPercP26            NUMBER:=0;
        nTotUtil            DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nTotUtilVarComp     DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nTotEleg            DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        nTotElegVarComp     DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        vStrCatMatr         VARCHAR2(4000);
        nTotPercPossesso    DB_CONDUZIONE_PARTICELLA.PERCENTUALE_POSSESSO%TYPE:=0;
        nTotPercUtilizzo    DB_CONDUZIONE_ELEGGIBILITA.PERCENTUALE_UTILIZZO%TYPE;
        nNumEleggibilita    INTEGER:=0;
        nEttariTollVite     NUMBER:=0;
        nPercTollVite       NUMBER:=0;
        nEttariTolCalc      NUMBER:=0;
        nEttariTollAltro    NUMBER:=0;
        nIdFonteReg         DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE;

    BEGIN
        -- ennesima tolleranza in ettari ma solamente
        -- per gli utilizzi non a vite
        BEGIN
            nEttariTollAltro := MY_TO_NUMBER(SelectValoreParametro (kvCodParEttariTolleranzaP26Alt),'999999D999999');
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 nEttariTollAltro := 0;
        END;

        -- reperisco la massima tolleranza possibile in ettari di scostamento
        -- tra superficie utilizzata e superficie eleggibile a vite
        BEGIN
            nEttariTollVite := MY_TO_NUMBER(SelectValoreParametro (kvCodParEttariTolleranzaP26UV),'999999D999999');
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 nEttariTollVite := 0.0001;
        END;

        -- prendo un'ennesima percentuale di tolleranza solamente per la vite
        BEGIN
            nPercTollVite := MY_TO_NUMBER(SelectValoreParametro (kvCodParPercTolleranzaP26UV),'999999D999999');
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 nPercTollVite := 0;
        END;

        -- assegno alla variabile la percentuale di tolleranza data in input
        nPercP26 := pPercTolleranza;
        -- se è a null imposto tolleranza allo 0 per cento
        IF nPercP26 IS NULL THEN
           nPercP26 := 0;
        END IF;

        -- cerco se la particella compare nel registro pascoli
        nIdFonteReg := SelTFontePartInRegPascByIdPart (pIdPartCertif);

        -- controllo se i parametri id_azienda, id_particella e id_particella certificata
        -- sono valorizzati
        IF pIdAzienda IS NOT NULL AND
           pIdParticella IS NOT NULL AND
           pIdPartCertif IS NOT NULL THEN

           -- cerco la superficie utilizzata totale per la particella
           -- solo per catalogo matrici compatibili con eleggibilita' vite
           nTotUtil := SelTotUtilizzataForPartAVite (pIdAzienda,
                                                     pIdParticella,
                                                     vStrCatMatr);

           -- cerco la superficie eleggibile totale per la particella
           nTotEleg := SelTotSupElegByPartEVetVarNTar (pIdPartCertif,
                                                       vStrCatMatr,
                                                       nIdFonteReg); 

           -- cerco la percentuale di possesso totale per la particella
           nTotPercPossesso := SelTotPercPossessoAziendaPart (pIdAzienda,
                                                              pIdParticella);

           -- cerco la percentuale di utilizzo a vite totale per la particella
           nTotPercUtilizzo := SelTotPercUtilByAziendaPartEl (pIdAzienda,
                                                              pIdParticella,
                                                              knIdEleggibilitaColtArbSpec,
                                                              knIdEleggibilitaFitVit);

           IF nTotPercUtilizzo > 100 THEN
              nTotPercUtilizzo := 100;
           END IF;

           IF nTotPercPossesso > 100 THEN
              nTotPercPossesso := 100;
           END IF;

           -- controllo se c'è la P26 a livello di totale particella
           IF nTotUtil > TRUNC(NVL(nTotEleg,0),4) + TRUNC(NVL(nTotEleg,0) * (nPercP26 / 100),4) + nEttariTollAltro THEN
              nP26 := 1;
           ELSE
              nTotUtil := 0;
              nTotEleg := 0;
              vStrCatMatr := NULL;
               -- se non c'è devo controllare se c'è per varietà
              FOR recSupUtilEdElegPerVarieta IN curSupUtilEdElegPerVarieta LOOP
                   -- loop su ogni varietà estraggo la superficie eleggibile per la varietà
                   vStrCatMatr := recSupUtilEdElegPerVarieta.ID_CATALOGO_MATRICE;
                   nTotEleg := SelTotSupElegByPartEVetVarNTar(pIdPartCertif,
                                                              vStrCatMatr,
                                                              nIdFonteReg); 

                  IF NVL(recSupUtilEdElegPerVarieta.COEFFICIENTE_RIDUZIONE,0) = 0 THEN
                     IF TRUNC(recSupUtilEdElegPerVarieta.SUPERFICIE_UTILIZZATA,4) >
                      TRUNC(NVL(nTotEleg,0),4) + TRUNC(NVL(nTotEleg,0) * (nPercP26 / 100),4)THEN
                      nP26 := 1;
                      EXIT;
                     end if;

                  elSE
                    IF TRUNC(recSupUtilEdElegPerVarieta.SUPERFICIE_UTILIZZATA,4) >
                      TRUNC(NVL(nTotEleg,0),4) + TRUNC(NVL(nTotEleg,0) * (nPercP26 / 100),4) +
                      nEttariTollAltro THEN
                     nP26 := 1;
                     EXIT;
                    END IF;
                  END IF;
                  -- altrimenti lavoro per il gruppo di varietà compatibili con quello attuale
                  -- mi calcolo la superficie utilizzata totale
                  -- delle altre varietà compatibili con quest'ultima e le accodo
                  -- in una stringa di appoggio vStrVar divese dal carattere ","
                  nTotUtilVarComp := SelTotSupUtilVarCompatibili (pIdAzienda,
                                                                  pIdParticella,
                                                                  pIdPartCertif,
                                                                  recSupUtilEdElegPerVarieta.ID_CATALOGO_MATRICE, 
                                                                  vStrCatMatr); 

                  -- vStrVar è valorizzata dalla procedure SelTotSupUtilVarCompatibili con le altre
                  -- varietà devo accodare solo quella in elaborazione
                  IF vStrCatMatr IS NOT NULL THEN
                     vStrCatMatr := vStrCatMatr || ',' || recSupUtilEdElegPerVarieta.ID_CATALOGO_MATRICE;
                  ELSE
                     vStrCatMatr := recSupUtilEdElegPerVarieta.ID_CATALOGO_MATRICE;
                  END IF;

                  -- infine mi calcolo la superficie eleggibili per tutte le varietà
                  -- compatibili a partire da quella in elaborazione
                  nTotEleg  := SelTotSupElegByPartEVetVarNTar (pIdPartCertif,
                                                               vStrCatMatr, 
                                                               nIdFonteReg); 

                  -- mi calcolo il totale utilizzato per il gruppo varietà compatibili
                  nTotUtil := nTotUtilVarComp + recSupUtilEdElegPerVarieta.SUPERFICIE_UTILIZZATA;

                  -- controllo se il totale utilizzato è maggiore del totale eleggibile + tolleranza
                  IF recSupUtilEdElegPerVarieta.TIPO = 'V' THEN
                     -- mi calcolo gli ettari di tolleranza per la vite
                     -- rispetto alla superficie eleggibile applicando la percentuale
                     nEttariTolCalc := NVL(nTotEleg,0) * nPercTollVite;
                     -- applico la percentuale di possesso alla superficie eleggibile
                     nTotEleg := ROUND(nTotEleg * NVL(nTotPercUtilizzo,nTotPercPossesso) / 100,4);
                     -- sostituita TRUNC con ROUND
                     --IF TRUNC(nTotUtil,4) <> TRUNC(NVL(nTotEleg,0),4) THEN
                     IF ROUND(nTotUtil,4) <> ROUND(NVL(nTotEleg,0),4) THEN
                        IF nTotPercPossesso = 100 THEN
                           nP26 := 1;
                           EXIT;
                        ELSE
                           IF nEttariTolCalc < nEttariTollVite THEN
                              -- se la tolleranza così calcolata è inferiore a quella specificata nell'apposito
                              -- prametro uso quella da parametro
                              nEttariTolCalc := nEttariTollVite;
                           END IF;

                           -- altrimenti controllo se tra le due superfici c'è uno scostamento
                           -- maggiore del numero di ettari calcolati
                           IF ABS (ROUND(nTotUtil,4) - ROUND(NVL(nTotEleg,0),4)) > nEttariTolCalc  THEN
                              nP26 := 1;
                              EXIT;
                           END IF;
                        END IF;
                     END IF;
                  ELSE
                      -- per il non vite è molto più semplice basta che il totale dell'utilizzata
                      -- non supereri il totale dell'eleggibile
                      IF NVL(recSupUtilEdElegPerVarieta.COEFFICIENTE_RIDUZIONE,0) = 0 THEN
                        IF TRUNC(nTotUtil,4) > TRUNC(NVL(nTotEleg,0),4) +
                                             TRUNC(NVL(nTotEleg,0) * (nPercP26 / 100),4) THEN --
                         nP26 := 1;
                         EXIT;
                        END IF;

                      elSE
                        IF TRUNC(nTotUtil,4) > TRUNC(NVL(nTotEleg,0),4) +
                                             TRUNC(NVL(nTotEleg,0) * (nPercP26 / 100),4) +
                                             nEttariTollAltro THEN 
                         nP26 := 1;
                         EXIT;
                        END IF;
                      END IF;
                  END IF;

              END LOOP;
            END IF;
        ELSE
            nP26 := NULL;
        END IF;

        RETURN nP26;

    EXCEPTION
        WHEN OTHERS THEN
             RAISE;
    END Calcola_P26_UV_Con_Tolleranza;


    /*********************************************************************
    Calcola l'anomalia P26 riferendosi ai dati presenti per l'azienda
    sul piano di lavorazione attuale
    Tipo: funzione
    input: pIdAzienda, pIdParticella, pIdPartCertif
    output: nessuno
    ritorno: 0 = No P26, 1 = P26 , NULL = Parametri mancanti / errore oracle
    *********************************************************************/
    FUNCTION Calcola_P26 (pIdAzienda    IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                          pIdParticella IN DB_PARTICELLA.ID_PARTICELLA%TYPE,
                          pIdPartCertif IN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE) RETURN NUMBER IS
        nP26        INTEGER:=0;
    BEGIN

        nP26 :=Calcola_P26_Con_Tolleranza  (pIdAzienda,pIdParticella,pIdPartCertif,0);

        RETURN nP26;

    EXCEPTION
        WHEN OTHERS THEN
             RETURN NULL;
    END Calcola_P26;

    /*********************************************************************
    Calcola l'anomalia P26 riferendosi ai dati presenti per l'azienda
    e sul piano della dichiarazione di consistenza data in input,
    eventualmente applicando la tolleranza espressa in percentuale e
    passata in input (0-100)
    Tipo: funzione
    input: pIdAzienda, pIdDichCons pIdParticella, pIdPartCertif, pPercTolleranza
    output: nessuno
    ritorno: 0 = No P26, 1 = P26 , NULL = Parametri mancanti / errore oracle
    *********************************************************************/
    FUNCTION Calcola_P26_Con_Tolleranza (pIdAzienda        IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                                         pIdDichCons       IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                         pIdParticella     IN DB_PARTICELLA.ID_PARTICELLA%TYPE,
                                         pIdPartCertif     IN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE,
                                         pPercTolleranza   IN NUMBER) RETURN NUMBER IS

        nP26    INTEGER:=0;

        -- aggiunta tabella DB_TIPO_UTILIZZO per capire se si tratta di VITE o meno
        -- in base alla colonna TIPO
        CURSOR curSupUtilEdElegPerVarieta IS
        SELECT A.ID_CATALOGO_MATRICE, 
               SUM(A.SUPERFICIE_UTILIZZATA * CM.COEFFICIENTE_RIDUZIONE) AS SUPERFICIE_UTILIZZATA,
               CM.ID_UTILIZZO,
               TU.TIPO,
               TU.PASCOLO_MAGRO, 
               CM.COEFFICIENTE_RIDUZIONE
          FROM DB_UTILIZZO_DICHIARATO A,
               DB_TIPO_UTILIZZO TU,
               DB_CONDUZIONE_DICHIARATA B,
               DB_DICHIARAZIONE_CONSISTENZA C,DB_R_CATALOGO_MATRICE CM 
         WHERE A.ID_CONDUZIONE_DICHIARATA= B.ID_CONDUZIONE_DICHIARATA
           AND C.CODICE_FOTOGRAFIA_TERRENI= B.CODICE_FOTOGRAFIA_TERRENI
           AND B.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento
           AND C.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
           AND B.ID_PARTICELLA = pIdParticella
           AND A.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE
           AND TU.ID_UTILIZZO = CM.ID_UTILIZZO
           AND TU.ESCLUDI_CONTROLLO_ELEGGIBILITA = 'N'
      GROUP BY A.ID_CATALOGO_MATRICE, CM.ID_UTILIZZO, TU.TIPO, TU.PASCOLO_MAGRO,CM.COEFFICIENTE_RIDUZIONE;

        nPercP26            NUMBER:=0;
        nTotUtil            DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nTotUtilVarComp     DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        nTotEleg            DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        nTotElegVarComp     DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        vStrCatMatr         VARCHAR2(4000);
        nTotPercPossesso    DB_CONDUZIONE_DICHIARATA.PERCENTUALE_POSSESSO%TYPE:=0;
        nTotPercUtilizzo    DB_ELEGGIBILITA_DICHIARATA.PERCENTUALE_UTILIZZO%TYPE;
        nEttariTollVite     NUMBER:=0;
        nPercTollVite       NUMBER:=0;
        nEttariTolCalc      NUMBER:=0;
        nEttariTollAltro    NUMBER:=0;
        nIdFonteReg         DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE;

    BEGIN
        -- ennesima tolleranza in ettari ma solamente
        -- per gli utilizzi non a vite
        BEGIN
            nEttariTollAltro := MY_TO_NUMBER(SelectValoreParametro (kvCodParEttariTolleranzaP26Alt),'999999D999999');
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 nEttariTollAltro := 0;
        END;

        -- reperisco la massima tolleranza possibile in ettari di scostamento
        -- tra superficie utilizzata e superficie eleggibile a vite
        BEGIN
            nEttariTollVite := MY_TO_NUMBER(SelectValoreParametro (kvCodParEttariTolleranzaP26UV),'999999D999999');
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 nEttariTollVite := 0.0001;
        END;

        -- prendo un'ennesima percentuale di tolleranza solamente per la vite
        BEGIN
            nPercTollVite := MY_TO_NUMBER(SelectValoreParametro (kvCodParPercTolleranzaP26UV),'999999D999999');
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 nPercTollVite := 0;
        END;

        -- cerco se la particella compare nel registro pascoli
        nIdFonteReg := SelTFontePartInRegPascByIdPart (pIdPartCertif);

        -- assegno alla variabile la percentuale di tolleranza data in input
        nPercP26 := pPercTolleranza;
        -- se è a null imposto tolleranza allo 0 per cento
        IF nPercP26 IS NULL THEN
           nPercP26 := 0;
        END IF;

        -- controllo se i parametri di input sono valorizzati
        IF pIdAzienda IS NOT NULL AND
           pIdDichCons IS NOT NULL AND
           pIdParticella IS NOT NULL AND
           pIdPartCertif IS NOT NULL THEN

           -- cerco la superficie utilizzata totale per la particella
           nTotUtil := SelTotUtilForParticellaDic (pIdDichCons,
                                                   pIdParticella,
                                                   vStrCatMatr);  

           -- cerco la superficie eleggibile per la particella
           nTotEleg := SelTotSupElegByPartEVetVarNTar (pIdPartCertif,
                                                       vStrCatMatr,  
                                                       nIdFonteReg); 

           -- cerco la percentuale di possesso totale per la particella
           nTotPercPossesso := SelTotPercPossessoDichPart (pIdDichCons,
                                                           pIdParticella);

           -- cerco la percentuale di utilizzo a vite totale per la particella
           nTotPercUtilizzo := SelTotPercUtilByDichPartEl (pIdDichCons,
                                                           pIdParticella,
                                                           knIdEleggibilitaColtArbSpec,
                                                           knIdEleggibilitaFitVit);

           IF nTotPercUtilizzo > 100 THEN
              nTotPercUtilizzo := 100;
           END IF;

           IF nTotPercPossesso > 100 THEN
              nTotPercPossesso := 100;
           END IF;

           -- controllo se c'è la P26 a livello di totale particella
           IF nTotUtil > TRUNC(NVL(nTotEleg,0),4) + TRUNC(NVL(nTotEleg,0) * (nPercP26 / 100),4) + nEttariTollAltro THEN 
              nP26 := 1;
           ELSE
              nTotUtil := 0;
              nTotEleg := 0;
              vStrCatMatr := NULL;
               -- se non c'è devo controllare se c'è per varietà
              FOR recSupUtilEdElegPerVarieta IN curSupUtilEdElegPerVarieta LOOP
                   -- loop su ogni varietà estraggo la superficie eleggibile per la varietà
                   vStrCatMatr := recSupUtilEdElegPerVarieta.ID_CATALOGO_MATRICE;
                   nTotEleg := SelTotSupElegByPartEVetVarNTar (pIdPartCertif,vStrCatMatr,nIdFonteReg); 

                  IF NVL(recSupUtilEdElegPerVarieta.COEFFICIENTE_RIDUZIONE,0) = 0 THEN
                     IF TRUNC(recSupUtilEdElegPerVarieta.SUPERFICIE_UTILIZZATA,4) >
                      TRUNC(NVL(nTotEleg,0),4) + TRUNC(NVL(nTotEleg,0) * (nPercP26 / 100),4)THEN
                      nP26 := 1;
                      EXIT;
                     end if;

                  elSE
                    IF TRUNC(recSupUtilEdElegPerVarieta.SUPERFICIE_UTILIZZATA,4) >
                      TRUNC(NVL(nTotEleg,0),4) + TRUNC(NVL(nTotEleg,0) * (nPercP26 / 100),4) +
                      nEttariTollAltro THEN
                     nP26 := 1;
                     EXIT;
                    END IF;
                  END IF;
                  -- altrimenti lavoro per il gruppo di varietà compatibili con quello attuale
                  -- mi calcolo la superficie utilizzata totale
                  -- delle altre varietà compatibili con quest'ultima e le accodo
                  -- in una stringa di appoggio vStrVar divese dal carattere ","
                  nTotUtilVarComp := SelTotSupUtilVarCompatDich (pIdDichCons,
                                                                 pIdParticella,
                                                                 pIdPartCertif,
                                                                 recSupUtilEdElegPerVarieta.ID_CATALOGO_MATRICE,
                                                                 vStrCatMatr);
                  -- vStrVar è valorizzata dalla procedure SelTotSupUtilVarCompatibili con le altre
                  -- varietà devo accodare solo quella in elaborazione
                  IF vStrCatMatr IS NOT NULL THEN
                     vStrCatMatr := vStrCatMatr || ',' || recSupUtilEdElegPerVarieta.ID_CATALOGO_MATRICE;
                  ELSE
                     vStrCatMatr := recSupUtilEdElegPerVarieta.ID_CATALOGO_MATRICE;
                  END IF;

                  -- infine mi calcolo la superficie eleggibili per tutte le varietà
                  -- compatibili a partire da quella in elaborazione
                  nTotEleg  := SelTotSupElegByPartEVetVarNTar( pIdPartCertif,
                                                               vStrCatMatr,
                                                               nIdFonteReg); 

                  -- mi calcolo il totale utilizzato per il gruppo varietà compatibili
                  nTotUtil := nTotUtilVarComp + recSupUtilEdElegPerVarieta.SUPERFICIE_UTILIZZATA;

                  -- controllo se il totale utilizzato è maggiore del totale eleggibile + tolleranza
                  
                  -- la function SelTotSupUtilVarCompatibili
                  IF recSupUtilEdElegPerVarieta.TIPO = 'V' THEN
                     -- mi calcolo gli ettari di tolleranza per la vite
                     -- rispetto alla superficie eleggibile applicando la percentuale
                     nEttariTolCalc := NVL(nTotEleg,0) * nPercTollVite;
                     -- applico la percentuale di utilizzo (od in assensa la percentuale di possesso) alla superficie eleggibile
                     nTotEleg := ROUND(nTotEleg * NVL(nTotPercUtilizzo,nTotPercPossesso) / 100,4);

                     -- sostituita TRUNC con ROUND
                     --IF TRUNC(nTotUtil,4) <> TRUNC(NVL(nTotEleg,0),4) THEN
                     IF ROUND(nTotUtil,4) <> ROUND(NVL(nTotEleg,0),4) THEN
                        -- dare subito l'anomalia
                        IF nTotPercPossesso = 100 THEN
                           nP26 := 1;
                           EXIT;
                        ELSE
                           IF nEttariTolCalc < nEttariTollVite THEN
                              -- se la tolleranza così calcolata è inferiore a quella specificata nell'apposito
                              -- prametro uso quella da parametro
                              nEttariTolCalc := nEttariTollVite;
                           END IF;

                           -- altrimenti controllo se tra le due superfici c'è uno scostamento
                           -- maggiore del numero di ettari calcolati
                           IF ABS (ROUND(nTotUtil,4) - ROUND(NVL(nTotEleg,0),4)) > nEttariTolCalc THEN
                              nP26 := 1;
                              EXIT;
                           END IF;
                        END IF;
                     END IF;
                  ELSE
                     -- per il non vite è molto più semplice basta che il totale dell'utilizzata
                      -- non supereri il totale dell'eleggibile
                      IF NVL(recSupUtilEdElegPerVarieta.COEFFICIENTE_RIDUZIONE,0) = 0 THEN
                        IF TRUNC(nTotUtil,4) > TRUNC(NVL(nTotEleg,0),4) +
                                             TRUNC(NVL(nTotEleg,0) * (nPercP26 / 100),4) THEN --
                         nP26 := 1;
                         EXIT;
                        END IF;

                      elSE
                        IF TRUNC(nTotUtil,4) > TRUNC(NVL(nTotEleg,0),4) +
                                             TRUNC(NVL(nTotEleg,0) * (nPercP26 / 100),4) +
                                             nEttariTollAltro THEN 
                         nP26 := 1;
                         EXIT;
                        END IF;
                      END IF;
                  END IF;
              END LOOP;
           END IF;
        ELSE
            -- se i parametri in input non erano valorizzata ritorno null
            nP26 := NULL;
        END IF;

        RETURN nP26;

    EXCEPTION
        WHEN OTHERS THEN
             RAISE;
    END Calcola_P26_Con_Tolleranza;

    /*********************************************************************
    Calcola l'anomalia P26 riferendosi ai dati presenti per l'azienda
    e sul piano della dichiarazione di consistenza data in input
    Tipo: funzione
    input: pIdAzienda, pIdDichCons pIdParticella, pIdPartCertif
    output: nessuno
    ritorno: 0 = No P26, 1 = P26 , NULL = Parametri mancanti / errore oracle
    *********************************************************************/
    FUNCTION Calcola_P26 (pIdAzienda    IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                          pIdDichCons   IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                          pIdParticella IN DB_PARTICELLA.ID_PARTICELLA%TYPE,
                          pidPartCertif IN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE) RETURN NUMBER IS
        nP26    INTEGER:=0;
    BEGIN

        nP26 := Calcola_P26_Con_Tolleranza(pIdAzienda,pIdDichCons,pIdParticella,pidPartCertif,0);

        RETURN nP26;

    EXCEPTION
        WHEN OTHERS THEN
             RETURN NULL;
    END Calcola_P26;

    /*********************************************************************
    Verifica se lo storico particella dato in input era in anomalia
    P30 (PARTICELLA SENZA RISCONTRO NELLA B.I. GRAFICA (GIS)) nel periodo
    dato in input (oppure se il periodo è a null guarda se è attualmente in P30)
    Tipo: funzione
    input: pIdStoricoParticella, pDataConfronto
    output: nessuno
    ritorno: 0 = No P30, 1 = P30 , NULL = Parametri mancanti / errore oracle
    *********************************************************************/
    FUNCTION Calcola_P30 (pIdStoricoParticella IN DB_STORICO_PARTICELLA.ID_STORICO_PARTICELLA%TYPE,
                          pDataConfronto       IN DB_PARTICELLA_CERTIFICATA.DATA_INIZIO_VALIDITA%TYPE) RETURN NUMBER IS
        nRec INTEGER:=0;
    BEGIN

        IF pIdStoricoParticella IS NOT NULL THEN

            -- considero in P30 anche le particelle non presenti
            -- su DB_PARTICELLA_CERTIFICATA
            SELECT COUNT (SP.ID_STORICO_PARTICELLA)
              INTO nRec
              FROM DB_STORICO_PARTICELLA SP,
                   DB_TIPO_CASO_PARTICOLARE TCP
             WHERE SP.ID_STORICO_PARTICELLA = pIdStoricoParticella
               AND NVL(SP.ID_CASO_PARTICOLARE,99) = TCP.ID_CASO_PARTICOLARE
               AND TCP.EFFETTUA_CONTROLLI_GIS = 'S'
               AND NOT EXISTS(SELECT PC.ID_PARTICELLA_CERTIFICATA
                                FROM DB_PARTICELLA_CERTIFICATA PC
                               WHERE SP.ID_PARTICELLA = PC.ID_PARTICELLA
                                 AND PC.DATA_FINE_VALIDITA IS NULL);

            IF nRec > 0 THEN
               nRec := 1;
            ELSE
                -- vado solamente più per ID_PARTICELLA
                -- e non per chiave catastale da anni l'ID_PARTICELLA
                -- e' sempre valorizzato su DB_PARTICELLA_CERTIFICATA
                SELECT COUNT (PC.ID_PARTICELLA_CERTIFICATA)
                  INTO nRec
                  FROM DB_STORICO_PARTICELLA SP,
                       DB_PARTICELLA_CERTIFICATA PC,
                       DB_TIPO_CASO_PARTICOLARE TCP
                 WHERE SP.ID_STORICO_PARTICELLA = pIdStoricoParticella
                   AND NVL(SP.ID_CASO_PARTICOLARE,99) = TCP.ID_CASO_PARTICOLARE 
                   AND TCP.EFFETTUA_CONTROLLI_GIS = 'S' 
                   AND SP.ID_PARTICELLA = PC.ID_PARTICELLA 
                   AND PC.PARTICELLA_A_GIS = 0
                   AND ((pDataConfronto IS NOT NULL AND pDataConfronto BETWEEN PC.DATA_INIZIO_VALIDITA AND NVL(PC.DATA_FINE_VALIDITA,pDataConfronto)) OR
                        (pDataConfronto IS NULL AND PC.DATA_FINE_VALIDITA IS NULL));

                IF nRec > 0 THEN
                   nRec := 1;
                END IF;
            END IF;

        ELSE
            nRec := NULL;
        END IF;

        RETURN nRec;

    END Calcola_P30;

    /*********************************************************************
    Dati in input un azienda e le relative particella, particella certificata
    ed utilizzo particella ritorna la superficie eleggibile riproporzionata
    per l'utilizzo
    Tipo: funzione
    input: pIdAzienda, pIdParticella, pIdPartCertif , pIdUtilizzoPart
    output: nessuno
    ritorno: nSupRipr (null = parametri mancanti, -1 = errore oracle, Se >= 0 =superficie eleggibile riproporzionata)
    *********************************************************************/
    FUNCTION Sup_Eleggibile_Riproporzionata (pIdAzienda       IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                                             pIdParticella    IN DB_PARTICELLA.ID_PARTICELLA%TYPE,
                                             pIdPartCertif    IN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE,
                                             pIdUtilizzoPart  IN DB_UTILIZZO_PARTICELLA.ID_UTILIZZO_PARTICELLA%TYPE
                                             ) RETURN DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE IS
        nSupRipr    DB_UTILIZZO_PARTICELLA.SUPERFICIE_UTILIZZATA%TYPE;
        NO_SUP_ELEG EXCEPTION;
        PRAGMA EXCEPTION_INIT(NO_SUP_ELEG, -01476);

    BEGIN

        -- controllo se i parametri di input sono valorizzati
        IF pIdAzienda IS NOT NULL AND
           pIdParticella IS NOT NULL AND
           pIdPartCertif IS NOT NULL AND
           pIdUtilizzoPart IS NOT NULL THEN

            WITH ELENCO_MATRICI AS (
            SELECT A.ID_CATALOGO_MATRICE,
                   A.ID_UTILIZZO_PARTICELLA,
                   SUM(SUPERFICIE_UTILIZZATA) AS SUPERFICIE_UTILIZZATA
              FROM DB_UTILIZZO_PARTICELLA A,
                   DB_CONDUZIONE_PARTICELLA B,
                   DB_UTE C
             WHERE A.ID_CONDUZIONE_PARTICELLA = B.ID_CONDUZIONE_PARTICELLA
               AND B.DATA_FINE_CONDUZIONE IS NULL
               AND C.ID_UTE = B.ID_UTE
               AND C.DATA_FINE_ATTIVITA IS NULL
               AND C.ID_AZIENDA = pIdAzienda
               AND B.ID_PARTICELLA = pIdParticella
               AND B.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento
            GROUP BY A.ID_CATALOGO_MATRICE, A.ID_UTILIZZO_PARTICELLA),
            MATRICE_VARIETA_ELEGGIBILITA AS (
            SELECT VE.ID_ELEGGIBILITA,
                   VE.ID_ELEGGIBILITA_FIT,
                   EV.ID_UTILIZZO_PARTICELLA,
                   EV.ID_CATALOGO_MATRICE ,
                   EV.SUPERFICIE_UTILIZZATA,
                   NVL(PCE.SUPERFICIE,0) AS SUPERFICIE,
                   SUM(EV.SUPERFICIE_UTILIZZATA) OVER (PARTITION BY PCE.ID_ELEGGIBILITA , PCE.ID_ELEGGIBILITA_FIT) AS TOT_SUP
              FROM DB_VARIETA_ELEGGIBILITA VE,
                   ELENCO_MATRICI EV,
                   DB_PARTICELLA_CERT_ELEG PCE
             WHERE VE.ID_CATALOGO_MATRICE = EV.ID_CATALOGO_MATRICE
               AND VE.DATA_FINE_VALIDITA IS NULL
               AND VE.ID_ELEGGIBILITA = PCE.ID_ELEGGIBILITA (+)
               AND VE.ID_ELEGGIBILITA_FIT = PCE.ID_ELEGGIBILITA_FIT (+)
               AND PCE.ID_PARTICELLA_CERTIFICATA (+) = pIdPartCertif
               AND PCE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                          FROM DB_PARTICELLA_CERT_ELEG
                                         WHERE ID_PARTICELLA_CERTIFICATA = pIdPartCertif)) 
            SELECT TRUNC(NVL(SUM((M.SUPERFICIE_UTILIZZATA / M.TOT_SUP) * M.SUPERFICIE),0),4) AS SUP_RIPR
              INTO nSupRipr
              FROM MATRICE_VARIETA_ELEGGIBILITA M 
             WHERE ID_UTILIZZO_PARTICELLA = pIdUtilizzoPart;  

        ELSE
            nSupRipr := NULL;
        END IF;

        RETURN nSupRipr;

    EXCEPTION
        WHEN NO_SUP_ELEG THEN
             RETURN 0;
        WHEN OTHERS THEN
             RETURN -1;
    END Sup_Eleggibile_Riproporzionata;

    /*********************************************************************
    Dati in input un azienda, un id_dichiarazione consistenza e le relative particella,
    particella certificata ed utilizzo dichiarato ritorna la superficie
    eleggibile riproporzionata per l'utilizzo
    Tipo: funzione
    input: pIdAzienda, pIdDichCons, pIdParticella, pIdPartCertif , pIdUtilizzoDich
    output: nessuno
    ritorno: nSupRipr
            (null = parametri mancanti, -1 = errore oracle, Se >= 0 =superficie eleggibile riproporzionata)
    *********************************************************************/
    FUNCTION Sup_Eleggibile_Riproporzionata (pIdAzienda       IN DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE,
                                             pIdDichCons      IN DB_DICHIARAZIONE_CONSISTENZA.ID_DICHIARAZIONE_CONSISTENZA%TYPE,
                                             pIdParticella    IN DB_PARTICELLA.ID_PARTICELLA%TYPE,
                                             pIdPartCertif    IN DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE,
                                             pIdUtilizzoDich  IN DB_UTILIZZO_DICHIARATO.ID_UTILIZZO_DICHIARATO%TYPE
                                             ) RETURN DB_UTILIZZO_DICHIARATO.SUPERFICIE_UTILIZZATA%TYPE IS
        nSupRipr DB_UTILIZZO_DICHIARATO.SUPERFICIE_UTILIZZATA%TYPE;
    BEGIN

        -- controllo se i parametri di input sono valorizzati
        IF pIdAzienda IS NOT NULL AND
           pIdDichCons IS NOT NULL AND
           pIdParticella IS NOT NULL AND
           pIdPartCertif IS NOT NULL AND
           pIdUtilizzoDich IS NOT NULL THEN

            WITH ELENCO_MATRICI AS (
            SELECT A.ID_CATALOGO_MATRICE, 
                   A.ID_UTILIZZO_DICHIARATO,
                   SUM(A.SUPERFICIE_UTILIZZATA) AS SUPERFICIE_UTILIZZATA
              FROM DB_UTILIZZO_DICHIARATO A,
                   DB_CONDUZIONE_DICHIARATA B,
                   DB_DICHIARAZIONE_CONSISTENZA C
             WHERE A.ID_CONDUZIONE_DICHIARATA= B.ID_CONDUZIONE_DICHIARATA
               AND C.CODICE_FOTOGRAFIA_TERRENI= B.CODICE_FOTOGRAFIA_TERRENI
               AND B.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento
               AND C.ID_DICHIARAZIONE_CONSISTENZA = pIdDichCons
               AND B.ID_PARTICELLA = pIdParticella
            GROUP BY A.ID_CATALOGO_MATRICE,A.ID_UTILIZZO_DICHIARATO),
            MATRICE_VARIETA_ELEGGIBILITA AS (
            SELECT VE.ID_ELEGGIBILITA,
                   VE.ID_ELEGGIBILITA_FIT,
                   EV.ID_UTILIZZO_DICHIARATO,
                   EV.ID_CATALOGO_MATRICE , 
                   EV.SUPERFICIE_UTILIZZATA,
                   NVL(PCE.SUPERFICIE,0) AS SUPERFICIE,
                   SUM(EV.SUPERFICIE_UTILIZZATA) OVER (PARTITION BY PCE.ID_ELEGGIBILITA , PCE.ID_ELEGGIBILITA_FIT) AS TOT_SUP
              FROM DB_VARIETA_ELEGGIBILITA VE,
                   ELENCO_MATRICI EV, 
                   DB_PARTICELLA_CERT_ELEG PCE
             WHERE VE.ID_CATALOGO_MATRICE = EV.ID_CATALOGO_MATRICE 
               AND VE.DATA_FINE_VALIDITA IS NULL
               AND VE.ID_ELEGGIBILITA = PCE.ID_ELEGGIBILITA (+)
               AND VE.ID_ELEGGIBILITA_FIT = PCE.ID_ELEGGIBILITA_FIT (+)
               AND PCE.ID_PARTICELLA_CERTIFICATA (+) = pIdPartCertif
               AND PCE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                          FROM DB_PARTICELLA_CERT_ELEG
                                         WHERE ID_PARTICELLA_CERTIFICATA = pIdPartCertif)) 
            SELECT TRUNC(NVL(SUM((M.SUPERFICIE_UTILIZZATA / M.TOT_SUP) * M.SUPERFICIE),0),4) AS SUP_RIPR
              INTO nSupRipr
              FROM MATRICE_VARIETA_ELEGGIBILITA M 
             WHERE ID_UTILIZZO_DICHIARATO = pIdUtilizzoDich;  

        ELSE
            nSupRipr := NULL;
        END IF;

        RETURN nSupRipr;

    EXCEPTION
        WHEN OTHERS THEN
             RETURN -1;
    END Sup_Eleggibile_Riproporzionata;

    /*********************************************************************
    Effettua l'eventuale aggiornamento della superficie utilizzata per gli
    usi del suolo dell'azienda data in input se fanno parte di quelli relativi
    ai macro usi col flag ALLINEA_A_ELEGGIBILE ad 'S', se sono in P26 e
    se la superficie eleggibile è calcolabile e maggiore di zero
    Tipo: procedure
    input: pIdAzienda , pIdUtenteAgg
    output: pResult --> 0 = Elaborazione OK (COMMITTARE Da Java)
                    --> 1 = Elaborazione KO (ROLLBACKARE Da Java)
                    --> 2 = Elaborazione OK ma con anomalie (COMMITTARE Da Java)
            pMsg    --> Messaggio di errore bloccate se pResult = 1
                        Messaggio/i di anomalia concatenati nel seguente modo :
                        ID_PARTICELLA;MESSAGGIO|ID_PARTICELLA;MESSAGGIO|ETC
                        se pResult = 2
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE Allinea_Sup_Utilizzata (pIdAzienda    IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                      pIdUtenteAgg  IN DB_UTILIZZO_PARTICELLA.ID_UTENTE_AGGIORNAMENTO%TYPE,
                                      pResult      OUT VARCHAR2,
                                      pMsg         OUT VARCHAR2) IS


        -- estraggo gli utilizzi della particella
        -- per i quali il macro uso a ALLINEA ad ELEGGIBILE a 'S'
        CURSOR curUtilizzoParticella IS
        SELECT UP.ID_UTILIZZO_PARTICELLA,
               UP.ID_CONDUZIONE_PARTICELLA,
               UP.SUPERFICIE_UTILIZZATA,
               UP.SUP_UTILIZZATA_SECONDARIA,
               CP.ID_PARTICELLA,
               GREATEST(SP.SUP_CATASTALE, SP.SUPERFICIE_GRAFICA) AS SUP_GRAFICA, 
               MU.ALLINEA_A_ELEGGIBILE
          FROM DB_UTILIZZO_PARTICELLA UP,
               DB_CONDUZIONE_PARTICELLA CP,
               DB_STORICO_PARTICELLA SP,
               DB_UTE U,
               DB_TIPO_MACRO_USO_VARIETA MUV,
               DB_TIPO_MACRO_USO MU,DB_R_CATALOGO_MATRICE CM 
         WHERE UP.ID_CONDUZIONE_PARTICELLA = CP.ID_CONDUZIONE_PARTICELLA
           AND CP.ID_TITOLO_POSSESSO <> knIdTitPossessoAsservimento
           AND CP.ID_PARTICELLA = SP.ID_PARTICELLA
           AND SP.DATA_FINE_VALIDITA IS NULL
           AND CP.DATA_FINE_CONDUZIONE IS NULL
           AND CP.ID_UTE = U.ID_UTE
           AND U.DATA_FINE_ATTIVITA IS NULL
           AND U.ID_AZIENDA = pIdAzienda
           AND CM.ID_CATALOGO_MATRICE = UP.ID_CATALOGO_MATRICE 
           AND MUV.ID_CATALOGO_MATRICE = CM.ID_CATALOGO_MATRICE 
           AND MUV.DATA_FINE_VALIDITA IS NULL
           AND MUV.ID_MACRO_USO = MU.ID_MACRO_USO
      ORDER BY CP.ID_PARTICELLA, UP.ID_CONDUZIONE_PARTICELLA;

        -- cursore degli utilizzi per i quali riproporzionando la superficie
        -- utilizzata rispetto all'eleggibile mi sono perso almeno un metro quadro
        -- in arrotondamenti
        CURSOR curUtilizzoDaRiempire  (pIdAzienda       IN DB_UTE.ID_AZIENDA%TYPE,
                                       pIdParticella    IN DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE) IS
        SELECT TEF.ID_ELEGGIBILITA_FIT,
               SUM (UP.SUPERFICIE_UTILIZZATA),
               MIN(UP.ID_UTILIZZO_PARTICELLA) AS ID_UTILIZZO_PARTICELLA,
               PCE.SUPERFICIE
          FROM DB_TIPO_ELEGGIBILITA_FIT TEF,
               DB_UTILIZZO_PARTICELLA UP,
               DB_VARIETA_ELEGGIBILITA VE,
               DB_PARTICELLA_CERTIFICATA PC,
               DB_CONDUZIONE_PARTICELLA CP,
               DB_UTE U,
               DB_PARTICELLA_CERT_ELEG PCE
         WHERE PCE.ID_ELEGGIBILITA_FIT = TEF.ID_ELEGGIBILITA_FIT
           AND U.ID_AZIENDA = pIdAzienda
           AND U.ID_UTE = CP.ID_UTE
           AND U.DATA_FINE_ATTIVITA IS NULL
           AND CP.DATA_FINE_CONDUZIONE IS NULL
           AND CP.ID_CONDUZIONE_PARTICELLA = UP.ID_CONDUZIONE_PARTICELLA
           AND CP.ID_PARTICELLA = pIdParticella
           AND CP.ID_PARTICELLA = PC.ID_PARTICELLA
           AND PCE.ID_PARTICELLA_CERTIFICATA = PC.ID_PARTICELLA_CERTIFICATA
           AND VE.ID_CATALOGO_MATRICE = UP.ID_CATALOGO_MATRICE 
           AND VE.DATA_FINE_VALIDITA IS NULL
           AND PC.DATA_FINE_VALIDITA IS NULL
           AND VE.ID_ELEGGIBILITA_FIT = PCE.ID_ELEGGIBILITA_FIT
           AND PCE.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                      FROM DB_PARTICELLA_CERT_ELEG
                                     WHERE ID_PARTICELLA_CERTIFICATA = PC.ID_PARTICELLA_CERTIFICATA)
      GROUP BY TEF.ID_ELEGGIBILITA_FIT, PCE.SUPERFICIE
      HAVING PCE.SUPERFICIE - SUM (UP.SUPERFICIE_UTILIZZATA) = 0.0001;


        nIdPartCertif   DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE;
        nSumSupEleg     DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        nRecAnomali     INTEGER:=0;
        nRecAccodati    INTEGER:=0;
        nRecUtilizzi    INTEGER:=0;
        nPercP26        NUMBER:=0;
        VetParticella   VetTypTipoParticella;
        nIdCondPart     DB_CONDUZIONE_PARTICELLA.ID_CONDUZIONE_PARTICELLA%TYPE;
        nIdParticella   DB_CONDUZIONE_PARTICELLA.ID_PARTICELLA%TYPE;
        CALCOLO_ERRATO  EXCEPTION;
        nRecInRegPasc   INTEGER:=0;
        nIdFonte        DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE;
        nSuperficie     NUMBER;
    BEGIN
        -- cerco il parametro contenete la percentuale di tolleranza per il calcolo della P26
        nPercP26 := SelectValoreParametro (kvIdParamPercP26);

        <<USI_DEL_SUOLO>>
        FOR recUtilizzoParticella IN curUtilizzoParticella LOOP
            -- scorro gli usi del suolo e mi calcolo l'eventuale id_particella_certificata
            nIdPartCertif := SelectIdPartCertif (recUtilizzoParticella.ID_PARTICELLA);
            -- se è -1 vuol dire che non sono riuscito ad identificare univocamente
            -- un id_particella certificata a fronte di un id_particella probabilmente
            -- su DB_PARTICELLA_CERTIFICATA manca una data_fine_validita
            IF nIdPartCertif = -1 THEN
               -- accodo la particella nel vettore
               -- mettendo l'esito = - 1
               IF VetParticella.COUNT = 0 OR
                  VetParticella(VetParticella.COUNT).nIdParticella <> recUtilizzoParticella.ID_PARTICELLA THEN
                  nRecAccodati := nRecAccodati + 1;
                  VetParticella(nRecAccodati).nIdParticella := recUtilizzoParticella.ID_PARTICELLA;
                  VetParticella(nRecAccodati).nEsito := -1;
               END IF;
            ELSIF nIdPartCertif IS NULL THEN
               -- se è a null vuol dire che la corrispettiva particella certificata non è presente su
               -- DB_PARTICELLA_CERTIFICATA , accodo la particella nel vettore mettendo l'esito = -2
               IF VetParticella.COUNT = 0 OR
                  VetParticella(VetParticella.COUNT).nIdParticella <> recUtilizzoParticella.ID_PARTICELLA THEN
                  nRecAccodati := nRecAccodati + 1;
                  VetParticella(nRecAccodati).nIdParticella := recUtilizzoParticella.ID_PARTICELLA;
                  VetParticella(nRecAccodati).nEsito := -2;
               END IF;
            ELSE

               -- uso questa select che e' stata modifica
               -- per usare il flag CALCOLA_ELEGGIBILE di DB_TIPO_FONTE
               nIdFonte := SelTFontePartInRegPascByIdPart (nIdPartCertif);
               /*
               -- se la particella certificata e' nel registro pascoli
               -- la escludo dall'allineamento
               SELECT COUNT(EPM.ID_ESITO_PASCOLO_MAGRO)
                 INTO nRecInRegPasc
                 FROM DB_ESITO_PASCOLO_MAGRO EPM
                WHERE EPM.ID_PARTICELLA_CERTIFICATA = nIdPartCertif
                  AND EPM.ANNO_CAMPAGNA = (SELECT MAX(ANNO_CAMPAGNA)
                                             FROM DB_ESITO_PASCOLO_MAGRO
                                            WHERE ID_PARTICELLA_CERTIFICATA = nIdPartCertif)
                  AND EPM.DATA_FINE_VALIDITA IS NULL;*/

               IF nIdFonte IS NOT NULL THEN
                  IF VetParticella.COUNT = 0 OR
                     VetParticella(VetParticella.COUNT).nIdParticella <> recUtilizzoParticella.ID_PARTICELLA THEN
                     nRecAccodati := nRecAccodati + 1;
                     VetParticella(nRecAccodati).nIdParticella := recUtilizzoParticella.ID_PARTICELLA;
                     VetParticella(nRecAccodati).nEsito := -3;
                  END IF;
               ELSE
                   -- altrimenti se ho trovato la particella certificata posso calcolare la P26
                   --IF Calcola_P26_Con_Tolleranza (pIdAzienda,recUtilizzoParticella.ID_PARTICELLA,nIdPartCertif,nPercP26) = 1 THEN
                      -- ALLINEA_A_ELEGGIBILE è ad 'S'
                      IF recUtilizzoParticella.ALLINEA_A_ELEGGIBILE = 'S' THEN
                         nSumSupEleg := Sup_Eleggibile_Riproporzionata (pIdAzienda,
                                                                        recUtilizzoParticella.ID_PARTICELLA,
                                                                        nIdPartCertif,
                                                                        recUtilizzoParticella.ID_UTILIZZO_PARTICELLA);
                         IF nSumSupEleg = -1 THEN
                            AccodaMessaggio (pMsg,recUtilizzoParticella.ID_PARTICELLA,'Impossibile calcolare superficie riproporzionata');
                            RAISE CALCOLO_ERRATO;
                         ELSIF nSumSupEleg = 0 THEN
                            nSumSupEleg := recUtilizzoParticella.SUPERFICIE_UTILIZZATA;
                         END IF;
                      ELSE
                         nSumSupEleg := recUtilizzoParticella.SUPERFICIE_UTILIZZATA;
                      END IF;

                      -- se la particella è in P26 l'accodo nel vettore con esito = 0
                      -- andando anche ad aggiornare la superficie condotta , e la superficie riproporzionata
                      -- stando attento che se la particella era già presente nel vettore la superficie riproporzionata
                      -- che ho calcolato è da sommarsi a quella attuale
                      IF VetParticella.COUNT = 0 OR
                         VetParticella(VetParticella.COUNT).nIdParticella <> recUtilizzoParticella.ID_PARTICELLA THEN
                         nRecAccodati := nRecAccodati + 1;
                         VetParticella(nRecAccodati).nIdParticella := recUtilizzoParticella.ID_PARTICELLA;
                         VetParticella(nRecAccodati).nSupGrafica := recUtilizzoParticella.SUP_GRAFICA; 
                         VetParticella(nRecAccodati).nTotSupRipr := nSumSupEleg;
                         VetParticella(nRecAccodati).nEsito := 0;
                         -- a rottura di particella azzero il contatore degli utilizzi
                         nRecUtilizzi := 0;
                      ELSE
                         VetParticella(nRecAccodati).nTotSupRipr := VetParticella(nRecAccodati).nTotSupRipr + nSumSupEleg;
                      END IF;
                      -- devo anche accodare gli utilizzi nel apposito vettore annidato nel vettore delle particelle
                      nRecUtilizzi := nRecUtilizzi + 1;
                      VetParticella(nRecAccodati).VetUtilizzi(nRecUtilizzi).nIdUtilizzoParticella := recUtilizzoParticella.ID_UTILIZZO_PARTICELLA;
                      VetParticella(nRecAccodati).VetUtilizzi(nRecUtilizzi).nIdConduzioneParticella := recUtilizzoParticella.ID_CONDUZIONE_PARTICELLA;
                      VetParticella(nRecAccodati).VetUtilizzi(nRecUtilizzi).nSupUtilizzaRipr := nSumSupEleg;
                      VetParticella(nRecAccodati).VetUtilizzi(nRecUtilizzi).nSupUtilizzataSec := recUtilizzoParticella.SUP_UTILIZZATA_SECONDARIA;
                      VetParticella(nRecAccodati).VetUtilizzi(nRecUtilizzi).vAllinea := recUtilizzoParticella.ALLINEA_A_ELEGGIBILE;

                   --END IF;
               END IF;
            END IF;
        END LOOP;

        -- scorro il vettore delle particelle andando a segnalare le anomalie
        -- se gli esiti sono uguali a -2 e - 1
        FOR I IN 1..VetParticella.COUNT LOOP

            IF VetParticella(i).nEsito = -2 THEN
                nRecAnomali := nRecAnomali + 1;
                AccodaMessaggio (pMsg,
                                 VetParticella(i).nIdParticella,
                                 'Nessuna particella certificata presente per l''id_particella ');
            ELSIF VetParticella(i).nEsito = -1 THEN
                nRecAnomali := nRecAnomali + 1;
                AccodaMessaggio (pMsg,
                                 VetParticella(i).nIdParticella,
                                 'Impossibile identificare univocamente la particella certificata relativa all''id_particella');
            ELSIF VetParticella(i).nEsito = -3 THEN
                nRecAnomali := nRecAnomali + 1;
                AccodaMessaggio (pMsg,
                                 VetParticella(i).nIdParticella,
                                 'Particella presente sul registro pascoli ed esclusa dall''allineamento');
            -- mentre se l'esito è uguale a zero
            ELSIF VetParticella(i).nEsito = 0 THEN
               -- controllo se il  totale della superficie riproporzionata
               -- è uguale a zero
               IF VetParticella(i).nTotSupRipr = 0 THEN
                  -- in questo caso sono sempre in anomalia
                  nRecAnomali := nRecAnomali + 1;
                  AccodaMessaggio (pMsg,
                                   VetParticella(i).nIdParticella,
                                   'Superficie Eleggibile = 0');
               ELSE
                  -- se invece è maggiore di zero controllo se il totale riproporzionato
                  -- è minore od uguale alla superficie grafica della particella
                  IF VetParticella(i).nTotSupRipr <= VetParticella(i).nSupGrafica THEN 
                     nIdCondPart := NULL;
                     FOR J IN 1..VetParticella(i).VetUtilizzi.COUNT LOOP
                         
                         IF VetParticella(i).VetUtilizzi(j).vAllinea = 'S' THEN
                            AggiornaSupUtilizzata (VetParticella(i).VetUtilizzi(j).nIdUtilizzoParticella,
                                                   VetParticella(i).VetUtilizzi(j).nSupUtilizzataSec,
                                                   VetParticella(i).VetUtilizzi(j).nSupUtilizzaRipr,
                                                   pIdUtenteAgg);
                         END IF;
                         
                         IF VetParticella(i).VetUtilizzi(j).nIdConduzioneParticella <> NVL(nIdCondPart,0) THEN
                            IF nIdCondPart IS NOT NULL THEN
                               SELECT DECODE(SUP_CATASTALE,0,SUPERFICIE_GRAFICA, SUP_CATASTALE)
                               INTO   nSuperficie
                               FROM   DB_STORICO_PARTICELLA
                               WHERE  ID_PARTICELLA      = VetParticella(i).nIdParticella
                               AND    DATA_FINE_VALIDITA IS NULL;

                               UPDATE DB_CONDUZIONE_PARTICELLA
                                  SET SUPERFICIE_CONDOTTA = (SELECT SUM(SUPERFICIE_UTILIZZATA)
                                                               FROM DB_UTILIZZO_PARTICELLA
                                                              WHERE ID_CONDUZIONE_PARTICELLA = nIdCondPart),
                                      PERCENTUALE_POSSESSO = CASE WHEN nSuperficie = 0 OR PERCENTUALE_POSSESSO = 100 THEN PERCENTUALE_POSSESSO
                                                             ELSE
                                                             ROUND(((SELECT SUM(SUPERFICIE_UTILIZZATA)
                                                               FROM DB_UTILIZZO_PARTICELLA
                                                              WHERE ID_CONDUZIONE_PARTICELLA = nIdCondPart)/nSuperficie)*100,2) END
                                WHERE ID_CONDUZIONE_PARTICELLA = nIdCondPart;

                            END IF;
                            nIdCondPart := VetParticella(i).VetUtilizzi(j).nIdConduzioneParticella;
                         END IF;

                     END LOOP;
                     -- l'ultimo aggiornamento della superficie condotta va effettuato fuori ciclo
                     IF nIdCondPart IS NOT NULL THEN
                        SELECT DECODE(SUP_CATASTALE,0,SUPERFICIE_GRAFICA, SUP_CATASTALE)
                        INTO   nSuperficie
                        FROM   DB_STORICO_PARTICELLA
                        WHERE  ID_PARTICELLA      = VetParticella(i).nIdParticella
                        AND    DATA_FINE_VALIDITA IS NULL;

                        UPDATE DB_CONDUZIONE_PARTICELLA
                           SET SUPERFICIE_CONDOTTA = (SELECT SUM(SUPERFICIE_UTILIZZATA)
                                                        FROM DB_UTILIZZO_PARTICELLA
                                                       WHERE ID_CONDUZIONE_PARTICELLA = nIdCondPart),
                               PERCENTUALE_POSSESSO = CASE WHEN nSuperficie = 0 OR PERCENTUALE_POSSESSO = 100 THEN PERCENTUALE_POSSESSO
                                                     ELSE
                                                     ROUND(((SELECT SUM(SUPERFICIE_UTILIZZATA)
                                                       FROM DB_UTILIZZO_PARTICELLA
                                                      WHERE ID_CONDUZIONE_PARTICELLA = nIdCondPart)/nSuperficie)*100,2) END
                         WHERE ID_CONDUZIONE_PARTICELLA = nIdCondPart;

                     END IF;
                    
                     FOR recUtilizzoDaRiempire IN curUtilizzoDaRiempire (pIdAzienda,
                                                                         VetParticella(i).nIdParticella) LOOP
                         UPDATE DB_UTILIZZO_PARTICELLA
                            SET SUPERFICIE_UTILIZZATA = SUPERFICIE_UTILIZZATA + 0.0001
                          WHERE ID_UTILIZZO_PARTICELLA = recUtilizzoDaRiempire.ID_UTILIZZO_PARTICELLA
                      RETURNING ID_CONDUZIONE_PARTICELLA INTO nIdCondPart;

                        SELECT DECODE(SUP_CATASTALE,0,SUPERFICIE_GRAFICA, SUP_CATASTALE)
                        INTO   nSuperficie
                        FROM   DB_STORICO_PARTICELLA
                        WHERE  ID_PARTICELLA      = VetParticella(i).nIdParticella
                        AND    DATA_FINE_VALIDITA IS NULL;

                        UPDATE DB_CONDUZIONE_PARTICELLA
                           SET SUPERFICIE_CONDOTTA = (SELECT SUM(SUPERFICIE_UTILIZZATA)
                                                        FROM DB_UTILIZZO_PARTICELLA
                                                       WHERE ID_CONDUZIONE_PARTICELLA = nIdCondPart),
                               PERCENTUALE_POSSESSO = CASE WHEN nSuperficie = 0 OR PERCENTUALE_POSSESSO = 100 THEN PERCENTUALE_POSSESSO
                                                     ELSE
                                                     ROUND(((SELECT SUM(SUPERFICIE_UTILIZZATA)
                                                       FROM DB_UTILIZZO_PARTICELLA
                                                      WHERE ID_CONDUZIONE_PARTICELLA = nIdCondPart)/nSuperficie)*100,2) END
                         WHERE ID_CONDUZIONE_PARTICELLA = nIdCondPart;

                     END LOOP;

                  ELSE
                     -- altrimenti segnalo l'anomalia
                     nRecAnomali := nRecAnomali + 1;
                     AccodaMessaggio (pMsg,
                                      VetParticella(i).nIdParticella,
                                      'Superficie Eleggibile > Superficie grafica');
                  END IF;

               END IF;
            END IF;
        END LOOP;

        -- se non ci sono state anomalie do esito = 0
        IF nRecAnomali = 0 THEN
           pResult := 0;
        ELSE
           -- altrimenti do esito = 2
           pResult := 2;
        END IF;

    EXCEPTION
        WHEN CALCOLO_ERRATO THEN
             pResult := 1;
        WHEN OTHERS THEN
             pResult := 1;
             AccodaMessaggio (pMsg,NULL,'Errore Oracle : ' || SUBSTR(SQLERRM,1,150));
    END Allinea_Sup_Utilizzata;





    /*********************************************************************
    Dati un codice fotografia terreni , una data di inserimento dichiarazione,
    un identificativo particella ed un identificativo varieta somma la superficie
    eleggibile eventualmente presente su DB_ELEGGIBILITA_DICHIARATA e la ritorna in output
    Tipo: function
    input: pCodiceFoto, pDataInsDich ,pIdParticella, pIdCatalogoMatrice
    output: nessuno
    ritorno: nTotSupEleg
    *********************************************************************/
    FUNCTION SelSupElegDichByFotoIdPartVar (pCodiceFoto      IN DB_ELEGGIBILITA_DICHIARATA.CODICE_FOTOGRAFIA_TERRENI%TYPE,
                                            pDataInsDich     IN DB_DICHIARAZIONE_CONSISTENZA.DATA_INSERIMENTO_DICHIARAZIONE%TYPE,
                                            pIdParticella    IN DB_ELEGGIBILITA_DICHIARATA.ID_PARTICELLA%TYPE,
                                            
                                            pIdCatalogoMatrice  DB_VARIETA_ELEGGIBILITA.ID_CATALOGO_MATRICE%TYPE
                                             ) RETURN DB_ELEGGIBILITA_DICHIARATA.SUPERFICIE%TYPE IS

        nTotSupEleg         DB_ELEGGIBILITA_DICHIARATA.SUPERFICIE%TYPE;
        nTotSupElegRegistro DB_ESITO_PASCOLO_MAGRO.SUPERFICIE%TYPE;
        nTotSupElegPascolo  DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        nTotSupElegBosco    DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        nIdPartCertificata  DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE;
        nIdFonte            DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE;
        nIdVarieta          DB_R_CATALOGO_MATRICE.ID_VARIETA%TYPE;

    BEGIN

        nIdPartCertificata := SelIdPartCertifByFotoEIdPart (pCodiceFoto,pIdParticella);
        -- se lo trovo posso effettuare le verifiche su DB_ESITO_PASCOLO_MAGRO
        IF nIdPartCertificata IS NOT NULL THEN
            nIdFonte := SelTFntPrtInRegPascByIdPrtYear (nIdPartCertificata, EXTRACT(YEAR FROM pDataInsDich));

            SELECT ID_VARIETA
            INTO   nIdVarieta
            FROM   DB_R_CATALOGO_MATRICE
            WHERE  ID_CATALOGO_MATRICE = pIdCatalogoMatrice;

            IF nIdFonte IS NOT NULL AND IsVarietaAblitataForFonteDt (nIdVarieta, nIdFonte, pDataInsDich) THEN
               -- prendo la superficie del registor per la fonte all'anno della validazione
               nTotSupElegRegistro := SelTotSupElePMagroByParFntAnno (nIdPartCertificata,nIdFonte, EXTRACT(YEAR FROM pDataInsDich));
               -- se la fonte e' registro storico pascoli dichiarativo
               IF nIdFonte = knIdFontePMagroDichiarativo THEN
                  -- se ho superficie eleggibile a pascolo magro dal registro storico
                  -- devo controllare se ho della superficie eleggibile a bosco sul GIS
                  SELECT NVL(SUM(ED.SUPERFICIE),0)
                    INTO nTotSupElegBosco
                    FROM DB_ELEGGIBILITA_DICHIARATA ED,
                         DB_TIPO_ELEGGIBILITA_FIT TEF
                   WHERE ED.ID_PARTICELLA = pIdParticella
                     AND ED.ID_PARTICELLA_CERTIFICATA = nIdPartCertificata
                     AND ED.CODICE_FOTOGRAFIA_TERRENI = pCodiceFoto
                     AND ED.ID_ELEGGIBILITA_FIT = TEF.ID_ELEGGIBILITA_FIT
                     AND TEF.FLAG_BOSCO = 'S';

                   -- se ne ho m'invento una sega mentale
                  IF nTotSupElegBosco > 0 THEN
                      -- cerco se sul gis ho della superficie eleggibile a pascolo
                      SELECT NVL(SUM(ED.SUPERFICIE * (1 - TEF.TARA)),0)
                        INTO nTotSupElegPascolo
                        FROM DB_ELEGGIBILITA_DICHIARATA ED,
                             DB_TIPO_ELEGGIBILITA_FIT TEF
                       WHERE ED.ID_PARTICELLA = pIdParticella
                         AND ED.ID_PARTICELLA_CERTIFICATA = nIdPartCertificata
                         AND ED.CODICE_FOTOGRAFIA_TERRENI = pCodiceFoto
                         AND ED.ID_ELEGGIBILITA_FIT = TEF.ID_ELEGGIBILITA_FIT
                         AND TEF.FLAG_PASCOLO = 'S';

                       -- se questa è maggiore della superficie del registro storico
                       IF nTotSupElegPascolo > nTotSupElegRegistro THEN
                          -- diventa la nuova superficie eleggibile
                          nTotSupElegRegistro := nTotSupElegPascolo;
                       ELSE
                          -- altrimenti controllo se la somma eleggibile bosco + pascolo GIS
                          -- è inferiore alla superficie del registro storico
                          IF (nTotSupElegBosco + nTotSupElegPascolo) < nTotSupElegRegistro THEN
                              -- se si diventa la nuova eleggibile
                              nTotSupElegRegistro := nTotSupElegBosco + nTotSupElegPascolo;
                          END IF;
                       END IF;

                       nTotSupEleg := nTotSupElegRegistro;

                  ELSE
                      SELECT NVL(SUM(ED.SUPERFICIE),0)
                        INTO nTotSupEleg
                        FROM DB_ELEGGIBILITA_DICHIARATA ED
                       WHERE ED.CODICE_FOTOGRAFIA_TERRENI = pCodiceFoto
                         AND ED.ID_PARTICELLA_CERTIFICATA = nIdPartCertificata
                         AND ED.ID_PARTICELLA = pIdParticella
                         AND EXISTS (SELECT ID_VARIETA_ELEGGIBILITA
                                       FROM DB_VARIETA_ELEGGIBILITA VE,
                                            DB_DICHIARAZIONE_CONSISTENZA DC
                                      WHERE DC.CODICE_FOTOGRAFIA_TERRENI = pCodiceFoto
                                        AND VE.ID_ELEGGIBILITA = ED.ID_ELEGGIBILITA
                                        AND VE.ID_ELEGGIBILITA_FIT = ED.ID_ELEGGIBILITA_FIT
                                        AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN VE.DATA_INIZIO_VALIDITA
                                                                                  AND NVL(VE.DATA_FINE_VALIDITA, TO_DATE('01/01/9999','DD/MM/YYYY'))
                                        AND VE.ID_CATALOGO_MATRICE = pIdCatalogoMatrice); 

                  END IF;
               ELSE
                   nTotSupEleg := nTotSupElegRegistro;
               END IF;
            ELSE
                SELECT NVL(SUM(ED.SUPERFICIE),0)
                  INTO nTotSupEleg
                  FROM DB_ELEGGIBILITA_DICHIARATA ED
                 WHERE ED.CODICE_FOTOGRAFIA_TERRENI = pCodiceFoto
                   AND ED.ID_PARTICELLA_CERTIFICATA = nIdPartCertificata
                   AND ED.ID_PARTICELLA = pIdParticella
                   AND EXISTS (SELECT ID_VARIETA_ELEGGIBILITA
                                 FROM DB_VARIETA_ELEGGIBILITA VE,
                                      DB_DICHIARAZIONE_CONSISTENZA DC
                                WHERE DC.CODICE_FOTOGRAFIA_TERRENI = pCodiceFoto
                                  AND VE.ID_ELEGGIBILITA = ED.ID_ELEGGIBILITA
                                  AND VE.ID_ELEGGIBILITA_FIT = ED.ID_ELEGGIBILITA_FIT
                                  AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN VE.DATA_INIZIO_VALIDITA
                                                                            AND NVL(VE.DATA_FINE_VALIDITA, TO_DATE('01/01/9999','DD/MM/YYYY'))
                                  AND VE.ID_CATALOGO_MATRICE = pIdCatalogoMatrice); 
            END IF;
        ELSE
            nTotSupEleg := NULL;
        END IF;

        RETURN nTotSupEleg;

    EXCEPTION
        WHEN OTHERS THEN
             RETURN -1;
    END SelSupElegDichByFotoIdPartVar;

    /*********************************************************************
    Dati un codice fotografia terreni , una data di inserimento dichiarazione,
    un identificativo particella ed un identificativo varieta somma la superficie
    eleggibile eventualmente presente su DB_ELEGGIBILITA_DICHIARATA al netto
    della tara e la ritorna in output
    Tipo: function
    input: pCodiceFoto, pDataInsDich ,pIdParticella, pIdCatalogoMatrice
    output: nessuno
    ritorno: nTotSupEleg
    *********************************************************************/
    FUNCTION SelSupElegDichByFtIdPartVarNT (pCodiceFoto      IN DB_ELEGGIBILITA_DICHIARATA.CODICE_FOTOGRAFIA_TERRENI%TYPE,
                                            pDataInsDich     IN DB_DICHIARAZIONE_CONSISTENZA.DATA_INSERIMENTO_DICHIARAZIONE%TYPE,
                                            pIdParticella    IN DB_ELEGGIBILITA_DICHIARATA.ID_PARTICELLA%TYPE,
                                            
                                            pIdCatalogoMatrice  DB_VARIETA_ELEGGIBILITA.ID_CATALOGO_MATRICE%TYPE
                                            ) RETURN DB_ELEGGIBILITA_DICHIARATA.SUPERFICIE%TYPE IS
        nTotSupEleg         DB_ELEGGIBILITA_DICHIARATA.SUPERFICIE%TYPE;
        nTotSupElegRegistro DB_ESITO_PASCOLO_MAGRO.SUPERFICIE%TYPE;
        nTotSupElegBosco    DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        nTotSupElegPascolo  DB_PARTICELLA_CERT_ELEG.SUPERFICIE%TYPE;
        nIdPartCertificata  DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA_CERTIFICATA%TYPE;
        nIdFonte            DB_ESITO_PASCOLO_MAGRO.ID_FONTE%TYPE;
        nIdVarieta          DB_R_CATALOGO_MATRICE.ID_VARIETA%TYPE;
    BEGIN
        nIdPartCertificata := SelIdPartCertifByFotoEIdPart (pCodiceFoto,pIdParticella);
        -- se lo trovo posso effettuare le verifiche su DB_ESITO_PASCOLO_MAGRO
        IF nIdPartCertificata IS NOT NULL THEN
           nIdFonte := SelTFntPrtInRegPascByIdPrtYear (nIdPartCertificata, EXTRACT(YEAR FROM pDataInsDich));

           BEGIN
             SELECT ID_VARIETA
             INTO   nIdVarieta
             FROM   DB_R_CATALOGO_MATRICE
             WHERE  ID_CATALOGO_MATRICE = pIdCatalogoMatrice;
           EXCEPTION
             WHEN NO_DATA_FOUND THEN
               nIdVarieta := NULL;
           END;

           IF nIdFonte IS NOT NULL AND IsVarietaAblitataForFonteDt (nIdVarieta, nIdFonte, pDataInsDich) THEN
              -- prendo la superficie del registor per la fonte all'anno della validazione
              nTotSupElegRegistro := SelTotSupElePMagroByParFntAnno (nIdPartCertificata,nIdFonte, EXTRACT(YEAR FROM pDataInsDich));
              -- se la fonte e' registro storico pascoli dichiarativo
              IF nIdFonte = knIdFontePMagroDichiarativo THEN
                 -- se ho superficie eleggibile a pascolo magro dal registro storico
                 -- devo controllare se ho della superficie eleggibile a bosco sul GIS
                 SELECT NVL(SUM(ED.SUPERFICIE),0)
                   INTO nTotSupElegBosco
                   FROM DB_ELEGGIBILITA_DICHIARATA ED,
                        DB_TIPO_ELEGGIBILITA_FIT TEF
                  WHERE ED.ID_PARTICELLA = pIdParticella
                    AND ED.ID_PARTICELLA_CERTIFICATA = nIdPartCertificata
                    AND ED.CODICE_FOTOGRAFIA_TERRENI = pCodiceFoto
                    AND ED.ID_ELEGGIBILITA_FIT = TEF.ID_ELEGGIBILITA_FIT
                    AND TEF.FLAG_BOSCO = 'S';

                  -- se ne ho m'invento una sega mentale
                 IF nTotSupElegBosco > 0 THEN
                     -- cerco se sul gis ho della superficie eleggibile a pascolo
                     SELECT NVL(SUM(ED.SUPERFICIE * (1 - TEF.TARA)),0)
                       INTO nTotSupElegPascolo
                       FROM DB_ELEGGIBILITA_DICHIARATA ED,
                            DB_TIPO_ELEGGIBILITA_FIT TEF
                      WHERE ED.ID_PARTICELLA = pIdParticella
                        AND ED.ID_PARTICELLA_CERTIFICATA = nIdPartCertificata
                        AND ED.CODICE_FOTOGRAFIA_TERRENI = pCodiceFoto
                        AND ED.ID_ELEGGIBILITA_FIT = TEF.ID_ELEGGIBILITA_FIT
                        AND TEF.FLAG_PASCOLO = 'S';

                          -- se questa è maggiore della superficie del registro storico
                          IF nTotSupElegPascolo > nTotSupElegRegistro THEN
                             -- diventa la nuova superficie eleggibile
                             nTotSupElegRegistro := nTotSupElegPascolo;
                          ELSE
                             -- altrimenti controllo se la somma eleggibile bosco + pascolo GIS
                             -- è inferiore alla superficie del registro storico
                             IF (nTotSupElegBosco + nTotSupElegPascolo) < nTotSupElegRegistro THEN
                                 -- se si diventa la nuova eleggibile
                                 nTotSupElegRegistro := nTotSupElegBosco + nTotSupElegPascolo;
                             END IF;
                          END IF;

                          nTotSupEleg := nTotSupElegRegistro;

                 ELSE
                      SELECT NVL(SUM(ED.SUPERFICIE * (1 - TEF.TARA)),0)
                        INTO nTotSupEleg
                        FROM DB_ELEGGIBILITA_DICHIARATA ED,
                             DB_TIPO_ELEGGIBILITA_FIT TEF
                       WHERE ED.CODICE_FOTOGRAFIA_TERRENI = pCodiceFoto
                         AND ED.ID_PARTICELLA_CERTIFICATA = nIdPartCertificata
                         AND ED.ID_ELEGGIBILITA_FIT = TEF.ID_ELEGGIBILITA_FIT
                         AND ED.ID_PARTICELLA = pIdParticella
                         AND EXISTS (SELECT ID_VARIETA_ELEGGIBILITA
                                       FROM DB_VARIETA_ELEGGIBILITA VE,
                                            DB_DICHIARAZIONE_CONSISTENZA DC
                                      WHERE DC.CODICE_FOTOGRAFIA_TERRENI = pCodiceFoto
                                        AND VE.ID_ELEGGIBILITA = ED.ID_ELEGGIBILITA
                                        AND VE.ID_ELEGGIBILITA_FIT = ED.ID_ELEGGIBILITA_FIT
                                        AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN VE.DATA_INIZIO_VALIDITA
                                                                                  AND NVL(VE.DATA_FINE_VALIDITA, TO_DATE('01/01/9999','DD/MM/YYYY'))
                                        AND VE.ID_CATALOGO_MATRICE = pIdCatalogoMatrice); 

                 END IF;
               ELSE
                   nTotSupEleg := nTotSupElegRegistro;
               END IF;
            ELSE
                SELECT NVL(SUM(ED.SUPERFICIE * (1 - TEF.TARA)),0)
                  INTO nTotSupEleg
                  FROM DB_ELEGGIBILITA_DICHIARATA ED,
                       DB_TIPO_ELEGGIBILITA_FIT TEF
                 WHERE ED.CODICE_FOTOGRAFIA_TERRENI = pCodiceFoto
                   AND ED.ID_PARTICELLA_CERTIFICATA = nIdPartCertificata
                   AND ED.ID_PARTICELLA = pIdParticella
                   AND ED.ID_ELEGGIBILITA_FIT = TEF.ID_ELEGGIBILITA_FIT
                   AND EXISTS (SELECT ID_VARIETA_ELEGGIBILITA
                                 FROM DB_VARIETA_ELEGGIBILITA VE,
                                      DB_DICHIARAZIONE_CONSISTENZA DC
                                WHERE DC.CODICE_FOTOGRAFIA_TERRENI = pCodiceFoto
                                  AND VE.ID_ELEGGIBILITA = ED.ID_ELEGGIBILITA
                                  AND VE.ID_ELEGGIBILITA_FIT = ED.ID_ELEGGIBILITA_FIT
                                  AND DC.DATA_INSERIMENTO_DICHIARAZIONE BETWEEN VE.DATA_INIZIO_VALIDITA
                                                                            AND NVL(VE.DATA_FINE_VALIDITA, TO_DATE('01/01/9999','DD/MM/YYYY'))
                                  AND VE.ID_CATALOGO_MATRICE = pIdCatalogoMatrice); 
            END IF;
        ELSE
            nTotSupEleg := NULL;
        END IF;

        RETURN nTotSupEleg;

    EXCEPTION
        WHEN OTHERS THEN
             RETURN -1;
    END SelSupElegDichByFtIdPartVarNT;

    /********************************************************************************
    Descrizione:  CercaIstanzaRiesame
                  Restituisce l'esistenza e/o lo stato di una eventuale richiesta
                  di isanza di riesame.

    Tipo:         Function;
    Input:        pAnnoCampagna    IN DB_ISTANZA_RIESAME.ANNO%TYPE,
                  pIdAzienda       IN DB_ISTANZA_RIESAME.ID_AZIENDA%TYPE
                  pIdParticella    IN DB_ISTANZA_RIESAME.ID_PARTICELLA%TYPE

    Return:       INTEGER;
                 - 0 = non è stata richiesta alcuna istanza di riesame per la particella
                 - 1 = E' stata richiesta un'istanza di riesame per la particella
                 - 2 = l'isanza di riesame per la particella è gia stata lavorata dal GIS;
    *********************************************************************************/
    FUNCTION CercaIstanzaRiesame( pAnnoCampagna    IN DB_ISTANZA_RIESAME.ANNO%TYPE,
                                  pIdAzienda       IN DB_ISTANZA_RIESAME.ID_AZIENDA%TYPE,
                                  pIdParticella    IN DB_ISTANZA_RIESAME.ID_PARTICELLA%TYPE
                                ) RETURN INTEGER IS
        nNumIstanze             INTEGER;
        nNumIstanzeDaEvadere    INTEGER;
        nNumIstanzeEvase        INTEGER;
        nRet                    INTEGER;
    BEGIN

        -- cerco il numero di istanze di riesame totale
        -- il numero di istanze riesame evase
        -- il numero di istanze di riesame non evase
        -- per l'azienda / particella
        SELECT COUNT(DECODE(DATA_EVASIONE,NULL,ID_ISTANZA_RIESAME)) ,
               COUNT(DECODE(DATA_EVASIONE,NULL,NULL,ID_ISTANZA_RIESAME)),
               COUNT(ID_ISTANZA_RIESAME)
          INTO nNumIstanzeDaEvadere,
               nNumIstanzeEvase,
               nNumIstanze
          FROM DB_ISTANZA_RIESAME
         WHERE ID_AZIENDA = pIdAzienda
           AND ANNO = pAnnoCampagna 
           AND ID_PARTICELLA = pIdParticella
           AND DATA_ANNULLAMENTO IS NULL;

        -- se ci sono delle istanze di riesame non annullate da evadere
        IF nNumIstanzeDaEvadere > 0 THEN
           -- posso ritornare subito 1 (particella in riesame)
           nRet := 1;
        ELSE
           -- altrimenti controllo se c'è mai stata una richiesta di riesame
           IF nNumIstanze > 0 THEN
              -- poi controllo che il numero delle istanze di riesame
              -- della particella totale coincida con quello delle istanze di riesame
              -- evase
              IF nNumIstanze = nNumIstanzeEvase THEN
                 -- se si posso tornare 2 (riesame effettuato sulla particella)
                 nRet := 2;
              ELSE
                 -- altrimenti torno 0 (istanza di riesame non richiesta)
                 -- non dovrebbe mai succedere
                 nRet := 0;
              END IF;
           ELSE
              -- se non ho mai avuto istanze di riesame
              -- posso ritornare  0 (istanza di riesame non richiesta)
              nRet := 0;
           END IF;

        END IF;

        RETURN nRet;
    END CercaIstanzaRiesame;

     /*********************************************************************
    Dato un codice fiscale estrae le informazioni quali data nascita, comune
    nascita e sesso
    Tipo: function
    input: pCodFiscale
    output: pSesso, pComuneNasc
    ritorno: data_nascita
    *********************************************************************/
    FUNCTION FncInfoDaCodFiscale (pCodFiscale IN VARCHAR2,
                                  pSesso OUT CHAR,
                                  pComuneNasc OUT  VARCHAR2
                                 ) RETURN DATE IS

       sAnno             VARCHAR2(2);
       nGiorno           NUMBER(2);
       nMese             NUMBER(2);
       sAnnoFourDigit    VARCHAR2(4);
       sIstatComuneNasc  VARCHAR2(6);
       CodComuneCodFisc  VARCHAR2(4);

  BEGIN

     sAnno := SUBSTR(pCodFiscale,7,2);
     nGiorno := TO_NUMBER(SUBSTR(pCodFiscale,10,2),'99');

     IF TO_NUMBER(nGiorno) > 40 THEN
        nGiorno := nGiorno - 40;
        pSesso  :='F';
     ELSE
        pSesso  :='M';
     END IF;

     IF SUBSTR(pCodFiscale,9,1) = 'A' THEN
        nMese := 1;
     ELSIF SUBSTR(pCodFiscale,9,1) = 'B' THEN
        nMese := 2;
     ELSIF SUBSTR(pCodFiscale,9,1) = 'C' THEN
        nMese := 3;
     ELSIF SUBSTR(pCodFiscale,9,1) = 'D' THEN
        nMese := 4;
     ELSIF SUBSTR(pCodFiscale,9,1) = 'E' THEN
        nMese := 5;
     ELSIF SUBSTR(pCodFiscale,9,1) = 'H' THEN
        nMese := 6;
     ELSIF SUBSTR(pCodFiscale,9,1) = 'L' THEN
        nMese := 7;
     ELSIF SUBSTR(pCodFiscale,9,1) = 'M' THEN
        nMese := 8;
     ELSIF SUBSTR(pCodFiscale,9,1) = 'P' THEN
        nMese := 9;
     ELSIF SUBSTR(pCodFiscale,9,1) = 'R' THEN
        nMese := 10;
     ELSIF SUBSTR(pCodFiscale,9,1) = 'S' THEN
        nMese := 11;
     ELSIF SUBSTR(pCodFiscale,9,1) = 'T' THEN
        nMese := 12;
     END IF;
    -- Determinare il Comune di nascita
    CodComuneCodFisc:=SUBSTR(pCodFiscale,12,4);

     BEGIN
      SELECT COM.ISTAT_COMUNE
        INTO sIstatComuneNasc
        FROM COMUNE COM
       WHERE COM.CODFISC = CodComuneCodFisc;
     EXCEPTION
      WHEN NO_DATA_FOUND THEN
        sIstatComuneNasc := '';
      WHEN OTHERS THEN
         sIstatComuneNasc := '';
     END;

     pComuneNasc:=sIstatComuneNasc;

         -- 17/11/1909 --> 17/11/0209
     IF TO_NUMBER(sAnno,'99') > TO_NUMBER(TO_CHAR(SYSDATE,'yy')) AND
        TO_NUMBER(sAnno,'99') <= 99  THEN
        sAnnoFourDigit := '19' || sAnno;
     ELSE
        sAnnoFourDigit := '20' || sAnno;
     END IF;

    RETURN TO_DATE(nGiorno || '/' || nMese || '/' || sAnnoFourDigit,'dd/mm/yyyy');
  EXCEPTION
    WHEN OTHERS THEN
      RETURN NULL;
  END;


    /*********************************************************************
    Dato un record di tipo DB_INTERMEDIARIO lo inserisce sulla tabella omonima
    Tipo: procedure
    input: pRecTIntermediario
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTIntermediario (pRecTIntermediario IN DB_INTERMEDIARIO%ROWTYPE) IS

    BEGIN
        INSERT INTO DB_INTERMEDIARIO
        (
        ID_INTERMEDIARIO,
        DENOMINAZIONE,
        CODICE_FISCALE,
        INDIRIZZO,
        CAP,
        COMUNE,
        TIPO_INTERMEDIARIO,
        ID_INTERMEDIARIO_PADRE,
        LIVELLO,
        PARTITA_IVA,
        DATA_FINE_VALIDITA,
        RESPONSABILE,
        TELEFONO,
        FAX,
        EMAIL,
        PEC,
        EXT_ID_AZIENDA,
        EXT_CUAA
        )
        VALUES
        (
        pRecTIntermediario.ID_INTERMEDIARIO,
        pRecTIntermediario.DENOMINAZIONE,
        pRecTIntermediario.CODICE_FISCALE,
        pRecTIntermediario.INDIRIZZO,
        pRecTIntermediario.CAP,
        pRecTIntermediario.COMUNE,
        pRecTIntermediario.TIPO_INTERMEDIARIO,
        pRecTIntermediario.ID_INTERMEDIARIO_PADRE,
        pRecTIntermediario.LIVELLO,
        pRecTIntermediario.PARTITA_IVA,
        pRecTIntermediario.DATA_FINE_VALIDITA,
        pRecTIntermediario.RESPONSABILE,
        pRecTIntermediario.TELEFONO,
        pRecTIntermediario.FAX,
        pRecTIntermediario.EMAIL,
        pRecTIntermediario.PEC,
        pRecTIntermediario.EXT_ID_AZIENDA,
        pRecTIntermediario.EXT_CUAA
        );
    END;
    /*********************************************************************
    Dato un record di tipo DB_UFFICIO_ZONA_INTERMEDIARIO lo inserisce sulla tabella omonima
    Tipo: procedure
    input: pRecTIntermediario
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTUffZonaIntermediario (pRecUffZonaIntermediario IN DB_UFFICIO_ZONA_INTERMEDIARIO%ROWTYPE) IS

    BEGIN
        INSERT INTO DB_UFFICIO_ZONA_INTERMEDIARIO
        (
        ID_UFFICIO_ZONA_INTERMEDIARIO,
        ID_INTERMEDIARIO,
        DENOMINAZIONE,
        CODICE_AGEA,
        INDIRIZZO,
        CAP,
        COMUNE,
        RECAPITO
        )
        VALUES
        (
        pRecUffZonaIntermediario.ID_UFFICIO_ZONA_INTERMEDIARIO,
        pRecUffZonaIntermediario.ID_INTERMEDIARIO,
        pRecUffZonaIntermediario.DENOMINAZIONE,
        pRecUffZonaIntermediario.CODICE_AGEA,
        pRecUffZonaIntermediario.INDIRIZZO,
        pRecUffZonaIntermediario.CAP,
        pRecUffZonaIntermediario.COMUNE,
        pRecUffZonaIntermediario.RECAPITO
        );

    END;
     /*********************************************************************
    Dato un record di tipo DB_CONTITIOLARE lo inserisce sulla tabella omonima
    Tipo: procedure
    input: pRecTContitolare
    output: nessuno
    ritorno: nessuno
    *********************************************************************/

    PROCEDURE InsertTContitolare (pRecTContitolare IN DB_CONTITOLARE%ROWTYPE) IS
    BEGIN

        INSERT INTO DB_CONTITOLARE
            (
            ID_CONTITOLARE,
            ID_SOGGETTO,
            ID_RUOLO,
            ID_AZIENDA,
            DATA_INIZIO_RUOLO,
            DATA_FINE_RUOLO,
            FLAG_ACCESSO_FORZATO,
            DATA_INIZIO_RUOLO_MOD,
            DATA_FINE_RUOLO_MOD
            )
        VALUES
            (
            pRecTContitolare.ID_CONTITOLARE,
            pRecTContitolare.ID_SOGGETTO,
            pRecTContitolare.ID_RUOLO,
            pRecTContitolare.ID_AZIENDA,
            pRecTContitolare.DATA_INIZIO_RUOLO,
            pRecTContitolare.DATA_FINE_RUOLO,
            pRecTContitolare.FLAG_ACCESSO_FORZATO,
            pRecTContitolare.DATA_INIZIO_RUOLO_MOD,
            pRecTContitolare.DATA_FINE_RUOLO_MOD
            );
    END InsertTContitolare;
     /*********************************************************************
    Dato un record di tipo DB_SOGGETTO_ASSOCIATO lo inserisce sulla tabella omonima
    Tipo: procedure
    input: pRecTSoggAssociato
    output: nessuno
    ritorno: nessuno
    *********************************************************************/

    PROCEDURE InsertTSoggAssociato (pRecTSoggAssociato IN DB_SOGGETTO_ASSOCIATO%ROWTYPE) IS

    BEGIN
        INSERT INTO DB_SOGGETTO_ASSOCIATO
            (
            ID_SOGGETTO_ASSOCIATO,
            CUAA,
            DENOMINAZIONE,
            PARTITA_IVA,
            INDIRIZZO,
            COMUNE,
            CAP
            )
        VALUES
            (
            pRecTSoggAssociato.ID_SOGGETTO_ASSOCIATO,
            pRecTSoggAssociato.CUAA,
            pRecTSoggAssociato.DENOMINAZIONE,
            pRecTSoggAssociato.PARTITA_IVA,
            pRecTSoggAssociato.INDIRIZZO,
            pRecTSoggAssociato.COMUNE,
            pRecTSoggAssociato.CAP
            );

    END InsertTSoggAssociato;

         /*********************************************************************
    Dato un record di tipo DB_SOGGETTO_ASSOCIATO lo inserisce sulla tabella omonima
    Tipo: procedure
    input: pRecTSoggAssociato
    output: nessuno
    ritorno: nessuno
    *********************************************************************/

    PROCEDURE InsertTAziendaCollegata (pRecTAziendaCollegata IN DB_AZIENDA_COLLEGATA%ROWTYPE) IS

    BEGIN
        INSERT INTO DB_AZIENDA_COLLEGATA
            (
            ID_AZIENDA_COLLEGATA,
            ID_AZIENDA,
            ID_AZIENDA_ASSOCIATA,
            DATA_INGRESSO,
            DATA_USCITA,
            DATA_INIZIO_VALIDITA,
            DATA_FINE_VALIDITA,
            DATA_AGGIORNAMENTO,
            ID_UTENTE_AGGIORNAMENTO,
            ID_SOGGETTO_ASSOCIATO,
            CODICE_ENTE
            )
        VALUES
            (
            pRecTAziendaCollegata.ID_AZIENDA_COLLEGATA,
            pRecTAziendaCollegata.ID_AZIENDA,
            pRecTAziendaCollegata.ID_AZIENDA_ASSOCIATA,
            pRecTAziendaCollegata.DATA_INGRESSO,
            pRecTAziendaCollegata.DATA_USCITA,
            pRecTAziendaCollegata.DATA_INIZIO_VALIDITA,
            pRecTAziendaCollegata.DATA_FINE_VALIDITA,
            pRecTAziendaCollegata.DATA_AGGIORNAMENTO,
            pRecTAziendaCollegata.ID_UTENTE_AGGIORNAMENTO,
            pRecTAziendaCollegata.ID_SOGGETTO_ASSOCIATO,
            pRecTAziendaCollegata.CODICE_ENTE
            );

    END InsertTAziendaCollegata;

    /*******************************************************************************
     NAME: RibaltaTIntermediario
     PURPOSE: Verifica se una particella appartiene alla pubblica amministrazione
              verificando che nella denominazione del proprietario siano presenti
              determinate stringhe parametrizzate.
     Parametri:
            input: id richiesta azienda, richiesta di aggioanemrnto
                   pIdAzienda, id dellazienda appena creata
            Output: Prisultato a 0 se la funzione non ha generato errori
                   pMessaggio
            Valore di ritorno: il record DB_intermediario carico in tabella
     
     *******************************************************************************/
    FUNCTION RibaltaTIntermediario (pIdRichAzienda      IN DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                                     pIdAzienda          IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                     pRisultato         OUT VARCHAR2,
                                     pMessaggio         OUT VARCHAR2
                                      ) RETURN DB_INTERMEDIARIO%ROWTYPE IS
     nEsisteIntermediario     NUMBER(1);
     RecIntermediario         DB_INTERMEDIARIO%ROWTYPE;
     recTWAziendaNuova        SMRGAA_W_AZIENDA_NUOVA%ROWTYPE;
     RecUffZonaIntermediario  DB_UFFICIO_ZONA_INTERMEDIARIO%ROWTYPE;
     vCodiceEnte              SMRGAA_W_AZIENDA_NUOVA.CODICE_ENTE%TYPE;
     nIdAziendaNuova          SMRGAA_W_AZIENDA_NUOVA.ID_AZIENDA_NUOVA%TYPE;
     NoCodiceEnte             EXCEPTION;
     ErroreAggiornamento      EXCEPTION;

    BEGIN
        BEGIN
        SELECT WAN.*
          INTO recTWAziendaNuova
          FROM DB_RICHIESTA_AZIENDA DRA,
               SMRGAA_W_AZIENDA_NUOVA WAN
         WHERE DRA.ID_RICHIESTA_AZIENDA = pIdRichAzienda
           AND DRA.ID_AZIENDA_NUOVA = WAN.ID_AZIENDA_NUOVA
           AND WAN.CODICE_ENTE IS NOT NULL;

        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                RAISE NoCodiceEnte;
        END;
         ---prima verifico se l'azienda è già presente come intermediario
     SELECT COUNT(*)
       INTO nEsisteIntermediario
       FROM DB_INTERMEDIARIO DBI
      WHERE DBI.DATA_FINE_VALIDITA IS NULL
        AND DBI.CODICE_FISCALE=recTWAziendaNuova.CODICE_ENTE;

        IF nEsisteIntermediario>0 THEN
         --Aggiorno DB_INTERMEDIARIO campo EXT_ID_AZIENDA all'ID_AZIENDA nuovo

            BEGIN
                UPDATE DB_INTERMEDIARIO DBI
                   SET DBI.EXT_ID_AZIENDA=pIdAzienda,
                       DBI.EXT_CUAA      =recTWAziendaNuova.CUAA
                 WHERE DBI.CODICE_FISCALE=recTWAziendaNuova.CODICE_ENTE
                   AND DBI.DATA_FINE_VALIDITA IS NULL;
            EXCEPTION
                WHEN OTHERS THEN
                pMessaggio:='RibaltaTIntermediario : ' || SUBSTR(SQLERRM,1,150);
                RAISE ErroreAggiornamento;
            END;

        ELSE
         ---Carico un nuovo record per DB_INTERMEDIARIO
        RecIntermediario.DENOMINAZIONE         :=recTWAziendaNuova.DENOMINAZIONE;
        RecIntermediario.CODICE_FISCALE        :=recTWAziendaNuova.CODICE_ENTE;
        RecIntermediario.INDIRIZZO             :=recTWAziendaNuova.RES_INDIRIZZO;
        RecIntermediario.COMUNE                :=recTWAziendaNuova.RES_COMUNE;
        RecIntermediario.CAP                   :=recTWAziendaNuova.RES_CAP;
        RecIntermediario.TIPO_INTERMEDIARIO    :=kvCodTipoIntermediario;

            IF SUBSTR(recTWAziendaNuova.CODICE_ENTE, -6 ) ='000000' THEN

                RecIntermediario.ID_INTERMEDIARIO_PADRE:=NULL;
                RecIntermediario.LIVELLO               :='R';

            ELSIF SUBSTR(recTWAziendaNuova.CODICE_ENTE, -3 ) ='000' THEN

                RecIntermediario.LIVELLO :='P';

                BEGIN

                SELECT ID_INTERMEDIARIO
                  INTO RecIntermediario.ID_INTERMEDIARIO_PADRE
                  FROM DB_INTERMEDIARIO
                 WHERE CODICE_FISCALE=SUBSTR(recTWAziendaNuova.CODICE_ENTE,1,3)||'000000';

                EXCEPTION
                    WHEN NO_DATA_FOUND THEN
                        pMessaggio:='RibaltaTIntermediario : ' || SUBSTR(SQLERRM,1,150);
                        RAISE ErroreAggiornamento;
                END;
            ELSE
                RecIntermediario.LIVELLO :='Z';
                BEGIN

                SELECT ID_INTERMEDIARIO
                  INTO RecIntermediario.ID_INTERMEDIARIO_PADRE
                  FROM DB_INTERMEDIARIO
                 WHERE CODICE_FISCALE=SUBSTR(recTWAziendaNuova.CODICE_ENTE,1,6)||'000';

                EXCEPTION
                    WHEN NO_DATA_FOUND THEN
                        pMessaggio:='RibaltaTIntermediario : ' || SUBSTR(SQLERRM,1,150);
                        RAISE ErroreAggiornamento;
                END;


            END IF;

            RecIntermediario.PARTITA_IVA           :=recTWAziendaNuova.PARTITA_IVA;
            RecIntermediario.DATA_FINE_VALIDITA    :=NULL;
            RecIntermediario.RESPONSABILE          :=TRIM(recTWAziendaNuova.COGNOME)||' '||TRIM(recTWAziendaNuova.NOME);
            RecIntermediario.TELEFONO              :=recTWAziendaNuova.TELEFONO;
            RecIntermediario.FAX                   :=recTWAziendaNuova.FAX;
            RecIntermediario.EMAIL                 :=recTWAziendaNuova.MAIL;
            RecIntermediario.PEC                   :=recTWAziendaNuova.PEC;
            RecIntermediario.EXT_ID_AZIENDA        :=pIdAzienda;
            RecIntermediario.EXT_CUAA              :=recTWAziendaNuova.CUAA;
                 ---stacco la sequences

            SELECT SEQ_INTERMEDIARIO.NEXTVAL
            INTO RecIntermediario.ID_INTERMEDIARIO
            FROM DUAL;

            InsertTIntermediario(RecIntermediario);

         --intermediario tipo z
            IF  RecIntermediario.LIVELLO='Z' THEN
                --Carico un record in DB_UFFICIO_ZONA_INTEREMEDIARIO
                RecUffZonaIntermediario.ID_INTERMEDIARIO   :=RecIntermediario.ID_INTERMEDIARIO;
                RecUffZonaIntermediario.DENOMINAZIONE      :=recTWAziendaNuova.DENOMINAZIONE;
                RecUffZonaIntermediario.CODICE_AGEA        :=recTWAziendaNuova.CODICE_ENTE;
                RecUffZonaIntermediario.INDIRIZZO          :=recTWAziendaNuova.RES_INDIRIZZO;
                RecUffZonaIntermediario.CAP                :=recTWAziendaNuova.RES_CAP;
                RecUffZonaIntermediario.COMUNE             :=recTWAziendaNuova.RES_COMUNE;
                RecUffZonaIntermediario.RECAPITO           :=recTWAziendaNuova.TELEFONO||' '||recTWAziendaNuova.MAIL;

                SELECT SEQ_UFFICIO_ZONA_INTERMEDIARIO.NEXTVAL
                  INTO RecUffZonaIntermediario.ID_UFFICIO_ZONA_INTERMEDIARIO
                FROM DUAL;
                InsertTUffZonaIntermediario(RecUffZonaIntermediario);
            END IF;
        END IF;

        RETURN RecIntermediario;

    EXCEPTION
        WHEN NoCodiceEnte THEN
        --ESCO DALLA PROCEDURA SENZA ERRORI
            pRisultato:='0';
            pMessaggio:='';
            RETURN RecIntermediario;
        WHEN ErroreAggiornamento THEN
            pRisultato:='0';
            RETURN RecIntermediario;
        WHEN OTHERS THEN
            pRisultato:='0';
            pMessaggio:='RibaltaTIntermediario : ' || SUBSTR(SQLERRM,1,150);
            RETURN RecIntermediario;
    END;

    PROCEDURE RibaltaSoggCollegati (pIdRichAzienda      IN DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                                   pIdAzienda          IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                   pRisultato         OUT VARCHAR2,
                                   pMessaggio         OUT VARCHAR2
                                   ) IS

        recTPersonaFisica           DB_PERSONA_FISICA%ROWTYPE;
        recTPersonaFisicaGiaPres    DB_PERSONA_FISICA%ROWTYPE;
        bNewPersona                 BOOLEAN:=TRUE;
        recTSoggetto                DB_SOGGETTO%ROWTYPE;
        recTContitolare             DB_CONTITOLARE%ROWTYPE;

   CURSOR CurPersFisicheMancanti IS
        SELECT SAN.CODICE_FISCALE,
               SAN.COGNOME,
               SAN.NOME,
               SAN.COMUNE_RESIDENZA,
               SAN.INDIRIZZO_RESIDENZA,
               SAN.CAP_RESIDENZA,
               SAN.TELEFONO,
               SAN.EMAIL,
               SAN.FAX,
               SAN.ID_RUOLO,
               SAN.DATA_INIZIO_RUOLO,
               RA.ID_UTENTE_AGGIORNAMENTO
          FROM DB_RICHIESTA_AZIENDA RA,
               SMRGAA_W_SOGGETTI_AZ_NUOVA SAN
         WHERE RA.ID_RICHIESTA_AZIENDA = pIdRichAzienda
           AND RA.ID_AZIENDA_NUOVA = SAN.ID_AZIENDA_NUOVA
           AND SAN.FLAG_ELIMINATO='N'
           AND SAN.ID_RUOLO != 1;  

    BEGIN
--  Leggo il cursore delle presone fisiche da inserire in DB_PERSONA_FISICA se non gia' presenti
        FOR RecPerFisicheMancanti IN CurPersFisicheMancanti LOOP

            recTPersonaFisica.CODICE_FISCALE            :=RecPerFisicheMancanti.CODICE_FISCALE;
            recTPersonaFisica.COGNOME                   :=RecPerFisicheMancanti.COGNOME;
            recTPersonaFisica.NOME                      :=RecPerFisicheMancanti.NOME;
            --Ricavo le informazioni dal codiice fiscali per i dati anagrafici
            recTPersonaFisica.NASCITA_DATA:=FncInfoDaCodFiscale(recTPersonaFisica.CODICE_FISCALE,
                                                            recTPersonaFisica.SESSO,
                                                            recTPersonaFisica.NASCITA_COMUNE
                                                            );
            recTPersonaFisica.RES_COMUNE                :=RecPerFisicheMancanti.COMUNE_RESIDENZA;
            recTPersonaFisica.RES_INDIRIZZO             :=RecPerFisicheMancanti.INDIRIZZO_RESIDENZA;
            recTPersonaFisica.RES_CAP                   :=RecPerFisicheMancanti.CAP_RESIDENZA;
            recTPersonaFisica.RES_TELEFONO              :=RecPerFisicheMancanti.TELEFONO;
            recTPersonaFisica.RES_FAX                   :=RecPerFisicheMancanti.FAX;
            recTPersonaFisica.RES_MAIL                  :=RecPerFisicheMancanti.EMAIL;
            recTPersonaFisica.DATA_AGGIORNAMENTO        :=SYSDATE;
            recTPersonaFisica.NOTE                      :=NULL;
            recTPersonaFisica.ID_UTENTE_AGGIORNAMENTO   :=RecPerFisicheMancanti.ID_UTENTE_AGGIORNAMENTO;

               -- in quel caso contiene gli ID_SOGGETTO che avevano un ruolo sull'azienda
               -- e posso cercare la persona fisica per ID_SOGGETTO e CF
            BEGIN
                 SELECT *
                   INTO recTPersonaFisicaGiaPres
                   FROM DB_PERSONA_FISICA
                   WHERE CODICE_FISCALE = recTPersonaFisica.CODICE_FISCALE;
            EXCEPTION
              WHEN NO_DATA_FOUND THEN
                 recTPersonaFisicaGiaPres := NULL;
            END;

            IF recTPersonaFisicaGiaPres.ID_PERSONA_FISICA IS NOT NULL THEN
               bNewPersona := FALSE;
               recTPersonaFisica := recTPersonaFisicaGiaPres;
               pMessaggio := 'Persona fisica gia'' esistente';
            END IF;

            IF bNewPersona THEN
               SELECT SEQ_SOGGETTO.nextval
                 INTO recTSoggetto.ID_SOGGETTO
                 FROM DUAL;

               recTSoggetto.Flag_Fisico := 'S';
               InsertTSoggetto(recTSoggetto);

               SELECT SEQ_PERSONA_FISICA.nextval
                 INTO recTPersonaFisica.ID_PERSONA_FISICA
                 FROM DUAL;

               recTPersonaFisica.ID_SOGGETTO := recTSoggetto.ID_SOGGETTO;
               recTPersonaFisica.DATA_INIZIO_RESIDENZA := NULL;
               recTPersonaFisica.FLAG_CF_OK := NULL;
               InsertTPersonaFisica (recTPersonaFisica);

            END IF;
            ---AGGIUNGO UN NUOVO RECORD IN DB_CONTITOLARE

           recTContitolare.ID_SOGGETTO          :=recTPersonaFisica.ID_SOGGETTO;
           recTContitolare.ID_RUOLO             :=RecPerFisicheMancanti.ID_RUOLO;
           recTContitolare.ID_AZIENDA           :=pIdAzienda;
           recTContitolare.DATA_INIZIO_RUOLO    :=SYSDATE;
           recTContitolare.DATA_FINE_RUOLO      :=NULL;
           recTContitolare.FLAG_ACCESSO_FORZATO :=NULL;
           recTContitolare.DATA_INIZIO_RUOLO_MOD:=RecPerFisicheMancanti.DATA_INIZIO_RUOLO;
           recTContitolare.DATA_FINE_RUOLO_MOD  :=NULL;

           SELECT SEQ_CONTITOLARE.NEXTVAL
             INTO recTContitolare.ID_CONTITOLARE
             FROM DUAL;

           InsertTContitolare(recTContitolare);

        END LOOP;
        pRisultato := '0';

    EXCEPTION
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'RibaltaSoggCollegati : ' || SUBSTR(SQLERRM,1,150);
    END RibaltaSoggCollegati;

    PROCEDURE RibaltaAziendeAssociate  (pIdRichAzienda      IN DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                                   pIdAzienda          IN DB_AZIENDA.ID_AZIENDA%TYPE,
                                   pRisultato         OUT VARCHAR2,
                                   pMessaggio         OUT VARCHAR2
                                   ) IS


    RecWSoggAssAzNuova     SMRGAA_W_SOGG_ASS_AZ_NUOVA%ROWTYPE;
    RecTSoggettoAssociato  DB_SOGGETTO_ASSOCIATO%ROWTYPE;
    RecTAziendaCollegata   DB_AZIENDA_COLLEGATA%ROWTYPE;
    RecTIntermediario      DB_INTERMEDIARIO%ROWTYPE;

CURSOR CurAziendeAssociate IS
    SELECT WAAN.*,
           DRA.ID_UTENTE_AGGIORNAMENTO
      FROM SMRGAA_W_ASSOCIATE_AZ_NUOVE WAAN,
           SMRGAA_W_AZIENDA_NUOVA WAN,
           DB_RICHIESTA_AZIENDA   DRA
    WHERE  WAN.ID_AZIENDA_NUOVA=WAAN.ID_AZIENDA_NUOVA
      AND  DRA.ID_AZIENDA_NUOVA=WAN.ID_AZIENDA_NUOVA
      AND  DRA.ID_RICHIESTA_AZIENDA=pIdRichAzienda;

BEGIN
    FOR  RecAziendeAssociate IN CurAziendeAssociate LOOP
        RecTSoggettoAssociato:=NULL;
        IF RecAziendeAssociate.ID_SOGG_ASS_AZ_NUOVA IS NOT NULL THEN
            BEGIN
              SELECT *
                INTO RecWSoggAssAzNuova
                FROM SMRGAA_W_SOGG_ASS_AZ_NUOVA WSAAN
               WHERE WSAAN.ID_SOGG_ASS_AZ_NUOVA =RecAziendeAssociate.ID_SOGG_ASS_AZ_NUOVA;
            END;

            RecTSoggettoAssociato.CUAA                  :=RecWSoggAssAzNuova.CUAA;
            RecTSoggettoAssociato.DENOMINAZIONE         :=RecWSoggAssAzNuova.DENOMINAZIONE;
            RecTSoggettoAssociato.PARTITA_IVA           :=RecWSoggAssAzNuova.PARTITA_IVA;
            RecTSoggettoAssociato.INDIRIZZO             :=RecWSoggAssAzNuova.INDIRIZZO;
            RecTSoggettoAssociato.COMUNE                :=RecWSoggAssAzNuova.COMUNE;
            RecTSoggettoAssociato.CAP                   :=RecWSoggAssAzNuova.CAP;

            SELECT SEQ_SOGGETTO_ASSOCIATO.NEXTVAL
              INTO RecTSoggettoAssociato.ID_SOGGETTO_ASSOCIATO
              FROM DUAL;

            InsertTSoggAssociato(RecTSoggettoAssociato);

        END IF;

        IF RecAziendeAssociate.CODICE_ENTE  IS NOT NULL THEN
            RecTSoggettoAssociato:=NULL;
            BEGIN

              SELECT *
                INTO RecTIntermediario
                FROM DB_INTERMEDIARIO DI
               WHERE DI.DATA_FINE_VALIDITA IS NULL
                  AND DI.CODICE_FISCALE = RecAziendeAssociate.CODICE_ENTE;

            END;

            RecTSoggettoAssociato.CUAA                  :=RecTIntermediario.CODICE_FISCALE;
            RecTSoggettoAssociato.DENOMINAZIONE         :=RecTIntermediario.DENOMINAZIONE;
            RecTSoggettoAssociato.PARTITA_IVA           :=RecTIntermediario.PARTITA_IVA;
            RecTSoggettoAssociato.INDIRIZZO             :=RecTIntermediario.INDIRIZZO;
            RecTSoggettoAssociato.COMUNE                :=RecTIntermediario.COMUNE;
            RecTSoggettoAssociato.CAP                   :=RecTIntermediario.CAP;

            SELECT SEQ_SOGGETTO_ASSOCIATO.NEXTVAL
              INTO RecTSoggettoAssociato.ID_SOGGETTO_ASSOCIATO
              FROM DUAL;

            InsertTSoggAssociato(RecTSoggettoAssociato);
        END IF;

    --Inserisco il record in DB_AZIENDA_COLLEGATA
    RecTAziendaCollegata.ID_AZIENDA             :=pIdAzienda;
    RecTAziendaCollegata.ID_AZIENDA_ASSOCIATA   :=RecAziendeAssociate.ID_AZIENDA_ASSOCIATA;
    RecTAziendaCollegata.DATA_INGRESSO          :=RecAziendeAssociate.DATA_INGRESSO;
    RecTAziendaCollegata.DATA_USCITA            :=NULL;
    RecTAziendaCollegata.DATA_INIZIO_VALIDITA   :=SYSDATE;
    RecTAziendaCollegata.DATA_FINE_VALIDITA     :=NULL;
    RecTAziendaCollegata.DATA_AGGIORNAMENTO     :=SYSDATE;
    RecTAziendaCollegata.ID_UTENTE_AGGIORNAMENTO:=RecAziendeAssociate.ID_UTENTE_AGGIORNAMENTO;
    RecTAziendaCollegata.ID_SOGGETTO_ASSOCIATO  :=RecTSoggettoAssociato.ID_SOGGETTO_ASSOCIATO;
    RecTAziendaCollegata.CODICE_ENTE            :=RecAziendeAssociate.CODICE_ENTE;

    SELECT SEQ_DB_AZIENDA_COLLEGATA.NEXTVAL
    INTO RecTAziendaCollegata.ID_AZIENDA_COLLEGATA
    FROM DUAL;

    InsertTAziendaCollegata(RecTAziendaCollegata);

    END LOOP;

    pRisultato := '0';
    pMessaggio := NULL;

EXCEPTION
    WHEN OTHERS THEN
          --recTPersonaFisica.ID_PERSONA_FISICA := -1;
      pRisultato := '1';
      pMessaggio := 'RibaltaAziendeAssociate : ' || SUBSTR(SQLERRM,1,150);

END RibaltaAziendeAssociate;

PROCEDURE RibaltaBarre(pIdRichAzienda      DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                       pRisultato      OUT VARCHAR2,
                       pMessaggio      OUT VARCHAR2) IS

  nIdAzienda  DB_RICHIESTA_AZIENDA.ID_AZIENDA%TYPE;
BEGIN
  pRisultato := '0';
  pMessaggio := NULL;

  SELECT ID_AZIENDA
  INTO   nIdAzienda
  FROM   DB_RICHIESTA_AZIENDA
  WHERE  ID_RICHIESTA_AZIENDA = pIdRichAzienda;

  FOR recMacch IN (SELECT *
                   FROM   DB_MACCHINE_AZ_NUOVA MAN
                   WHERE  MAN.ID_RICHIESTA_AZIENDA = pIdRichAzienda) LOOP

    IF recMacch.ID_MACCHINA IS NULL THEN
      UPDATE DB_POSSESSO_MACCHINA
      SET    FLAG_VALIDA = 'S'
      WHERE  ID_UTE      IN (SELECT ID_UTE FROM DB_UTE WHERE ID_AZIENDA = nIdAzienda)
      AND    ID_MACCHINA = recMacch.ID_MACCHINA_NUOVA;
    END IF;

    IF recMacch.ID_MACCHINA IS NOT NULL AND recMacch.DATA_SCARICO IS NOT NULL THEN
      UPDATE DB_POSSESSO_MACCHINA
      SET    DATA_SCARICO = recMacch.DATA_SCARICO
      WHERE  ID_UTE       IN (SELECT ID_UTE FROM DB_UTE WHERE ID_AZIENDA = nIdAzienda)
      AND    ID_MACCHINA  = recMacch.ID_MACCHINA;
    END IF;
  END LOOP;

EXCEPTION
  WHEN OTHERS THEN
    pRisultato := '1';
    pMessaggio := 'RibaltaBarre : ' || SUBSTR(SQLERRM,1,150);
END RibaltaBarre;

PROCEDURE AziendeAssociate(pIdRichAzienda      DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                           pRisultato      OUT VARCHAR2,
                           pMessaggio      OUT VARCHAR2) IS

  TYPE tblWAssAzNuove IS TABLE OF SMRGAA_W_ASSOCIATE_AZ_NUOVE%ROWTYPE INDEX BY BINARY_INTEGER;

  nIdAzienda              DB_RICHIESTA_AZIENDA.ID_AZIENDA%TYPE;
  WAssAzNuove             tblWAssAzNuove;
  nCont                   SIMPLE_INTEGER := 0;
  nIdUtenteAggiornamento  DB_RICHIESTA_AZIENDA.ID_UTENTE_AGGIORNAMENTO%TYPE;
  nIdSoggettoAssociato    DB_SOGGETTO_ASSOCIATO.ID_SOGGETTO_ASSOCIATO%TYPE;
BEGIN
  pRisultato := '0';
  pMessaggio := NULL;

  SELECT ID_AZIENDA,ID_UTENTE_AGGIORNAMENTO
  INTO   nIdAzienda,nIdUtenteAggiornamento
  FROM   DB_RICHIESTA_AZIENDA
  WHERE  ID_RICHIESTA_AZIENDA = pIdRichAzienda;

  SELECT *
  BULK COLLECT INTO WAssAzNuove
  FROM   SMRGAA_W_ASSOCIATE_AZ_NUOVE
  WHERE  ID_RICHIESTA_AZIENDA = pIdRichAzienda;

  FOR i IN 1..WAssAzNuove.COUNT LOOP

    IF WAssAzNuove(i).ID_AZIENDA_COLLEGATA IS NOT NULL AND WAssAzNuove(i).DATA_USCITA IS NOT NULL THEN
      UPDATE DB_AZIENDA_COLLEGATA
      SET    DATA_FINE_VALIDITA   = SYSDATE
      WHERE  ID_AZIENDA_COLLEGATA = WAssAzNuove(i).ID_AZIENDA_COLLEGATA;

      INSERT INTO DB_AZIENDA_COLLEGATA
      (ID_AZIENDA_COLLEGATA, ID_AZIENDA, ID_AZIENDA_ASSOCIATA, DATA_INGRESSO, DATA_USCITA,
       DATA_INIZIO_VALIDITA,DATA_AGGIORNAMENTO,ID_UTENTE_AGGIORNAMENTO,ID_SOGGETTO_ASSOCIATO, CODICE_ENTE)
      (SELECT SEQ_DB_AZIENDA_COLLEGATA.NEXTVAL,ID_AZIENDA, ID_AZIENDA_ASSOCIATA, DATA_INGRESSO,WAssAzNuove(i).DATA_USCITA,
              SYSDATE,SYSDATE,nIdUtenteAggiornamento, ID_SOGGETTO_ASSOCIATO, CODICE_ENTE
       FROM   DB_AZIENDA_COLLEGATA
       WHERE  ID_AZIENDA_COLLEGATA = WAssAzNuove(i).ID_AZIENDA_COLLEGATA);
    END IF;

    IF WAssAzNuove(i).ID_AZIENDA_COLLEGATA IS NOT NULL AND WAssAzNuove(i).FLAG_ELIMINATO = 'S' THEN
      UPDATE DB_AZIENDA_COLLEGATA
      SET    DATA_FINE_VALIDITA   = SYSDATE,
             DATA_USCITA          = SYSDATE
      WHERE  ID_AZIENDA_COLLEGATA = WAssAzNuove(i).ID_AZIENDA_COLLEGATA;

      SELECT COUNT(*)
      INTO   nCont
      FROM   DB_AZIENDA_COLLEGATA
      WHERE  ID_AZIENDA_COLLEGATA = WAssAzNuove(i).ID_AZIENDA_COLLEGATA
      AND    NOT EXISTS           (SELECT 'X'
                                   FROM   DB_DICHIARAZIONE_CONSISTENZA
                                   WHERE  ID_AZIENDA                     = nIdAzienda
                                   AND    DATA_INSERIMENTO_DICHIARAZIONE > DATA_INIZIO_VALIDITA);

      IF nCont != 0 THEN
        DELETE SMRGAA_W_ASSOCIATE_AZ_NUOVE
        WHERE  ID_ASSOCIATE_AZ_NUOVE = WAssAzNuove(i).ID_ASSOCIATE_AZ_NUOVE;

        DELETE DB_AZIENDA_COLLEGATA
        WHERE  ID_AZIENDA_COLLEGATA = WAssAzNuove(i).ID_AZIENDA_COLLEGATA
        AND    NOT EXISTS           (SELECT 'X'
                                     FROM   DB_DICHIARAZIONE_CONSISTENZA
                                     WHERE  ID_AZIENDA                     = nIdAzienda
                                     AND    DATA_INSERIMENTO_DICHIARAZIONE > DATA_INIZIO_VALIDITA);
      END IF;
    END IF;

    IF WAssAzNuove(i).ID_AZIENDA_COLLEGATA IS NULL THEN
      nIdSoggettoAssociato := NULL;
      IF WAssAzNuove(i).ID_SOGG_ASS_AZ_NUOVA IS NOT NULL THEN
        nIdSoggettoAssociato := SEQ_SOGGETTO_ASSOCIATO.NEXTVAL;

        INSERT INTO DB_SOGGETTO_ASSOCIATO
        (ID_SOGGETTO_ASSOCIATO, CUAA, DENOMINAZIONE, PARTITA_IVA, INDIRIZZO, COMUNE,
         CAP)
        (SELECT nIdSoggettoAssociato,CUAA,DENOMINAZIONE,PARTITA_IVA,INDIRIZZO,COMUNE,CAP
         FROM   SMRGAA_W_SOGG_ASS_AZ_NUOVA
         WHERE  ID_SOGG_ASS_AZ_NUOVA = WAssAzNuove(i).ID_SOGG_ASS_AZ_NUOVA);
      END IF;

      INSERT INTO DB_AZIENDA_COLLEGATA
      (ID_AZIENDA_COLLEGATA, ID_AZIENDA, ID_AZIENDA_ASSOCIATA, DATA_INGRESSO, DATA_USCITA, DATA_INIZIO_VALIDITA,
       DATA_FINE_VALIDITA, DATA_AGGIORNAMENTO, ID_UTENTE_AGGIORNAMENTO, ID_SOGGETTO_ASSOCIATO, CODICE_ENTE)
      VALUES
      (SEQ_DB_AZIENDA_COLLEGATA.NEXTVAL,nIdAzienda,WAssAzNuove(i).ID_AZIENDA_ASSOCIATA,
       WAssAzNuove(i).DATA_INGRESSO, NULL, SYSDATE,
       NULL, SYSDATE, nIdUtenteAggiornamento, nIdSoggettoAssociato, WAssAzNuove(i).CODICE_ENTE);
    END IF;
  END LOOP;
EXCEPTION
  WHEN OTHERS THEN
    pRisultato := '1';
    pMessaggio := 'AziendeAssociate : ' || SUBSTR(SQLERRM,1,150);
END AziendeAssociate;

    /*********************************************************************
    Effettua il ribaltamento dei dati dell'azienda in proprio provvisori
    sulle tabelle effettive
    Tipo: Procedure
    input: pIdRichAzienda
    output: pRisultato, pMessaggio
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE Ribalta_Azienda (pIdRichAzienda    IN DB_RICHIESTA_AZIENDA.ID_RICHIESTA_AZIENDA%TYPE,
                               pRisultato       OUT VARCHAR2,
                               pMessaggio       OUT VARCHAR2
                               ) IS
        NO_PAR_RICHIESTA        EXCEPTION;
        NO_RICHIESTA            EXCEPTION;
        STATO_RICHIESTA_ERRATO  EXCEPTION;
        AZIENDA_ESISTENTE       EXCEPTION;
        AZIENDA_NON_ESISTENTE   EXCEPTION;
        ERR_RIBALTA             EXCEPTION;
        recTRichAzienda         DB_RICHIESTA_AZIENDA%ROWTYPE;
        recTIterRichAzienda     DB_ITER_RICHIESTA_AZIENDA%ROWTYPE;
        recTAzienda             DB_AZIENDA%ROWTYPE;
        recTAnagrAz             DB_ANAGRAFICA_AZIENDA%ROWTYPE;
        recTIntermediario       DB_INTERMEDIARIO%ROWTYPE;  
        nCntrolPresAzienda      NUMBER(1)   :=0;           
        recTPersFisica          DB_PERSONA_FISICA%ROWTYPE;
        recTContitolare         DB_CONTITOLARE%ROWTYPE;
        nIdAzienda              DB_ANAGRAFICA_AZIENDA.ID_AZIENDA%TYPE;
        VetSoggetto             Num_Varray := Num_Varray ();
        vCodiceRichiesta        DB_TIPO_RICHIESTA.CODICE_RICHIESTA%TYPE;

    BEGIN
        -- controllo che il parametro ID_RICHIESTA_AZIENDA
        -- sia valorizzato
        IF pIdRichAzienda IS NULL THEN
           -- altrimenti esco immediatamente
           RAISE NO_PAR_RICHIESTA;
        ELSE
           SELECT TR.CODICE_RICHIESTA
           INTO   vCodiceRichiesta
           FROM   DB_RICHIESTA_AZIENDA RA,DB_TIPO_RICHIESTA TR
           WHERE  RA.ID_RICHIESTA_AZIENDA = pIdRichAzienda
           AND    RA.ID_TIPO_RICHIESTA    = TR.ID_TIPO_RICHIESTA;

           IF vCodiceRichiesta = 'VAR_AA' THEN
             AziendeAssociate(pIdRichAzienda,
                              pRisultato,
                              pMessaggio);

             IF pRisultato <> '0' THEN
               RAISE ERR_RIBALTA;
             END IF;

             -- infine possono chiudere l'iter richiesta azienda
             -- trasmessa
             recTRichAzienda := SelTRichAziendaWithLastIter (pIdRichAzienda, recTIterRichAzienda);
             ChiudiIterRichiesta(recTIterRichAzienda);

             -- ed inserire il nuovo iter validata da PA
             SELECT SEQ_DB_ITER_RICHIESTA_AZIENDA.nextval
             INTO recTIterRichAzienda.ID_ITER_RICHIESTA_AZIENDA
             FROM DUAL;

             recTIterRichAzienda.ID_STATO_RICHIESTA      := knIdStatoRichAziendaValPa;
             recTIterRichAzienda.DATA_INIZIO_VALIDITA    := SYSDATE;
             recTIterRichAzienda.ID_UTENTE_AGGIORNAMENTO := recTRichAzienda.ID_UTENTE_AGGIORNAMENTO;
             recTIterRichAzienda.DATA_AGGIORNAMENTO      := SYSDATE;
             InsertTIterRichiestaAzienda (recTIterRichAzienda);
           END IF;

           IF vCodiceRichiesta = 'VAR_IR' THEN
             RibaltaBarre(pIdRichAzienda,
                          pRisultato,
                          pMessaggio);

             IF pRisultato <> '0' THEN
               RAISE ERR_RIBALTA;
             END IF;

             -- infine possono chiudere l'iter richiesta azienda
             -- trasmessa
             recTRichAzienda := SelTRichAziendaWithLastIter (pIdRichAzienda, recTIterRichAzienda);
             ChiudiIterRichiesta(recTIterRichAzienda);

             -- ed inserire il nuovo iter validata da PA
             SELECT SEQ_DB_ITER_RICHIESTA_AZIENDA.nextval
             INTO recTIterRichAzienda.ID_ITER_RICHIESTA_AZIENDA
             FROM DUAL;

             recTIterRichAzienda.ID_STATO_RICHIESTA      := knIdStatoRichAziendaValPa;
             recTIterRichAzienda.DATA_INIZIO_VALIDITA    := SYSDATE;
             recTIterRichAzienda.ID_UTENTE_AGGIORNAMENTO := recTRichAzienda.ID_UTENTE_AGGIORNAMENTO;
             recTIterRichAzienda.DATA_AGGIORNAMENTO      := SYSDATE;
             InsertTIterRichiestaAzienda (recTIterRichAzienda);


           END IF;

           IF vCodiceRichiesta in ('ISCR','AGG_AZ') THEN
           -- se e' valorizzato controllo se la richiesta esiste in tabelle
           -- e mi prelevo l'eventuale iter attivo
           recTRichAzienda := SelTRichAziendaWithLastIter (pIdRichAzienda, recTIterRichAzienda);
           -- se esiste
           IF recTRichAzienda.ID_RICHIESTA_AZIENDA IS NOT NULL THEN
              -- controllo se l'iter e' quello previsto dal ribaltamento
              IF NVL(recTIterRichAzienda.ID_STATO_RICHIESTA,-1) <> knIdStatoRichAziendaTrasmessa THEN
                 -- se non lo e' do apposita anomalia
                 RAISE STATO_RICHIESTA_ERRATO;
              ELSE
               SELECT COUNT(*)
                 INTO nCntrolPresAzienda
                 FROM SMRGAA_W_AZIENDA_NUOVA SWAN,
                      DB_TIPO_TIPOLOGIA_AZIENDA  DTTA
                WHERE SWAN.ID_TIPOLOGIA_AZIENDA=DTTA.ID_TIPOLOGIA_AZIENDA
                  AND SWAN.ID_AZIENDA_NUOVA    =recTRichAzienda.ID_AZIENDA_NUOVA
                  AND SWAN.CODICE_ENTE IS NULL
                  AND DTTA.FLAG_CONTROLLI_UNIVOCITA='S';

                 --MC se nCntrolPresAzienda è maggiore di uno controllo la presenza azienda
                 IF nCntrolPresAzienda > 0  THEN
                     -- se lo e' controllo se per caso l'azienda e' gia' presente
                     -- ed attiva su DB_ANAGRAFICA_AZIENDA (controllo per CUAA, TIPOLOGIA e FORMA GIURIDICA)
                     IF AziendaGiaPresente (pIdRichAzienda, nIdAzienda) THEN
                        -- se ' gia' attiva posso operare solo se la tipologia di richiesta e' quella di aggiornamento azienda obsoleta
                        IF recTRichAzienda.ID_TIPO_RICHIESTA = knIdTipoRichiestaAggAzObsoleta THEN
                           -- in quel caso devo aver identificato una sola azienda
                           IF nIdAzienda = -1 THEN
                              pRisultato := '1';
                              pMessaggio := 'Impossibile identificare univocamente un''azienda per il CUAA';
                              RAISE ERR_RIBALTA;
                           END IF;
                           -- chiudo tutte le ute attive e le relative tabelle figlie
                           ChiudiAllUteAttiveForAzienda (nIdAzienda, recTRichAzienda.ID_UTENTE_AGGIORNAMENTO, pRisultato , pMessaggio);
                           IF pRisultato <> '0' THEN
                              RAISE ERR_RIBALTA;
                           END IF;
                           -- chiudo tutti i cc attivi
                           ChiudiAllCCAttiviForAzienda (nIdAzienda, recTRichAzienda.ID_UTENTE_AGGIORNAMENTO,pRisultato , pMessaggio);
                           IF pRisultato <> '0' THEN
                              RAISE ERR_RIBALTA;
                           END IF;
                           -- e tutte le deleghe attive
                           ChiudiAllDelegheForAzienda (nIdAzienda, recTIterRichAzienda, pRisultato , pMessaggio);
                           IF pRisultato <> '0' THEN
                              RAISE ERR_RIBALTA;
                           END IF;
                           -- ed anche l'anagrafica azienda attiva
                           ChiudiAnagraficaAzienda (nIdAzienda, recTRichAzienda.ID_UTENTE_AGGIORNAMENTO, pRisultato , pMessaggio);
                           IF pRisultato <> '0' THEN
                              RAISE ERR_RIBALTA;
                           END IF;

                           -- ed anche tutte le u.v. attive
                           ChiudiUvAttive (nIdAzienda, recTRichAzienda.ID_UTENTE_AGGIORNAMENTO, pRisultato , pMessaggio);
                           IF pRisultato <> '0' THEN
                              RAISE ERR_RIBALTA;
                           END IF;

                           UPDATE DB_AZIENDA
                              SET FASCICOLO_DEMATERIALIZZATO = 'S'
                            WHERE ID_AZIENDA = nIdAzienda;

                        ELSE
                           -- se ho trovato l'azienda attiva e non sono in tipologia richiesta aggiornamento
                           -- aziende obsolete do anomalia
                           RAISE AZIENDA_ESISTENTE;
                        END IF;
                     ELSE
                        -- se non ho trovato l'azienda e sono in tipologia richiesta aggiornamento aziende obsolete do anomalia
                        IF recTRichAzienda.ID_TIPO_RICHIESTA = knIdTipoRichiestaAggAzObsoleta THEN
                           -- se lo e' do apposita anomalia
                           RAISE AZIENDA_NON_ESISTENTE;
                        END IF;
                     END IF;

                 END IF;
                 -- se sono arrivato qui senza saltare nelle exception precedenti posso procedere
                 -- con i ribaltamenti distinguendo in base alla valorizzazione o meno della variabile
                 -- nIdAzienda (se e' valorizzata si tratta di tipo richiesta aggiornamento azienda obsolete)
                 IF nIdAzienda IS NULL THEN
                    -- se e' null parto a ribaltare
                    -- inizio con DB_AZIENDA
                    recTAzienda := RibaltaTAzienda (pIdRichAzienda, pRisultato , pMessaggio);
                    -- se va male vado in exception nel pMessaggio ci dovrebbe essere l'errore specifico
                    IF pRisultato <> '0' THEN
                       RAISE ERR_RIBALTA;
                    END IF;

                 END IF;

                 -- poi ribalto l'anagrafica dell'azienda
                 -- o sul nuovo ID_AZIENDA di recTAzienda o sul nIdAzienda
                 recTAnagrAz := RibaltaTAnagraficaAzienda (pIdRichAzienda,
                                                           NVL(nIdAzienda,recTAzienda.ID_AZIENDA),
                                                           pRisultato ,
                                                           pMessaggio);
                 -- se va male vado in exception nel pMessaggio ci dovrebbe essere l'errore specifico
                 IF pRisultato <> '0' THEN
                    RAISE ERR_RIBALTA;
                 END IF;


                 recTIntermediario:= RibaltaTIntermediario (pIdRichAzienda,
                                                           NVL(nIdAzienda,recTAzienda.ID_AZIENDA),
                                                           pRisultato ,
                                                           pMessaggio);

                -- se va male vado in exception nel pMessaggio ci dovrebbe essere l'errore specifico
                 IF pRisultato <> '0' THEN
                    RAISE ERR_RIBALTA;
                 END IF;


                 -- se e' nIdAzienda e' not null devo fare cose particolari su contitolare , soggetto e persona fisica
                 IF nIdAzienda IS NOT NULL THEN
                    ChiudiERiapriContitolare (nIdAzienda, pIdRichAzienda, pRisultato , pMessaggio);

                    IF pRisultato <> '0' THEN
                       RAISE ERR_RIBALTA;
                    END IF;
                 ELSE
                    -- altrimenti son sicuro che non ci sia ancora un contitolare
                    -- poi ribalto la persona fisica (e' possibile che sia anche gia' presente)
                    recTPersFisica := RibaltaPersonaFisica (pIdRichAzienda,
                                                            recTAzienda.ID_AZIENDA,
                                                            VetSoggetto,
                                                            pRisultato ,
                                                            pMessaggio);

                    -- se va male vado in exception nel pMessaggio ci dovrebbe essere l'errore specifico
                    IF pRisultato <> '0' THEN
                       RAISE ERR_RIBALTA;
                    END IF;

                    -- inserisco il contitolare quello dovrebbe non essere gia' presente
                    recTContitolare := RibaltaContitolare (recTPersFisica.ID_SOGGETTO,
                                                           recTAzienda.ID_AZIENDA,
                                                           pRisultato ,
                                                           pMessaggio);
                    -- se va male vado in exception nel pMessaggio ci dovrebbe essere l'errore specifico
                    IF pRisultato <> '0' THEN
                       RAISE ERR_RIBALTA;
                    END IF;
                 END IF;

                 -- Ribalto l'ute , i fabbricati e le relative particelle e gli utilizzi delle particelle
                 -- nonche' gli allevamenti e le categorie animali
                 RibaltaUteEFiglie (pIdRichAzienda,
                                    NVL(nIdAzienda,recTAzienda.ID_AZIENDA),
                                    pRisultato,
                                    pMessaggio);

                 -- se va male vado in exception nel pMessaggio ci dovrebbe essere l'errore specifico
                 IF pRisultato <> '0' THEN
                    RAISE ERR_RIBALTA;
                 END IF;

                 -- ribalto il conto corrente
                 RibaltaContoCorrente (pIdRichAzienda,
                                       NVL(nIdAzienda,recTAzienda.ID_AZIENDA),
                                       pRisultato,
                                       pMessaggio);

                 -- se va male vado in exception nel pMessaggio ci dovrebbe essere l'errore specifico
                 IF pRisultato <> '0' THEN
                    RAISE ERR_RIBALTA;
                 END IF;
                 --Ribalt i Soggetti Collegati
                 RibaltaSoggCollegati(pIdRichAzienda,
                                       NVL(nIdAzienda,recTAzienda.ID_AZIENDA),
                                       pRisultato,
                                       pMessaggio);

                 -- se va male vado in exception nel pMessaggio ci dovrebbe essere l'errore specifico
                 IF pRisultato <> '0' THEN
                    RAISE ERR_RIBALTA;
                 END IF;



                 RibaltaAziendeAssociate(pIdRichAzienda,
                                       NVL(nIdAzienda,recTAzienda.ID_AZIENDA),
                                       pRisultato,
                                       pMessaggio);

                 -- se va male vado in exception nel pMessaggio ci dovrebbe essere l'errore specifico
                 IF pRisultato <> '0' THEN
                    RAISE ERR_RIBALTA;
                 END IF;

                 -- ribalto gli eventuali documenti
                 RibaltaDocumentiEdAllegati (pIdRichAzienda,
                                             NVL(nIdAzienda,recTAzienda.ID_AZIENDA),
                                             recTAnagrAz.CUAA,
                                             pRisultato,
                                             pMessaggio);

                 -- se va male vado in exception nel pMessaggio ci dovrebbe essere l'errore specifico
                 IF pRisultato <> '0' THEN
                    RAISE ERR_RIBALTA;
                 END IF;

                 -- infine possono chiudere l'iter richiesta azienda
                 -- trasmessa
                 ChiudiIterRichiesta (recTIterRichAzienda);

                 -- ed inserire il nuovo iter validata da PA
                 SELECT SEQ_DB_ITER_RICHIESTA_AZIENDA.nextval
                   INTO recTIterRichAzienda.ID_ITER_RICHIESTA_AZIENDA
                   FROM DUAL;

                 recTIterRichAzienda.ID_STATO_RICHIESTA := knIdStatoRichAziendaValPa;
                 recTIterRichAzienda.DATA_INIZIO_VALIDITA := SYSDATE;
                 recTIterRichAzienda.ID_UTENTE_AGGIORNAMENTO := recTRichAzienda.ID_UTENTE_AGGIORNAMENTO;
                 recTIterRichAzienda.DATA_AGGIORNAMENTO := SYSDATE;
                 InsertTIterRichiestaAzienda (recTIterRichAzienda);
                 -- e poi updatare la richiesta impostando l'ID_AZIENDA che ho creato
                 UPDATE DB_RICHIESTA_AZIENDA
                    SET ID_AZIENDA = NVL(nIdAzienda,recTAzienda.ID_AZIENDA)
                  WHERE ID_RICHIESTA_AZIENDA = recTRichAzienda.ID_RICHIESTA_AZIENDA;


              END IF;
           ELSE
              RAISE NO_RICHIESTA;
           END IF;
          end if;
        END IF;

        pRisultato := '0';

    EXCEPTION
        WHEN NO_PAR_RICHIESTA THEN
             pRisultato := '1';
             pMessaggio := 'Parametro ID_RICHIESTA_AZIENDA non valorizzato';
        WHEN NO_RICHIESTA THEN
             pRisultato := '1';
             pMessaggio := 'Richiesta non presente nella base dati';
        WHEN STATO_RICHIESTA_ERRATO THEN
             pRisultato := '1';
             pMessaggio := 'E'' possibile effettuare la presa in carico solo se la richiesta e'' in stato Trasmessa';
        WHEN AZIENDA_ESISTENTE THEN
             pRisultato := '1';
             pMessaggio := 'L''Azienda risulta gia'' attiva in anagrafe aziende agricole';
        WHEN AZIENDA_NON_ESISTENTE THEN
             pRisultato := '1';
             pMessaggio := 'Non risultano aziende obsolete attive in anagrafe aziende agricole';
        WHEN ERR_RIBALTA THEN
             pRisultato := '1';
        WHEN OTHERS THEN
             pRisultato := '1';
             pMessaggio := 'Ribalta_Azienda - Errore PL/SQL non gestito : ' || SUBSTR(SQLERRM,1,150);
    END Ribalta_Azienda;

    /*********************************************************************
    Dato in input un cuaa ne ritorna le storicizzazione / subentri
    avvenute su DB_ANAGRAFICA_AZIENDA e/o su DB_AZIENDA_TRIBUTARIA
    Tipo: function
    input: pCuaa
    output: nessuno
    ritorno: typVetRecStatoCuaa
    *********************************************************************/
    FUNCTION VerificaStatoCuaa (pCuaa IN DB_ANAGRAFICA_AZIENDA.CUAA%TYPE)
    RETURN typVetRecStatoCuaa IS
        NO_PAR_CUAA         EXCEPTION;

        recTAnagAziendaNew  DB_ANAGRAFICA_AZIENDA%ROWTYPE;
        recTAnagAziendaOld  DB_ANAGRAFICA_AZIENDA%ROWTYPE;
        recTAziendaTrib     DB_AZIENDA_TRIBUTARIA%ROWTYPE;
        recTAzienda         DB_AZIENDA%ROWTYPE;
        vetRecStatoCuaa     typVetRecStatoCuaa;
        nRec                INTEGER:=0;
        nRecAtt             INTEGER:=0;
        vMessaggio          VARCHAR2(1000);
        vProvCompNew        PROVINCIA.SIGLA_PROVINCIA%TYPE;
        vProvCompOld        PROVINCIA.SIGLA_PROVINCIA%TYPE;
        bConsorzioAss       BOOLEAN:=FALSE;


        CURSOR curAziendaValidaXCuaa IS
        SELECT AZ.*,
               P.SIGLA_PROVINCIA,
               TTA.FLAG_CONTROLLI_UNIVOCITA 
          FROM DB_ANAGRAFICA_AZIENDA AZ,
               PROVINCIA P,
               DB_TIPO_TIPOLOGIA_AZIENDA TTA
         WHERE AZ.CUAA = pCuaa
           AND AZ.DATA_FINE_VALIDITA IS NULL
           AND AZ.PROVINCIA_COMPETENZA = P.ISTAT_PROVINCIA
           AND AZ.ID_TIPOLOGIA_AZIENDA = TTA.ID_TIPOLOGIA_AZIENDA;

        CURSOR curAziendaNonValidaXCuaa IS
        SELECT AZ.*,
               P.SIGLA_PROVINCIA
          FROM DB_ANAGRAFICA_AZIENDA AZ,
               PROVINCIA P
         WHERE AZ.CUAA = pCuaa
           AND AZ.DATA_FINE_VALIDITA = (SELECT MAX(DATA_FINE_VALIDITA)
                                          FROM DB_ANAGRAFICA_AZIENDA
                                         WHERE CUAA = pCuaa
                                           AND ID_AZIENDA = AZ.ID_AZIENDA
                                           AND DATA_FINE_VALIDITA IS NOT NULL)
           AND AZ.PROVINCIA_COMPETENZA = P.ISTAT_PROVINCIA;

    BEGIN

        IF pCuaa IS NULL THEN
           RAISE NO_PAR_CUAA;
        END IF;

        vetRecStatoCuaa := typVetRecStatoCuaa();

        bConsorzioAss := FALSE;

        FOR recAziendaValidaXCuaa IN curAziendaValidaXCuaa LOOP
            nRecAtt := nRecAtt + 1;
            recTAnagAziendaNew := NULL;
            recTAnagAziendaOld := NULL;
            recTAzienda := NULL;
            vProvCompNew := NULL;
            vProvCompOld := NULL;
            IF recAziendaValidaXCuaa.FLAG_CONTROLLI_UNIVOCITA = 'N' THEN
               bConsorzioAss := TRUE;
            END IF;

            -- se non e' cessato
            IF recAziendaValidaXCuaa.DATA_CESSAZIONE IS NULL THEN
               -- cerco l'azienda su DB_AZIENDA
               recTAzienda := SelTAziendaById(recAziendaValidaXCuaa.ID_AZIENDA);
               -- se l'id_azienda_provenienza e' not null
               IF recTAzienda.ID_AZIENDA_PROVENIENZA IS NOT NULL THEN
                  -- cerco la vecchia azienda su DB_ANAGRAFICA_AZIENDA
                  recTAnagAziendaOld := SelTAnagAziendaByIDAzienda(recTAzienda.ID_AZIENDA_PROVENIENZA);
                  -- se la trovo
                  IF recTAnagAziendaOld.ID_ANAGRAFICA_AZIENDA IS NOT NULL THEN

                     vProvCompOld := SelSiglaProvByIstatProv (recTAnagAziendaOld.PROVINCIA_COMPETENZA);

                     -- accodo il record nel vettore
                     nRec := nRec + 1;
                     vetRecStatoCuaa.EXTEND;
                     vetRecStatoCuaa(vetRecStatoCuaa.COUNT) := typRecStatoCuaa
                                                            (recAziendaValidaXCuaa.ID_AZIENDA, -- ID_AZIENDA NUOVO (-- in questo caso id azienda nuovo e vecchio coincidono)
                                                             pCuaa, -- CUAA NUOVO
                                                             recAziendaValidaXCuaa.DENOMINAZIONE, -- DENOMINAZIONE NUOVO
                                                             recAziendaValidaXCuaa.SIGLA_PROVINCIA, -- PROVINCIA COMPENTENZA NUOVA
                                                             recTAnagAziendaOld.ID_AZIENDA, -- l'id_azienda vecchio e' quello dell'azienda di provenienza
                                                             recTAnagAziendaOld.CUAA, -- CUAA VECCHIO
                                                             recTAnagAziendaOld.DENOMINAZIONE, -- VECCHIA DENOMINAZIONE
                                                             vProvCompOld, -- PROVINCIA COMPETENZA VECCHIA
                                                             'N', -- il flag cuaa chiamante lo settiano ad N (NUOVO)
                                                             NVL(recTAzienda.DATA_INSEDIAMENTO, recTAzienda.DATA_INIZIO_VALIDITA), -- la data di modifica viene settata o alla data di insediamento dell'ID_AZIENDA nuovo o alla data di inizio validita'
                                                             CASE WHEN recTAzienda.DATA_INSEDIAMENTO IS NOT NULL THEN 3 ELSE 2 END, -- idem il tipo modifica
                                                             CASE WHEN recTAzienda.DATA_INSEDIAMENTO IS NOT NULL THEN 'Insediamento giovani' ELSE 'Subentro' END, -- e la descrizione modifica
                                                             0); -- esito

                  END IF;

               END IF;

               -- proseguo andando a vedere se per l'id_azienda del cuaa
               -- esistono records su DB_ANAGRAFICA_AZIENDA con data fine validita
               -- dove il cuaa e' diverso e prendo l'ultimo
               BEGIN

                   SELECT *
                     INTO recTAnagAziendaOld
                     FROM DB_ANAGRAFICA_AZIENDA AZ
                    WHERE AZ.ID_AZIENDA = recAziendaValidaXCuaa.ID_AZIENDA
                      AND AZ.CUAA <> recAziendaValidaXCuaa.CUAA
                      AND AZ.DATA_FINE_VALIDITA IS NOT NULL
                      AND AZ.DATA_FINE_VALIDITA = (SELECT MAX(DATA_FINE_VALIDITA)
                                                     FROM DB_ANAGRAFICA_AZIENDA
                                                    WHERE ID_AZIENDA = recAziendaValidaXCuaa.ID_AZIENDA
                                                      AND CUAA <> recAziendaValidaXCuaa.CUAA
                                                      AND DATA_FINE_VALIDITA IS NOT NULL);
               EXCEPTION
                    WHEN NO_DATA_FOUND THEN
                         recTAnagAziendaOld := NULL;
               END;
               -- se ne ho trovati
               IF recTAnagAziendaOld.ID_ANAGRAFICA_AZIENDA IS NOT NULL THEN

                  vProvCompOld := SelSiglaProvByIstatProv (recTAnagAziendaOld.PROVINCIA_COMPETENZA);

                  -- accodo un record nel vettore
                  nRec := nRec + 1;
                  vetRecStatoCuaa.EXTEND;

                  vetRecStatoCuaa(vetRecStatoCuaa.COUNT) := typRecStatoCuaa
                                                            (recAziendaValidaXCuaa.ID_AZIENDA, -- ID_AZIENDA NUOVO (-- in questo caso id azienda nuovo e vecchio coincidono)
                                                             pCuaa, -- CUAA NUOVO
                                                             recAziendaValidaXCuaa.DENOMINAZIONE, -- DENOMINAZIONE NUOVO
                                                             recAziendaValidaXCuaa.SIGLA_PROVINCIA, -- PROVINCIA COMPENTENZA NUOVA
                                                             recTAnagAziendaOld.ID_AZIENDA, -- l'id_azienda vecchio e' quello dell'azienda di provenienza
                                                             recTAnagAziendaOld.CUAA, -- CUAA VECCHIO
                                                             recTAnagAziendaOld.DENOMINAZIONE, -- VECCHIA DENOMINAZIONE
                                                             vProvCompOld, -- PROVINCIA COMPETENZA VECCHIA
                                                             'N', -- il flag cuaa chiamante lo settiano ad N (NUOVO)
                                                             recTAnagAziendaOld.DATA_FINE_VALIDITA, -- la data di modifica e' la massima data di fine validita' della storicizzazione di DB_ANAGRAFICA_AZIENDA per l'azienda
                                                             4, -- tipologia modifica
                                                             'Variazione anagrafica', -- descrizione modifica
                                                             0); -- esito


               END IF;

            ELSE
               -- altrimenti se il record valido di DB_ANAGRAFICA_AZIENDA
               -- per il CUAA ha la data cessazione valorizzata
               -- cerco se l'ID_AZIENDA e' censito come ID_AZIENDA_PROVENIENZA
               -- di un'altra azienda
               BEGIN
                    SELECT *
                      INTO recTAzienda
                      FROM DB_AZIENDA
                     WHERE ID_AZIENDA = (SELECT MAX(ID_AZIENDA)
                                           FROM DB_AZIENDA
                                          WHERE ID_AZIENDA_PROVENIENZA = recAziendaValidaXCuaa.ID_AZIENDA);

                    -- se si mi prendo l'anagrafica
                    SELECT *
                      INTO recTAnagAziendaNew
                      FROM DB_ANAGRAFICA_AZIENDA
                     WHERE ID_AZIENDA = recTAzienda.ID_AZIENDA
                       AND DATA_FINE_VALIDITA IS NULL;

               EXCEPTION
                    WHEN NO_DATA_FOUND THEN
                        recTAzienda := NULL;
                        recTAnagAziendaNew := NULL;

               END;

               -- se ho trovato la nuova azienda
               -- accodo un record nel vettore
               IF recTAnagAziendaNew.ID_ANAGRAFICA_AZIENDA IS NOT NULL THEN
                  nRec := nRec + 1;
                  vProvCompNew := SelSiglaProvByIstatProv (recTAnagAziendaNew.PROVINCIA_COMPETENZA);

                  vetRecStatoCuaa.EXTEND;

                  vetRecStatoCuaa(vetRecStatoCuaa.COUNT) := typRecStatoCuaa
                                                            (recTAnagAziendaNew.ID_AZIENDA, -- in id azienda nuovo metto l'id_azienda della nuova azienda
                                                             recTAnagAziendaNew.CUAA, -- in cuaa nuovo metto il cuaa della nuova azienda
                                                             recTAnagAziendaNew.DENOMINAZIONE, -- denominazione della nuova azienda
                                                             vProvCompNew, -- provincia di competenza della nuova azienda
                                                             recAziendaValidaXCuaa.ID_AZIENDA, -- in id azienda vecchio metto l'id_azienda trovato per il CUAA passato in input
                                                             pCuaa,  -- in cuaa vecchio il cuaa dato in input
                                                             recAziendaValidaXCuaa.DENOMINAZIONE, -- denominazione vecchia azienda
                                                             recAziendaValidaXCuaa.SIGLA_PROVINCIA, -- provincia di competenza vecchia azienda
                                                             'V', -- il cuaa chiamante e' V,
                                                             NVL(recTAzienda.DATA_INSEDIAMENTO, recTAzienda.DATA_INIZIO_VALIDITA), -- la data di modifica viene settata o alla data di insediamento dell'ID_AZIENDA nuovo o alla data di inizio validita'
                                                             CASE WHEN recTAzienda.DATA_INSEDIAMENTO IS NOT NULL THEN 3 ELSE 2 END, -- idem il tipo modifica
                                                             CASE WHEN recTAzienda.DATA_INSEDIAMENTO IS NOT NULL THEN 'Insediamento giovani' ELSE 'Subentro' END, -- e la descrizione modifica
                                                             0);-- esito

               END IF;

               -- proseguo verificando se per caso
               -- e' presente per l'azienda cessata(DATA_CESSAZIONE)
               -- anche un record con DATA_FINE_VALIDITA a NOT NULL
               -- ma CUAA diverso (per stesso ID_AZIENDA)
               BEGIN

                   SELECT *
                     INTO recTAnagAziendaOld
                     FROM DB_ANAGRAFICA_AZIENDA AZ
                    WHERE AZ.ID_AZIENDA = recAziendaValidaXCuaa.ID_AZIENDA
                      AND AZ.CUAA <> recAziendaValidaXCuaa.CUAA
                      AND AZ.DATA_FINE_VALIDITA IS NOT NULL
                      AND AZ.DATA_FINE_VALIDITA = (SELECT MAX(DATA_FINE_VALIDITA)
                                                     FROM DB_ANAGRAFICA_AZIENDA
                                                    WHERE ID_AZIENDA = recAziendaValidaXCuaa.ID_AZIENDA
                                                      AND CUAA <> recAziendaValidaXCuaa.CUAA
                                                      AND DATA_FINE_VALIDITA IS NOT NULL);
               EXCEPTION
                    WHEN NO_DATA_FOUND THEN
                         recTAnagAziendaOld := NULL;
               END;
               -- se si
               IF recTAnagAziendaOld.ID_ANAGRAFICA_AZIENDA IS NOT NULL THEN
                  -- accodo un record nel vettore
                  vProvCompOld := SelSiglaProvByIstatProv (recTAnagAziendaOld.PROVINCIA_COMPETENZA);
                  nRec := nRec + 1;
                  vetRecStatoCuaa.EXTEND;
                  -- il cuaa nuovo e' quello dato in input
                  vetRecStatoCuaa(vetRecStatoCuaa.COUNT) := typRecStatoCuaa
                                                            (recAziendaValidaXCuaa.ID_AZIENDA, -- ID_AZIENDA NUOVO (-- in questo caso id azienda nuovo e vecchio coincidono)
                                                             pCuaa, -- CUAA NUOVO
                                                             recAziendaValidaXCuaa.DENOMINAZIONE, -- DENOMINAZIONE NUOVO
                                                             recAziendaValidaXCuaa.SIGLA_PROVINCIA, -- PROVINCIA COMPENTENZA NUOVA
                                                             recAziendaValidaXCuaa.ID_AZIENDA, -- ID AZIENDA VECCHIO (in questo caso id azienda nuovo e vecchio coincidono)
                                                             recTAnagAziendaOld.CUAA, -- CUAA VECCHIO
                                                             recTAnagAziendaOld.DENOMINAZIONE, -- VECCHIA DENOMINAZIONE
                                                             NULL, -- PROVINCIA COMPETENZA VECCHIA
                                                             'N', -- il flag cuaa chiamante lo settiano ad N (NUOVO)
                                                             recTAnagAziendaOld.DATA_FINE_VALIDITA, -- la data di modifica e' la massima data di fine validita' della storicizzazione di DB_ANAGRAFICA_AZIENDA per l'azienda
                                                             4, -- tipo modifica a  4
                                                             'Variazione anagrafica', -- descrizione modifica
                                                             0); -- esito
               END IF;

            END IF;

        END LOOP;

        IF nRecAtt = 0 OR bConsorzioAss THEN
           FOR recAziendaNonValidaXCuaa IN curAziendaNonValidaXCuaa LOOP
              recTAnagAziendaNew := NULL;
              recTAnagAziendaOld := NULL;
              recTAzienda := NULL;
              vProvCompNew := NULL;
              vProvCompOld := NULL;
              -- altrimenti se il record che ho trovato il CUAA dato in input
              -- su DB_ANAGRAFICA_AZIENDA ha la DATA_FINE_VALIDITA valorizzata
              -- cerco se con lo stesso ID_AZIENDA c'è un record attivo
              recTAnagAziendaNew := SelTAnagAziendaByIDAzienda (recAziendaNonValidaXCuaa.ID_AZIENDA);
              -- se si
              IF recTAnagAziendaNew.ID_ANAGRAFICA_AZIENDA IS NOT NULL THEN
                 -- controllo se il cuaa e' diverso da quello dato in input
                 IF recTAnagAziendaNew.CUAA <> recAziendaNonValidaXCuaa.CUAA THEN

                    vProvCompNew := SelSiglaProvByIstatProv (recTAnagAziendaNew.PROVINCIA_COMPETENZA);
                    -- se si accodo un record nel vettore
                    nRec := nRec + 1;
                    vetRecStatoCuaa.EXTEND;
                    -- se il cuaa chiamente e' un consorzio od una coperativa
                    IF bConsorzioAss THEN
                        vetRecStatoCuaa(vetRecStatoCuaa.COUNT) := typRecStatoCuaa
                                                                (recTAnagAziendaNew.ID_AZIENDA, -- in id azienda nuovo metto l'id_azienda della nuova azienda
                                                                 recTAnagAziendaNew.CUAA, -- in cuaa nuovo metto il cuaa della nuova azienda
                                                                 recTAnagAziendaNew.DENOMINAZIONE, -- denominazione della nuova azienda
                                                                 vProvCompNew, -- provincia di competenza della nuova azienda
                                                                 recAziendaNonValidaXCuaa.ID_AZIENDA, -- in id azienda vecchio metto l'id_azienda trovato per il CUAA passato in input
                                                                 pCuaa,  -- in cuaa vecchio il cuaa dato in input
                                                                 recAziendaNonValidaXCuaa.DENOMINAZIONE, -- denominazione vecchia azienda
                                                                 recAziendaNonValidaXCuaa.SIGLA_PROVINCIA, -- provincia di competenza vecchia azienda
                                                                 'V', -- il cuaa chiamante e' V,
                                                                 recAziendaNonValidaXCuaa.DATA_FINE_VALIDITA,
                                                                 4,-- tipo modifica
                                                                 'Variazione anagrafica', -- descrizione modifica
                                                                 3);-- esito
                    ELSE
                        vetRecStatoCuaa(vetRecStatoCuaa.COUNT) := typRecStatoCuaa
                                                                (recTAnagAziendaNew.ID_AZIENDA, -- in id azienda nuovo metto l'id_azienda della nuova azienda
                                                                 recTAnagAziendaNew.CUAA, -- in cuaa nuovo metto il cuaa della nuova azienda
                                                                 recTAnagAziendaNew.DENOMINAZIONE, -- denominazione della nuova azienda
                                                                 vProvCompNew, -- provincia di competenza della nuova azienda
                                                                 recAziendaNonValidaXCuaa.ID_AZIENDA, -- in id azienda vecchio metto l'id_azienda trovato per il CUAA passato in input
                                                                 pCuaa,  -- in cuaa vecchio il cuaa dato in input
                                                                 recAziendaNonValidaXCuaa.DENOMINAZIONE, -- denominazione vecchia azienda
                                                                 recAziendaNonValidaXCuaa.SIGLA_PROVINCIA, -- provincia di competenza vecchia azienda
                                                                 'V', -- il cuaa chiamante e' V,
                                                                 recAziendaNonValidaXCuaa.DATA_FINE_VALIDITA,
                                                                 4,-- tipo modifica
                                                                 'Variazione anagrafica', -- descrizione modifica
                                                                 0);-- esito

                    END IF;
                 END IF;
              END IF;

              -- proseguo verificando se l'azienda recuperata per il cuaa dato input
              -- e' presente come ID_AZIENDA_PROVENIENZA di un'altra azienda
              BEGIN

                 SELECT *
                   INTO recTAzienda
                   FROM DB_AZIENDA
                  WHERE ID_AZIENDA = (SELECT MAX(ID_AZIENDA)
                                        FROM DB_AZIENDA
                                       WHERE ID_AZIENDA_PROVENIENZA = recAziendaNonValidaXCuaa.ID_AZIENDA);

                  -- se si ne recupero l'anagrafica
                  SELECT *
                    INTO recTAnagAziendaNew
                    FROM DB_ANAGRAFICA_AZIENDA
                   WHERE ID_AZIENDA = recTAzienda.ID_AZIENDA
                     AND DATA_FINE_VALIDITA IS NULL;
              EXCEPTION
                 WHEN NO_DATA_FOUND THEN
                      recTAzienda := NULL;
                      recTAnagAziendaNew := NULL;
              END;

              -- se ho trovato l'anagrafica
              IF recTAnagAziendaNew.ID_ANAGRAFICA_AZIENDA IS NOT NULL THEN
                 -- accodo un record nel vettore
                 nRec := nRec + 1;
                 vetRecStatoCuaa.EXTEND;
                 vProvCompNew := SelSiglaProvByIstatProv (recTAnagAziendaNew.PROVINCIA_COMPETENZA);

                 vetRecStatoCuaa(vetRecStatoCuaa.COUNT) := typRecStatoCuaa
                                                            (recTAnagAziendaNew.ID_AZIENDA, -- in id azienda nuovo metto l'id_azienda della nuova azienda
                                                             recTAnagAziendaNew.CUAA, -- in cuaa nuovo metto il cuaa della nuova azienda
                                                             recTAnagAziendaNew.DENOMINAZIONE, -- denominazione della nuova azienda
                                                             vProvCompNew, -- provincia di competenza della nuova azienda
                                                             recAziendaNonValidaXCuaa.ID_AZIENDA, -- in id azienda vecchio metto l'id_azienda trovato per il CUAA passato in input
                                                             pCuaa,  -- in cuaa vecchio il cuaa dato in input
                                                             recAziendaNonValidaXCuaa.DENOMINAZIONE, -- denominazione vecchia azienda
                                                             recAziendaNonValidaXCuaa.SIGLA_PROVINCIA, -- provincia di competenza vecchia azienda
                                                             'V', -- il cuaa chiamante e' V,
                                                             NVL(recTAzienda.DATA_INSEDIAMENTO, recTAzienda.DATA_INIZIO_VALIDITA), -- la data di modifica viene settata o alla data di insediamento dell'ID_AZIENDA nuovo o alla data di inizio validita'
                                                             CASE WHEN recTAzienda.DATA_INSEDIAMENTO IS NOT NULL THEN 3 ELSE 2 END, -- idem il tipo modifica
                                                             CASE WHEN recTAzienda.DATA_INSEDIAMENTO IS NOT NULL THEN 'Insediamento giovani' ELSE 'Subentro' END, -- e la descrizione modifica
                                                             0);-- esito

              END IF;

           END LOOP;
        END IF;

        -- solamente se il cuaa passato in input e' lungo 16
        -- controllo cosa c'è su anagrafe tributaria
        IF LENGTH(pCuaa) = 16 THEN
            -- in ogni caso sia che abbia trovato l'azienda per cuaa su DB_ANAGRAFICA_AZIENDA
            -- che l'abbia trovata attiva o cessata poi ricerco su DB_AZIENDA_TRIBUTARIA
            recTAziendaTrib := SelTAziendaTributariaByCuaa (pCuaa);

            -- se la trovo e se il CUAA (ci finisce il cuaa chiamante del ws anagrafe tributaria)
            -- e' diverso dal CUAA_ANAGRAFE_TRIBUTARIA
            IF recTAziendaTrib.ID_AZIENDA_TRIBUTARIA IS NOT NULL AND
               -- recTAziendaTrib.CUAA <> NVL(recTAziendaTrib.PARTITA_IVA,'#') AND 
               LENGTH(recTAziendaTrib.CUAA) = 16 AND 
               recTAziendaTrib.CUAA <> recTAziendaTrib.CUAA_ANAGRAFE_TRIBUTARIA THEN

               -- se si accodo un record nel vettore
               nRec := nRec + 1;
               vetRecStatoCuaa.EXTEND;

               vetRecStatoCuaa(vetRecStatoCuaa.COUNT) := typRecStatoCuaa (NULL, -- ID_AZIENDA_NUOVA non valorizzato
                                                                          recTAziendaTrib.CUAA_ANAGRAFE_TRIBUTARIA, -- CUAA NUOVO
                                                                          NULL, -- DENOMINAZIONE NUOVA
                                                                          NULL, -- PROVINCIA COMPETENZA NUOVA
                                                                          NULL, -- ID_AZIENDA_VECCHIA non valorizzato
                                                                          pCuaa, -- CUAA VECCHIO
                                                                          NULL, -- DENOMINAZIONE VECCHIA
                                                                          NULL, -- PROVINCIA COMPETENZA VECCHIA
                                                                          'V', -- in cuaa chiamante metto V (VECCHIO)
                                                                          recTAziendaTrib.DATA_AGGIORNAMENTO, -- in cuaa nuovo metto il cuaa dell'anagrafe tributaria la data di modifica diventa la data di aggiornamento di DB_AZIENDA_TRIBUTARIA
                                                                          1, -- tipo modifica
                                                                          'Cambio cuaa su anagrafe tributaria', -- la descrizione modifica cambio cuaa su anagrafe tributaria
                                                                          0); -- esito
            ELSE
               -- se non trovo record per CUAA
               -- provo a ricercare per CUAA_ANAGRAFE_TRIBUTARIA = CUAA dato in input
               -- e CUAA <> CUAA dato in input
               BEGIN
                   SELECT *
                     INTO recTAziendaTrib
                     FROM DB_AZIENDA_TRIBUTARIA ATR
                    WHERE ATR.CUAA_ANAGRAFE_TRIBUTARIA = pCuaa
                      AND ATR.CUAA <> pCuaa
                      AND LENGTH(ATR.CUAA) = 16; 
                      -- AND ATR.CUAA <> NVL(ATR.PARTITA_IVA,'#'); 
               EXCEPTION
                   WHEN NO_DATA_FOUND THEN
                        recTAziendaTrib := NULL;
               END;
               -- se trovo qualcosa
               IF recTAziendaTrib.ID_AZIENDA_TRIBUTARIA IS NOT NULL THEN
                  -- accodo un record nel vettore
                  nRec := nRec + 1;
                  vetRecStatoCuaa.EXTEND;

                  vetRecStatoCuaa(vetRecStatoCuaa.COUNT) := typRecStatoCuaa (NULL, -- ID_AZIENDA_NUOVA non valorizzato
                                                                             pCuaa, -- CUAA NUOVO
                                                                             NULL, -- DENOMINAZIONE NUOVA
                                                                             NULL, -- PROVINCIA COMPETENZA NUOVA
                                                                             NULL, -- ID_AZIENDA_VECCHIA non valorizzato
                                                                             recTAziendaTrib.CUAA, -- CUAA VECCHIO
                                                                             NULL, -- DENOMINAZIONE VECCHIA
                                                                             NULL, -- PROVINCIA COMPETENZA VECCHIA
                                                                             'N', -- in cuaa chiamante metto N (NUOVO)
                                                                             recTAziendaTrib.DATA_AGGIORNAMENTO, -- in cuaa nuovo metto il cuaa dell'anagrafe tributaria la data di modifica diventa la data di aggiornamento di DB_AZIENDA_TRIBUTARIA
                                                                             1, -- tipo modifica
                                                                             'Cambio cuaa su anagrafe tributaria', -- la descrizione modifica cambio cuaa su anagrafe tributaria
                                                                             0);

               END IF;

            END IF;
        END IF;

        -- se non ho storicizzato records nel vettore
        IF nRec = 0 THEN
           nRec := nRec + 1;
           vetRecStatoCuaa.EXTEND;

           vetRecStatoCuaa(vetRecStatoCuaa.COUNT) := typRecStatoCuaa (NULL, -- ID_AZIENDA_NUOVO
                                                                      pCuaa, -- CUAA NUOVO
                                                                      NULL, -- DENOMINAZIONE NUOVA
                                                                      NULL, -- PROVINCIA COMPETENZA NUOVA
                                                                      NULL, -- ID_AZIENDA_VECCHIA non valorizzato
                                                                      NULL, -- CUAA VECCHIO
                                                                      NULL, -- DENOMINAZIONE VECCHIA
                                                                      NULL, -- PROVINCIA COMPETENZA VECCHIA
                                                                      'N', -- in cuaa chiamante metto N (NUOVO)
                                                                      NULL, -- la data di modifica e' a null
                                                                      0, -- tipo modifica a zero
                                                                      'Nessuna modifica', -- descrizione modifica a nessuna modifica
                                                                      2 -- esito a 2
                                                                      );

        END IF;

        RETURN vetRecStatoCuaa;

    EXCEPTION
        WHEN NO_PAR_CUAA THEN
             nRec := nRec + 1;
             vetRecStatoCuaa.EXTEND;

             vetRecStatoCuaa(vetRecStatoCuaa.COUNT) := typRecStatoCuaa (NULL, -- ID_AZIENDA_NUOVO
                                                                        NULL, -- CUAA NUOVO
                                                                        NULL, -- DENOMINAZIONE NUOVA
                                                                        NULL, -- PROVINCIA COMPETENZA NUOVA
                                                                        NULL, -- ID_AZIENDA_VECCHIA non valorizzato
                                                                        NULL, -- CUAA VECCHIO
                                                                        NULL, -- DENOMINAZIONE VECCHIA
                                                                        NULL, -- PROVINCIA COMPETENZA VECCHIA
                                                                        NULL, -- in cuaa chiamante metto NULL
                                                                        NULL, -- la data di modifica e' a null
                                                                        NULL, -- tipo modifica a null
                                                                        'Parametro di input non presente', -- descrizione modifica a parametro di input non presente
                                                                        1 -- esito a 1
                                                                        );
             RETURN vetRecStatoCuaa;
        WHEN OTHERS THEN
             vMessaggio := SUBSTR(SQLERRM,1,200);
             nRec := nRec + 1;
             vetRecStatoCuaa.EXTEND;

             vetRecStatoCuaa(vetRecStatoCuaa.COUNT) := typRecStatoCuaa (NULL, -- ID_AZIENDA_NUOVO
                                                                        NULL, -- CUAA NUOVO
                                                                        NULL, -- DENOMINAZIONE NUOVA
                                                                        NULL, -- PROVINCIA COMPETENZA NUOVA
                                                                        NULL, -- ID_AZIENDA_VECCHIA non valorizzato
                                                                        NULL, -- CUAA VECCHIO
                                                                        NULL, -- DENOMINAZIONE VECCHIA
                                                                        NULL, -- PROVINCIA COMPETENZA VECCHIA
                                                                        NULL, -- in cuaa chiamante metto NULL
                                                                        NULL, -- la data di modifica e' a null
                                                                        NULL, -- tipo modifica a null
                                                                        'Errore PL/SQL : ' || SUBSTR(SQLERRM,1,150), -- errore pl/sql nella descrizione modifica
                                                                        1 -- esito ad 1
                                                                        );
             RETURN vetRecStatoCuaa;
    END VerificaStatoCuaa;


     /********************************************************************************
    Descrizione:  trovaNotificaEntitaByIdentif



    Tipo:         Function

    Input:        pIdAzienda

                     pCodEntita
                        Codice dell'entita' per cui sto cercando notifiche attive.

                     pIdentificativo
                        Id del campo chiave/identificativo utilizzato per cercare l'entita' sulla tabella che la contiene
                        (es. id_particella,id_unita_arborea...ecc)

                     pTipoIdentificativo
                        Tipo di chiave utilizzata: mi dice quindi la natura della chiave/identificativo che sto passando
                        (es. P = id_particella, U = id_unita_arborea...ecc)

                    pIdTipolNotifica                                                                        --> RENDERE NON OBBLIGATORIO??!!
                        Id Tipologia di Notifica: vitivinicolo, warning...ecc

    ESEMPIO: potrei cercare le notifiche esistenti per le unita' arboree passando come
                     chiave/identificativo o l' id_unita_arborea o l'id_particella!!


    Return:       INTEGER;
                     -    1 = esiste notifica
                     -    0 = non è presente notifica
                     -   -1 = parametri in input non valorizzati
                     -   -2 = codice entita' non trovato su DB_TIPO_ENTITA
                     - NULL = parametri mancanti/errore oracle
    *********************************************************************************/
    FUNCTION trovaNotificaEntitaByIdentif(pIdAzienda           DB_AZIENDA.ID_AZIENDA%TYPE,
                                          pCodEntita           DB_TIPO_ENTITA.CODICE_TIPO_ENTITA%TYPE,
                                          pIdentificativo      DB_NOTIFICA_ENTITA.IDENTIFICATIVO%TYPE,
                                          pTipoIdentificativo  VARCHAR2,
                                          pIdTipolNotifica     DB_TIPO_TIPOLOGIA_NOTIFICA.ID_TIPOLOGIA_NOTIFICA%TYPE,
                                          pAnnoNotifica        NUMBER,
                                          pNotificaAttiva      NUMBER) RETURN INTEGER IS

        -- except
        NO_PARAM             EXCEPTION;
        --  collect
        recTipoEntita           DB_TIPO_ENTITA%ROWTYPE;
        -- vars
        nCount                    INTEGER := 0;

    BEGIN
        -- no parametri --> no party
        IF pIdAzienda IS NULL
            OR pCodEntita IS NULL
            OR pIdentificativo IS NULL
            OR pTipoIdentificativo IS NULL
            OR pIdTipolNotifica IS NULL THEN

            RAISE NO_PARAM;
        END IF;

        -- recupero dati essenziali dell'entita' --> n.b. in realta' mi basta l'ID ma se dovessi
        -- pescare il nome tabella e campo per un'utilizzo dinamico ho gia' il record!
        BEGIN
            SELECT *
            INTO
                recTipoEntita
            FROM
                DB_TIPO_ENTITA
            WHERE
                CODICE_TIPO_ENTITA = pCodEntita;

        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                RETURN -2;
        END;
        --------------------------------------------------------------------------------------------------------------
        -- cerco notifiche attive... per la mia entita' e filtrando con la mia chiave/identificativo   ..

        -- cerco notifiche per l'ENTITA'  'UV' con IDENTIFICATIVO = 'ID_PARTICELLA'
        IF pCodEntita = 'U' AND pTipoIdentificativo = 'P' THEN
            SELECT
                COUNT(0)
            INTO
                nCount
            FROM
                DB_NOTIFICA_ENTITA NE,
                DB_NOTIFICA N
            WHERE
                NE.ID_TIPO_ENTITA = recTipoEntita.ID_TIPO_ENTITA
                --
                AND EXISTS (SELECT 1
                                        FROM
                                            DB_STORICO_UNITA_ARBOREA SUA
                                        WHERE
                                            SUA.ID_AZIENDA = pIdAzienda
                                            AND ID_PARTICELLA = pIdentificativo
                                            AND SUA.DATA_FINE_VALIDITA IS NULL
                                            AND SUA.DATA_CESSAZIONE IS NULL
                                            --
                                            AND SUA.ID_UNITA_ARBOREA = NE.IDENTIFICATIVO
                                      )
                AND NE.DATA_FINE_VALIDITA IS NULL    --> CI VA??!!
                --
                AND NE.ID_NOTIFICA = N.ID_NOTIFICA
                --
                AND N.ID_AZIENDA = pIdAzienda --> CI VA??!!
                AND N.ID_TIPOLOGIA_NOTIFICA = pIdTipolNotifica
                AND ((pNotificaAttiva = 1 AND N.DATA_CHIUSURA IS NULL) OR (pNotificaAttiva = 0 AND 1 = 1))
                AND ((pAnnoNotifica IS NOT NULL AND TO_NUMBER(TO_CHAR(N.DATA_INSERIMENTO,'YYYY')) = pAnnoNotifica) OR
                     (pAnnoNotifica IS NULL AND 1 = 1))
                --
                AND ROWNUM = 1;
        ELSE
            -- ricerca generica...
            SELECT
                COUNT(0)
            INTO
                nCount
            FROM
                DB_NOTIFICA_ENTITA NE,
                DB_NOTIFICA N
            WHERE
                NE.ID_TIPO_ENTITA = recTipoEntita.ID_TIPO_ENTITA
                AND NE.IDENTIFICATIVO =  pIdentificativo
                AND NE.DATA_FINE_VALIDITA IS NULL --> CI VA??!!
                --
                AND NE.ID_NOTIFICA = N.ID_NOTIFICA
                --
                AND N.ID_AZIENDA = pIdAzienda  --> CI VA??!!
                AND N.ID_TIPOLOGIA_NOTIFICA = pIdTipolNotifica
                AND N.DATA_CHIUSURA IS NULL
                AND ((pNotificaAttiva = 1 AND N.DATA_CHIUSURA IS NULL) OR (pNotificaAttiva = 0 AND 1 = 1))
                AND ((pAnnoNotifica IS NOT NULL AND TO_NUMBER(TO_CHAR(N.DATA_INSERIMENTO,'YYYY')) = pAnnoNotifica) OR
                     (pAnnoNotifica IS NULL AND 1 = 1))
                --
                AND ROWNUM = 1;
        END IF;  -- IF pCodEntita = 'U' AND pTipoIdentificativo = 'P' THEN

        RETURN nCount;

    EXCEPTION
        WHEN NO_PARAM THEN --> tornare un intero differente per parametri NON valorizzati??!!
            RETURN -1;
        WHEN OTHERS THEN
             RETURN NULL;

    END trovaNotificaEntitaByIdentif;

/*******************************************************************************
 NAME: FncIsParticallaPA
 PURPOSE: Verifica se una particella appartiene alla pubblica amministrazione
          verificando che nella denominazione del proprietario siano presenti
          determinate stringhe parametrizzate.
 Parametri:
        input: Id della particella della tabella DB_PARTICELLA
        Output: nessuno
        Valore di ritorno: 1 se la condizione è verifica 0 altrimenti
 
 *******************************************************************************/


    FUNCTION FncIsParticallaPA   (pIdParticella     IN   DB_PARTICELLA_CERTIFICATA.ID_PARTICELLA%TYPE
                              ) RETURN INTEGER is

    sDenomPropPa1    VARCHAR2(10)   :='COMUNE';
    sDenomPropPa2    VARCHAR2(10)   :='PROVINCIA';
    sDenomPropPa3    VARCHAR2(10)   :='REGIONE';

    nEsistePA        NUMBER;

    BEGIN


        SELECT COUNT(*)
          INTO nEsistePA
          FROM DB_PARTICELLA_CERTIFICATA  PARC,
               DB_PROPRIETA_CERTIFICATA   PROC,
               DB_SOGGETTO                SOG,
               DB_PERSONA_GIURIDICA       PGIU
         WHERE PARC.ID_PARTICELLA=pIdParticella
           AND PARC.DATA_FINE_VALIDITA IS NULL
           AND PARC.ID_PARTICELLA_CERTIFICATA = PROC.ID_PARTICELLA_CERTIFICATA
           AND PROC.ID_SOGGETTO=SOG.ID_SOGGETTO
           AND PROC.DATA_FINE_VALIDITA is NULL
           AND FLAG_FISICO='N'
           AND SOG.ID_SOGGETTO=PGIU.ID_SOGGETTO
           AND (INSTR(UPPER( PGIU.denominazione), sDenomPropPa1)>0
                OR
                INSTR(UPPER( PGIU.denominazione), sDenomPropPa2)>0
                OR
                INSTR(UPPER( PGIU.denominazione), sDenomPropPa3)>0
               );

        IF nEsistePA >0 THEN
        --la particella è di proprietà della PA
            RETURN(1);
        ELSE
            RETURN(0);
        END IF;

    END;

FUNCTION getListIdPraticaMantenimento(pIdCatalogoMatrice  DB_R_CATALOGO_MATRICE.ID_CATALOGO_MATRICE%TYPE,
                                      pFlagDefault        VARCHAR2 DEFAULT NULL) RETURN TYPVETRECPRATMANT IS

  VetRecPratMant  TypVetRecPratMant;
  bFound          BOOLEAN := FALSE;
  nCont           SIMPLE_INTEGER := 0;
BEGIN
  VetRecPratMant := TypVetRecPratMant();

  FOR rec IN (SELECT ID_PRATICA_MANTENIMENTO
              FROM   DB_R_CATALOGO_MANTENIMENTO
              WHERE  ID_CATALOGO_MATRICE = pIdCatalogoMatrice
              AND    ((pFlagDefault          = 'S' AND FLAG_DEFAULT = 'S') OR
                      (NVL(pFlagDefault,'N') = 'N' AND FLAG_DEFAULT IN ('S','N')))) LOOP

    bFound := TRUE;
    VetRecPratMant.EXTEND;
    VetRecPratMant(VetRecPratMant.COUNT) := TypRecPratMant(rec.ID_PRATICA_MANTENIMENTO);
  END LOOP;

  IF NOT bFound THEN
    FOR rec IN (SELECT PGM.ID_PRATICA_MANTENIMENTO,GM.NOME_COLONNA_CONFRONTO
                FROM   DB_GRUPPO_MANTENIMENTO GM,DB_R_PRATICA_GRUPPO_MANTENIMEN PGM
                WHERE  GM.NOME_COLONNA_CONFRONTO IS NOT NULL
                AND    GM.ID_GRUPPO_MANTENIMENTO = PGM.ID_GRUPPO_MANTENIMENTO
                AND    ((pFlagDefault            = 'S' AND PGM.FLAG_DEFAULT = 'S') OR
                        (NVL(pFlagDefault,'N')   = 'N' AND PGM.FLAG_DEFAULT IN ('S','N')))) LOOP

      EXECUTE IMMEDIATE('SELECT COUNT(*)
                         FROM   DB_R_CATALOGO_MATRICE
                         WHERE  ID_CATALOGO_MATRICE = '||pIdCatalogoMatrice||'
                         AND    '||REC.NOME_COLONNA_CONFRONTO||' = ''S''') INTO nCont;

      IF nCont != 0 THEN
        bFound := TRUE;
        VetRecPratMant.EXTEND;
        VetRecPratMant(VetRecPratMant.COUNT) := TypRecPratMant(rec.ID_PRATICA_MANTENIMENTO);
      END IF;
    END LOOP;

    IF NOT bFound THEN
      FOR rec IN (SELECT PGM.ID_PRATICA_MANTENIMENTO
                  FROM   DB_GRUPPO_MANTENIMENTO GM,DB_R_PRATICA_GRUPPO_MANTENIMEN PGM
                  WHERE  GM.NOME_COLONNA_CONFRONTO IS NULL
                  AND    GM.ID_GRUPPO_MANTENIMENTO = PGM.ID_GRUPPO_MANTENIMENTO
                  AND    ((pFlagDefault            = 'S' AND PGM.FLAG_DEFAULT = 'S') OR
                          (NVL(pFlagDefault,'N')   = 'N' AND PGM.FLAG_DEFAULT IN ('S','N')))) LOOP

        VetRecPratMant.EXTEND;
        VetRecPratMant(VetRecPratMant.COUNT) := TypRecPratMant(rec.ID_PRATICA_MANTENIMENTO);
      END LOOP;
    END IF;
  END IF;

  RETURN VetRecPratMant;
END getListIdPraticaMantenimento;

-- permette di inserire un vincolo su un conto corrente passato in input, rendendolo esclusivo rispetto
-- alla pratica che pone il vincolo su di esso
PROCEDURE vincoloContoCorrente(pIdAzienda                         DB_AZIENDA.ID_AZIENDA%TYPE,
                               pIdContoCorrente                   DB_CONTO_CORRENTE.ID_CONTO_CORRENTE%TYPE,
                               pIdProcedimentoVincolo             DB_TIPO_PROCEDIMENTO.ID_PROCEDIMENTO%TYPE,
                               pIdPraticaVincolo                  DB_CONTO_CORRENTE_VINCOLO.EXT_ID_PRATICA_VINCOLO%TYPE,
                               pIdentificativoPraticaVincolo      DB_CONTO_CORRENTE_VINCOLO.IDENTIFICATIVO_PRATICA_VINCOLO%TYPE,
                               pRisultato                     OUT VARCHAR2,
                               pMessaggio                     OUT VARCHAR2) IS
  ERRORE  EXCEPTION;
  recCc   DB_CONTO_CORRENTE%ROWTYPE;
BEGIN
  pRisultato := '0';
  pMessaggio := NULL;

  IF pIdAzienda             IS NULL OR
     pIdContoCorrente       IS NULL OR
     pIdProcedimentoVincolo IS NULL THEN

    pMessaggio := 'Uno o piu'' parametri di input obbligatori sono nulli';
    RAISE ERRORE;
  END IF;

  BEGIN
    SELECT *
    INTO   recCc
    FROM   DB_CONTO_CORRENTE
    WHERE  ID_CONTO_CORRENTE = pIdContoCorrente;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      pMessaggio := 'Il conto corrente passato in input non esiste';
      RAISE ERRORE;
  END;

  IF recCc.ID_AZIENDA != pIdAzienda THEN
    pMessaggio := 'Il conto corrente passato in input non e'' collegato all''azienda indicata in input';
    RAISE ERRORE;
  END IF;

  IF recCc.DATA_FINE_VALIDITA IS NOT NULL THEN
    pMessaggio := 'Il conto corrente passato in input non e'' piu'' attivo';
    RAISE ERRORE;
  END IF;

  IF recCc.DATA_ESTINZIONE IS NOT NULL THEN
    pMessaggio := 'Il conto corrente passato in input e'' estinto';
    RAISE ERRORE;
  END IF;

  IF recCc.FLAG_CONTO_VINCOLATO = 'S' THEN
    pMessaggio := 'Il conto corrente passato in input risulta gia'' vincolato';
    RAISE ERRORE;
  END IF;

  IF pIdPraticaVincolo IS NULL AND pIdentificativoPraticaVincolo IS NULL THEN
    pMessaggio := 'Deve essere valorizzato in input uno tra IdPraticaVincolo e IdentificativoPraticaVincolo';
    RAISE ERRORE;
  END IF;

  INSERT INTO DB_CONTO_CORRENTE_VINCOLO
  (ID_CONTO_CORRENTE_VINCOLO, ID_CONTO_CORRENTE, DT_INIZIO_VINCOLO,EXT_ID_PROCEDIMENTO_VINCOLO,
   EXT_ID_PRATICA_VINCOLO, IDENTIFICATIVO_PRATICA_VINCOLO)
  VALUES
  (SEQ_DB_CONTO_CORRENTE_VINCOLO.NEXTVAL,pIdContoCorrente,SYSDATE,pIdProcedimentoVincolo,
   pIdPraticaVincolo,pIdentificativoPraticaVincolo);

  UPDATE DB_CONTO_CORRENTE
  SET    FLAG_CONTO_VINCOLATO = 'S'
  WHERE  ID_CONTO_CORRENTE    = pIdContoCorrente;

EXCEPTION
  WHEN ERRORE THEN
    pRisultato := '1';
  WHEN OTHERS THEN
    pRisultato := '1';
    pMessaggio := 'ERRORE DI SISTEMA = '||SQLERRM||' - RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
END vincoloContoCorrente;

-- permette di rimuovere il vincolo su un conto corrente passato in input, fornendone una motivazione
PROCEDURE svincoloContoCorrente(pIdAzienda                DB_AZIENDA.ID_AZIENDA%TYPE,
                                pIdContoCorrente          DB_CONTO_CORRENTE.ID_CONTO_CORRENTE%TYPE,
                                pMotivazioneSvincolo      VARCHAR2,
                                pRisultato            OUT VARCHAR2,
                                pMessaggio            OUT VARCHAR2) IS
  ERRORE  EXCEPTION;
  recCc   DB_CONTO_CORRENTE%ROWTYPE;
BEGIN
  pRisultato := '0';
  pMessaggio := NULL;

  IF pIdAzienda           IS NULL OR
     pIdContoCorrente     IS NULL OR
     pMotivazioneSvincolo IS NULL THEN

    pMessaggio := 'Uno o piu'' parametri di input obbligatori sono nulli';
    RAISE ERRORE;
  END IF;

  BEGIN
    SELECT *
    INTO   recCc
    FROM   DB_CONTO_CORRENTE
    WHERE  ID_CONTO_CORRENTE = pIdContoCorrente;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      pMessaggio := 'Il conto corrente passato in input non esiste';
      RAISE ERRORE;
  END;

  IF recCc.ID_AZIENDA != pIdAzienda THEN
    pMessaggio := 'Il conto corrente passato in input non e'' collegato all''azienda indicata in input';
    RAISE ERRORE;
  END IF;

  IF recCc.DATA_FINE_VALIDITA IS NOT NULL THEN
    pMessaggio := 'Il conto corrente passato in input non e'' piu'' attivo';
    RAISE ERRORE;
  END IF;

  IF recCc.DATA_ESTINZIONE IS NOT NULL THEN
    pMessaggio := 'Il conto corrente passato in input e'' estinto';
    RAISE ERRORE;
  END IF;

  IF recCc.FLAG_CONTO_VINCOLATO = 'N' THEN
    pMessaggio := 'Il conto corrente passato in input risulta gia'' svincolato';
    RAISE ERRORE;
  END IF;

  UPDATE DB_CONTO_CORRENTE_VINCOLO
  SET    DT_FINE_VINCOLO      = SYSDATE,
         MOTIVAZIONE_SVINCOLO = pMotivazioneSvincolo
  WHERE  ID_CONTO_CORRENTE    = pIdContoCorrente
  AND    DT_FINE_VINCOLO      IS NULL;

  UPDATE DB_CONTO_CORRENTE
  SET    FLAG_CONTO_VINCOLATO = 'N'
  WHERE  ID_CONTO_CORRENTE    = pIdContoCorrente;

EXCEPTION
  WHEN ERRORE THEN
    pRisultato := '1';
  WHEN OTHERS THEN
    pRisultato := '1';
    pMessaggio := 'ERRORE DI SISTEMA = '||SQLERRM||' - RIGA = '||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE;
END svincoloContoCorrente;

END Pck_Smrgaa_Libreria;

/
--------------------------------------------------------
--  DDL for Package Body PCK_SMRGAA_LOG
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_SMRGAA_LOG" AS
/**********************************************************************************
Libreria di gestione del Log per le procedure Batch di SMRGAA
**********************************************************************************/

   /*********************************************************************
    Ricerca il codice parametro nella tavola DB_PARAMENTRO e ne
    espone il valore
    Tipo:    function
    input:  pCodParamentro
    output: nessuno
    ritorno: VARCHAR2
    *********************************************************************/
    FUNCTION SelectValoreParametro (pCodParametro IN VARCHAR2) RETURN VARCHAR2 IS
        vValParametro DB_PARAMETRO.VALORE%TYPE;
    BEGIN

        SELECT VALORE
          INTO vValParametro
          FROM DB_PARAMETRO
         WHERE ID_PARAMETRO = pCodParametro;

        RETURN vValParametro;

    END SelectValoreParametro;

    /*********************************************************************
    Preleva l'ultimo record in ordine di DT_INIZIO_ESECUZIONE da SMRGAA_T_ESECUZIONE_BATCH
    in base ad un ID_APPLICAZIONE
    Tipo:     funzione esterna
    input:   pIdApplicazione
    output:  nessuno
    ritorno: SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE o NULL
    *********************************************************************/
    FUNCTION SelectTLastEsecuzione(pIdApplicazione SMRGAA_T_ESECUZIONE_BATCH.ID_APPLICAZIONE%TYPE) RETURN SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE IS

         recTEsecuzione SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE;

    BEGIN

        SELECT EB.*
          INTO recTEsecuzione
          FROM SMRGAA_T_ESECUZIONE_BATCH EB
         WHERE EB.id_applicazione = pIdApplicazione
           AND EB.dt_inizio_esecuzione = (SELECT MAX(dt_inizio_esecuzione)
                                            FROM SMRGAA_T_ESECUZIONE_BATCH
                                           WHERE id_applicazione = EB.id_applicazione);


        RETURN recTEsecuzione;

    EXCEPTION
      WHEN NO_DATA_FOUND THEN
            Pck_Smrgaa_Log.LogSqlError('SelectTLastEsecuzione - Nessun record trovato per pIdApplicazione : ' || pIdApplicazione );
            RETURN NULL;
      WHEN OTHERS THEN
            Pck_Smrgaa_Log.LogSqlError( 'SelectTLastEsecuzione - pIdApplicazione : ' || pIdApplicazione);
            RAISE;
    END SelectTLastEsecuzione;

    /*********************************************************************
    Preleva l'ultimo record in ordine di DT_INIZIO_ESECUZIONE da SMRGAA_T_ESECUZIONE_BATCH
    in base ad un ID_APPLICAZIONE che però abbia avuto esito = 0 (OK)
    Tipo:     funzione esterna
    input:   pIdApplicazione
    output:  nessuno
    ritorno: SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE o NULL
    *********************************************************************/
    FUNCTION SelectTLastEsecuzioneOK(pIdApplicazione SMRGAA_T_ESECUZIONE_BATCH.ID_APPLICAZIONE%TYPE) RETURN SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE IS

         recTEsecuzione SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE;

    BEGIN

        SELECT EB.*
          INTO recTEsecuzione
          FROM SMRGAA_T_ESECUZIONE_BATCH EB
         WHERE EB.id_applicazione = pIdApplicazione
           AND EB.flag_esito = 0
           AND EB.dt_inizio_esecuzione = (SELECT MAX(dt_inizio_esecuzione)
                                            FROM SMRGAA_T_ESECUZIONE_BATCH
                                           WHERE id_applicazione = EB.id_applicazione
                                             AND flag_esito = 0);

        RETURN recTEsecuzione;

    EXCEPTION
      WHEN NO_DATA_FOUND THEN
            Pck_Smrgaa_Log.LogSqlError('SelectTLastEsecuzioneOK - Nessun record trovato per pIdApplicazione : ' || pIdApplicazione );
            RETURN NULL;
      WHEN OTHERS THEN
            Pck_Smrgaa_Log.LogSqlError( 'SelectTLastEsecuzioneOK - pIdApplicazione : ' || pIdApplicazione);
            RAISE;
    END SelectTLastEsecuzioneOK;

    /*********************************************************************
    Preleva un record da SMRGAA_T_ESECUZIONE_BATCH in base ad un ID_APPLICAZIONE ed
    una data di riferimento prendendo un range massimo di 13 ora
    Tipo:     funzione esterna
    input:   pIdApplicazione , pDtRiferimento
    output:  nessuno
    ritorno: SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE o NULL
    *********************************************************************/
    FUNCTION SelectTEsecuzione(pIdApplicazione SMRGAA_T_ESECUZIONE_BATCH.ID_APPLICAZIONE%TYPE,
                               pDtRiferimento  SMRGAA_T_ESECUZIONE_BATCH.DT_INIZIO_ESECUZIONE%TYPE) RETURN SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE IS

         recTEsecuzione SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE;
         dDataDa        DATE;
         nOreAttesa     NUMBER(2);

    BEGIN

        BEGIN
/*
            SELECT VALORE
              INTO nOreAttesa
              FROM SMRGAA_C_CONFIGURAZIONE
             WHERE codice = knCodParOre;
*/
            nOreAttesa := 8;
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                 nOreAttesa := 8;
            WHEN TOO_MANY_ROWS THEN
                 nOreAttesa := 8;
        END;

        dDataDa := pDtRiferimento - (nOreAttesa / 24);

        SELECT *
          INTO recTEsecuzione
          FROM SMRGAA_T_ESECUZIONE_BATCH
         WHERE id_applicazione = pIdApplicazione
           AND dt_inizio_esecuzione BETWEEN dDataDa AND pDtRiferimento;


        RETURN recTEsecuzione;

    EXCEPTION
      WHEN NO_DATA_FOUND THEN
             DBMS_OUTPUT.PUT_LINE('SelectTEsecuzione - Nessun record trovato per pIdApplicazione : ' || pIdApplicazione || ', dDataDa : ' || TO_CHAR(dDataDa,'DD/MM/YYYY HH24:MI:SS') || ', pDtRiferimento : ' || TO_CHAR(pDtRiferimento,'DD/MM/YYYY HH24:MI:SS'));
             RETURN NULL;
      WHEN OTHERS THEN
             DBMS_OUTPUT.PUT_LINE('SelectTEsecuzione - pIdApplicazione : ' || pIdApplicazione || ', dDataDa : ' || TO_CHAR(dDataDa,'DD/MM/YYYY HH24:MI:SS') || ', pDtRiferimento : ' || TO_CHAR(pDtRiferimento,'DD/MM/YYYY HH24:MI:SS') || SUBSTR(SQLERRM,1,100));
           RAISE;
    END SelectTEsecuzione;

    /*********************************************************************
    Verifica se i batch da cui dipende quello corrente sono stati eseguiti in data SYSDATE
    Tipo:     funzione esterna
    input:   pIdApplicazione
    output:  nessuno
    ritorno: TRUE = Verifiche OK, FALSE = Verifiche KO
    *********************************************************************/
    FUNCTION VerificaDipendenzeBatch (pIdApplicazione SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE) RETURN BOOLEAN IS

        bRet      BOOLEAN:=TRUE;
        recTEsec SMRGAA_T_ESECUZIONE_BATCH%ROWTYPE;


        CURSOR curDipendenze IS
           SELECT *
                FROM SMRGAA_R_VINCOLI_BATCH
            WHERE ID_APPLICAZIONE = pIdApplicazione;

    BEGIN

         FOR recDipendenze IN curDipendenze LOOP
              recTEsec := SelectTEsecuzione (recDipendenze.id_applicazione_vincolo,SYSDATE);

             IF recTEsec.id_esecuzione IS NULL THEN
                 bRet := FALSE;
                DBMS_OUTPUT.PUT_LINE('VerificaDipendenzeBatch per ID_APPLICAZIONE = ' || pIDApplicazione || ' - Nessun Esecuzione con ID_APPLICAZIONE_VINCOLO = ' || recDipendenze.id_applicazione_vincolo || ' in data ' || TO_CHAR(SYSDATE,'DD/MM/YYYY'));
             ELSE
                  IF recTEsec.flag_esito <> 0 THEN
                     bRet := FALSE;
                    DBMS_OUTPUT.PUT_LINE('VerificaDipendenzeBatch per ID_APPLICAZIONE = ' || pIDApplicazione || ' - Esecuzione con ID_APPLICAZIONE_VINCOLO = ' || recDipendenze.id_applicazione_vincolo || ' in data ' || TO_CHAR(SYSDATE,'DD/MM/YYYY') || ' terminata con esito diverso da zero ( ' || recTEsec.flag_esito || ' )');
                 END IF;
             END IF;

         END LOOP;

         RETURN bRet;

    EXCEPTION
      WHEN OTHERS THEN
             DBMS_OUTPUT.PUT_LINE('VerificaDipendenzeBatch - pIdApplicazione : ' || pIdApplicazione || ' ' || SUBSTR(SQLERRM,1,200));
           RAISE;
    END VerificaDipendenzeBatch;

    /*********************************************************************
    Verifica di attivazione del BATCH
    Tipo:     funzione esterna
    input:   id_applicazione
    output:  pRecApplicazione
    ritorno: 0 Batch attivo, 1 Errore Oracle, 2 Batch non attivo, 3 dipendenze batch non verificate
    *********************************************************************/
    FUNCTION VerificaAttivazioneBatch( pIdApplicazione  IN  SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE,
                                       pRecApplicazione OUT SMRGAA_D_APPLICAZIONI_BATCH%ROWTYPE ) RETURN NUMBER IS

    BEGIN

      SELECT *
        INTO pRecApplicazione
        FROM SMRGAA_D_APPLICAZIONI_BATCH
       WHERE ID_APPLICAZIONE = pIdApplicazione;

      IF pRecApplicazione.dt_fine_validita IS NULL OR pRecApplicazione.dt_fine_validita >= TRUNC(SYSDATE) THEN
           -- controllo se il batch identificato dall'id_applicazione comporto
         -- che siano stati eseguiti precedentemente altri batch
           IF VerificaDipendenzeBatch(pIdApplicazione) THEN
               RETURN 0;
         ELSE
             RETURN 3;
         END IF;
      ELSE
         RETURN 2;
      END IF;

      EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('VerificaAttivazioneBatch - pIdApplicazione : ' || pIdApplicazione || ' ' || SUBSTR(SQLERRM,1,200));
            RETURN 1;

    END VerificaAttivazioneBatch;

    /*********************************************************************
    Inserimento nella tabella SMRGAA_T_ESECUZIONE_BATCH
    Tipo:    procedura esterna
    input:  pIdApplicazione
    output:  pIdEsecuzione
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertTEsecuzione( pIdApplicazione IN SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE,
                                  pIdEsecuzione     OUT SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE ) IS

    BEGIN

      SELECT SEQ_SMRGAA_T_ESECUZIONE_BATCH.NEXTVAL INTO pIdEsecuzione FROM DUAL;

      INSERT INTO SMRGAA_T_ESECUZIONE_BATCH
               (
               ID_ESECUZIONE,
               ID_APPLICAZIONE,
               DT_INIZIO_ESECUZIONE,
               DT_FINE_ESECUZIONE
             )
      VALUES (
                 pIdEsecuzione,
               pIdApplicazione,
               SYSDATE,
               NULL
               );

    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('InsertTEsecuzione - pIdApplicazione : ' || pIdApplicazione || ' pIdEsecuzione : ' || pIdEsecuzione || ' ' || SUBSTR(SQLERRM,1,100));
            RAISE;

    END InsertTEsecuzione;

    /*********************************************************************
    Inserimento nella tabella SMRGAA_R_SORICO_DATI
    Tipo:    procedura esterna
    input: pIdEsecuzione, pNomeFile, pDescrizione
    output: nessuno
    ritorno: nessuno
    *********************************************************************/
    PROCEDURE InsertRStoricoDati( pIdEsecuzione     IN SMRGAA_R_STORICODATI.ID_ESECUZIONE%TYPE,
                                   pNomeFile            IN SMRGAA_R_STORICODATI.NOME_FILE%TYPE,
                                  pDescrizioneDati  IN SMRGAA_R_STORICODATI.DESCRIZIONE_DATI%TYPE ) IS

      nIdStoricoDati SMRGAA_R_STORICODATI.ID_STORICO_DATI%TYPE;

    BEGIN

      SELECT SEQ_SMRGAA_R_STORICODATI.NEXTVAL INTO nIdStoricoDati FROM DUAL;

      INSERT INTO SMRGAA_R_STORICODATI
               (
               ID_STORICO_DATI,
               ID_ESECUZIONE,
               NOME_FILE,
               DESCRIZIONE_DATI
             )
      VALUES (
                 nIdStoricoDati,
               pIdEsecuzione,
               pNomeFile,
               pDescrizioneDati
               );

    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('InsertTEsecuzione - pIdEsecuzione : ' || pIdEsecuzione || ' pNomeFile : ' || pNomeFile || ' pDescrizioneDati : ' || pDescrizioneDati || ' ' || SUBSTR(SQLERRM,1,100));
            RAISE;

    END InsertRStoricoDati;

    /*********************************************************************
    Scrive il messaggio di log su tabella col relativo livello
    Tipo:    procedura interna
    *********************************************************************/
    PROCEDURE LogMessage( pLevel NUMBER, pMessage VARCHAR2 ) IS
        vLevel VARCHAR2(10) := 'XXXXXXXXXX';
        buffer_overflow EXCEPTION;
        PRAGMA EXCEPTION_INIT(buffer_overflow, -20000);
    BEGIN
        IF pLevel = kLevelDebug THEN
            vLevel := kvLevelDebug;
        ELSIF pLevel = kLevelInfo THEN
            vLevel := kvLevelInfo;
        ELSIF pLevel = kLevelAnomalia THEN
            vLevel := kvLevelAnomalia;
        ELSIF pLevel = kLevelError THEN
            vLevel := kvLevelError;
        END IF;

        INSERT INTO SMRGAA_L_LOG_BATCH
           ( ID_LOG_BATCH,        -- 1
                LIVELLO,            -- 2
             ID_ESECUZIONE,        -- 3
             DATA,                -- 4
             MESSAGGIO            -- 5
            )
        VALUES
           ( SEQ_SMRGAA_L_LOG_BATCH.NEXTVAL,  -- 1
                vLevel,                       -- 2
             nIdEsecuzione,                   -- 3
             SYSDATE,                       -- 4
             '[' || SUBSTR(vStep,1,30) || '] ' || SUBSTR(pMessage,1,450)  -- 5
            );

        DBMS_OUTPUT.PUT_LINE( TO_CHAR(SYSDATE,'HH24:MI:SS') || ' [' || nBatch || '-' || vStep || '] ' || vLevel || ': ' || SUBSTR(pMessage,1,200) );

    EXCEPTION
        WHEN buffer_overflow THEN
             DBMS_OUTPUT.DISABLE;
             DBMS_OUTPUT.ENABLE(1000000); -- resetto il buffer
             DBMS_OUTPUT.PUT_LINE( TO_CHAR(SYSDATE,'HH24:MI:SS') || ' [' || nBatch || '-' || vStep || '] ' || vLevel || ': ' || SUBSTR(pMessage,1,200) ); -- provo a riscrivere la riga su DBMS_OUTPUT

    END LogMessage;

    /*********************************************************************
    Setta il livello di Log corrente
    Tipo:    procedura esterna
    Input:     livello di log (vedi costanti sopra)
    Output: nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE SetLogLevel( pLevel NUMBER ) IS
    BEGIN
        nLevel := pLevel;
    END SetLogLevel;

    /*********************************************************************
    Inizializza il nome del batch (id applicazione) e lo step corrente
    Tipo:    procedura esterna
    Input:     id del batch, nome dello step
    Output: nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE Init( pBatch NUMBER, pStep VARCHAR2 ) IS
    BEGIN
        nBatch := pBatch;
        vStep  := pStep;
        -- imposto il buffer per DBMS_OUPUT ad 1.000.0000 di bytes
        -- il massimo disponibile
        DBMS_OUTPUT.ENABLE(1000000);
    END Init;

    /*********************************************************************
    Scrive nel log un messaggio di debug
    Tipo:    procedura esterna
    Input:    messaggio da loggare
    Output:    nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE LogDebug( pMessage VARCHAR2 ) IS
    BEGIN
        IF nLevel <= kLevelDebug THEN
            LogMessage( kLevelDebug, pMessage );
        END IF;
    END LogDebug;

    /*********************************************************************
    Scrive nel log un messaggio di informazione
    Tipo:    procedura esterna
    Input:    messaggio da loggare
    Output:    nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE LogInfo( pMessage VARCHAR2 ) IS
    BEGIN
        IF nLevel <= kLevelInfo THEN
            LogMessage( kLevelInfo, pMessage );
        END IF;
    END LogInfo;

    /*********************************************************************
    Scrive nel log un messaggio di anomalia
    Tipo:    procedura esterna
    Input:    messaggio da loggare
    Output:    nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE LogAnomalia( pMessage VARCHAR2 ) IS
    BEGIN
        IF nLevel <= kLevelAnomalia THEN
            LogMessage( kLevelAnomalia, pMessage );
        END IF;
    END LogAnomalia;

    /*********************************************************************
    Scrive nel log un messaggio di errore
    Tipo:    procedura esterna
    Input:    messaggio da loggare
    Output:    nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE LogError( pMessage VARCHAR2 ) IS
    BEGIN
        IF nLevel <= kLevelError THEN
            LogMessage( kLevelError, pMessage );
        END IF;
    END LogError;

    /*********************************************************************
    Scrive nel log un messaggio di errore con SQLCODE e SQLERRM
    Tipo:    procedura esterna
    Input:    messaggio da loggare
    Output:    nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE LogSqlError( pMessage VARCHAR2 ) IS
    BEGIN
        LogError( pMessage || ' - Errore: ' || SQLERRM );
    END LogSqlError;

    /*********************************************************************
    Svuota la tabella SMRGAA_L_LOG_BATCH
    Tipo:    procedura esterna
    Input:     nessuno
    Output: nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE ClearAllLog IS
    BEGIN
        DELETE FROM SMRGAA_L_LOG_BATCH;
    END ClearAllLog;

    /***************************************************************************
    ScriviFileEsecuzione
    Tipo: procedura esterna
    Input : pFileBatchEsecuzione, pPathFileDB, pIdEsecuzione
    Output:    nessuno
    Return:    nessuno
    ***************************************************************************/
    PROCEDURE ScriviFileEsecuzione ( pFileBatchEsecuzione IN VARCHAR2,
                                        pPathFileDB           IN VARCHAR2,
                                        pIdEsecuzione          IN NUMBER ) IS

      fpFileEsecuzione    UTL_FILE.FILE_TYPE;

    BEGIN

      fpFileEsecuzione := UTL_FILE.FOPEN (pPathFileDB, pFileBatchEsecuzione, 'W');

        UTL_FILE.PUT_LINE (fpFileEsecuzione, TO_CHAR(pIdEsecuzione));

         UTL_FILE.FCLOSE(fpFileEsecuzione);

    EXCEPTION
      WHEN OTHERS THEN

        IF UTL_FILE.IS_OPEN(fpFileEsecuzione) THEN
           UTL_FILE.FCLOSE(fpFileEsecuzione);
        END IF;

        DBMS_OUTPUT.PUT_LINE('ScriviFileEsecuzione - pIdEsecuzione : ' || pIdEsecuzione || ' ' || SUBSTR(SQLERRM,1,200));

        RAISE;

    END ScriviFileEsecuzione;

    /***************************************************************************
    LeggiFileEsecuzione
    Tipo: procedura esterna
    Output:    nessuno
    Return:    nessuno
    ***************************************************************************/
    PROCEDURE LeggiFileEsecuzione ( pFileBatchEsecuzione IN VARCHAR2,
                                       pPathFileDB          IN VARCHAR2 ) IS

      fpFileEsecuzione    UTL_FILE.FILE_TYPE;
      vBufferInput         VARCHAR2(255);

    BEGIN

      fpFileEsecuzione := UTL_FILE.FOPEN (pPathFileDB, pFileBatchEsecuzione, 'R');

      UTL_FILE.GET_LINE(fpFileEsecuzione,vBufferInput);

      UTL_FILE.FCLOSE(fpFileEsecuzione);

      nIdEsecuzione := TO_NUMBER(vBufferInput);

    EXCEPTION
      WHEN OTHERS THEN
        IF UTL_FILE.IS_OPEN(fpFileEsecuzione) THEN
           UTL_FILE.FCLOSE(fpFileEsecuzione);
        END IF;

        DBMS_OUTPUT.PUT_LINE('LeggiFileEsecuzione - pFileBatchEsecuzione/pPathFileDB : ' || pFileBatchEsecuzione || '/' || pPathFileDB || ' ' || SUBSTR(SQLERRM,1,100));
        RAISE;

    END LeggiFileEsecuzione;

    /*********************************************************************
    Aggiorna a zero l'esito di un'esecuzione di batch censita su SMRGAA_T_ESECUZIONE_BATCH
    Tipo:    funzione interna
    Input:    pLevel, pFileBatchEsecuzione, pPathFileDb
    Output:    nessuno
    Return:    0 = OK , 1 = KO
    *********************************************************************/
    FUNCTION ValorizzaEsitoBatch(pLevel               IN NUMBER,
                                   pFileBatchEsecuzione IN VARCHAR2,
                                 pPathFileDB           IN VARCHAR2) RETURN NUMBER IS
    BEGIN

         IF Pck_Smrgaa_Log.nIdEsecuzione IS NULL THEN

              Pck_Smrgaa_Log.SetLogLevel(pLevel);
            -- essendo trasversale a più batch non valorizzo la variabile nBatch ...
            Pck_Smrgaa_Log.Init( NULL, 'ValorizzaEsitoBatch' );

              Pck_Smrgaa_Log.LeggiFileEsecuzione ( pFileBatchEsecuzione, pPathFileDB );

         END IF;

         Pck_Smrgaa_Log.LogInfo('Inizio Elaborazione x pFileBatchEsecuzione = ' || pFileBatchEsecuzione || ', nIdEsecuzione = ' || TO_CHAR(nIdEsecuzione));

         UPDATE SMRGAA_T_ESECUZIONE_BATCH
             SET    FLAG_ESITO = 0
          WHERE ID_ESECUZIONE = nIdEsecuzione;

         Pck_Smrgaa_Log.LogInfo('Fine Elaborazione');

         COMMIT;

         RETURN 0;

    EXCEPTION
        WHEN OTHERS THEN
            Pck_Smrgaa_Log.LogSqlError( 'ValorizzaEsitoBatch - pFileBatchEsecuzione = ' ||pFileBatchEsecuzione || ', nIdEsecuzione = ' || TO_CHAR(nIdEsecuzione));
            RETURN 1;
    END ValorizzaEsitoBatch;

    /*********************************************************************
    Dato un pIdEsecuzione ritorna l'esito del BATCH eseguito (0 = OK , <> 0 = KO)
    Tipo:    funzione interna
    Input:    pIdEsecuzione
    Output:    nessuno
    Return:    0 = OK , 1 = KO
    *********************************************************************/
    FUNCTION EsecuzioneOk(pIdEsecuzione IN NUMBER) RETURN NUMBER IS
         nFlagEsito NUMBER;
    BEGIN

         SELECT Flag_Esito
           INTO nFlagEsito
           FROM SMRGAA_T_ESECUZIONE_BATCH
          WHERE ID_ESECUZIONE = pIdEsecuzione;

         RETURN NVL(nFlagEsito,1);

    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('EsecuzioneOk - pIdEsecuzione : ' || pIdEsecuzione || ' ' || SUBSTR(SQLERRM,1,100));
            RETURN 1;
    END EsecuzioneOk;

    /*********************************************************************
    Aggiorna a zero l'esito di un'esecuzione di batch censita su SMRGAA_T_ESECUZIONE_BATCH
    da richiamare per shell con un solo step PL/SQL
    Tipo:    procedure
    Input:    nessuno
    Output:    nessuno
    Return:    nessuno
    *********************************************************************/
    PROCEDURE ValorizzaEsitoBatch IS
    BEGIN

         UPDATE SMRGAA_T_ESECUZIONE_BATCH
             SET    FLAG_ESITO = 0,
                DT_FINE_ESECUZIONE = SYSDATE
          WHERE ID_ESECUZIONE = nIdEsecuzione;

    EXCEPTION
        WHEN OTHERS THEN
            Pck_Smrgaa_Log.LogSqlError( 'ValorizzaEsitoBatch , nIdEsecuzione = ' || TO_CHAR(nIdEsecuzione));
            RAISE;
    END ValorizzaEsitoBatch;

    /*********************************************************************
    Dato un id_applicazione ritorna il vettore di parametri che servono
    al batch per operare
    Tipo:    procedure
    Input:    pIdApplicazione
    Output:    nessuno
    Return:    TypVetParametriApplicazione
    *********************************************************************/
   FUNCTION CaricaParametriApplicazione (pIdApplicazione IN SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE)
   RETURN TypVetParametriApplicazione IS

        CURSOR curParametri IS
        SELECT *
          FROM SMRGAA_R_PARAM_APPLICAZIONE
         WHERE ID_APPLICAZIONE = pIdApplicazione;

        CURSOR curParametriVettore (pIDParametroApplicazione IN SMRGAA_R_PARAM_APPLICAZIONE.ID_PARAMETRO_APPLICAZIONE%TYPE) IS
        SELECT *
          FROM SMRGAA_R_VALORE_PARAM_VETTORE
         WHERE ID_PARAMETRO_APPLICAZIONE = pIDParametroApplicazione;


        vetParametri TypVetParametriApplicazione;
        nCont        NUMBER:=0;

   BEGIN

       FOR recParametri IN curParametri LOOP

            vetParametri(recParametri.COD_PARAMETRO).TIPO_PARAM := recParametri.TIPO_PARAMETRO;
            vetParametri(recParametri.COD_PARAMETRO).VAL_VARCHAR2 := recParametri.VALORE_VARCHAR2;
            vetParametri(recParametri.COD_PARAMETRO).VAL_DATE := recParametri.VALORE_DATE;
            vetParametri(recParametri.COD_PARAMETRO).VAL_NUMBER := recParametri.VALORE_NUMBER;

            IF recParametri.TIPO_PARAMETRO = 'V' THEN
               FOR recParametriVettore IN curParametriVettore (recParametri.id_parametro_applicazione) LOOP
                   nCont := nCont + 1;
                   vetParametri(recParametri.COD_PARAMETRO).VETTORE (nCont).TIPO_PARAM := recParametriVettore.TIPO_VALORE;
                   vetParametri(recParametri.COD_PARAMETRO).VETTORE (nCont).VAL_VARCHAR2 := recParametriVettore.VALORE_VARCHAR2;
                   vetParametri(recParametri.COD_PARAMETRO).VETTORE (nCont).VAL_DATE := recParametriVettore.VALORE_DATE;
                   vetParametri(recParametri.COD_PARAMETRO).VETTORE (nCont).VAL_NUMBER := recParametriVettore.VALORE_NUMBER;
               END LOOP;
            END IF;

       END LOOP;

       RETURN vetParametri;

   EXCEPTION
         WHEN OTHERS THEN
            Pck_Smrgaa_Log.LogSqlError( 'CaricaParametriApplicazione , pIdApplicazione = ' || pIdApplicazione );
            RAISE;
   END CaricaParametriApplicazione;

    /*********************************************************************
    Dato un id_applicazione ed un codice parametro elimina quest'ultimo
    dai parametri dell'applicazione
    Tipo:    procedure
    Input:    pIdApplicazione
    Output:    nessuno
    Return:    TypVetParametriApplicazione
    *********************************************************************/
    PROCEDURE EliminaParametroApplicazione (pIdApplicazione IN SMRGAA_R_PARAM_APPLICAZIONE.ID_APPLICAZIONE%TYPE,
                                            pCodParametro   IN SMRGAA_R_PARAM_APPLICAZIONE.COD_PARAMETRO%TYPE
                                           ) IS
        VIOLAZIONE_FK EXCEPTION;
        PRAGMA EXCEPTION_INIT(VIOLAZIONE_FK, -02292);
    BEGIN

        DELETE
          FROM SMRGAA_R_PARAM_APPLICAZIONE
         WHERE ID_APPLICAZIONE = pIdApplicazione
           AND COD_PARAMETRO = pCodParametro;

        Pck_Smrgaa_Log.LogDebug ('EliminaParametroApplicazione - pCodParametro = ' || pCodParametro || ' ' || SQL%ROWCOUNT || ' records eliminati');

    EXCEPTION
         WHEN VIOLAZIONE_FK THEN
              DELETE
                FROM SMRGAA_R_VALORE_PARAM_VETTORE
               WHERE ID_PARAMETRO_APPLICAZIONE IN (SELECT ID_PARAMETRO_APPLICAZIONE
                                                     FROM SMRGAA_R_PARAM_APPLICAZIONE
                                                    WHERE ID_APPLICAZIONE = pIdApplicazione
                                                      AND COD_PARAMETRO = pCodParametro);

              DELETE
                FROM SMRGAA_R_PARAM_APPLICAZIONE
               WHERE ID_APPLICAZIONE = pIdApplicazione
                 AND COD_PARAMETRO = pCodParametro;

            Pck_Smrgaa_Log.LogDebug ('EliminaParametroApplicazione - pCodParametro = ' || pCodParametro || ' ' || SQL%ROWCOUNT || ' records eliminati');

         WHEN OTHERS THEN
              Pck_Smrgaa_Log.LogSqlError( 'EliminaParametroApplicazione , pIdApplicazione / pCodParametro= ' || pIdApplicazione || '/' || pCodParametro);
              RAISE;
    END EliminaParametroApplicazione;

    /*********************************************************************
    Dato un id_applicazione storicizza i parametri di esecuzione su SMRGAA_T_ESECUZIONE_PARAMETRO
    Tipo:    procedure
    Input:    pIdApplicazione
    Output:    nessuno
    Return:    nessuno
    *********************************************************************/
   PROCEDURE StoricizzaParametri (pIDApplicazione IN SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE) IS
   BEGIN

       INSERT INTO SMRGAA_T_ESECUZIONE_PARAMETRO
            (
             ID_ESECUZIONE_PARAMETRO,
             ID_ESECUZIONE,
             COD_PARAMETRO,
             DESCRIZIONE_PARAMETRO,
             TIPO_PARAMETRO,
             VALORE_VARCHAR2,
             VALORE_NUMBER,
             VALORE_DATE
            )
       SELECT SEQ_SMRGAA_T_ESECUZ_PARAMETRO.nextval,
              nIdEsecuzione,
              COD_PARAMETRO,
              DESCRIZIONE_PARAMETRO,
              TIPO_PARAMETRO,
              VALORE_VARCHAR2,
              VALORE_NUMBER,
              VALORE_DATE
         FROM SMRGAA_R_PARAM_APPLICAZIONE
        WHERE ID_APPLICAZIONE = pIdApplicazione
          AND TIPO_PARAMETRO IN ('S','D','N');

       INSERT INTO SMRGAA_T_ESECUZIONE_PARAMETRO
            (
             ID_ESECUZIONE_PARAMETRO,
             ID_ESECUZIONE,
             COD_PARAMETRO,
             DESCRIZIONE_PARAMETRO,
             TIPO_PARAMETRO,
             VALORE_VARCHAR2,
             VALORE_NUMBER,
             VALORE_DATE
            )
       SELECT SEQ_SMRGAA_T_ESECUZ_PARAMETRO.nextval,
              nIdEsecuzione,
              PA.COD_PARAMETRO,
              PA.DESCRIZIONE_PARAMETRO,
              VPV.TIPO_VALORE,
              VPV.VALORE_VARCHAR2,
              VPV.VALORE_NUMBER,
              VPV.VALORE_DATE
         FROM SMRGAA_R_PARAM_APPLICAZIONE PA,
              SMRGAA_R_VALORE_PARAM_VETTORE VPV
        WHERE PA.ID_APPLICAZIONE = pIdApplicazione
          AND PA.TIPO_PARAMETRO = 'V'
          AND PA.ID_PARAMETRO_APPLICAZIONE = VPV.ID_PARAMETRO_APPLICAZIONE;

   EXCEPTION
        WHEN OTHERS THEN
            Pck_Smrgaa_Log.LogSqlError( 'StoricizzaParametri , IdApplicazione / IdEsecuzione = ' || pIdApplicazione || '/' || nIdEsecuzione);
            RAISE;
   END StoricizzaParametri;

   /*********************************************************************
   Disabilita le foreign key basate sulla chiave primaria delle tavole
   delle esecuzioni BATCH :  SMRGAA_T_ESECUZIONE_BATCH
   Tipo:    procedura
   input:    nessuno
   output: nessuno
   ritorno: nessuno
   *********************************************************************/
   PROCEDURE DisableConstraint IS

        CURSOR CurConsDisab IS
        SELECT table_name, constraint_name
          FROM user_constraints
         WHERE r_constraint_name IN
              (SELECT constraint_name
                 FROM user_constraints
                WHERE table_name IN ('SMRGAA_T_ESECUZIONE_BATCH')
                  AND constraint_type = 'P');
         vComando VARCHAR2(500);
   BEGIN

        FOR recCons IN CurConsDisab LOOP
            vComando := 'ALTER TABLE '||recCons.TABLE_NAME||' DISABLE CONSTRAINT '||recCons.CONSTRAINT_NAME;
            EXECUTE IMMEDIATE (vComando);
        END LOOP;

   EXCEPTION
        WHEN OTHERS THEN
             Pck_Smrgaa_Log.LogSqlError( 'DisableConstraint - vComando = ' || vComando);
             RAISE;
   END DisableConstraint;

   /*********************************************************************
   Abilita le foreign key basate sulla chiave primaria delle tavole
   delle esecuzioni BATCH :  SMRGAA_T_ESECUZIONE_BATCH
   Tipo:    procedura
   input:    nessuno
   output: nessuno
   ritorno: nessuno
   *********************************************************************/
   PROCEDURE EnableConstraint IS

        CURSOR CurConsDisab IS
        SELECT table_name, constraint_name
          FROM user_constraints
         WHERE r_constraint_name IN
              (SELECT constraint_name
                 FROM user_constraints
                WHERE table_name IN ('SMRGAA_T_ESECUZIONE_BATCH')
                  AND constraint_type = 'P');
         vComando VARCHAR2(500);
   BEGIN

        FOR recCons IN CurConsDisab LOOP
            vComando := 'ALTER TABLE '||recCons.TABLE_NAME||' ENABLE CONSTRAINT '||recCons.CONSTRAINT_NAME;
            EXECUTE IMMEDIATE (vComando);
        END LOOP;

   EXCEPTION
        WHEN OTHERS THEN
             Pck_Smrgaa_Log.LogSqlError( 'EnableConstraint - vComando = ' || vComando);
             RAISE;
   END EnableConstraint;

   /*********************************************************************
   Effettua la riorganizzazione di tutte le tavole legate all'esecuzione
   dei BATCH interessate da cancellazioni e dei corrispettivi indici
   e poi ricalcola le statistiche
   Tipo:    procedura
   input:    nessuno
   output: nessuno
   ritorno: nessuno
   *********************************************************************/
   PROCEDURE RiorganizzaTabelleSvecchiate IS
      CURSOR curTabelleSvecchiate IS
      SELECT *
        FROM USER_TABLES
       WHERE TABLE_NAME IN ('SMRGAA_T_ESECUZIONE_PARAMETRO',
                            'SMRGAA_L_LOG_BATCH',
                            'SMRGAA_R_STORICODATI',
                            'SMRGAA_T_ESECUZIONE_BATCH');

      CURSOR curIndiciTabelleSvecchiate IS
      SELECT *
        FROM USER_INDEXES
       WHERE TABLE_NAME IN ('SMRGAA_T_ESECUZIONE_PARAMETRO',
                            'SMRGAA_L_LOG_BATCH',
                            'SMRGAA_R_STORICODATI',
                            'SMRGAA_T_ESECUZIONE_BATCH');

      vComando VARCHAR2(500);

   BEGIN

      Pck_Smrgaa_Log.LogInfo ('Inizio ricostruzione tabelle esecuzioni batch');

      FOR recTabelleSvecchiate IN curTabelleSvecchiate LOOP
          vComando := 'ALTER TABLE '||recTabelleSvecchiate.TABLE_NAME||' MOVE TABLESPACE ' || recTabelleSvecchiate.TABLESPACE_NAME;
          EXECUTE IMMEDIATE (vComando);
      END LOOP;

      FOR recIndiciTabelleSvecchiate IN curIndiciTabelleSvecchiate LOOP
          vComando := 'ALTER INDEX '||recIndiciTabelleSvecchiate.INDEX_NAME||' REBUILD TABLESPACE ' || recIndiciTabelleSvecchiate.TABLESPACE_NAME ;
          EXECUTE IMMEDIATE (vComando);
      END LOOP;

      Pck_Smrgaa_Log.LogInfo ('Ricostruzione tabelle esecuzioni batch completata');

      Pck_Smrgaa_Log.LogInfo ('Inizio ricalcolo delle statistiche delle tabelle riorganizzate');
      Pck_Smrgaa_Log.LogInfo ('Inizio ricalcolo statistiche tabelle SMRGAA_T_ESECUZIONE_PARAMETRO');
      DBMS_STATS.GATHER_TABLE_STATS(OwnName  => 'SMRGAA', TabName   => 'SMRGAA_T_ESECUZIONE_PARAMETRO',DEGREE => 4,CASCADE => TRUE);
      Pck_Smrgaa_Log.LogInfo ('Ricalcolo statistiche tabelle SMRGAA_T_ESECUZIONE_PARAMETRO terminato');
      Pck_Smrgaa_Log.LogInfo ('Inizio ricalcolo statistiche tabelle SMRGAA_L_LOG_BATCH');
      DBMS_STATS.GATHER_TABLE_STATS(OwnName  => 'SMRGAA', TabName   => 'SMRGAA_L_LOG_BATCH',DEGREE => 4,CASCADE => TRUE);
      Pck_Smrgaa_Log.LogInfo ('Ricalcolo statistiche tabelle SMRGAA_L_LOG_BATCH terminato');
      Pck_Smrgaa_Log.LogInfo ('Inizio ricalcolo statistiche tabelle SMRGAA_R_STORICODATI');
      DBMS_STATS.GATHER_TABLE_STATS(OwnName  => 'SMRGAA', TabName   => 'SMRGAA_R_STORICODATI',DEGREE => 4,CASCADE => TRUE);
      Pck_Smrgaa_Log.LogInfo ('Ricalcolo statistiche tabelle SMRGAA_R_STORICODATI terminato');
      Pck_Smrgaa_Log.LogInfo ('Inizio ricalcolo statistiche tabelle SMRGAA_T_ESECUZIONE_BATCH');
      DBMS_STATS.GATHER_TABLE_STATS(OwnName  => 'SMRGAA', TabName   => 'SMRGAA_T_ESECUZIONE_BATCH',DEGREE => 4,CASCADE => TRUE);
      Pck_Smrgaa_Log.LogInfo ('Ricalcolo statistiche tabelle SMRGAA_T_ESECUZIONE_BATCH terminato');
      Pck_Smrgaa_Log.LogInfo ('Fine ricalcolo delle statistiche delle tabelle riorganizzate');

   EXCEPTION
      WHEN OTHERS THEN
             Pck_Smrgaa_Log.LogSqlError( 'RiorganizzaTabelleSvecchiate - vComando = ' || vComando);
             RAISE;
   END RiorganizzaTabelleSvecchiate;

   /*********************************************************************
   Dato un id_esecuzione cancella tutti i record della tabella
   SMRGAA_R_STORICODATI ad esso legati
   Tipo:    procedura
   input:    pIdEsecuzione
   output: nessuno
   ritorno: nessuno
   *********************************************************************/
   PROCEDURE CancellaRStoricoDati (pIdEsecuzione IN SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE) IS
   BEGIN

      DELETE
        FROM SMRGAA_R_STORICODATI
       WHERE ID_ESECUZIONE = pIdEsecuzione;

      Pck_Smrgaa_Log.LogInfo ('ID_ESECUZIONE : ' || pIdEsecuzione || ' cancellate ' || SQL%ROWCOUNT || ' righe da SMRGAA_R_STORICODATI');

      COMMIT;

   EXCEPTION
      WHEN OTHERS THEN
             Pck_Smrgaa_Log.LogSqlError( 'CancellaRStoricoDati - pIdEsecuzione = ' || pIdEsecuzione);
             RAISE;
   END CancellaRStoricoDati;

   /*********************************************************************
   Dato un id_esecuzione cancella tutti i record della tabella
   SMRGAA_T_ESECUZIONE_PARAMETRO ad esso legati
   Tipo:    procedura
   input:    pIdEsecuzione
   output: nessuno
   ritorno: nessuno
   *********************************************************************/
   PROCEDURE CancellaTEsecuzioneParametro (pIdEsecuzione IN SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE) IS
   BEGIN

      DELETE
        FROM SMRGAA_T_ESECUZIONE_PARAMETRO
       WHERE ID_ESECUZIONE = pIdEsecuzione;

      Pck_Smrgaa_Log.LogInfo ('ID_ESECUZIONE : ' || pIdEsecuzione || ' cancellate ' || SQL%ROWCOUNT || ' righe da SMRGAA_T_ESECUZIONE_PARAMETRO');

      COMMIT;

   EXCEPTION
      WHEN OTHERS THEN
             Pck_Smrgaa_Log.LogSqlError( 'CancellaTEsecuzioneParametro - pIdEsecuzione = ' || pIdEsecuzione);
             RAISE;
   END CancellaTEsecuzioneParametro;

   /*********************************************************************
   Dato un id_esecuzione cancella tutti i record della tabella
   SMRGAA_L_LOG_BATCH ad esso legati
   Tipo:    procedura
   input:    pIdEsecuzione
   output: nessuno
   ritorno: nessuno
   *********************************************************************/
   PROCEDURE CancellaLLogBatch (pIdEsecuzione IN SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE) IS
   BEGIN

      DELETE
        FROM SMRGAA_L_LOG_BATCH
       WHERE ID_ESECUZIONE = pIdEsecuzione;

      Pck_Smrgaa_Log.LogInfo ('ID_ESECUZIONE : ' || pIdEsecuzione || ' cancellate ' || SQL%ROWCOUNT || ' righe da SMRGAA_L_LOG_BATCH');

      COMMIT;

   EXCEPTION
      WHEN OTHERS THEN
             Pck_Smrgaa_Log.LogSqlError( 'CancellaLLogBatch - pIdEsecuzione = ' || pIdEsecuzione);
             RAISE;
   END CancellaLLogBatch;


   /*********************************************************************
   Dato un id_esecuzione cancella tutti i record della tabella
   SMRGAA_T_ESECUZIONE_BATCH ad esso legati
   Tipo:    procedura
   input:    pIdEsecuzione
   output: nessuno
   ritorno: nessuno
   *********************************************************************/
   PROCEDURE CancellaTEsecuzioneBatch (pIdEsecuzione IN SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE) IS
   BEGIN

      DELETE
        FROM SMRGAA_T_ESECUZIONE_BATCH
       WHERE ID_ESECUZIONE = pIdEsecuzione;

      Pck_Smrgaa_Log.LogInfo ('ID_ESECUZIONE : ' || pIdEsecuzione || ' cancellate ' || SQL%ROWCOUNT || ' righe da SMRGAA_T_ESECUZIONE_BATCH');

      COMMIT;

   EXCEPTION
      WHEN OTHERS THEN
             Pck_Smrgaa_Log.LogSqlError( 'CancellaTEsecuzioneBatch - pIdEsecuzione = ' || pIdEsecuzione);
             RAISE;
   END CancellaTEsecuzioneBatch;

   /*********************************************************************
   Reperisce i due parametri che contengono rispettivamente
   la data fino a cui svecchiare le esecuzioni e l'eventuale id_applicazione
   (facoltativo) e cancella da SMRGAA_T_ESECUZIONE e figlie i record ad essi
   relativi, poi effettua la riorganizzazione delle tabelle svecchiate e dei
   relativi indici
   Tipo:    funzione
   input:    nessuno
   output: nessuno
   ritorno: 0 OK, 1 KO
   *********************************************************************/
   FUNCTION SvecchiamentoEsecuzioni RETURN NUMBER IS
        -- record di appoggio per il reperimento dei dati dell'applicazione corrente
        recDApplicazione    SMRGAA_D_APPLICAZIONI_BATCH%ROWTYPE;
        -- conterrà l'id esecuzione
        nIdEsecuzione       SMRGAA_T_ESECUZIONE_BATCH.ID_ESECUZIONE%TYPE;
        -- conterrà il codice di ritorno
        nRetCode            NUMBER(1):=0;
        -- vettore che conterrà i parametri per questo batch
        -- ad ora sono sue : la data limite fino a cui svecchiare ed eventualmente l'id_applicazione
        vetParSvecchiamento TypVetParametriApplicazione;
        -- variabile che conterrà la data limite fino alla quale le esecuzioni saranno da cancellare
        dDataLimite         DATE;
        --  variabile che conterrà l'eventuale id_applicazione per cui le esecuzioni saranno da cancellare
        nIdApplDaSvecchiare SMRGAA_D_APPLICAZIONI_BATCH.ID_APPLICAZIONE%TYPE;
        -- boleana che mi dice se i parametri sono correttamenti valorizzati
        bParamOK            BOOLEAN:=TRUE;
        -- cursore delle esecuzioni da svecchiare
        CURSOR curEsecuzioni IS
        SELECT *
          FROM SMRGAA_T_ESECUZIONE_BATCH
         WHERE TRUNC(DT_INIZIO_ESECUZIONE) <= dDataLimite
           AND (ID_APPLICAZIONE = nIdApplDaSvecchiare OR nIdApplDaSvecchiare IS NULL);

        nNumEsecuzioni      NUMBER:=0;

   BEGIN

        nRetCode := Pck_Smrgaa_Log.VerificaAttivazioneBatch( knIdApplSvecchiaEsecuzioni ,recDApplicazione);

        IF nRetCode > 0 THEN
             -- Errore, Batch non attivo
            RETURN nRetCode;
        END IF;

         -- Inserimento in tabella dell'identificativo di esecuzione
         -- nIdEsecuzione restituito in output
        Pck_Smrgaa_Log.InsertTEsecuzione ( knIdApplSvecchiaEsecuzioni, nIdEsecuzione );
        COMMIT;

         -- Scrittura nel file nomefile_esecuzione del nIdEsecuzione
        Pck_Smrgaa_Log.ScriviFileEsecuzione (  recDApplicazione.nomefile_esecuzione,
                                            recDApplicazione.path_file_esecuzione,
                                            nIdEsecuzione );

        Pck_Smrgaa_Log.LeggiFileEsecuzione ( recDApplicazione.nomefile_esecuzione, recDApplicazione.path_file_esecuzione );

        Pck_Smrgaa_Log.SetLogLevel ( recDApplicazione.log_level );

        Pck_Smrgaa_Log.Init( knIdApplSvecchiaEsecuzioni, 'SvecchiamentoEsecuzioni' );
        -- prelevo i parametri per lo svecchiamento
        vetParSvecchiamento := Pck_Smrgaa_Log.CaricaParametriApplicazione(knIdApplSvecchiaEsecuzioni);
        -- se non ce ne sono segnalo apposita anomalia
        IF vetParSvecchiamento.COUNT = 0 THEN
            Pck_Smrgaa_Log.loganomalia ('Nessuno dei parametri previsti è stato caricato !! - Termino Elaborazione !!');
            bParamOk := FALSE;
        ELSE
          -- prelevo la data limite che dev'esserci per forza
          BEGIN
              dDataLimite := vetParSvecchiamento (kvCodParDataLimite).val_date;
          EXCEPTION
              WHEN OTHERS THEN
                   Pck_Smrgaa_Log.loganomalia ('Parametro ' || kvCodParDataLimite || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                   bParamOk := FALSE;
          END;
          -- prelevo l'id_applicazione che è facoltativo
          BEGIN
              nIdApplDaSvecchiare := vetParSvecchiamento (kvCodParIdApplSvecch).val_number;
          EXCEPTION
              WHEN NO_DATA_FOUND THEN
                   -- se non è nel vettore assegno null
                   nIdApplDaSvecchiare := NULL;
              WHEN OTHERS THEN
                   Pck_Smrgaa_Log.loganomalia ('Parametro ' || kvCodParIdApplSvecch || ' non valorizzato correttamente  !! - Termino Elaborazione !!');
                   bParamOk := FALSE;
          END;

        END IF;
        -- se i parametri sono a posto
        IF bParamOk THEN
            -- a seconda se effettuo lo svecchiamento totale
            -- o lo svecchiamento per id_applicazione do apposito messaggio
            IF nIdApplDaSvecchiare IS NULL THEN
                Pck_Smrgaa_Log.LogInfo ('SvecchiamentoEsecuzioni - Fino alla data : ' || dDataLimite);
            ELSE
                Pck_Smrgaa_Log.LogInfo ('SvecchiamentoEsecuzioni - Per Id_Applicazione = ' || nIdApplDaSvecchiare || ' Fino alla data : ' || dDataLimite);
            END IF;
            -- disabilito le contraint
            DisableConstraint;
            -- ciclo sull'esecuzione da svecchiare
            FOR recEsecuzioni IN curEsecuzioni LOOP
                nNumEsecuzioni := nNumEsecuzioni + 1;

                Pck_Smrgaa_Log.LogInfo ('Inizio Svecchiamento ID_ESECUZIONE : ' || recEsecuzioni.id_esecuzione);
                -- effettuo le cancellazioni per id_esecuzione su SMRGAA_R_STORICODATI
                CancellaRStoricoDati (recEsecuzioni.id_esecuzione);
                -- effettuo le cancellazioni per id_esecuzione su SMRGAA_T_ESECUZIONE_PARAMETRO
                CancellaTEsecuzioneParametro (recEsecuzioni.id_esecuzione);
                -- effettuo le cancellazioni per id_esecuzione su SMRGAA_L_LOG_BATCH
                CancellaLLogBatch (recEsecuzioni.id_esecuzione);
                -- ed infine cancello il record da SMRGAA_T_ESECUZIONE_BATCH
                CancellaTEsecuzioneBatch (recEsecuzioni.id_esecuzione);

                Pck_Smrgaa_Log.LogInfo ('Fine Svecchiamento ID_ESECUZIONE : ' || recEsecuzioni.id_esecuzione);

            END LOOP;
            -- riabilito le constraint
            EnableConstraint;
            -- se ho cancellato almeno un'esecuzione
            IF nNumEsecuzioni > 0 THEN
               -- effettuo la riorganizzazione delle tabelle svecchiate e dei relativi indici
               -- ed il ricalcolo delle statistiche sulle stesse
               RiorganizzaTabelleSvecchiate;
            END IF;

        END IF;

        Pck_Smrgaa_Log.LogInfo ('Fine SvecchiamentoEsecuzioni, svecchiate : ' || nNumEsecuzioni || ' esecuzioni di batch');
        Pck_Smrgaa_Log.ValorizzaEsitoBatch;

        COMMIT;

        RETURN 0;

   EXCEPTION
        WHEN OTHERS THEN
             ROLLBACK;
             Pck_Smrgaa_Log.logsqlerror ('SvecchiamentoEsecuzioni');
             RETURN 1;
   END SvecchiamentoEsecuzioni;

   /*********************************************************************
   Data una stringa SQL in input la esegue tramite EXECUTE IMMEDIATE
   Tipo:  funzione
   input: pSqlStr
   output: nessuno
   ritorno: 0 OK, 1 KO
   *********************************************************************/
   FUNCTION EseguiComandoSql (pSqlStr IN VARCHAR2) RETURN INTEGER IS
   BEGIN

        DBMS_OUTPUT.PUT_LINE ('Esecuzione stringa SQL : ' || SUBSTR(pSqlStr,1,200));
        DBMS_OUTPUT.PUT_LINE ('Inizio : ' || TO_CHAR(SYSDATE,'DD/MM/YYYY HH24:MI:SS'));

        EXECUTE IMMEDIATE pSqlStr;
        COMMIT;
        DBMS_OUTPUT.PUT_LINE ('Fine : ' || TO_CHAR(SYSDATE,'DD/MM/YYYY HH24:MI:SS'));
        DBMS_OUTPUT.PUT_LINE ('Esecuzione OK');
        RETURN 0;

   EXCEPTION
       WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE (TO_CHAR(SQLCODE) || ' - ' || SUBSTR(SQLERRM,1,150));
            DBMS_OUTPUT.PUT_LINE ('Fine : ' || TO_CHAR(SYSDATE,'DD/MM/YYYY HH24:MI:SS'));
            DBMS_OUTPUT.PUT_LINE ('Esecuzione KO');
            RETURN 1;
   END EseguiComandoSql;

END Pck_Smrgaa_Log;

/
--------------------------------------------------------
--  DDL for Package Body PCK_UTILITY_FILE
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_UTILITY_FILE" AS

FUNCTION FileOpen
   (
    pFilePath      VARCHAR2,
    pFileName      VARCHAR2,
    pOpenMode       VARCHAR2 := 'w',
    pLngRiga            NUMBER DEFAULT 1500
   )
   RETURN UTL_FILE.FILE_TYPE
   IS
   BEGIN
     RETURN UTL_FILE.FOPEN( pFilePath, pFileName, pOpenMode,pLngRiga );

   EXCEPTION
        WHEN UTL_FILE.INVALID_PATH THEN
       DBMS_OUTPUT.PUT_LINE( 'FileOpen: <<INVALID_PATH>>' );
       RAISE;
        WHEN UTL_FILE.INVALID_MODE THEN
       DBMS_OUTPUT.PUT_LINE( 'FileOpen: <<INVALID_MODE>>' );
       RAISE;
        WHEN UTL_FILE.INVALID_OPERATION THEN
       DBMS_OUTPUT.PUT_LINE( 'FileOpen: <<INVALID_OPERATION>>' );
       IF UPPER(pOpenMode) = 'A' THEN
         RETURN UTL_FILE.FOPEN( pFilePath, pFileName, 'W',pLngRiga );
       ELSE
         RAISE;
       END IF;
   END FileOpen;
----------------------
------FileRead--------
----------------------

   PROCEDURE FileRead
   (
    PFILE   IN UTL_FILE.FILE_TYPE,
    pStr    OUT VARCHAR2
   )
   IS
   BEGIN
     UTL_FILE.GET_LINE( PFILE, pStr );
   EXCEPTION
        WHEN UTL_FILE.INVALID_FILEHANDLE THEN
       DBMS_OUTPUT.PUT_LINE( 'FileRead: <<INVALID_FILEHANDLE>>' );
       RAISE;
        WHEN UTL_FILE.INVALID_OPERATION THEN
       DBMS_OUTPUT.PUT_LINE( 'FileRead: <<INVALID_OPERATION>>' );
       RAISE;
        WHEN UTL_FILE.READ_ERROR THEN
       DBMS_OUTPUT.PUT_LINE( 'FileRead: <<READ_ERROR>>' );
       RAISE;
   END FileRead;



 ---------------
 -- FileClose --
 ---------------
   PROCEDURE FileClose
   (
    PFILE   IN OUT UTL_FILE.FILE_TYPE
   )
   IS
   BEGIN
     UTL_FILE.FCLOSE( PFILE );

   EXCEPTION
        WHEN UTL_FILE.INVALID_FILEHANDLE THEN
       DBMS_OUTPUT.PUT_LINE( 'FileClose: <<INVALID_FILEHANDLE>>' );
       RAISE;
        WHEN UTL_FILE.WRITE_ERROR THEN
       DBMS_OUTPUT.PUT_LINE( 'FileClose: <<WRITE_ERROR>>' );
       RAISE;
   END FileClose;

 ---------------
 -- FileWrite --
 ---------------
   PROCEDURE FileWrite
   (
    PFILE   IN OUT UTL_FILE.FILE_TYPE,
    pStr    IN VARCHAR2
   )
   IS
   BEGIN
     UTL_FILE.PUT_LINE( PFILE, pStr );

   EXCEPTION
        WHEN UTL_FILE.INVALID_FILEHANDLE THEN
       DBMS_OUTPUT.PUT_LINE( 'FileWrite: <<INVALID_FILEHANDLE>>' );
       RAISE;
        WHEN UTL_FILE.INVALID_OPERATION THEN
       DBMS_OUTPUT.PUT_LINE( 'FileWrite: <<INVALID_OPERATION>>' );
       RAISE;
        WHEN UTL_FILE.WRITE_ERROR THEN
       DBMS_OUTPUT.PUT_LINE( 'FileWrite: <<WRITE_ERROR>>' );
       RAISE;
   END FileWrite;


FUNCTION ControllaData
   (
    pVal    VARCHAR2
   )
   RETURN BOOLEAN IS
     dVal   DATE := NULL;
     EXC_NOT_VALID_DAY_FOR_MONTH  EXCEPTION;
     PRAGMA EXCEPTION_INIT( EXC_NOT_VALID_DAY_FOR_MONTH, -1839 );    -- giorno non valido nel mese
     EXC_NOT_VALID_LENGHT_FORMAT  EXCEPTION;
     PRAGMA EXCEPTION_INIT( EXC_NOT_VALID_LENGHT_FORMAT, -1840 );    -- lungh. non valida
     EXC_NOT_VALID_YEAR  EXCEPTION;
     PRAGMA EXCEPTION_INIT( EXC_NOT_VALID_YEAR, -1841 );             -- anno non valido
     EXC_NOT_VALID_MONTH  EXCEPTION;
     PRAGMA EXCEPTION_INIT( EXC_NOT_VALID_MONTH, -1843 );             -- mese non valido
     EXC_NOT_VALID_DATE  EXCEPTION;
     PRAGMA EXCEPTION_INIT( EXC_NOT_VALID_DATE, -1847 );                 -- data non valida
     EXC_NOT_VALID_DATE_PICTURE  EXCEPTION;
     PRAGMA EXCEPTION_INIT( EXC_NOT_VALID_DATE, -1847 );                 -- data non valida
     EXC_NOT_VALID_STRING  EXCEPTION;
        PRAGMA EXCEPTION_INIT( EXC_NOT_VALID_STRING, -1830 );             -- date format picture ends before converting entire input string
   BEGIN
     IF NOT IsNumber( pVal ) THEN
       RETURN FALSE;
     END IF;
     dVal := TO_DATE( pVal, 'YYYY-MM-DD' );
--     dVal := TO_DATE( pVal, 'YYYYMMDD' );
-- DBMS_OUTPUT.Put_Line('Controlla data ' || pVal );
     RETURN TRUE;
   EXCEPTION
     WHEN EXC_NOT_VALID_DAY_FOR_MONTH THEN
       RETURN FALSE;
     WHEN EXC_NOT_VALID_LENGHT_FORMAT THEN
       RETURN FALSE;
     WHEN EXC_NOT_VALID_YEAR THEN
       RETURN FALSE;
     WHEN EXC_NOT_VALID_MONTH THEN
       RETURN FALSE;
     WHEN EXC_NOT_VALID_DATE THEN
       RETURN FALSE;
     WHEN EXC_NOT_VALID_STRING THEN
       RETURN FALSE;
      WHEN OTHERS THEN
       RETURN FALSE;
END ControllaData;

FUNCTION IsNumber
   (
    pVal    VARCHAR2,
    pDec    BOOLEAN := FALSE   -- se TRUE accetta anche i decimali
   )
   RETURN BOOLEAN IS
     sVal   VARCHAR2(200) := NULL;
     nVal   NUMBER(9) := 0;
     EXC_NOT_NUMERIC  EXCEPTION;
     PRAGMA EXCEPTION_INIT( EXC_NOT_NUMERIC, -6502 );
   BEGIN
     IF pVal IS NULL THEN
       RETURN FALSE;                           -- se il valore e nullo NON e numerico
     END IF;
     sVal := REPLACE( pVal, ' ', '*' );         -- se il valore contiene spazi sost. con '*'
     nVal := TO_NUMBER( sVal );                   -- provo a convertire il valore in numero
     IF NOT pDec THEN                          -- se NON devo accettare i decimali
       IF nVal <> FLOOR( nVal ) THEN         -- testo se il numero e intero
         RAISE EXC_NOT_NUMERIC;
       END IF;
     END IF;
     RETURN TRUE;                                  -- il valore e numerico
   EXCEPTION
     WHEN EXC_NOT_NUMERIC THEN
       RETURN FALSE;                               -- il valore NON e numerico
END IsNumber;

FUNCTION IsNull
   (
    pVal    VARCHAR2
   )
   RETURN BOOLEAN IS
   BEGIN
     IF (LTRIM(RTRIM( pVal )) IS NULL) THEN
       RETURN TRUE;
     ELSE
       RETURN FALSE;
     END IF;
END IsNull;


FUNCTION Check_Codfisc (prmCodFisc VARCHAR2) RETURN BOOLEAN IS
   CheckCf  BOOLEAN;
  /* *****************
  Descrizione: Controllo formale del codice fiscale o P.Iva
  Modifiche: Lunel 20/06/2002 aggiunto controllo numeri del CF
  Funzioni richiamate:
  ***************** */

-- dichiarazione variabili locali
    I NUMBER  := 0;
    J NUMBER  := 0;
    K NUMBER  := 0; --L001
    Lungh NUMBER;
    Somma NUMBER := 0;
    Resto NUMBER := 0;
    Posizione NUMBER := 0;
    Valore VARCHAR2(1) := 0;
    SzValore VARCHAR2(1) := 0;
    CheckDigit VARCHAR2(1) := '0';
    StringaPari VARCHAR2(5) := '0';
    StringaDispari VARCHAR2(4) := '0';
    SommaPari NUMBER := 0;
    SommaDispari NUMBER := 0;

BEGIN
-- inizializzo variabile booleana di ritorno
   CheckCf := FALSE;

-- controllo formale del Codice Fiscale se lungo sedici caratteri

   IF LENGTH(RTRIM(prmCodFisc)) = 16 THEN
--  controllo formale ( i  caratteri al posto 1-6 , 9 ,12 devono essere alfabetici)

      Lungh := 16;

      FOR I IN 1..15  LOOP
              SzValore :=  SUBSTR(prmCodFisc , I, 1);
              SELECT DECODE(I, 1,1, 2,1, 3,1, 4,1, 5,1, 6,1, 9,1, 12,1) INTO J FROM DUAL;

                IF J = 1 AND (SzValore < 'A'  OR SzValore > 'Z') THEN
   -- CODICE FISCALE FORMALMENTE NON CORRETTO
   -- ritorno alla procedura chiamante impostando il codice ritorno
                     CheckCf := FALSE;
                     RETURN CheckCf;
                    END IF;
/* aggiunta Lunel per controllo numeri all'interno del Cf*/
              SELECT DECODE(I, 7,1, 8,1, 10,1, 11,1, 13,1, 14,1, 15,1 ) INTO K FROM DUAL;

                IF K = 1 AND (SzValore < '0'  OR SzValore > '9') THEN
   -- CODICE FISCALE FORMALMENTE NON CORRETTO
   -- ritorno alla procedura chiamante impostando il codice ritorno
                     CheckCf := FALSE;
                     RETURN CheckCf;
                    END IF;

      END LOOP;
   --  calcolo del check digit
           I := 0;
           J := 0;
           WHILE I < 15 LOOP
                   I := I + 1;
              Valore :=  SUBSTR(prmCodFisc , I, 1);
              SELECT DECODE(I, 1,1, 3,1, 5,1, 7,1, 9,1, 11,1, 13,1, 15,1) INTO J FROM DUAL;
                       IF J = 1 THEN
                             Posizione := INSTR('BAKPLCQDREVOSFTGUHMINJWZYX' ,Valore,1);

                             IF Posizione = 0 THEN
                                  Posizione := INSTR('10   2 3 4   5 6 7 8 9' ,Valore,1) -1;
                           ELSE
                                Posizione := Posizione -1;
                              END IF;

                       ELSE

                           Posizione := INSTR('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' ,Valore,1);
                           IF Posizione >= 27 THEN
                                Posizione := Posizione - 27;
                           ELSE
                                Posizione := Posizione -1;
                           END IF;
                       END IF;
      Somma := Somma + Posizione;

      END LOOP;

      Resto := MOD(Somma,26);
      CheckDigit := SUBSTR('ABCDEFGHIJKLMNOPQRSTUVWXYZ', Resto + 1 ,1);

      -- controllo check digit
      IF  CheckDigit <> SUBSTR(prmCodFisc , Lungh , 1) THEN
          -- cofice fiscale errato nel CD
                   CheckCf := FALSE;
               -- ritorno alla procedura chiamante impostando il codice ritorno
               RETURN CheckCf;
      ELSE
-- codice fiscale formalmente corretto
           CheckCf := TRUE;
               -- ritorno alla procedura chiamante impostando il codice ritorno
               RETURN CheckCf;
      END IF;

   ELSIF LENGTH(RTRIM(prmCodFisc)) = 11 THEN
--  controllo formale Partita Iva
                  Lungh := 11;
                 StringaPari := SUBSTR(prmCodFisc,2,1) || SUBSTR(prmCodFisc,4,1) || SUBSTR(prmCodFisc,6,1) ||SUBSTR(prmCodFisc,8,1) || SUBSTR(prmCodFisc,10,1) ;
             FOR I IN 1..5  LOOP
                      J :=  SUBSTR(StringaPari , I, 1) * 2;

                        IF J > 9  THEN
                              Somma := Somma + 1 + MOD(J,10);
                        ELSE
                                Somma := Somma + J;
                        END IF;

             END LOOP;

                 SommaDispari := TO_NUMBER(SUBSTR(prmCodFisc,1,1)) + TO_NUMBER(SUBSTR(prmCodFisc,3,1))
                                                  + TO_NUMBER(SUBSTR(prmCodFisc,5,1)) + TO_NUMBER(SUBSTR(prmCodFisc,7,1))
                                                  + TO_NUMBER(SUBSTR(prmCodFisc,9,1));

                 Somma := Somma + SommaDispari;
                 Resto := MOD(Somma,10);

                 IF Resto = 0 THEN
                         CheckDigit := 0;
                 ELSE
                         CheckDigit := 10 - Resto;
                 END IF;
      -- controllo check digit
           IF  CheckDigit <> TO_NUMBER(SUBSTR(prmCodFisc , Lungh , 1)) THEN
              -- Partita IVA  errato nel CD
                       CheckCf := FALSE;
                   -- ritorno alla procedura chiamante impostando il codice ritorno
                   RETURN CheckCf;
           ELSIF TO_NUMBER(prmCodFisc) = 0 THEN
-- Partita IVA  errato nel CD
                       CheckCf := FALSE;
 -- ritorno alla procedura chiamante impostando il codice ritorno
                   RETURN CheckCf;

          ELSE
    -- codice fiscale formalmente corretto
               CheckCf := TRUE;
                   -- ritorno alla procedura chiamante impostando il codice ritorno
                   RETURN CheckCf;
          END IF;

   ELSIF LENGTH(RTRIM(prmCodFisc)) = 9 THEN
--  controllo formale Partita Iva
                  Lungh := 9;
                 SommaPari := TO_NUMBER(SUBSTR(prmCodFisc,2,1)) + TO_NUMBER(SUBSTR(prmCodFisc,4,1))
                              + TO_NUMBER(SUBSTR(prmCodFisc,6,1)) + TO_NUMBER(SUBSTR(prmCodFisc,8,1)) ;

             Somma := SommaPari;
         StringaDispari := SUBSTR(prmCodFisc,1,1) || SUBSTR(prmCodFisc,3,1) || SUBSTR(prmCodFisc,5,1)
                          || SUBSTR(prmCodFisc,7,1);

             FOR I IN 1..4  LOOP
                              Somma := Somma + TO_NUMBER(SUBSTR('1057624389' ,TO_NUMBER(SUBSTR(StringaDispari , I, 1 )) + 1 , 1));

             END LOOP;

                   CheckDigit := MOD(Somma , 10);
      -- controllo check digit
           IF  CheckDigit <> TO_NUMBER(SUBSTR(prmCodFisc , Lungh , 1)) THEN
              -- Partita IVA  errato nel CD
                       CheckCf := FALSE;
                   -- ritorno alla procedura chiamante impostando il codice ritorno
                   RETURN CheckCf;
          ELSE
    -- codice fiscale formalmente corretto
               CheckCf := TRUE;
                   -- ritorno alla procedura chiamante impostando il codice ritorno
                   RETURN CheckCf;
          END IF;

   ELSE

       CheckCf := FALSE;
   -- ritorno alla procedura chiamante impostando il codice ritorno
   RETURN CheckCf;

   END IF;
EXCEPTION
    WHEN OTHERS THEN

       CheckCf := FALSE;
   -- ritorno alla procedura chiamante impostando il codice ritorno
   RETURN CheckCf;

END Check_Codfisc;



END Pck_Utility_File;

/
--------------------------------------------------------
--  DDL for Package Body PCK_UTL_OBFUSCATION
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_UTL_OBFUSCATION" AS

FUNCTION FNC_ENCRYPT (    input_string     IN VARCHAR2,
                                pKey                IN    VARCHAR2    ) RETURN VARCHAR2 IS

data_crypt VARCHAR2(256);
data_crypt_out VARCHAR2(256);

BEGIN

    data_crypt := RPAD( input_string,(TRUNC(LENGTH(input_string)/8)+1)*8, CHR(0) );

    dbms_obfuscation_toolkit.DESEncrypt(input_string         => data_crypt,
                                                    key_string             => pkey,
                                                    encrypted_string    => data_crypt_out);
RETURN data_crypt_out;

END;

FUNCTION FNC_DECRYPT (    input_string     IN VARCHAR2,
                            pkey                IN VARCHAR2    ) RETURN VARCHAR2 IS

data_decrypt_out VARCHAR2(256);

BEGIN

    dbms_obfuscation_toolkit.DESDecrypt(input_string         => input_string,
                                                    key_string             => Pkey,
                                                    DECRYPTED_string    => data_decrypt_out);

RETURN RTRIM( data_decrypt_out, CHR(0) );
END FNC_DECRYPT;

END Pck_Utl_Obfuscation;

/
--------------------------------------------------------
--  DDL for Package Body PCK_UTL_OBJ
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_UTL_OBJ" AS

-- Funzione che torna una collection (TYPOBJ_CUAA_REL) dell'oggetto (TYPOBJ_CUAA_REL) unico campo CUAA

FUNCTION TABLE_CUAA_COLL_SQL ( pCuaa  IN VARCHAR2,    pCuaaRet    IN VARCHAR2 DEFAULT NULL ) RETURN TYPCOLL_CUAA_REL IS

    vCuaa       DB_ANAGRAFICA_AZIENDA.CUAA%TYPE;
    vCuaaRet    DB_ANAGRAFICA_AZIENDA.CUAA%TYPE;

    CURSOR CUR_CUAA_COLL IS
    SELECT DISTINCT CODICE_FISCALE_PF  CUAA_RIC,2 ORDINE
      FROM DB_AZIENDA_TRIBUTARIA AZITRI,
           DB_CF_COLLEGATI_SIAN    SIAN
     WHERE AZITRI.CUAA = vCuaa 
       AND SIAN.ID_AZIENDA_TRIBUTARIA = AZITRI.ID_AZIENDA_TRIBUTARIA
       AND AZITRI.FLAG_PRESENTE_AT = 'S'
       AND CODICE_FISCALE_PF != vCuaa 
    UNION
    SELECT DISTINCT CODICE_FISCALE_PG CUAA_RIC,2 ORDINE
      FROM DB_AZIENDA_TRIBUTARIA AZITRI,
           DB_CF_COLLEGATI_SIAN SIAN
     WHERE AZITRI.CUAA = vCuaa 
       AND SIAN.ID_AZIENDA_TRIBUTARIA = AZITRI.ID_AZIENDA_TRIBUTARIA
       AND AZITRI.FLAG_PRESENTE_AT = 'S'
       AND CODICE_FISCALE_PG != vCuaa 
    UNION
    SELECT CUAA_ANAGRAFE_TRIBUTARIA CUAA_RIC,1 ORDINE
      FROM DB_AZIENDA_TRIBUTARIA AZITRI
     WHERE AZITRI.CUAA = vCuaa 
       AND AZITRI.FLAG_PRESENTE_AT = 'S'
       AND CUAA_ANAGRAFE_TRIBUTARIA != vCuaa 
    ORDER BY 2,1;

    n             NUMBER;
    nCountCuaa    NUMBER;
    pElencoCuaa    TYPCOLL_CUAA_REL;

BEGIN

    vCuaa := UPPER(pCuaa);
    vCuaaRet := UPPER(pCuaaRet);

    pElencoCuaa := TYPCOLL_CUAA_REL();

    n := 0;
    FOR REC_C IN CUR_CUAA_COLL LOOP

        IF RTRIM(LTRIM(REC_C.CUAA_RIC)) IS NOT NULL THEN
            n := n + 1;

            pElencoCuaa.EXTEND;
            pElencoCuaa(pElencoCuaa.COUNT) := TYPOBJ_CUAA_REL(REC_C.CUAA_RIC,NULL,NULL);

        END IF;
    END LOOP;


    IF vCuaaRet IS NOT NULL THEN

        SELECT COUNT(*)  INTO nCountCuaa
        FROM
        (SELECT DISTINCT CODICE_FISCALE_PF  CUAA_RIC
        FROM     DB_AZIENDA_TRIBUTARIA    AZITRI,
                DB_CF_COLLEGATI_SIAN        SIAN
        WHERE AZITRI.CUAA = vCuaa
        AND    SIAN.ID_AZIENDA_TRIBUTARIA = AZITRI.ID_AZIENDA_TRIBUTARIA
        AND    AZITRI.FLAG_PRESENTE_AT        =    'S'
        AND    CODICE_FISCALE_PF             = vCuaa
        UNION
        SELECT DISTINCT CODICE_FISCALE_PG CUAA_RIC
        FROM     DB_AZIENDA_TRIBUTARIA    AZITRI,
                DB_CF_COLLEGATI_SIAN        SIAN
        WHERE AZITRI.CUAA = vCuaa
        AND    SIAN.ID_AZIENDA_TRIBUTARIA = AZITRI.ID_AZIENDA_TRIBUTARIA
        AND    AZITRI.FLAG_PRESENTE_AT        =    'S'
        AND    CODICE_FISCALE_PG             = vCuaa
        UNION
        SELECT CUAA_ANAGRAFE_TRIBUTARIA CUAA_RIC
        FROM DB_AZIENDA_TRIBUTARIA    AZITRI
        WHERE AZITRI.CUAA = vCuaa
        AND    AZITRI.FLAG_PRESENTE_AT        =    'S'
        /*AND     CUAA_ANAGRAFE_TRIBUTARIA     = vCuaa*/) PIPPO;

        IF nCountCuaa > 0 THEN
            n := n + 1;

            pElencoCuaa.EXTEND;
            pElencoCuaa(pElencoCuaa.COUNT) := TYPOBJ_CUAA_REL(vCuaa,NULL,NULL);
        END IF;
    END IF;



    RETURN(pElencoCuaa);

END TABLE_CUAA_COLL_SQL;


-- Funzione che richiama la function TABLE_CUAA_COLL_SQL e torna
-- una collection (TYPOBJ_CUAA_REL) dell'oggetto (TYPOBJ_CUAA_REL) unico campo CUAA
-- questa e' richiamabile da Java e SQL ma non PLSQL come una semplice Query

FUNCTION TABLE_CUAA_COLL_JAVA ( pCuaa  IN VARCHAR2,    pCuaaRet    IN VARCHAR2 DEFAULT NULL ) RETURN TYPCOLL_CUAA_REL PIPELINED IS

    n NUMBER;
    pElencoCuaaOut    TYPCOLL_CUAA_REL;
    pElencoCuaaIn    TYPCOLL_CUAA_REL;
    vCuaa           DB_ANAGRAFICA_AZIENDA.CUAA%TYPE;
    vCuaaRet        DB_ANAGRAFICA_AZIENDA.CUAA%TYPE;
BEGIN

   vCuaa := UPPER(pCuaa);
    vCuaaRet := UPPER(pCuaaRet);

    IF vCuaaRet IS NOT NULL THEN
        pElencoCuaaIn := TABLE_CUAA_COLL_SQL(vCuaa,vCuaaRet);
    ELSE
        pElencoCuaaIn := TABLE_CUAA_COLL_SQL(vCuaa);
    END IF;

    IF pElencoCuaaIn.COUNT > 0 THEN

        pElencoCuaaOut := TYPCOLL_CUAA_REL();

        n := 0;
        FOR i IN pElencoCuaaIn.FIRST..pElencoCuaaIn.LAST LOOP
            n := n + 1;

            pElencoCuaaOut.EXTEND;

            pElencoCuaaOut(pElencoCuaaOut.COUNT) := TYPOBJ_CUAA_REL(pElencoCuaaIn(i).CUAA,NULL,NULL);


            PIPE ROW (pElencoCuaaOut(n));

        END LOOP;
    END IF;

    RETURN;

END TABLE_CUAA_COLL_JAVA;

FUNCTION TABLE_CUAA_AZIENDE_COLLEGATE_S ( pCuaa  IN VARCHAR2 ) RETURN TYPCOLL_CUAA_AZ IS

    vCuaa DB_ANAGRAFICA_AZIENDA.CUAA%TYPE;

    CURSOR CUR_AZIENDA (parCuaa IN VARCHAR2) IS
    SELECT DISTINCT AZI.ID_AZIENDA ID_AZIENDA
      FROM DB_ANAGRAFICA_AZIENDA AZI
     WHERE AZI.CUAA = parCuaa;

    CURSOR CUR_CUAA_2 (pElencoCuaa    TYPCOLL_CUAA_REL)    IS
    SELECT azi.CUAA CUAA,
           AZI.ID_AZIENDA,
           azi.ID_ANAGRAFICA_AZIENDA,
           AZI.PARTITA_IVA,
           AZI.DENOMINAZIONE,
           AZI.DATA_INIZIO_VALIDITA,
           AZI.DATA_CESSAZIONE,
           AZI.SEDELEG_COMUNE,
           AZI.SEDELEG_CITTA_ESTERO,
           COM.DESCOM,
           PRO.SIGLA_PROVINCIA,
           TIP.DESCRIZIONE
      FROM DB_ANAGRAFICA_AZIENDA AZI,
            COMUNE COM,
             PROVINCIA PRO,
           DB_TIPO_FORMA_GIURIDICA TIP
     WHERE COM.ISTAT_COMUNE(+) = AZI.SEDELEG_COMUNE
       AND PRO.ISTAT_PROVINCIA(+) = COM.ISTAT_PROVINCIA
       AND AZI.DATA_FINE_VALIDITA IS NULL
       AND TIP.ID_FORMA_GIURIDICA(+)= AZI.ID_FORMA_GIURIDICA
       AND AZI.ID_AZIENDA IN (SELECT DISTINCT AZI.ID_AZIENDA ID_AZIENDA
                                FROM DB_ANAGRAFICA_AZIENDA     AZI
                               WHERE AZI.CUAA IN (SELECT CUAA
                                                    FROM TABLE (CAST (pElencoCuaa AS TYPCOLL_CUAA_REL))
                                                   UNION
                                                  SELECT vCuaa CUAA FROM DUAL));

    RecCCU CUR_CUAA_2%ROWTYPE;

    CURSOR CUR_NO_ANA (pElencoCuaa    TYPCOLL_CUAA_REL) IS
    SELECT CUAA
      FROM TABLE (CAST (pElencoCuaa     AS TYPCOLL_CUAA_REL))
     UNION
     SELECT vCuaa CUAA FROM DUAL;

    CURSOR CUR_DES_I (pAzienda   IN VARCHAR2,
                     pElencoCuaa TYPCOLL_CUAA_REL) IS
    SELECT AZI.CUAA CUAA,
           AZI.ID_AZIENDA,
           AZI.ID_ANAGRAFICA_AZIENDA,
           AZI.PARTITA_IVA,
           AZI.DENOMINAZIONE,
           AZI.DATA_INIZIO_VALIDITA,
           AZI.DATA_CESSAZIONE,
           AZI.SEDELEG_COMUNE,
           AZI.SEDELEG_CITTA_ESTERO,
           COM.DESCOM,
           PRO.SIGLA_PROVINCIA,
           TIP.DESCRIZIONE
      FROM DB_ANAGRAFICA_AZIENDA AZI,
           COMUNE COM,
           PROVINCIA PRO,
           DB_TIPO_FORMA_GIURIDICA TIP,
           (SELECT ID_AZIENDA ID_AZI
              FROM DB_AZIENDA_DESTINAZIONE
            CONNECT BY PRIOR ID_AZIENDA = ID_AZIENDA_DI_DESTINAZIONE
            START WITH ID_AZIENDA_DI_DESTINAZIONE = pAzienda
            UNION
            SELECT ID_AZIENDA_DI_DESTINAZIONE    ID_AZI
              FROM DB_AZIENDA_DESTINAZIONE
            CONNECT BY PRIOR ID_AZIENDA_DI_DESTINAZIONE=ID_AZIENDA
            START WITH ID_AZIENDA = pAzienda) PIPPO
     WHERE COM.ISTAT_COMUNE(+) = AZI.SEDELEG_COMUNE
       AND PRO.ISTAT_PROVINCIA(+) = COM.ISTAT_PROVINCIA
       AND TIP.ID_FORMA_GIURIDICA(+) = AZI.ID_FORMA_GIURIDICA
       AND AZI.DATA_FINE_VALIDITA IS NULL
       AND AZI.ID_AZIENDA IN PIPPO.ID_AZI
       AND AZI.ID_AZIENDA NOT IN (SELECT AZI.ID_AZIENDA
                                    FROM DB_ANAGRAFICA_AZIENDA     AZI,
                                         COMUNE    COM,
                                         PROVINCIA PRO,
                                         DB_TIPO_FORMA_GIURIDICA TIP
                                   WHERE COM.ISTAT_COMUNE(+) = AZI.SEDELEG_COMUNE
                                     AND PRO.ISTAT_PROVINCIA(+) = COM.ISTAT_PROVINCIA
                                     AND AZI.DATA_FINE_VALIDITA    IS NULL
                                     AND TIP.ID_FORMA_GIURIDICA(+) = AZI.ID_FORMA_GIURIDICA
                                     AND AZI.ID_AZIENDA IN     (SELECT    DISTINCT AZI.ID_AZIENDA ID_AZIENDA
                                                               FROM DB_ANAGRAFICA_AZIENDA     AZI
                                                              WHERE AZI.CUAA IN (SELECT CUAA
                                                                                  FROM TABLE (CAST (pElencoCuaa     AS TYPCOLL_CUAA_REL)))));




    pElencoCuaa        TYPCOLL_CUAA_REL;
    pElencoAzi        TYPCOLL_CUAA_AZ;
    n                 NUMBER;
    nCountCuaa        NUMBER;
    nCountCC        NUMBER;
    bFlagCuaa        BOOLEAN;

BEGIN

    vCuaa := UPPER(pCuaa);

    pElencoCuaa := TABLE_CUAA_COLL_SQL(vCuaa,'S');

    n := 0;
    bFlagCuaa := FALSE;
--    IF pElencoCuaa.COUNT > 0 THEN
        FOR REC_C IN CUR_CUAA_2(pElencoCuaa) LOOP
            IF n = 0 THEN
                pElencoAzi  := TYPCOLL_CUAA_AZ();
            END IF;

            IF REC_C.CUAA = vCuaa THEN
                bFlagCuaa := TRUE;
            END IF;
            n := n + 1;
            pElencoAzi.EXTEND;
            pElencoAzi(pElencoAzi.COUNT) := TYPOBJ_CUAA_AZ( Rec_C.CUAA,
                                                                            Rec_C.ID_AZIENDA,
                                                                            Rec_C.ID_ANAGRAFICA_AZIENDA,
                                                           Rec_C.PARTITA_IVA,
                                                               Rec_C.DENOMINAZIONE,
                                                               Rec_C.DATA_INIZIO_VALIDITA,
                                                               Rec_C.DATA_CESSAZIONE,
                                                                            Rec_C.SEDELEG_COMUNE,
                                                                            Rec_C.SEDELEG_CITTA_ESTERO,
                                                               Rec_C.DESCOM,
                                                                Rec_C.SIGLA_PROVINCIA,
                                                                            Rec_C.DESCRIZIONE,
                                                                            NULL,
                                                                            NULL,
                                                                            NULL);

            FOR REC_DES IN CUR_DES_I (Rec_C.ID_AZIENDA,pElencoCuaa) LOOP
                    pElencoAzi.EXTEND;
                    pElencoAzi(pElencoAzi.COUNT) := TYPOBJ_CUAA_AZ( REC_DES.CUAA,
                                                                                    REC_DES.ID_AZIENDA,
                                                                                    REC_DES.ID_ANAGRAFICA_AZIENDA,
                                                                   REC_DES.PARTITA_IVA,
                                                                       REC_DES.DENOMINAZIONE,
                                                                       REC_DES.DATA_INIZIO_VALIDITA,
                                                                       REC_DES.DATA_CESSAZIONE,
                                                                                    REC_DES.SEDELEG_COMUNE,
                                                                                    REC_DES.SEDELEG_CITTA_ESTERO,
                                                                       REC_DES.DESCOM,
                                                                        REC_DES.SIGLA_PROVINCIA,
                                                                                    REC_DES.DESCRIZIONE,
                                                                                    NULL,
                                                                                    NULL,
                                                                                    NULL);

                END LOOP;

            END LOOP;

--        END IF;

        FOR REC_NO IN CUR_NO_ANA(pElencoCuaa) LOOP

            IF REC_NO.CUAA = vCuaa THEN
                IF bFlagCuaa = FALSE THEN
                    SELECT COUNT(*) INTO nCountCC
                    FROM TABLE (CAST (pElencoCuaa     AS TYPCOLL_CUAA_REL))
                    WHERE CUAA = vCuaa;

                    IF nCountCC > 0 THEN

                        IF n = 0 THEN
                            pElencoAzi  := TYPCOLL_CUAA_AZ();
                        END IF;

                        n := n + 1;
                        pElencoAzi.EXTEND;
                        pElencoAzi(pElencoAzi.COUNT) := TYPOBJ_CUAA_AZ( REC_NO.CUAA,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);

                    ELSE
                        SELECT COUNT(*) INTO nCountCuaa
                        FROM DB_ANAGRAFICA_AZIENDA     AZI
                        WHERE AZI.CUAA = REC_NO.CUAA;

                        IF nCountCuaa > 0 THEN
                            BEGIN
                                SELECT     azi.CUAA CUAA,
                                            AZI.ID_AZIENDA,
                                            azi.ID_ANAGRAFICA_AZIENDA,
                                            AZI.PARTITA_IVA,
                                            AZI.DENOMINAZIONE,
                                            AZI.DATA_INIZIO_VALIDITA,
                                            AZI.DATA_CESSAZIONE,
                                            AZI.SEDELEG_COMUNE,
                                            AZI.SEDELEG_CITTA_ESTERO,
                                            COM.DESCOM,
                                            PRO.SIGLA_PROVINCIA,
                                            TIP.DESCRIZIONE
                                    INTO         RecCCU
                                    FROM     DB_ANAGRAFICA_AZIENDA     AZI,
                                             COMUNE                        COM,
                                              PROVINCIA                     PRO,
                                            DB_TIPO_FORMA_GIURIDICA    TIP
                                    WHERE COM.ISTAT_COMUNE(+)             = AZI.SEDELEG_COMUNE
                                    AND    PRO.ISTAT_PROVINCIA(+)            =    COM.ISTAT_PROVINCIA
                                    AND    AZI.DATA_FINE_VALIDITA        IS NULL
                                    AND    TIP.ID_FORMA_GIURIDICA(+)     = AZI.ID_FORMA_GIURIDICA
                                    AND     AZI.CUAA                         = REC_NO.CUAA;

                                IF n = 0 THEN
                                    pElencoAzi  := TYPCOLL_CUAA_AZ();
                                END IF;

                                n := n + 1;
                                pElencoAzi.EXTEND;
                                pElencoAzi(pElencoAzi.COUNT) := TYPOBJ_CUAA_AZ( REC_NO.CUAA,
                                                                                                RecCCU.ID_AZIENDA,
                                                                                                RecCCU.ID_ANAGRAFICA_AZIENDA,
                                                                               RecCCU.PARTITA_IVA,
                                                                                   RecCCU.DENOMINAZIONE,
                                                                                   RecCCU.DATA_INIZIO_VALIDITA,
                                                                                   RecCCU.DATA_CESSAZIONE,
                                                                                                RecCCU.SEDELEG_COMUNE,
                                                                                                RecCCU.SEDELEG_CITTA_ESTERO,
                                                                                   RecCCU.DESCOM,
                                                                                    RecCCU.SIGLA_PROVINCIA,
                                                                                                RecCCU.DESCRIZIONE,
                                                                                                NULL,
                                                                                                NULL,
                                                                                                NULL);

                            EXCEPTION
                                WHEN OTHERS THEN
                                    NULL;
                            END;
                        END IF;
                    END IF;
                END IF;
            ELSE
                SELECT COUNT(*) INTO nCountCuaa
                FROM DB_ANAGRAFICA_AZIENDA     AZI
                WHERE AZI.CUAA = REC_NO.CUAA
                AND    AZI.DATA_FINE_VALIDITA        IS NULL;

                IF nCountCuaa = 0 THEN

                    IF n = 0 THEN
                        pElencoAzi  := TYPCOLL_CUAA_AZ();
                    END IF;

                    n := n + 1;
                    pElencoAzi.EXTEND;
                    pElencoAzi(pElencoAzi.COUNT) := TYPOBJ_CUAA_AZ( REC_NO.CUAA,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);

                END IF;
            END IF;
        END LOOP;


/*        FOR REC_NO IN CUR_NO_ANA(pElencoCuaa) LOOP

            SELECT COUNT(*) INTO nCountCuaa
            FROM DB_ANAGRAFICA_AZIENDA     AZI
            WHERE AZI.CUAA = REC_NO.CUAA;

            IF nCountCuaa = 0 THEN
                IF  REC_NO.CUAA != vCuaa THEN
                    IF n = 0 THEN
                        pElencoAzi  := TYPCOLL_CUAA_AZ();
                    END IF;

                    n := n + 1;
                    pElencoAzi.EXTEND;
                    pElencoAzi(pElencoAzi.COUNT) := TYPOBJ_CUAA_AZ( REC_NO.CUAA,
                                                                                    NULL,
                                                                   NULL,
                                                                                    NULL,
                                                                       NULL,
                                                                         NULL,
                                                                          NULL,
                                                                                    NULL,
                                                                                    NULL,
                                                                           NULL,
                                                                           NULL,
                                                                                    NULL,
                                                                                    NULL,
                                                                                    NULL,
                                                                                    NULL);
                END IF;
            ELSE
                IF REC_NO.CUAA = vCuaa THEN

                SELECT COUNT(*) INTO nCountCC
                FROM TABLE (CAST (pElencoCuaa     AS TYPCOLL_CUAA_REL))
                WHERE CUAA = vCuaa;

                    IF nCountCC = 0 THEN
                        IF n = 0 THEN
                            pElencoAzi  := TYPCOLL_CUAA_AZ();
                        END IF;
                        n := n + 1;
                        pElencoAzi.EXTEND;
                        pElencoAzi(pElencoAzi.COUNT) := TYPOBJ_CUAA_AZ( REC_NO.CUAA,
                                                                                        NULL,
                                                                       NULL,
                                                                                        NULL,
                                                                           NULL,
                                                                             NULL,
                                                                              NULL,
                                                                                        NULL,
                                                                                        NULL,
                                                                               NULL,
                                                                               NULL,
                                                                                        NULL,
                                                                                        NULL,
                                                                                        NULL,
                                                                                        NULL);
                    END IF;
                END IF;

            END IF;
        END LOOP;
*/
    RETURN(pElencoAzi);

END TABLE_CUAA_AZIENDE_COLLEGATE_S;


FUNCTION TABLE_CUAA_AZIENDE_COLLEGATE_J ( pCuaa  IN VARCHAR2 ) RETURN TYPCOLL_CUAA_AZ PIPELINED IS

    n                 NUMBER;
    nX                NUMBER;
    pElencoAzOut    TYPCOLL_CUAA_AZ;
    pElencoAzIn        TYPCOLL_CUAA_AZ;
    EXC_NO_ROWS        EXCEPTION;
    vCuaa           DB_ANAGRAFICA_AZIENDA.CUAA%TYPE;
BEGIN

    vCuaa := UPPER(pCuaa);
    pElencoAzIn := TABLE_CUAA_AZIENDE_COLLEGATE_S(vCuaa);

    BEGIN
        nX := pElencoAzIn.COUNT;
    EXCEPTION
        WHEN OTHERS THEN
            RAISE EXC_NO_ROWS;
    END;


        pElencoAzOut := TYPCOLL_CUAA_AZ();

        n := 0;

        FOR i IN pElencoAzIn.FIRST..pElencoAzIn.LAST LOOP
            n := n + 1;

            pElencoAzOut.EXTEND;

            pElencoAzOut(pElencoAzOut.COUNT) := TYPOBJ_CUAA_AZ(pElencoAzIn(i).CUAA,
                                                               pElencoAzIn(i).ID_AZIENDA,
                                                               pElencoAzIn(i).ID_ANAGRAFICA_AZIENDA,
                                                               pElencoAzIn(i).PARTITA_IVA,
                                                               pElencoAzIn(i).DENOMINAZIONE,
                                                               pElencoAzIn(i).DATA_INIZIO_VALIDITA,
                                                               pElencoAzIn(i).DATA_CESSAZIONE,
                                                               pElencoAzIn(i).SEDELEG_COMUNE,
                                                               pElencoAzIn(i).SEDELEG_CITTA_ESTERO,
                                                               pElencoAzIn(i).DESCRIZIONE_COMUNE,
                                                               pElencoAzIn(i).SIGLA_PROVINCIA,
                                                               pElencoAzIn(i).DESCRIZIONE_FORMA_GIU,
                                                               NULL,
                                                               NULL,
                                                               NULL);


            PIPE ROW (pElencoAzOut(n));

        END LOOP;


    RETURN;
EXCEPTION
    WHEN EXC_NO_ROWS THEN
            dbms_output.put_line('EXC_NO_ROWS');
            RETURN;
END TABLE_CUAA_AZIENDE_COLLEGATE_J;

END Pck_Utl_Obj;

/
--------------------------------------------------------
--  DDL for Package Body PCK_VARIAZIONI_AZIENDALI
--------------------------------------------------------

  CREATE OR REPLACE PACKAGE BODY "SMRGAA"."PCK_VARIAZIONI_AZIENDALI" AS

PROCEDURE GESTIONE_VARIAZIONE (pRecULT IN CUR_AZI%ROWTYPE,
                                         pRecPEN    IN CUR_AZI%ROWTYPE ) IS
nTotUltima            NUMBER;
nTotPenultima        NUMBER;
nCount                NUMBER;

nTotUlt                 NUMBER;
nTotPen                 NUMBER;

nVar1                    NUMBER(1);
nVar2                    NUMBER(1);
nVar3                    NUMBER(1);
nVar4                    NUMBER(1);
nVar5                    NUMBER(1);
nVar6                    NUMBER(1);
nVar7                    NUMBER(1);
nVar8                    NUMBER(1);


nIdVariazioneAziendale    NUMBER;
BEGIN

    nVar1                    := 0;
    nVar2                    := 0;
    nVar3                    := 0;
    nVar4                    := 0;
    nVar5                    := 0;
    nVar6                    := 0;
    nVar7                    := 0;
    nVar8                    := 0;

    IF pRecULT.DATA_CESSAZIONE IS NOT NULL THEN
        -- VARIAZIONE    4
        nVar4                    := 1;
    END IF;


    IF pRecPEN.ID_DICHIARAZIONE_CONSISTENZA IS NOT NULL THEN
        IF pRecULT.CUAA != pRecPEN.CUAA THEN
            -- VARIAZIONE    1
            nVar1                    := 1;
        END IF;

        IF pRecULT.SEDELEG_COMUNE||pRecULT.SEDELEG_INDIRIZZO||pRecULT.SEDELEG_CAP != pRecPEN.SEDELEG_COMUNE||pRecPEN.SEDELEG_INDIRIZZO||pRecPEN.SEDELEG_CAP THEN
            -- VARIAZIONE    2
            nVar2                    := 1;
        END IF;

        IF pRecULT.ID_SOGGETTO != pRecPEN.ID_SOGGETTO THEN
            -- VARIAZIONE    3
            nVar3                    := 1;
        END IF;



        SELECT COUNT(*)
        INTO nCount FROM
        (SELECT     ZIO.ID_TITOLO_POSSESSO                    ID_TITOLO_POSSESSO,
                    ZIO.SUPERFICIE_CONDOTTA                    SUPERFICIE_CONDOTTA,
                    ZIO.ID_PARTICELLA                            ID_PARTICELLA
        FROM         DB_CONDUZIONE_DICHIARATA        ZIO
        WHERE ZIO.CODICE_FOTOGRAFIA_TERRENI            =    pRecPEN.CODICE_FOTOGRAFIA_TERRENI
        MINUS
        SELECT     ZIO.ID_TITOLO_POSSESSO                    ID_TITOLO_POSSESSO,
                    ZIO.SUPERFICIE_CONDOTTA                    SUPERFICIE_CONDOTTA,
                    ZIO.ID_PARTICELLA                            ID_PARTICELLA
        FROM         DB_CONDUZIONE_DICHIARATA        ZIO
        WHERE ZIO.CODICE_FOTOGRAFIA_TERRENI            =    pRecULT.CODICE_FOTOGRAFIA_TERRENI) DIFF;


        IF nCount > 0 THEN
            -- VARIAZIONE    5
            nVar5                    := 1;
        END IF;

        SELECT COUNT(*)
        INTO nCount FROM
        (SELECT UNI.ANNO_IMPIANTO,
                 UNI.ANNO_ISCRIZIONE_ALBO,
                 UNI.AREA,
                 UNI.ID_TIPOLOGIA_VINO,
                 UNI.ID_VARIETA,
                 UNI.MATRICOLA_CCIAA,
                 UNI.NUM_CEPPI,
                 UNI.SESTO_SU_FILA,
                 UNI.SESTO_TRA_FILE,
                 UNI.SUPERFICIE_DA_ISCRIVERE_ALBO,
                 STO.ID_UNITA_ARBOREA
         FROM DB_UNITA_ARBOREA_DICHIARATA    UNI,
                DB_STORICO_UNITA_ARBOREA        STO
        WHERE UNI.CODICE_FOTOGRAFIA_TERRENI            =    pRecPEN.CODICE_FOTOGRAFIA_TERRENI
        AND    UNI.ID_STORICO_UNITA_ARBOREA            =    STO.ID_STORICO_UNITA_ARBOREA
        MINUS
        SELECT UNI.ANNO_IMPIANTO,
                 UNI.ANNO_ISCRIZIONE_ALBO,
                 UNI.AREA,
                 UNI.ID_TIPOLOGIA_VINO,
                 UNI.ID_VARIETA,
                 UNI.MATRICOLA_CCIAA,
                 UNI.NUM_CEPPI,
                 UNI.SESTO_SU_FILA,
                 UNI.SESTO_TRA_FILE,
                 UNI.SUPERFICIE_DA_ISCRIVERE_ALBO,
                 STO.ID_UNITA_ARBOREA
         FROM DB_UNITA_ARBOREA_DICHIARATA    UNI,
                DB_STORICO_UNITA_ARBOREA        STO
        WHERE UNI.CODICE_FOTOGRAFIA_TERRENI            =    pRecULT.CODICE_FOTOGRAFIA_TERRENI
        AND    UNI.ID_STORICO_UNITA_ARBOREA            =    STO.ID_STORICO_UNITA_ARBOREA) DIFF;

        IF nCount > 0 THEN
            -- VARIAZIONE    6
            nVar6                    := 1;
        END IF;


        SELECT COUNT(DISTINCT STO.ID_UNITA_ARBOREA) INTO nTotUltima
        FROM DB_UNITA_ARBOREA_DICHIARATA    UNI,
                DB_STORICO_UNITA_ARBOREA        STO
        WHERE UNI.CODICE_FOTOGRAFIA_TERRENI            =    pRecULT.CODICE_FOTOGRAFIA_TERRENI
        AND    UNI.ID_STORICO_UNITA_ARBOREA            =    STO.ID_STORICO_UNITA_ARBOREA;

        SELECT COUNT(DISTINCT STO.ID_UNITA_ARBOREA) INTO nTotPenultima
        FROM     DB_UNITA_ARBOREA_DICHIARATA    UNI,
                DB_STORICO_UNITA_ARBOREA        STO
        WHERE UNI.CODICE_FOTOGRAFIA_TERRENI            =    pRecPEN.CODICE_FOTOGRAFIA_TERRENI
        AND    UNI.ID_STORICO_UNITA_ARBOREA            =    STO.ID_STORICO_UNITA_ARBOREA;

        IF nTotUltima > nTotPenultima THEN
            -- VARIAZIONE    7
            nVar7                    := 1;
        ELSIF nTotUltima < nTotPenultima THEN
            -- VARIAZIONE    8
            nVar8                    := 1;
        END IF;

        FOR REC_UNI IN (    SELECT DISTINCT STO.ID_UNITA_ARBOREA ID_UNITA_ARBOREA
                                FROM     DB_UNITA_ARBOREA_DICHIARATA    UNI,
                                        DB_STORICO_UNITA_ARBOREA        STO
                                WHERE UNI.CODICE_FOTOGRAFIA_TERRENI            IN (    pRecULT.CODICE_FOTOGRAFIA_TERRENI, pRecPEN.CODICE_FOTOGRAFIA_TERRENI)
                                AND    UNI.ID_STORICO_UNITA_ARBOREA            =    STO.ID_STORICO_UNITA_ARBOREA ) LOOP


            SELECT     ULTIMA.TOT ,    PENULTIMA.TOT INTO nTotUlt, nTotPen
            FROM
            ( SELECT COUNT(STO1.ID_UNITA_ARBOREA) TOT, REC_UNI.ID_UNITA_ARBOREA
            FROM     DB_UNITA_ARBOREA_DICHIARATA    UNI1,
                    DB_STORICO_UNITA_ARBOREA        STO1
            WHERE UNI1.CODICE_FOTOGRAFIA_TERRENI            = pRecULT.CODICE_FOTOGRAFIA_TERRENI
            AND    UNI1.ID_STORICO_UNITA_ARBOREA                = STO1.ID_STORICO_UNITA_ARBOREA
            AND    STO1.ID_UNITA_ARBOREA                        = REC_UNI.ID_UNITA_ARBOREA ) ULTIMA,
            (    SELECT COUNT(STO2.ID_UNITA_ARBOREA) TOT, REC_UNI.ID_UNITA_ARBOREA
            FROM     DB_UNITA_ARBOREA_DICHIARATA    UNI2,
                    DB_STORICO_UNITA_ARBOREA        STO2
            WHERE UNI2.CODICE_FOTOGRAFIA_TERRENI            = pRecPEN.CODICE_FOTOGRAFIA_TERRENI
            AND    UNI2.ID_STORICO_UNITA_ARBOREA                = STO2.ID_STORICO_UNITA_ARBOREA
            AND    STO2.ID_UNITA_ARBOREA                        = REC_UNI.ID_UNITA_ARBOREA ) PENULTIMA;


            IF nTotUlt >  nTotPen THEN
                -- VARIAZIONE    7
                nVar7                    := 1;
            ELSIF nTotUlt <  nTotPen THEN
                -- VARIAZIONE    8
                nVar8                    := 1;
            END IF;

        END LOOP;
    END IF;

    IF    nVar1 + nVar2 + nVar3 + nVar4 + nVar5 +nVar6 + nVar7 + nVar8 > 0 THEN

        UPDATE DB_VARIAZIONE_AZIENDALE SET FLAG_STORICIZZATO = 'S'
        WHERE ID_AZIENDA = pRecULT.ID_AZIENDA;

        INSERT INTO DB_VARIAZIONE_AZIENDALE (ID_VARIAZIONE_AZIENDALE, ID_AZIENDA, DATA_VERIFICA_VARIAZIONE, ID_DICHIARAZIONE_CONSISTENZA_A, ID_DICHIARAZIONE_CONSISTENZA_P, FLAG_STORICIZZATO)
        VALUES (SEQ_VARIAZIONE_AZIENDALE.NEXTVAL, pRecULT.ID_AZIENDA, SYSDATE, pRecULT.ID_DICHIARAZIONE_CONSISTENZA,pRecPEN.ID_DICHIARAZIONE_CONSISTENZA,'N')
        RETURNING ID_VARIAZIONE_AZIENDALE INTO nIdVariazioneAziendale;

    END IF;

    IF nVar1  = 1 THEN
        INSERT INTO DB_DETTAGLIO_VARIAZIONE_AZI (    ID_DETTAGLIO_VARIAZIONE_AZI,                 ID_TIPO_VARIAZIONE_AZIENDA,     ID_VARIAZIONE_AZIENDALE,     DATA_VARIAZIONE)
        VALUES (                                                SEQ_DETTAGLIO_VARIAZIONE_AZI.NEXTVAL,    1,                                        nIdVariazioneAziendale,        pRecULT.DATA_INIZIO_VALIDITA);
    END IF;

    IF nVar2 = 1 THEN
        INSERT INTO DB_DETTAGLIO_VARIAZIONE_AZI (    ID_DETTAGLIO_VARIAZIONE_AZI,                 ID_TIPO_VARIAZIONE_AZIENDA,     ID_VARIAZIONE_AZIENDALE,     DATA_VARIAZIONE)
        VALUES (                                                SEQ_DETTAGLIO_VARIAZIONE_AZI.NEXTVAL,    2,                                        nIdVariazioneAziendale,        pRecULT.DATA_INIZIO_VALIDITA);
    END IF;

    IF nVar3  = 1 THEN
        INSERT INTO DB_DETTAGLIO_VARIAZIONE_AZI (    ID_DETTAGLIO_VARIAZIONE_AZI,                 ID_TIPO_VARIAZIONE_AZIENDA,     ID_VARIAZIONE_AZIENDALE,     DATA_VARIAZIONE)
        VALUES (                                                SEQ_DETTAGLIO_VARIAZIONE_AZI.NEXTVAL,    3,                                        nIdVariazioneAziendale,        pRecULT.DATA_INIZIO_RUOLO);
    END IF;

    IF nVar4  = 1 THEN
        INSERT INTO DB_DETTAGLIO_VARIAZIONE_AZI (    ID_DETTAGLIO_VARIAZIONE_AZI,                 ID_TIPO_VARIAZIONE_AZIENDA,     ID_VARIAZIONE_AZIENDALE,     DATA_VARIAZIONE)
        VALUES (                                                SEQ_DETTAGLIO_VARIAZIONE_AZI.NEXTVAL,    4,                                        nIdVariazioneAziendale,        pRecULT.DATA_INIZIO_VALIDITA);
    END IF;

    IF nVar5  = 1 THEN
        INSERT INTO DB_DETTAGLIO_VARIAZIONE_AZI (    ID_DETTAGLIO_VARIAZIONE_AZI,                 ID_TIPO_VARIAZIONE_AZIENDA,     ID_VARIAZIONE_AZIENDALE,     DATA_VARIAZIONE)
        VALUES (                                                SEQ_DETTAGLIO_VARIAZIONE_AZI.NEXTVAL,    5,                                        nIdVariazioneAziendale,        pRecULT.DATA);
    END IF;

    IF nVar6  = 1 THEN
        INSERT INTO DB_DETTAGLIO_VARIAZIONE_AZI (    ID_DETTAGLIO_VARIAZIONE_AZI,                 ID_TIPO_VARIAZIONE_AZIENDA,     ID_VARIAZIONE_AZIENDALE,     DATA_VARIAZIONE)
        VALUES (                                                SEQ_DETTAGLIO_VARIAZIONE_AZI.NEXTVAL,    6,                                        nIdVariazioneAziendale,        pRecULT.DATA);
    END IF;

    IF nVar7  = 1 THEN
        INSERT INTO DB_DETTAGLIO_VARIAZIONE_AZI (    ID_DETTAGLIO_VARIAZIONE_AZI,                 ID_TIPO_VARIAZIONE_AZIENDA,     ID_VARIAZIONE_AZIENDALE,     DATA_VARIAZIONE)
        VALUES (                                                SEQ_DETTAGLIO_VARIAZIONE_AZI.NEXTVAL,    7,                                        nIdVariazioneAziendale,        pRecULT.DATA);
    END IF;

    IF nVar8  = 1 THEN
        INSERT INTO DB_DETTAGLIO_VARIAZIONE_AZI (    ID_DETTAGLIO_VARIAZIONE_AZI,                 ID_TIPO_VARIAZIONE_AZIENDA,     ID_VARIAZIONE_AZIENDALE,     DATA_VARIAZIONE)
        VALUES (                                                SEQ_DETTAGLIO_VARIAZIONE_AZI.NEXTVAL,    8,                                        nIdVariazioneAziendale,        pRecULT.DATA);
    END IF;




END GESTIONE_VARIAZIONE;

FUNCTION MAIN RETURN NUMBER IS

   TmpVar NUMBER;
    dDataRif    DATE;
    nIdAziendaOld    NUMBER;
    nCountAz            NUMBER;

    REC_ULT    CUR_AZI%ROWTYPE;
    REC_PEN    CUR_AZI%ROWTYPE;
    bElabora            BOOLEAN;

    nCount     NUMBER;
    nCountTot NUMBER;
BEGIN
    nCount := 0;
    nCountTot := 0;
    SELECT TO_DATE(valore,'DD/MM/YYYY') INTO dDataRif FROM DB_PARAMETRO WHERE ID_PARAMETRO = 'VADT';
    nIdAziendaOld    := -1;

    bElabora    := FALSE;

    FOR REC_A IN CUR_AZI(dDataRif) LOOP
        nCountTot     := nCountTot + 1;
        nCount         := nCount + 1;
        IF REC_A.ID_AZIENDA != nIdAziendaOld OR nIdAziendaOld = - 1 THEN        -- rottura di azienda
            IF nIdAziendaOld > -1 THEN                                                        -- non solo al primo giro
                IF    bElabora = TRUE THEN                                                         -- ultima occorreza con FLAG_VAR_ANA= N

                    GESTIONE_VARIAZIONE(REC_ULT,REC_PEN);                                -- gestione azienda precedente
                    UPDATE DB_DICHIARAZIONE_CONSISTENZA SET FLAG_VARIAZIONE_VERIFICATA = 'S' WHERE ID_DICHIARAZIONE_CONSISTENZA = REC_ULT.ID_DICHIARAZIONE_CONSISTENZA;
                    bElabora := FALSE;                                                        -- risettaggio variabile booleana per prossima occorrenza

                END IF;
            END IF;

            REC_ULT    := NULL;                                                                    -- azzeramento rec
            REC_PEN    := NULL;                                                                    -- azzeramento rec
            IF  REC_A.FLAG_VARIAZIONE_VERIFICATA = 'N' THEN                            -- risettaggio variabile booleana
                bElabora := TRUE;
            END IF;
            REC_ULT := REC_A;                                                                 -- settaggio ultima occorrenza
            nCountAz    := 1;
        ELSE
            -- altra occorenza
            nCountAz := nCountAz + 1;
            IF nCountAz = 2 THEN
                REC_PEN := REC_A;                                                             -- settaggio penultima occorrenza
            END IF;
        END IF;

        nIdAziendaOld := REC_A.ID_AZIENDA;
        IF nCount > 1000 THEN

--            INSERT INTO ZZ_LOG_VAR VALUES ('ELABORATE  N '||nCountTot||' OCCORRENZE');
            COMMIT;

                nCount := 0;
        END IF;

    END LOOP;
    IF nCountAz > 0 THEN
        GESTIONE_VARIAZIONE(REC_ULT,REC_PEN);                                -- gestione azienda precedente
        UPDATE DB_DICHIARAZIONE_CONSISTENZA SET FLAG_VARIAZIONE_VERIFICATA = 'S' WHERE ID_DICHIARAZIONE_CONSISTENZA = REC_ULT.ID_DICHIARAZIONE_CONSISTENZA;
    END IF;

COMMIT;

RETURN(0);
   EXCEPTION
     WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('ERRORE ORACLE '||SUBSTR(SQLERRM,1,80));
            DBMS_OUTPUT.PUT_LINE('ID AZIENDA '||REC_ULT.ID_AZIENDA);
            DBMS_OUTPUT.PUT_LINE('ELABORAZIONE INTERROTTA ');
            RETURN(1);
END MAIN;

END Pck_Variazioni_Aziendali;

/
--------------------------------------------------------
--  DDL for Function FNC_SG_UPD_FLAG_IAP
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SMRGAA"."FNC_SG_UPD_FLAG_IAP" RETURN BOOLEAN IS
    /* ********************************************************************************
    Descrizione:  FNC_SG_UPD_FLAG_IAP;                                                 
                                                                                       
    Tipo:         FUNCTION;                                                           
                                                                                       
    Input:        none;                                                                
                                                                                       
    return:       boolean;                                                                
    ********************************************************************************* */
---  Costanti

--- Variabili    
    
--- Cursori
    CURSOR curAziendeIAP IS
        SELECT ID_AZIENDA
             , DATA_TRASMISSIONE
          FROM GNPS_RW.TMP_SG_CARICA_AZIENDE_IAP
--         WHERE ID_AZIENDA IN (227607,4831) -- prova
         ORDER BY 1;
                            

BEGIN
    INSERT INTO TMP_DEBUG
         VALUES (SYSDATE,'START:','FNC_SG_UPD_FLAG_IAP');
    COMMIT;
     
    FOR rec IN curAziendeIAP LOOP
        
        UPDATE DB_ANAGRAFICA_AZIENDA AAZ
           SET AAZ.FLAG_IAP = 'S'
         WHERE AAZ.ID_AZIENDA = rec.ID_AZIENDA
           AND NVL(AAZ.DATA_FINE_VALIDITA,SYSDATE) >= rec.DATA_TRASMISSIONE;
           
         COMMIT;       
         
    END LOOP;
    
                      
    INSERT INTO TMP_DEBUG
         VALUES (SYSDATE,'END:','FNC_SG_UPD_FLAG_IAP');
    COMMIT;
         

    RETURN TRUE;

EXCEPTION
    WHEN OTHERS THEN
         ROLLBACK;
         INSERT INTO TMP_DEBUG
         VALUES (SYSDATE,'KO:','FNC_SG_UPD_FLAG_IAP');
         COMMIT;
         RETURN FALSE;
         
END;

/
--------------------------------------------------------
--  DDL for Function TO_UPPER
--------------------------------------------------------

  CREATE OR REPLACE FUNCTION "SMRGAA"."TO_UPPER" (testo IN VARCHAR2) RETURN VARCHAR2 IS
BEGIN

   RETURN UPPER(testo);

END;

/
